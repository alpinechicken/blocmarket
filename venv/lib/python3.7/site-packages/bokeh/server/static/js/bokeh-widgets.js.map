{"version":3,"sources":["src/js/plugin-prelude.js","build/js/tree/models/widgets/abstract_button.js","build/js/tree/models/widgets/abstract_icon.js","build/js/tree/models/widgets/autocomplete_input.js","build/js/tree/models/widgets/button.js","build/js/tree/models/widgets/button_group_template.js","build/js/tree/models/widgets/button_template.js","build/js/tree/models/widgets/cell_editors.js","build/js/tree/models/widgets/cell_formatters.js","build/js/tree/models/widgets/checkbox_button_group.js","build/js/tree/models/widgets/checkbox_group.js","build/js/tree/models/widgets/data_table.js","build/js/tree/models/widgets/date_picker.js","build/js/tree/models/widgets/date_range_slider.js","build/js/tree/models/widgets/div.js","build/js/tree/models/widgets/dropdown.js","build/js/tree/models/widgets/dropdown_template.js","build/js/tree/models/widgets/index.js","build/js/tree/models/widgets/input_widget.js","build/js/tree/models/widgets/main.js","build/js/tree/models/widgets/markup.js","build/js/tree/models/widgets/markup_template.js","build/js/tree/models/widgets/multiselect.js","build/js/tree/models/widgets/multiselecttemplate.js","build/js/tree/models/widgets/panel.js","build/js/tree/models/widgets/paragraph.js","build/js/tree/models/widgets/pretext.js","build/js/tree/models/widgets/radio_button_group.js","build/js/tree/models/widgets/radio_group.js","build/js/tree/models/widgets/range_slider.js","build/js/tree/models/widgets/selectbox.js","build/js/tree/models/widgets/selecttemplate.js","build/js/tree/models/widgets/slider.js","build/js/tree/models/widgets/slidertemplate.js","build/js/tree/models/widgets/table_column.js","build/js/tree/models/widgets/table_widget.js","build/js/tree/models/widgets/tabs.js","build/js/tree/models/widgets/tabs_template.js","build/js/tree/models/widgets/text_input.js","build/js/tree/models/widgets/text_input_template.js","build/js/tree/models/widgets/toggle.js","build/js/tree/models/widgets/widget.js","node_modules/jquery-ui/autocomplete.js","node_modules/jquery-ui/button.js","node_modules/jquery-ui/core.js","node_modules/jquery-ui/datepicker.js","node_modules/jquery-ui/menu.js","node_modules/jquery-ui/mouse.js","node_modules/jquery-ui/position.js","node_modules/jquery-ui/slider.js","node_modules/jquery-ui/sortable.js","node_modules/jquery-ui/spinner.js","node_modules/jquery-ui/widget.js","src/vendor/bootstrap-3.1.1/js/button.js","src/vendor/bootstrap-3.1.1/js/dropdown.js","src/vendor/bootstrap-3.1.1/js/tab.js","src/vendor/jqrangeslider-5.7.0/jQDateRangeSlider.js","src/vendor/jqrangeslider-5.7.0/jQRangeSlider.js","src/vendor/jquery-event-2.2/jquery.event.drag.js","src/vendor/jquery-event-2.2/jquery.event.drop.js","src/vendor/slick-grid-2.1.0/plugins/slick.checkboxselectcolumn.js","src/vendor/slick-grid-2.1.0/plugins/slick.rowselectionmodel.js","src/vendor/slick-grid-2.1.0/slick.core.js","src/vendor/slick-grid-2.1.0/slick.grid.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACz/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9wCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bokeh-widgets.js","sourcesContent":["(function outer(modules, cache, entry) {\n  if (Bokeh != null) {\n    for (var name in modules) {\n      Bokeh.require.modules[name] = modules[name];\n    }\n\n    for (var i = 0; i < entry.length; i++) {\n      var plugin = Bokeh.require(entry[0]);\n      Bokeh.Models.register_models(plugin.models);\n\n      for (var name in plugin) {\n        if (name !== \"models\") {\n          Bokeh[name] = plugin[name];\n        }\n      }\n    }\n  } else {\n    throw new Error(\"Cannot find Bokeh. You have to load it prior to loading plugins.\");\n  }\n})\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"../../core/properties\");\nvar build_views_1 = require(\"../../core/build_views\");\nvar widget_1 = require(\"./widget\");\nvar button_template_1 = require(\"./button_template\");\nexports.AbstractButtonView = (function (superClass) {\n    extend(AbstractButtonView, superClass);\n    function AbstractButtonView() {\n        return AbstractButtonView.__super__.constructor.apply(this, arguments);\n    }\n    AbstractButtonView.prototype.events = {\n        \"click\": \"change_input\"\n    };\n    AbstractButtonView.prototype.template = button_template_1.default;\n    AbstractButtonView.prototype.initialize = function (options) {\n        AbstractButtonView.__super__.initialize.call(this, options);\n        this.icon_views = {};\n        this.listenTo(this.model, 'change', this.render);\n        return this.render();\n    };\n    AbstractButtonView.prototype.render = function () {\n        var $button, html, icon, key, ref, val;\n        AbstractButtonView.__super__.render.call(this);\n        icon = this.model.icon;\n        if (icon != null) {\n            build_views_1.build_views(this.icon_views, [icon]);\n            ref = this.icon_views;\n            for (key in ref) {\n                if (!hasProp.call(ref, key))\n                    continue;\n                val = ref[key];\n                val.$el.detach();\n            }\n        }\n        this.$el.empty();\n        html = this.template(this.model.attributes);\n        this.$el.append(html);\n        $button = this.$el.find('button');\n        if (icon != null) {\n            $button.prepend(\"&nbsp;\");\n            $button.prepend(this.icon_views[icon.id].$el);\n        }\n        $button.prop(\"disabled\", this.model.disabled);\n        return this;\n    };\n    AbstractButtonView.prototype.change_input = function () {\n        var ref;\n        return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n    };\n    return AbstractButtonView;\n})(widget_1.WidgetView);\nexports.AbstractButton = (function (superClass) {\n    extend(AbstractButton, superClass);\n    function AbstractButton() {\n        return AbstractButton.__super__.constructor.apply(this, arguments);\n    }\n    AbstractButton.prototype.type = \"AbstractButton\";\n    AbstractButton.prototype.default_view = exports.AbstractButtonView;\n    AbstractButton.define({\n        callback: [p.Instance],\n        label: [p.String, \"Button\"],\n        icon: [p.Instance],\n        button_type: [p.String, \"default\"]\n    });\n    return AbstractButton;\n})(widget_1.Widget);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar widget_1 = require(\"./widget\");\nexports.AbstractIcon = (function (superClass) {\n    extend(AbstractIcon, superClass);\n    function AbstractIcon() {\n        return AbstractIcon.__super__.constructor.apply(this, arguments);\n    }\n    AbstractIcon.prototype.type = \"AbstractIcon\";\n    return AbstractIcon;\n})(widget_1.Widget);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nrequire(\"jquery-ui/autocomplete\");\nvar text_input_1 = require(\"./text_input\");\nvar p = require(\"../../core/properties\");\nexports.AutocompleteInputView = (function (superClass) {\n    extend(AutocompleteInputView, superClass);\n    function AutocompleteInputView() {\n        return AutocompleteInputView.__super__.constructor.apply(this, arguments);\n    }\n    AutocompleteInputView.prototype.render = function () {\n        var $input;\n        AutocompleteInputView.__super__.render.call(this);\n        $input = this.$el.find(\"input\");\n        $input.autocomplete({\n            source: this.model.completions\n        });\n        $input.autocomplete(\"widget\").addClass(\"bk-autocomplete-input\");\n        return this;\n    };\n    return AutocompleteInputView;\n})(text_input_1.TextInputView);\nexports.AutocompleteInput = (function (superClass) {\n    extend(AutocompleteInput, superClass);\n    function AutocompleteInput() {\n        return AutocompleteInput.__super__.constructor.apply(this, arguments);\n    }\n    AutocompleteInput.prototype.type = \"AutocompleteInput\";\n    AutocompleteInput.prototype.default_view = exports.AutocompleteInputView;\n    AutocompleteInput.define({\n        completions: [p.Array, []]\n    });\n    return AutocompleteInput;\n})(text_input_1.TextInput);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"../../core/properties\");\nvar abstract_button_1 = require(\"./abstract_button\");\nexports.ButtonView = (function (superClass) {\n    extend(ButtonView, superClass);\n    function ButtonView() {\n        return ButtonView.__super__.constructor.apply(this, arguments);\n    }\n    ButtonView.prototype.change_input = function () {\n        this.model.clicks = this.model.clicks + 1;\n        return ButtonView.__super__.change_input.call(this);\n    };\n    return ButtonView;\n})(abstract_button_1.AbstractButtonView);\nexports.Button = (function (superClass) {\n    extend(Button, superClass);\n    function Button() {\n        return Button.__super__.constructor.apply(this, arguments);\n    }\n    Button.prototype.type = \"Button\";\n    Button.prototype.default_view = exports.ButtonView;\n    Button.define({\n        clicks: [p.Number, 0]\n    });\n    return Button;\n})(abstract_button_1.AbstractButton);\n","\"use strict\";\nvar DOM = require(\"../../core/util/dom\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = function () {\n    return DOM.createElement(\"div\", { class: \"bk-bs-btn-group\", \"data-bk-bs-toggle\": \"buttons\" });\n};\n","\"use strict\";\nvar DOM = require(\"../../core/util/dom\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = function (props) {\n    return (DOM.createElement(\"button\", { type: \"button\", class: \"bk-bs-btn bk-bs-btn-\" + props.button_type }, props.label));\n};\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar _ = require(\"underscore\");\nvar $ = require(\"jquery\");\nrequire(\"jquery-ui/autocomplete\");\nrequire(\"jquery-ui/spinner\");\nvar p = require(\"../../core/properties\");\nvar bokeh_view_1 = require(\"../../core/bokeh_view\");\nvar model_1 = require(\"../../model\");\nexports.CellEditorView = (function (superClass) {\n    extend(CellEditorView, superClass);\n    function CellEditorView() {\n        return CellEditorView.__super__.constructor.apply(this, arguments);\n    }\n    CellEditorView.prototype.tagName = \"div\";\n    CellEditorView.prototype.className = \"bk-cell-editor\";\n    CellEditorView.prototype.input = null;\n    CellEditorView.prototype.emptyValue = null;\n    CellEditorView.prototype.defaultValue = null;\n    CellEditorView.prototype.initialize = function (args) {\n        this.args = args;\n        this.model = this.args.column.editor;\n        CellEditorView.__super__.initialize.call(this);\n        return this.render();\n    };\n    CellEditorView.prototype.render = function () {\n        CellEditorView.__super__.render.call(this);\n        this.$el.appendTo(this.args.container);\n        this.$input = $(this.input);\n        this.$el.append(this.$input);\n        this.renderEditor();\n        this.disableNavigation();\n        return this;\n    };\n    CellEditorView.prototype.renderEditor = function () { };\n    CellEditorView.prototype.disableNavigation = function () {\n        return this.$input.keydown((function (_this) {\n            return function (event) {\n                var stop;\n                stop = function () {\n                    return event.stopImmediatePropagation();\n                };\n                switch (event.keyCode) {\n                    case $.ui.keyCode.LEFT:\n                        return stop();\n                    case $.ui.keyCode.RIGHT:\n                        return stop();\n                    case $.ui.keyCode.UP:\n                        return stop();\n                    case $.ui.keyCode.DOWN:\n                        return stop();\n                    case $.ui.keyCode.PAGE_UP:\n                        return stop();\n                    case $.ui.keyCode.PAGE_DOWN:\n                        return stop();\n                }\n            };\n        })(this));\n    };\n    CellEditorView.prototype.destroy = function () {\n        return this.remove();\n    };\n    CellEditorView.prototype.focus = function () {\n        return this.$input.focus();\n    };\n    CellEditorView.prototype.show = function () { };\n    CellEditorView.prototype.hide = function () { };\n    CellEditorView.prototype.position = function () { };\n    CellEditorView.prototype.getValue = function () {\n        return this.$input.val();\n    };\n    CellEditorView.prototype.setValue = function (val) {\n        return this.$input.val(val);\n    };\n    CellEditorView.prototype.serializeValue = function () {\n        return this.getValue();\n    };\n    CellEditorView.prototype.isValueChanged = function () {\n        return !(this.getValue() === \"\" && (this.defaultValue == null)) && (this.getValue() !== this.defaultValue);\n    };\n    CellEditorView.prototype.applyValue = function (item, state) {\n        return this.args.grid.getData().setField(item.index, this.args.column.field, state);\n    };\n    CellEditorView.prototype.loadValue = function (item) {\n        var value;\n        value = item[this.args.column.field];\n        this.defaultValue = value != null ? value : this.emptyValue;\n        return this.setValue(this.defaultValue);\n    };\n    CellEditorView.prototype.validateValue = function (value) {\n        var result;\n        if (this.args.column.validator) {\n            result = this.args.column.validator(value);\n            if (!result.valid) {\n                return result;\n            }\n        }\n        return {\n            valid: true,\n            msg: null\n        };\n    };\n    CellEditorView.prototype.validate = function () {\n        return this.validateValue(this.getValue());\n    };\n    return CellEditorView;\n})(bokeh_view_1.BokehView);\nexports.CellEditor = (function (superClass) {\n    extend(CellEditor, superClass);\n    function CellEditor() {\n        return CellEditor.__super__.constructor.apply(this, arguments);\n    }\n    CellEditor.prototype.type = \"CellEditor\";\n    CellEditor.prototype.default_view = exports.CellEditorView;\n    return CellEditor;\n})(model_1.Model);\nexports.StringEditorView = (function (superClass) {\n    extend(StringEditorView, superClass);\n    function StringEditorView() {\n        return StringEditorView.__super__.constructor.apply(this, arguments);\n    }\n    StringEditorView.prototype.emptyValue = \"\";\n    StringEditorView.prototype.input = '<input type=\"text\" />';\n    StringEditorView.prototype.renderEditor = function () {\n        var completions;\n        completions = this.model.completions;\n        if (!_.isEmpty(completions)) {\n            this.$input.autocomplete({\n                source: completions\n            });\n            this.$input.autocomplete(\"widget\").addClass(\"bk-cell-editor-completion\");\n        }\n        return this.$input.focus().select();\n    };\n    StringEditorView.prototype.loadValue = function (item) {\n        StringEditorView.__super__.loadValue.call(this, item);\n        this.$input[0].defaultValue = this.defaultValue;\n        return this.$input.select();\n    };\n    return StringEditorView;\n})(exports.CellEditorView);\nexports.StringEditor = (function (superClass) {\n    extend(StringEditor, superClass);\n    function StringEditor() {\n        return StringEditor.__super__.constructor.apply(this, arguments);\n    }\n    StringEditor.prototype.type = 'StringEditor';\n    StringEditor.prototype.default_view = exports.StringEditorView;\n    StringEditor.define({\n        completions: [p.Array, []]\n    });\n    return StringEditor;\n})(exports.CellEditor);\nexports.TextEditorView = (function (superClass) {\n    extend(TextEditorView, superClass);\n    function TextEditorView() {\n        return TextEditorView.__super__.constructor.apply(this, arguments);\n    }\n    return TextEditorView;\n})(exports.CellEditorView);\nexports.TextEditor = (function (superClass) {\n    extend(TextEditor, superClass);\n    function TextEditor() {\n        return TextEditor.__super__.constructor.apply(this, arguments);\n    }\n    TextEditor.prototype.type = 'TextEditor';\n    TextEditor.prototype.default_view = exports.TextEditorView;\n    return TextEditor;\n})(exports.CellEditor);\nexports.SelectEditorView = (function (superClass) {\n    extend(SelectEditorView, superClass);\n    function SelectEditorView() {\n        return SelectEditorView.__super__.constructor.apply(this, arguments);\n    }\n    SelectEditorView.prototype.input = '<select />';\n    SelectEditorView.prototype.renderEditor = function () {\n        var i, len, option, ref;\n        ref = this.model.options;\n        for (i = 0, len = ref.length; i < len; i++) {\n            option = ref[i];\n            this.$input.append($('<option>').attr({\n                value: option\n            }).text(option));\n        }\n        return this.focus();\n    };\n    SelectEditorView.prototype.loadValue = function (item) {\n        SelectEditorView.__super__.loadValue.call(this, item);\n        return this.$input.select();\n    };\n    return SelectEditorView;\n})(exports.CellEditorView);\nexports.SelectEditor = (function (superClass) {\n    extend(SelectEditor, superClass);\n    function SelectEditor() {\n        return SelectEditor.__super__.constructor.apply(this, arguments);\n    }\n    SelectEditor.prototype.type = 'SelectEditor';\n    SelectEditor.prototype.default_view = exports.SelectEditorView;\n    SelectEditor.define({\n        options: [p.Array, []]\n    });\n    return SelectEditor;\n})(exports.CellEditor);\nexports.PercentEditorView = (function (superClass) {\n    extend(PercentEditorView, superClass);\n    function PercentEditorView() {\n        return PercentEditorView.__super__.constructor.apply(this, arguments);\n    }\n    return PercentEditorView;\n})(exports.CellEditorView);\nexports.PercentEditor = (function (superClass) {\n    extend(PercentEditor, superClass);\n    function PercentEditor() {\n        return PercentEditor.__super__.constructor.apply(this, arguments);\n    }\n    PercentEditor.prototype.type = 'PercentEditor';\n    PercentEditor.prototype.default_view = exports.PercentEditorView;\n    return PercentEditor;\n})(exports.CellEditor);\nexports.CheckboxEditorView = (function (superClass) {\n    extend(CheckboxEditorView, superClass);\n    function CheckboxEditorView() {\n        return CheckboxEditorView.__super__.constructor.apply(this, arguments);\n    }\n    CheckboxEditorView.prototype.input = '<input type=\"checkbox\" value=\"true\" />';\n    CheckboxEditorView.prototype.renderEditor = function () {\n        return this.focus();\n    };\n    CheckboxEditorView.prototype.loadValue = function (item) {\n        this.defaultValue = !!item[this.args.column.field];\n        return this.$input.prop('checked', this.defaultValue);\n    };\n    CheckboxEditorView.prototype.serializeValue = function () {\n        return this.$input.prop('checked');\n    };\n    return CheckboxEditorView;\n})(exports.CellEditorView);\nexports.CheckboxEditor = (function (superClass) {\n    extend(CheckboxEditor, superClass);\n    function CheckboxEditor() {\n        return CheckboxEditor.__super__.constructor.apply(this, arguments);\n    }\n    CheckboxEditor.prototype.type = 'CheckboxEditor';\n    CheckboxEditor.prototype.default_view = exports.CheckboxEditorView;\n    return CheckboxEditor;\n})(exports.CellEditor);\nexports.IntEditorView = (function (superClass) {\n    extend(IntEditorView, superClass);\n    function IntEditorView() {\n        return IntEditorView.__super__.constructor.apply(this, arguments);\n    }\n    IntEditorView.prototype.input = '<input type=\"text\" />';\n    IntEditorView.prototype.renderEditor = function () {\n        this.$input.spinner({\n            step: this.model.step\n        });\n        return this.$input.focus().select();\n    };\n    IntEditorView.prototype.remove = function () {\n        this.$input.spinner(\"destroy\");\n        return IntEditorView.__super__.remove.call(this);\n    };\n    IntEditorView.prototype.serializeValue = function () {\n        return parseInt(this.getValue(), 10) || 0;\n    };\n    IntEditorView.prototype.loadValue = function (item) {\n        IntEditorView.__super__.loadValue.call(this, item);\n        this.$input[0].defaultValue = this.defaultValue;\n        return this.$input.select();\n    };\n    IntEditorView.prototype.validateValue = function (value) {\n        if (isNaN(value)) {\n            return {\n                valid: false,\n                msg: \"Please enter a valid integer\"\n            };\n        }\n        else {\n            return IntEditorView.__super__.validateValue.call(this, value);\n        }\n    };\n    return IntEditorView;\n})(exports.CellEditorView);\nexports.IntEditor = (function (superClass) {\n    extend(IntEditor, superClass);\n    function IntEditor() {\n        return IntEditor.__super__.constructor.apply(this, arguments);\n    }\n    IntEditor.prototype.type = 'IntEditor';\n    IntEditor.prototype.default_view = exports.IntEditorView;\n    IntEditor.define({\n        step: [p.Number, 1]\n    });\n    return IntEditor;\n})(exports.CellEditor);\nexports.NumberEditorView = (function (superClass) {\n    extend(NumberEditorView, superClass);\n    function NumberEditorView() {\n        return NumberEditorView.__super__.constructor.apply(this, arguments);\n    }\n    NumberEditorView.prototype.input = '<input type=\"text\" />';\n    NumberEditorView.prototype.renderEditor = function () {\n        this.$input.spinner({\n            step: this.model.step\n        });\n        return this.$input.focus().select();\n    };\n    NumberEditorView.prototype.remove = function () {\n        this.$input.spinner(\"destroy\");\n        return NumberEditorView.__super__.remove.call(this);\n    };\n    NumberEditorView.prototype.serializeValue = function () {\n        return parseFloat(this.getValue()) || 0.0;\n    };\n    NumberEditorView.prototype.loadValue = function (item) {\n        NumberEditorView.__super__.loadValue.call(this, item);\n        this.$input[0].defaultValue = this.defaultValue;\n        return this.$input.select();\n    };\n    NumberEditorView.prototype.validateValue = function (value) {\n        if (isNaN(value)) {\n            return {\n                valid: false,\n                msg: \"Please enter a valid number\"\n            };\n        }\n        else {\n            return NumberEditorView.__super__.validateValue.call(this, value);\n        }\n    };\n    return NumberEditorView;\n})(exports.CellEditorView);\nexports.NumberEditor = (function (superClass) {\n    extend(NumberEditor, superClass);\n    function NumberEditor() {\n        return NumberEditor.__super__.constructor.apply(this, arguments);\n    }\n    NumberEditor.prototype.type = 'NumberEditor';\n    NumberEditor.prototype.default_view = exports.NumberEditorView;\n    NumberEditor.define({\n        step: [p.Number, 0.01]\n    });\n    return NumberEditor;\n})(exports.CellEditor);\nexports.TimeEditorView = (function (superClass) {\n    extend(TimeEditorView, superClass);\n    function TimeEditorView() {\n        return TimeEditorView.__super__.constructor.apply(this, arguments);\n    }\n    return TimeEditorView;\n})(exports.CellEditorView);\nexports.TimeEditor = (function (superClass) {\n    extend(TimeEditor, superClass);\n    function TimeEditor() {\n        return TimeEditor.__super__.constructor.apply(this, arguments);\n    }\n    TimeEditor.prototype.type = 'TimeEditor';\n    TimeEditor.prototype.default_view = exports.TimeEditorView;\n    return TimeEditor;\n})(exports.CellEditor);\nexports.DateEditorView = (function (superClass) {\n    extend(DateEditorView, superClass);\n    function DateEditorView() {\n        return DateEditorView.__super__.constructor.apply(this, arguments);\n    }\n    DateEditorView.prototype.emptyValue = new window.Date();\n    DateEditorView.prototype.input = '<input type=\"text\" />';\n    DateEditorView.prototype.renderEditor = function () {\n        this.calendarOpen = false;\n        this.$input.datepicker({\n            showOn: \"button\",\n            buttonImageOnly: true,\n            beforeShow: (function (_this) {\n                return function () {\n                    return _this.calendarOpen = true;\n                };\n            })(this),\n            onClose: (function (_this) {\n                return function () {\n                    return _this.calendarOpen = false;\n                };\n            })(this)\n        });\n        this.$input.siblings(\".bk-ui-datepicker-trigger\").css({\n            \"vertical-align\": \"middle\"\n        });\n        this.$input.width(this.$input.width() - (14 + 2 * 4 + 4));\n        return this.$input.focus().select();\n    };\n    DateEditorView.prototype.destroy = function () {\n        $.datepicker.dpDiv.stop(true, true);\n        this.$input.datepicker(\"hide\");\n        this.$input.datepicker(\"destroy\");\n        return DateEditorView.__super__.destroy.call(this);\n    };\n    DateEditorView.prototype.show = function () {\n        if (this.calendarOpen) {\n            $.datepicker.dpDiv.stop(true, true).show();\n        }\n        return DateEditorView.__super__.show.call(this);\n    };\n    DateEditorView.prototype.hide = function () {\n        if (this.calendarOpen) {\n            $.datepicker.dpDiv.stop(true, true).hide();\n        }\n        return DateEditorView.__super__.hide.call(this);\n    };\n    DateEditorView.prototype.position = function (position) {\n        if (this.calendarOpen) {\n            $.datepicker.dpDiv.css({\n                top: position.top + 30,\n                left: position.left\n            });\n        }\n        return DateEditorView.__super__.position.call(this);\n    };\n    DateEditorView.prototype.getValue = function () {\n        return this.$input.datepicker(\"getDate\").getTime();\n    };\n    DateEditorView.prototype.setValue = function (val) {\n        return this.$input.datepicker(\"setDate\", new window.Date(val));\n    };\n    return DateEditorView;\n})(exports.CellEditorView);\nexports.DateEditor = (function (superClass) {\n    extend(DateEditor, superClass);\n    function DateEditor() {\n        return DateEditor.__super__.constructor.apply(this, arguments);\n    }\n    DateEditor.prototype.type = 'DateEditor';\n    DateEditor.prototype.default_view = exports.DateEditorView;\n    return DateEditor;\n})(exports.CellEditor);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar _ = require(\"underscore\");\nvar $ = require(\"jquery\");\nvar Numbro = require(\"numbro\");\nvar p = require(\"../../core/properties\");\nvar model_1 = require(\"../../model\");\nexports.CellFormatter = (function (superClass) {\n    extend(CellFormatter, superClass);\n    function CellFormatter() {\n        return CellFormatter.__super__.constructor.apply(this, arguments);\n    }\n    CellFormatter.prototype.doFormat = function (row, cell, value, columnDef, dataContext) {\n        if (value === null) {\n            return \"\";\n        }\n        else {\n            return (value + \"\").replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        }\n    };\n    return CellFormatter;\n})(model_1.Model);\nexports.StringFormatter = (function (superClass) {\n    extend(StringFormatter, superClass);\n    function StringFormatter() {\n        return StringFormatter.__super__.constructor.apply(this, arguments);\n    }\n    StringFormatter.prototype.type = 'StringFormatter';\n    StringFormatter.define({\n        font_style: [p.FontStyle, \"normal\"],\n        text_align: [p.TextAlign, \"left\"],\n        text_color: [p.Color]\n    });\n    StringFormatter.prototype.doFormat = function (row, cell, value, columnDef, dataContext) {\n        var font_style, text, text_align, text_color;\n        text = StringFormatter.__super__.doFormat.call(this, row, cell, value, columnDef, dataContext);\n        font_style = this.font_style;\n        text_align = this.text_align;\n        text_color = this.text_color;\n        if ((font_style != null) || (text_align != null) || (text_color != null)) {\n            text = $(\"<span>\" + text + \"</span>\");\n            switch (font_style) {\n                case \"bold\":\n                    text = text.css(\"font-weight\", \"bold\");\n                    break;\n                case \"italic\":\n                    text = text.css(\"font-style\", \"italic\");\n            }\n            if (text_align != null) {\n                text = text.css(\"text-align\", text_align);\n            }\n            if (text_color != null) {\n                text = text.css(\"color\", text_color);\n            }\n            text = text.prop('outerHTML');\n        }\n        return text;\n    };\n    return StringFormatter;\n})(exports.CellFormatter);\nexports.NumberFormatter = (function (superClass) {\n    extend(NumberFormatter, superClass);\n    function NumberFormatter() {\n        return NumberFormatter.__super__.constructor.apply(this, arguments);\n    }\n    NumberFormatter.prototype.type = 'NumberFormatter';\n    NumberFormatter.define({\n        format: [p.String, '0,0'],\n        language: [p.String, 'en'],\n        rounding: [p.String, 'round']\n    });\n    NumberFormatter.prototype.doFormat = function (row, cell, value, columnDef, dataContext) {\n        var format, language, rounding;\n        format = this.format;\n        language = this.language;\n        rounding = (function () {\n            switch (this.rounding) {\n                case \"round\":\n                case \"nearest\":\n                    return Math.round;\n                case \"floor\":\n                case \"rounddown\":\n                    return Math.floor;\n                case \"ceil\":\n                case \"roundup\":\n                    return Math.ceil;\n            }\n        }).call(this);\n        value = Numbro.format(value, format, language, rounding);\n        return NumberFormatter.__super__.doFormat.call(this, row, cell, value, columnDef, dataContext);\n    };\n    return NumberFormatter;\n})(exports.StringFormatter);\nexports.BooleanFormatter = (function (superClass) {\n    extend(BooleanFormatter, superClass);\n    function BooleanFormatter() {\n        return BooleanFormatter.__super__.constructor.apply(this, arguments);\n    }\n    BooleanFormatter.prototype.type = 'BooleanFormatter';\n    BooleanFormatter.define({\n        icon: [p.String, 'check']\n    });\n    BooleanFormatter.prototype.doFormat = function (row, cell, value, columnDef, dataContext) {\n        if (!!value) {\n            return $('<i>').addClass(this.icon).html();\n        }\n        else {\n            return \"\";\n        }\n    };\n    return BooleanFormatter;\n})(exports.CellFormatter);\nexports.DateFormatter = (function (superClass) {\n    extend(DateFormatter, superClass);\n    function DateFormatter() {\n        return DateFormatter.__super__.constructor.apply(this, arguments);\n    }\n    DateFormatter.prototype.type = 'DateFormatter';\n    DateFormatter.define({\n        format: [p.String, 'yy M d']\n    });\n    DateFormatter.prototype.getFormat = function () {\n        var format, name;\n        format = this.format;\n        name = (function () {\n            switch (format) {\n                case \"ATOM\":\n                case \"W3C\":\n                case \"RFC-3339\":\n                case \"ISO-8601\":\n                    return \"ISO-8601\";\n                case \"COOKIE\":\n                    return \"COOKIE\";\n                case \"RFC-850\":\n                    return \"RFC-850\";\n                case \"RFC-1036\":\n                    return \"RFC-1036\";\n                case \"RFC-1123\":\n                    return \"RFC-1123\";\n                case \"RFC-2822\":\n                    return \"RFC-2822\";\n                case \"RSS\":\n                case \"RFC-822\":\n                    return \"RFC-822\";\n                case \"TICKS\":\n                    return \"TICKS\";\n                case \"TIMESTAMP\":\n                    return \"TIMESTAMP\";\n                default:\n                    return null;\n            }\n        })();\n        if (name != null) {\n            return $.datepicker[name];\n        }\n        else {\n            return format;\n        }\n    };\n    DateFormatter.prototype.doFormat = function (row, cell, value, columnDef, dataContext) {\n        var date;\n        value = _.isString(value) ? parseInt(value, 10) : value;\n        date = $.datepicker.formatDate(this.getFormat(), new Date(value));\n        return DateFormatter.__super__.doFormat.call(this, row, cell, date, columnDef, dataContext);\n    };\n    return DateFormatter;\n})(exports.CellFormatter);\nexports.HTMLTemplateFormatter = (function (superClass) {\n    extend(HTMLTemplateFormatter, superClass);\n    function HTMLTemplateFormatter() {\n        return HTMLTemplateFormatter.__super__.constructor.apply(this, arguments);\n    }\n    HTMLTemplateFormatter.prototype.type = 'HTMLTemplateFormatter';\n    HTMLTemplateFormatter.define({\n        template: [p.String, '<%= value %>']\n    });\n    HTMLTemplateFormatter.prototype.doFormat = function (row, cell, value, columnDef, dataContext) {\n        var compiled_template, template;\n        template = this.template;\n        if (value === null) {\n            return \"\";\n        }\n        else {\n            dataContext = _.extend({}, dataContext, {\n                value: value\n            });\n            compiled_template = _.template(template);\n            return compiled_template(dataContext);\n        }\n    };\n    return HTMLTemplateFormatter;\n})(exports.CellFormatter);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar $ = require(\"jquery\");\nrequire(\"bootstrap/button\");\nvar widget_1 = require(\"./widget\");\nvar p = require(\"../../core/properties\");\nvar button_group_template_1 = require(\"./button_group_template\");\nexports.CheckboxButtonGroupView = (function (superClass) {\n    extend(CheckboxButtonGroupView, superClass);\n    function CheckboxButtonGroupView() {\n        return CheckboxButtonGroupView.__super__.constructor.apply(this, arguments);\n    }\n    CheckboxButtonGroupView.prototype.events = {\n        \"change input\": \"change_input\"\n    };\n    CheckboxButtonGroupView.prototype.template = button_group_template_1.default;\n    CheckboxButtonGroupView.prototype.initialize = function (options) {\n        CheckboxButtonGroupView.__super__.initialize.call(this, options);\n        this.render();\n        return this.listenTo(this.model, 'change', this.render);\n    };\n    CheckboxButtonGroupView.prototype.render = function () {\n        var $input, $label, active, html, i, j, label, len, ref;\n        CheckboxButtonGroupView.__super__.render.call(this);\n        this.$el.empty();\n        html = this.template();\n        this.$el.append(html);\n        active = this.model.active;\n        ref = this.model.labels;\n        for (i = j = 0, len = ref.length; j < len; i = ++j) {\n            label = ref[i];\n            $input = $('<input type=\"checkbox\">').attr({\n                value: \"\" + i\n            });\n            if (indexOf.call(active, i) >= 0) {\n                $input.prop(\"checked\", true);\n            }\n            $label = $('<label class=\"bk-bs-btn\"></label>');\n            $label.text(label).prepend($input);\n            $label.addClass(\"bk-bs-btn-\" + this.model.button_type);\n            if (indexOf.call(active, i) >= 0) {\n                $label.addClass(\"bk-bs-active\");\n            }\n            this.$el.find('.bk-bs-btn-group').append($label);\n        }\n        return this;\n    };\n    CheckboxButtonGroupView.prototype.change_input = function () {\n        var active, checkbox, i, ref;\n        active = (function () {\n            var j, len, ref, results;\n            ref = this.$el.find(\"input\");\n            results = [];\n            for (i = j = 0, len = ref.length; j < len; i = ++j) {\n                checkbox = ref[i];\n                if (checkbox.checked) {\n                    results.push(i);\n                }\n            }\n            return results;\n        }).call(this);\n        this.model.active = active;\n        return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n    };\n    return CheckboxButtonGroupView;\n})(widget_1.WidgetView);\nexports.CheckboxButtonGroup = (function (superClass) {\n    extend(CheckboxButtonGroup, superClass);\n    function CheckboxButtonGroup() {\n        return CheckboxButtonGroup.__super__.constructor.apply(this, arguments);\n    }\n    CheckboxButtonGroup.prototype.type = \"CheckboxButtonGroup\";\n    CheckboxButtonGroup.prototype.default_view = exports.CheckboxButtonGroupView;\n    CheckboxButtonGroup.define({\n        active: [p.Array, []],\n        labels: [p.Array, []],\n        button_type: [p.String, \"default\"],\n        callback: [p.Instance]\n    });\n    return CheckboxButtonGroup;\n})(widget_1.Widget);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item)\n        return i;\n} return -1; };\nvar $ = require(\"jquery\");\nvar widget_1 = require(\"./widget\");\nvar p = require(\"../../core/properties\");\nexports.CheckboxGroupView = (function (superClass) {\n    extend(CheckboxGroupView, superClass);\n    function CheckboxGroupView() {\n        return CheckboxGroupView.__super__.constructor.apply(this, arguments);\n    }\n    CheckboxGroupView.prototype.events = {\n        \"change input\": \"change_input\"\n    };\n    CheckboxGroupView.prototype.initialize = function (options) {\n        CheckboxGroupView.__super__.initialize.call(this, options);\n        this.render();\n        return this.listenTo(this.model, 'change', this.render);\n    };\n    CheckboxGroupView.prototype.render = function () {\n        var $div, $input, $label, active, i, j, label, len, ref;\n        CheckboxGroupView.__super__.render.call(this);\n        this.$el.empty();\n        active = this.model.active;\n        ref = this.model.labels;\n        for (i = j = 0, len = ref.length; j < len; i = ++j) {\n            label = ref[i];\n            $input = $('<input type=\"checkbox\">').attr({\n                value: \"\" + i\n            });\n            if (this.model.disabled) {\n                $input.prop(\"disabled\", true);\n            }\n            if (indexOf.call(active, i) >= 0) {\n                $input.prop(\"checked\", true);\n            }\n            $label = $('<label></label>').text(label).prepend($input);\n            if (this.model.inline) {\n                $label.addClass(\"bk-bs-checkbox-inline\");\n                this.$el.append($label);\n            }\n            else {\n                $div = $('<div class=\"bk-bs-checkbox\"></div>').append($label);\n                this.$el.append($div);\n            }\n        }\n        return this;\n    };\n    CheckboxGroupView.prototype.change_input = function () {\n        var active, checkbox, i, ref;\n        active = (function () {\n            var j, len, ref, results;\n            ref = this.$el.find(\"input\");\n            results = [];\n            for (i = j = 0, len = ref.length; j < len; i = ++j) {\n                checkbox = ref[i];\n                if (checkbox.checked) {\n                    results.push(i);\n                }\n            }\n            return results;\n        }).call(this);\n        this.model.active = active;\n        return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n    };\n    return CheckboxGroupView;\n})(widget_1.WidgetView);\nexports.CheckboxGroup = (function (superClass) {\n    extend(CheckboxGroup, superClass);\n    function CheckboxGroup() {\n        return CheckboxGroup.__super__.constructor.apply(this, arguments);\n    }\n    CheckboxGroup.prototype.type = \"CheckboxGroup\";\n    CheckboxGroup.prototype.default_view = exports.CheckboxGroupView;\n    CheckboxGroup.define({\n        active: [p.Array, []],\n        labels: [p.Array, []],\n        inline: [p.Bool, false],\n        callback: [p.Instance]\n    });\n    return CheckboxGroup;\n})(widget_1.Widget);\n","\"use strict\";\nvar wait_for_element, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar _ = require(\"underscore\");\nvar $ = require(\"jquery\");\nrequire(\"jquery-ui/sortable\");\nvar SlickGrid = require(\"slick_grid/slick.grid\");\nvar RowSelectionModel = require(\"slick_grid/plugins/slick.rowselectionmodel\");\nvar CheckboxSelectColumn = require(\"slick_grid/plugins/slick.checkboxselectcolumn\");\nvar hittest = require(\"../../core/hittest\");\nvar p = require(\"../../core/properties\");\nvar table_widget_1 = require(\"./table_widget\");\nvar widget_1 = require(\"./widget\");\nwait_for_element = function (el, fn) {\n    var handler, interval;\n    handler = (function (_this) {\n        return function () {\n            if ($.contains(document.documentElement, el)) {\n                clearInterval(interval);\n                return fn();\n            }\n        };\n    })(this);\n    return interval = setInterval(handler, 50);\n};\nexports.DataProvider = (function () {\n    function DataProvider(source1) {\n        var j, ref, results;\n        this.source = source1;\n        this.data = this.source.data;\n        this.fields = _.keys(this.data);\n        if (!_.contains(this.fields, \"index\")) {\n            this.data[\"index\"] = (function () {\n                results = [];\n                for (var j = 0, ref = this.getLength(); 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {\n                    results.push(j);\n                }\n                return results;\n            }).apply(this);\n            this.fields.push(\"index\");\n        }\n    }\n    DataProvider.prototype.getLength = function () {\n        return this.source.get_length();\n    };\n    DataProvider.prototype.getItem = function (offset) {\n        var field, item, j, len, ref;\n        item = {};\n        ref = this.fields;\n        for (j = 0, len = ref.length; j < len; j++) {\n            field = ref[j];\n            item[field] = this.data[field][offset];\n        }\n        return item;\n    };\n    DataProvider.prototype._setItem = function (offset, item) {\n        var field, value;\n        for (field in item) {\n            value = item[field];\n            this.data[field][offset] = value;\n        }\n    };\n    DataProvider.prototype.setItem = function (offset, item) {\n        this._setItem(offset, item);\n        return this.updateSource();\n    };\n    DataProvider.prototype.getField = function (index, field) {\n        var offset;\n        offset = this.data[\"index\"].indexOf(index);\n        return this.data[field][offset];\n    };\n    DataProvider.prototype._setField = function (index, field, value) {\n        var offset;\n        offset = this.data[\"index\"].indexOf(index);\n        this.data[field][offset] = value;\n    };\n    DataProvider.prototype.setField = function (index, field, value) {\n        this._setField(index, field, value);\n        return this.updateSource();\n    };\n    DataProvider.prototype.updateSource = function () {\n        return this.source.trigger(\"change:data\", this, this.source.attributes['data']);\n    };\n    DataProvider.prototype.getItemMetadata = function (index) {\n        return null;\n    };\n    DataProvider.prototype.getRecords = function () {\n        var i;\n        return (function () {\n            var j, ref, results;\n            results = [];\n            for (i = j = 0, ref = this.getLength(); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                results.push(this.getItem(i));\n            }\n            return results;\n        }).call(this);\n    };\n    DataProvider.prototype.sort = function (columns) {\n        var cols, column, i, j, len, record, records;\n        cols = (function () {\n            var j, len, results;\n            results = [];\n            for (j = 0, len = columns.length; j < len; j++) {\n                column = columns[j];\n                results.push([column.sortCol.field, column.sortAsc ? 1 : -1]);\n            }\n            return results;\n        })();\n        if (_.isEmpty(cols)) {\n            cols = [[\"index\", 1]];\n        }\n        records = this.getRecords();\n        records.sort(function (record1, record2) {\n            var field, j, len, ref, result, sign, value1, value2;\n            for (j = 0, len = cols.length; j < len; j++) {\n                ref = cols[j], field = ref[0], sign = ref[1];\n                value1 = record1[field];\n                value2 = record2[field];\n                result = value1 === value2 ? 0 : value1 > value2 ? sign : -sign;\n                if (result !== 0) {\n                    return result;\n                }\n            }\n            return 0;\n        });\n        for (i = j = 0, len = records.length; j < len; i = ++j) {\n            record = records[i];\n            this._setItem(i, record);\n        }\n        return this.updateSource();\n    };\n    return DataProvider;\n})();\nexports.DataTableView = (function (superClass) {\n    extend(DataTableView, superClass);\n    function DataTableView() {\n        return DataTableView.__super__.constructor.apply(this, arguments);\n    }\n    DataTableView.prototype.className = \"bk-data-table\";\n    DataTableView.prototype.initialize = function (options) {\n        var source;\n        DataTableView.__super__.initialize.call(this, options);\n        wait_for_element(this.el, (function (_this) {\n            return function () {\n                return _this.render();\n            };\n        })(this));\n        this.listenTo(this.model, 'change', (function (_this) {\n            return function () {\n                return _this.render();\n            };\n        })(this));\n        source = this.model.source;\n        this.listenTo(source, 'change:data', (function (_this) {\n            return function () {\n                return _this.updateGrid();\n            };\n        })(this));\n        return this.listenTo(source, 'change:selected', (function (_this) {\n            return function () {\n                return _this.updateSelection();\n            };\n        })(this));\n    };\n    DataTableView.prototype.updateGrid = function () {\n        this.data.constructor(this.model.source);\n        this.grid.invalidate();\n        this.grid.render();\n        this.model.source.data = this.model.source.data;\n        return this.model.source.trigger('change');\n    };\n    DataTableView.prototype.updateSelection = function () {\n        var cur_grid_range, indices, min_index, selected;\n        selected = this.model.source.selected;\n        indices = selected['1d'].indices;\n        this.grid.setSelectedRows(indices);\n        cur_grid_range = this.grid.getViewport();\n        if (this.model.scroll_to_selection && !_.any(indices, function (i) {\n            return (cur_grid_range.top <= i && i <= cur_grid_range.bottom);\n        })) {\n            min_index = Math.max(0, Math.min.apply(null, indices) - 1);\n            return this.grid.scrollRowToTop(min_index);\n        }\n    };\n    DataTableView.prototype.newIndexColumn = function () {\n        return {\n            id: _.uniqueId(),\n            name: \"#\",\n            field: \"index\",\n            width: 40,\n            behavior: \"select\",\n            cannotTriggerInsert: true,\n            resizable: false,\n            selectable: false,\n            sortable: true,\n            cssClass: \"bk-cell-index\"\n        };\n    };\n    DataTableView.prototype.render = function () {\n        var checkboxSelector, column, columns, height, options, width;\n        columns = (function () {\n            var j, len, ref, results;\n            ref = this.model.columns;\n            results = [];\n            for (j = 0, len = ref.length; j < len; j++) {\n                column = ref[j];\n                results.push(column.toColumn());\n            }\n            return results;\n        }).call(this);\n        if (this.model.selectable === \"checkbox\") {\n            checkboxSelector = new CheckboxSelectColumn({\n                cssClass: \"bk-cell-select\"\n            });\n            columns.unshift(checkboxSelector.getColumnDefinition());\n        }\n        if (this.model.row_headers && (this.model.source.get_column(\"index\") != null)) {\n            columns.unshift(this.newIndexColumn());\n        }\n        width = this.model.width;\n        height = this.model.height;\n        options = {\n            enableCellNavigation: this.model.selectable !== false,\n            enableColumnReorder: true,\n            forceFitColumns: this.model.fit_columns,\n            autoHeight: height === \"auto\",\n            multiColumnSort: this.model.sortable,\n            editable: this.model.editable,\n            autoEdit: false\n        };\n        if (width != null) {\n            this.$el.css({\n                width: this.model.width + \"px\"\n            });\n        }\n        else {\n            this.$el.css({\n                width: this.model.default_width + \"px\"\n            });\n        }\n        if ((height != null) && height !== \"auto\") {\n            this.$el.css({\n                height: this.model.height + \"px\"\n            });\n        }\n        this.data = new exports.DataProvider(this.model.source);\n        this.grid = new SlickGrid(this.el, this.data, columns, options);\n        this.grid.onSort.subscribe((function (_this) {\n            return function (event, args) {\n                columns = args.sortCols;\n                _this.data.sort(columns);\n                _this.grid.invalidate();\n                return _this.grid.render();\n            };\n        })(this));\n        if (this.model.selectable !== false) {\n            this.grid.setSelectionModel(new RowSelectionModel({\n                selectActiveRow: checkboxSelector == null\n            }));\n            if (checkboxSelector != null) {\n                this.grid.registerPlugin(checkboxSelector);\n            }\n            this.grid.onSelectedRowsChanged.subscribe((function (_this) {\n                return function (event, args) {\n                    var selected;\n                    selected = hittest.create_hit_test_result();\n                    selected['1d'].indices = args.rows;\n                    return _this.model.source.selected = selected;\n                };\n            })(this));\n        }\n        return this;\n    };\n    return DataTableView;\n})(widget_1.WidgetView);\nexports.DataTable = (function (superClass) {\n    extend(DataTable, superClass);\n    function DataTable() {\n        return DataTable.__super__.constructor.apply(this, arguments);\n    }\n    DataTable.prototype.type = 'DataTable';\n    DataTable.prototype.default_view = exports.DataTableView;\n    DataTable.define({\n        columns: [p.Array, []],\n        fit_columns: [p.Bool, true],\n        sortable: [p.Bool, true],\n        editable: [p.Bool, false],\n        selectable: [p.Bool, true],\n        row_headers: [p.Bool, true],\n        scroll_to_selection: [p.Bool, true]\n    });\n    DataTable.override({\n        height: 400\n    });\n    DataTable.internal({\n        default_width: [p.Number, 600]\n    });\n    return DataTable;\n})(table_widget_1.TableWidget);\n","\"use strict\";\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar $ = require(\"jquery\");\nrequire(\"jquery-ui/datepicker\");\nvar p = require(\"../../core/properties\");\nvar input_widget_1 = require(\"./input_widget\");\nexports.DatePickerView = (function (superClass) {\n    extend(DatePickerView, superClass);\n    function DatePickerView() {\n        this.onSelect = bind(this.onSelect, this);\n        return DatePickerView.__super__.constructor.apply(this, arguments);\n    }\n    DatePickerView.prototype.initialize = function (options) {\n        DatePickerView.__super__.initialize.call(this, options);\n        this.label = $('<label>').text(this.model.title);\n        this.input = $('<input type=\"text\">');\n        this.datepicker = this.input.datepicker({\n            defaultDate: new Date(this.model.value),\n            minDate: this.model.min_date != null ? new Date(this.model.min_date) : null,\n            maxDate: this.model.max_date != null ? new Date(this.model.max_date) : null,\n            onSelect: this.onSelect\n        });\n        return this.$el.append([this.label, this.input]);\n    };\n    DatePickerView.prototype.onSelect = function (dateText, ui) {\n        var d, ref;\n        d = new Date(dateText);\n        this.model.value = d.toString();\n        return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n    };\n    return DatePickerView;\n})(input_widget_1.InputWidgetView);\nexports.DatePicker = (function (superClass) {\n    extend(DatePicker, superClass);\n    function DatePicker() {\n        return DatePicker.__super__.constructor.apply(this, arguments);\n    }\n    DatePicker.prototype.type = \"DatePicker\";\n    DatePicker.prototype.default_view = exports.DatePickerView;\n    DatePicker.define({\n        value: [p.Any, Date.now()],\n        min_date: [p.Any],\n        max_date: [p.Any]\n    });\n    return DatePicker;\n})(input_widget_1.InputWidget);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar _ = require(\"underscore\");\nrequire(\"jqrangeslider/jQDateRangeSlider\");\nvar p = require(\"../../core/properties\");\nvar input_widget_1 = require(\"./input_widget\");\nexports.DateRangeSliderView = (function (superClass) {\n    extend(DateRangeSliderView, superClass);\n    function DateRangeSliderView() {\n        return DateRangeSliderView.__super__.constructor.apply(this, arguments);\n    }\n    DateRangeSliderView.prototype.initialize = function (options) {\n        DateRangeSliderView.__super__.initialize.call(this, options);\n        this.render();\n        return this.listenTo(this.model, 'change', (function (_this) {\n            return function () {\n                return _this.render;\n            };\n        })(this));\n    };\n    DateRangeSliderView.prototype.render = function () {\n        var bounds_max, bounds_min, range_max, range_min, ref, ref1, ref2, value_max, value_min;\n        DateRangeSliderView.__super__.render.call(this);\n        this.$el.empty();\n        ref = this.model.value, value_min = ref[0], value_max = ref[1];\n        ref1 = this.model.range, range_min = ref1[0], range_max = ref1[1];\n        ref2 = this.model.bounds, bounds_min = ref2[0], bounds_max = ref2[1];\n        this.$el.dateRangeSlider({\n            defaultValues: {\n                min: new Date(value_min),\n                max: new Date(value_max)\n            },\n            bounds: {\n                min: new Date(bounds_min),\n                max: new Date(bounds_max)\n            },\n            range: {\n                min: _.isObject(range_min) ? range_min : false,\n                max: _.isObject(range_max) ? range_max : false\n            },\n            step: this.model.step || {},\n            enabled: this.model.enabled,\n            arrows: this.model.arrows,\n            valueLabels: this.model.value_labels,\n            wheelMode: this.model.wheel_mode\n        });\n        this.$el.on(\"userValuesChanged\", (function (_this) {\n            return function (event, data) {\n                var ref3;\n                _this.model.value = [data.values.min, data.values.max];\n                return (ref3 = _this.model.callback) != null ? ref3.execute(_this.model) : void 0;\n            };\n        })(this));\n        return this;\n    };\n    return DateRangeSliderView;\n})(input_widget_1.InputWidgetView);\nexports.DateRangeSlider = (function (superClass) {\n    extend(DateRangeSlider, superClass);\n    function DateRangeSlider() {\n        return DateRangeSlider.__super__.constructor.apply(this, arguments);\n    }\n    DateRangeSlider.prototype.type = \"DateRangeSlider\";\n    DateRangeSlider.prototype.default_view = exports.DateRangeSliderView;\n    DateRangeSlider.define({\n        value: [p.Any],\n        range: [p.Any],\n        bounds: [p.Any],\n        step: [p.Any, {}],\n        enabled: [p.Bool, true],\n        arrows: [p.Bool, true],\n        value_labels: [p.String, \"show\"],\n        wheel_mode: [p.Any]\n    });\n    return DateRangeSlider;\n})(input_widget_1.InputWidget);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar $ = require(\"jquery\");\nvar markup_1 = require(\"./markup\");\nvar p = require(\"../../core/properties\");\nexports.DivView = (function (superClass) {\n    extend(DivView, superClass);\n    function DivView() {\n        return DivView.__super__.constructor.apply(this, arguments);\n    }\n    DivView.prototype.render = function () {\n        var $content;\n        DivView.__super__.render.call(this);\n        if (this.model.render_as_text === true) {\n            $content = $('<div></div>').text(this.model.text);\n        }\n        else {\n            $content = $('<div></div>').html(this.model.text);\n        }\n        this.$el.find('.bk-markup').append($content);\n        return this;\n    };\n    return DivView;\n})(markup_1.MarkupView);\nexports.Div = (function (superClass) {\n    extend(Div, superClass);\n    function Div() {\n        return Div.__super__.constructor.apply(this, arguments);\n    }\n    Div.prototype.type = \"Div\";\n    Div.prototype.default_view = exports.DivView;\n    Div.define({\n        render_as_text: [p.Bool, false]\n    });\n    return Div;\n})(markup_1.Markup);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar $ = require(\"jquery\");\nrequire(\"bootstrap/dropdown\");\nvar p = require(\"../../core/properties\");\nvar abstract_button_1 = require(\"./abstract_button\");\nvar dropdown_template_1 = require(\"./dropdown_template\");\nexports.DropdownView = (function (superClass) {\n    extend(DropdownView, superClass);\n    function DropdownView() {\n        return DropdownView.__super__.constructor.apply(this, arguments);\n    }\n    DropdownView.prototype.template = dropdown_template_1.default;\n    DropdownView.prototype.render = function () {\n        var $a, $item, i, item, items, label, len, ref, that, value;\n        DropdownView.__super__.render.call(this);\n        items = [];\n        ref = this.model.menu;\n        for (i = 0, len = ref.length; i < len; i++) {\n            item = ref[i];\n            $item = item != null ? ((label = item[0], value = item[1], item), $a = $(\"<a data-value='\" + value + \"'>\" + label + \"</a>\"), that = this, $a.click(function (e) {\n                return that.set_value($(this).data('value'));\n            }), $('<li></li>').append($a)) : $('<li class=\"bk-bs-divider\"></li>');\n            items.push($item);\n        }\n        this.$el.find('.bk-bs-dropdown-menu').append(items);\n        this.$el.find('button').val(this.model.default_value);\n        this.$el.find('button').dropdown();\n        return this;\n    };\n    DropdownView.prototype.set_value = function (value) {\n        this.model.value = value;\n        return this.$el.find('button').val(value);\n    };\n    return DropdownView;\n})(abstract_button_1.AbstractButtonView);\nexports.Dropdown = (function (superClass) {\n    extend(Dropdown, superClass);\n    function Dropdown() {\n        return Dropdown.__super__.constructor.apply(this, arguments);\n    }\n    Dropdown.prototype.type = \"Dropdown\";\n    Dropdown.prototype.default_view = exports.DropdownView;\n    Dropdown.define({\n        value: [p.String],\n        default_value: [p.String],\n        menu: [p.Array, []]\n    });\n    Dropdown.override({\n        label: \"Dropdown\"\n    });\n    return Dropdown;\n})(abstract_button_1.AbstractButton);\n","\"use strict\";\nvar DOM = require(\"../../core/util/dom\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = function (props) {\n    var classes = [\"bk-bs-btn\", \"bk-bs-btn-\" + props.button_type, \"bk-bs-dropdown-toggle\", \"bk-bs-dropdown-btn\"];\n    return (DOM.createElement(\"fragment\", null,\n        DOM.createElement(\"button\", { type: \"button\", class: classes, \"data-bk-bs-toggle\": \"dropdown\" },\n            props.label,\n            \" \",\n            DOM.createElement(\"span\", { class: \"bk-bs-caret\" })),\n        DOM.createElement(\"ul\", { class: \"bk-bs-dropdown-menu\" })));\n};\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./cell_editors\"));\n__export(require(\"./cell_formatters\"));\nvar abstract_button_1 = require(\"./abstract_button\");\nexports.AbstractButton = abstract_button_1.AbstractButton;\nvar abstract_icon_1 = require(\"./abstract_icon\");\nexports.AbstractIcon = abstract_icon_1.AbstractIcon;\nvar table_widget_1 = require(\"./table_widget\");\nexports.TableWidget = table_widget_1.TableWidget;\nvar markup_1 = require(\"./markup\");\nexports.Markup = markup_1.Markup;\nvar widget_1 = require(\"./widget\");\nexports.Widget = widget_1.Widget;\nvar input_widget_1 = require(\"./input_widget\");\nexports.InputWidget = input_widget_1.InputWidget;\nvar table_column_1 = require(\"./table_column\");\nexports.TableColumn = table_column_1.TableColumn;\nvar data_table_1 = require(\"./data_table\");\nexports.DataTable = data_table_1.DataTable;\nvar paragraph_1 = require(\"./paragraph\");\nexports.Paragraph = paragraph_1.Paragraph;\nvar div_1 = require(\"./div\");\nexports.Div = div_1.Div;\nvar text_input_1 = require(\"./text_input\");\nexports.TextInput = text_input_1.TextInput;\nvar autocomplete_input_1 = require(\"./autocomplete_input\");\nexports.AutocompleteInput = autocomplete_input_1.AutocompleteInput;\nvar pretext_1 = require(\"./pretext\");\nexports.PreText = pretext_1.PreText;\nvar selectbox_1 = require(\"./selectbox\");\nexports.Select = selectbox_1.Select;\nvar slider_1 = require(\"./slider\");\nexports.Slider = slider_1.Slider;\nvar range_slider_1 = require(\"./range_slider\");\nexports.RangeSlider = range_slider_1.RangeSlider;\nvar multiselect_1 = require(\"./multiselect\");\nexports.MultiSelect = multiselect_1.MultiSelect;\nvar date_range_slider_1 = require(\"./date_range_slider\");\nexports.DateRangeSlider = date_range_slider_1.DateRangeSlider;\nvar date_picker_1 = require(\"./date_picker\");\nexports.DatePicker = date_picker_1.DatePicker;\nvar panel_1 = require(\"./panel\");\nexports.Panel = panel_1.Panel;\nvar tabs_1 = require(\"./tabs\");\nexports.Tabs = tabs_1.Tabs;\nvar button_1 = require(\"./button\");\nexports.Button = button_1.Button;\nvar toggle_1 = require(\"./toggle\");\nexports.Toggle = toggle_1.Toggle;\nvar dropdown_1 = require(\"./dropdown\");\nexports.Dropdown = dropdown_1.Dropdown;\nvar checkbox_group_1 = require(\"./checkbox_group\");\nexports.CheckboxGroup = checkbox_group_1.CheckboxGroup;\nvar radio_group_1 = require(\"./radio_group\");\nexports.RadioGroup = radio_group_1.RadioGroup;\nvar checkbox_button_group_1 = require(\"./checkbox_button_group\");\nexports.CheckboxButtonGroup = checkbox_button_group_1.CheckboxButtonGroup;\nvar radio_button_group_1 = require(\"./radio_button_group\");\nexports.RadioButtonGroup = radio_button_group_1.RadioButtonGroup;\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar widget_1 = require(\"./widget\");\nvar p = require(\"../../core/properties\");\nexports.InputWidgetView = (function (superClass) {\n    extend(InputWidgetView, superClass);\n    function InputWidgetView() {\n        return InputWidgetView.__super__.constructor.apply(this, arguments);\n    }\n    InputWidgetView.prototype.render = function () {\n        InputWidgetView.__super__.render.call(this);\n        return this.$el.find('input').prop(\"disabled\", this.model.disabled);\n    };\n    InputWidgetView.prototype.change_input = function () {\n        var ref;\n        return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n    };\n    return InputWidgetView;\n})(widget_1.WidgetView);\nexports.InputWidget = (function (superClass) {\n    extend(InputWidget, superClass);\n    function InputWidget() {\n        return InputWidget.__super__.constructor.apply(this, arguments);\n    }\n    InputWidget.prototype.type = \"InputWidget\";\n    InputWidget.prototype.default_view = exports.InputWidgetView;\n    InputWidget.define({\n        callback: [p.Instance],\n        title: [p.String, '']\n    });\n    return InputWidget;\n})(widget_1.Widget);\n","\"use strict\";\nvar Widgets = require(\"./index\");\nexports.models = Widgets;\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"../../core/properties\");\nvar widget_1 = require(\"./widget\");\nvar markup_template_1 = require(\"./markup_template\");\nexports.MarkupView = (function (superClass) {\n    extend(MarkupView, superClass);\n    function MarkupView() {\n        return MarkupView.__super__.constructor.apply(this, arguments);\n    }\n    MarkupView.prototype.template = markup_template_1.default;\n    MarkupView.prototype.initialize = function (options) {\n        MarkupView.__super__.initialize.call(this, options);\n        this.render();\n        return this.listenTo(this.model, 'change', this.render);\n    };\n    MarkupView.prototype.render = function () {\n        MarkupView.__super__.render.call(this);\n        this.$el.empty();\n        this.$el.html(this.template());\n        if (this.model.height) {\n            this.$el.height(this.model.height);\n        }\n        if (this.model.width) {\n            return this.$el.width(this.model.width);\n        }\n    };\n    return MarkupView;\n})(widget_1.WidgetView);\nexports.Markup = (function (superClass) {\n    extend(Markup, superClass);\n    function Markup() {\n        return Markup.__super__.constructor.apply(this, arguments);\n    }\n    Markup.prototype.type = \"Markup\";\n    Markup.prototype.initialize = function (options) {\n        return Markup.__super__.initialize.call(this, options);\n    };\n    Markup.define({\n        text: [p.String, '']\n    });\n    return Markup;\n})(widget_1.Widget);\n","\"use strict\";\nvar DOM = require(\"../../core/util/dom\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = function () {\n    return DOM.createElement(\"div\", { class: \"bk-markup\" });\n};\n","\"use strict\";\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"../../core/properties\");\nvar input_widget_1 = require(\"./input_widget\");\nvar multiselecttemplate_1 = require(\"./multiselecttemplate\");\nexports.MultiSelectView = (function (superClass) {\n    extend(MultiSelectView, superClass);\n    function MultiSelectView() {\n        this.render_selection = bind(this.render_selection, this);\n        return MultiSelectView.__super__.constructor.apply(this, arguments);\n    }\n    MultiSelectView.prototype.tagName = \"div\";\n    MultiSelectView.prototype.template = multiselecttemplate_1.default;\n    MultiSelectView.prototype.events = {\n        \"change select\": \"change_input\"\n    };\n    MultiSelectView.prototype.initialize = function (options) {\n        MultiSelectView.__super__.initialize.call(this, options);\n        this.render();\n        this.listenTo(this.model, 'change:value', this.render_selection);\n        this.listenTo(this.model, 'change:options', this.render);\n        this.listenTo(this.model, 'change:name', this.render);\n        this.listenTo(this.model, 'change:title', this.render);\n        return this.listenTo(this.model, 'change:size', this.render);\n    };\n    MultiSelectView.prototype.render = function () {\n        var html;\n        MultiSelectView.__super__.render.call(this);\n        this.$el.empty();\n        html = this.template(this.model.attributes);\n        this.$el.html(html);\n        this.render_selection();\n        return this;\n    };\n    MultiSelectView.prototype.render_selection = function () {\n        var i, len, ref, values, x;\n        values = {};\n        ref = this.model.value;\n        for (i = 0, len = ref.length; i < len; i++) {\n            x = ref[i];\n            values[x] = true;\n        }\n        this.$el.find('option').each((function (_this) {\n            return function (el) {\n                el = _this.$el.find(el);\n                if (values[el.attr('value')]) {\n                    return el.attr('selected', 'selected');\n                }\n            };\n        })(this));\n        return this.$el.find('select').attr('size', this.model.size);\n    };\n    MultiSelectView.prototype.change_input = function () {\n        var is_focused, value;\n        is_focused = this.$el.find('select:focus').size();\n        value = this.$el.find('select').val();\n        if (value) {\n            this.model.value = value;\n        }\n        else {\n            this.model.value = [];\n        }\n        MultiSelectView.__super__.change_input.call(this);\n        if (is_focused) {\n            return this.$el.find('select').focus();\n        }\n    };\n    return MultiSelectView;\n})(input_widget_1.InputWidgetView);\nexports.MultiSelect = (function (superClass) {\n    extend(MultiSelect, superClass);\n    function MultiSelect() {\n        return MultiSelect.__super__.constructor.apply(this, arguments);\n    }\n    MultiSelect.prototype.type = \"MultiSelect\";\n    MultiSelect.prototype.default_view = exports.MultiSelectView;\n    MultiSelect.define({\n        value: [p.Array, []],\n        options: [p.Array, []],\n        size: [p.Number, 4]\n    });\n    return MultiSelect;\n})(input_widget_1.InputWidget);\n","\"use strict\";\nvar _ = require(\"underscore\");\nvar DOM = require(\"../../core/util/dom\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = function (props) {\n    return (DOM.createElement(\"fragment\", null,\n        DOM.createElement(\"label\", { for: props.id },\n            \" \",\n            props.title,\n            \" \"),\n        DOM.createElement(\"select\", { multiple: true, class: \"bk-widget-form-input\", id: props.id, name: props.name }, props.options.map(function (option) {\n            var value, label;\n            if (_.isString(option)) {\n                value = label = option;\n            }\n            else {\n                value = option[0], label = option[1];\n            }\n            var selected = props.value.indexOf(value) > -1;\n            return DOM.createElement(\"option\", { selected: selected, value: value }, label);\n        }))));\n};\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"../../core/properties\");\nvar widget_1 = require(\"./widget\");\nexports.PanelView = (function (superClass) {\n    extend(PanelView, superClass);\n    function PanelView() {\n        return PanelView.__super__.constructor.apply(this, arguments);\n    }\n    PanelView.prototype.render = function () {\n        PanelView.__super__.render.call(this);\n        this.$el.empty();\n        return this;\n    };\n    return PanelView;\n})(widget_1.WidgetView);\nexports.Panel = (function (superClass) {\n    extend(Panel, superClass);\n    function Panel() {\n        return Panel.__super__.constructor.apply(this, arguments);\n    }\n    Panel.prototype.type = \"Panel\";\n    Panel.prototype.default_view = exports.PanelView;\n    Panel.define({\n        title: [p.String, \"\"],\n        child: [p.Instance],\n        closable: [p.Bool, false]\n    });\n    return Panel;\n})(widget_1.Widget);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar $ = require(\"jquery\");\nvar markup_1 = require(\"./markup\");\nexports.ParagraphView = (function (superClass) {\n    extend(ParagraphView, superClass);\n    function ParagraphView() {\n        return ParagraphView.__super__.constructor.apply(this, arguments);\n    }\n    ParagraphView.prototype.render = function () {\n        var $para;\n        ParagraphView.__super__.render.call(this);\n        $para = $('<p style=\"margin: 0;\"></p>').text(this.model.text);\n        return this.$el.find('.bk-markup').append($para);\n    };\n    return ParagraphView;\n})(markup_1.MarkupView);\nexports.Paragraph = (function (superClass) {\n    extend(Paragraph, superClass);\n    function Paragraph() {\n        return Paragraph.__super__.constructor.apply(this, arguments);\n    }\n    Paragraph.prototype.type = \"Paragraph\";\n    Paragraph.prototype.default_view = exports.ParagraphView;\n    return Paragraph;\n})(markup_1.Markup);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar $ = require(\"jquery\");\nvar markup_1 = require(\"./markup\");\nexports.PreTextView = (function (superClass) {\n    extend(PreTextView, superClass);\n    function PreTextView() {\n        return PreTextView.__super__.constructor.apply(this, arguments);\n    }\n    PreTextView.prototype.render = function () {\n        var $pre;\n        PreTextView.__super__.render.call(this);\n        $pre = $('<pre style=\"overflow: auto\"></pre>').text(this.model.text);\n        return this.$el.find('.bk-markup').append($pre);\n    };\n    return PreTextView;\n})(markup_1.MarkupView);\nexports.PreText = (function (superClass) {\n    extend(PreText, superClass);\n    function PreText() {\n        return PreText.__super__.constructor.apply(this, arguments);\n    }\n    PreText.prototype.type = \"PreText\";\n    PreText.prototype.default_view = exports.PreTextView;\n    return PreText;\n})(markup_1.Markup);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar _ = require(\"underscore\");\nvar $ = require(\"jquery\");\nrequire(\"bootstrap/button\");\nvar p = require(\"../../core/properties\");\nvar widget_1 = require(\"./widget\");\nvar button_group_template_1 = require(\"./button_group_template\");\nexports.RadioButtonGroupView = (function (superClass) {\n    extend(RadioButtonGroupView, superClass);\n    function RadioButtonGroupView() {\n        return RadioButtonGroupView.__super__.constructor.apply(this, arguments);\n    }\n    RadioButtonGroupView.prototype.events = {\n        \"change input\": \"change_input\"\n    };\n    RadioButtonGroupView.prototype.template = button_group_template_1.default;\n    RadioButtonGroupView.prototype.initialize = function (options) {\n        RadioButtonGroupView.__super__.initialize.call(this, options);\n        this.render();\n        return this.listenTo(this.model, 'change', this.render);\n    };\n    RadioButtonGroupView.prototype.render = function () {\n        var $input, $label, active, html, i, j, label, len, name, ref;\n        RadioButtonGroupView.__super__.render.call(this);\n        this.$el.empty();\n        html = this.template();\n        this.$el.append(html);\n        name = _.uniqueId(\"RadioButtonGroup\");\n        active = this.model.active;\n        ref = this.model.labels;\n        for (i = j = 0, len = ref.length; j < len; i = ++j) {\n            label = ref[i];\n            $input = $('<input type=\"radio\">').attr({\n                name: name,\n                value: \"\" + i\n            });\n            if (i === active) {\n                $input.prop(\"checked\", true);\n            }\n            $label = $('<label class=\"bk-bs-btn\"></label>');\n            $label.text(label).prepend($input);\n            $label.addClass(\"bk-bs-btn-\" + this.model.button_type);\n            if (i === active) {\n                $label.addClass(\"bk-bs-active\");\n            }\n            this.$el.find('.bk-bs-btn-group').append($label);\n        }\n        return this;\n    };\n    RadioButtonGroupView.prototype.change_input = function () {\n        var active, i, radio, ref;\n        active = (function () {\n            var j, len, ref, results;\n            ref = this.$el.find(\"input\");\n            results = [];\n            for (i = j = 0, len = ref.length; j < len; i = ++j) {\n                radio = ref[i];\n                if (radio.checked) {\n                    results.push(i);\n                }\n            }\n            return results;\n        }).call(this);\n        this.model.active = active[0];\n        return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n    };\n    return RadioButtonGroupView;\n})(widget_1.WidgetView);\nexports.RadioButtonGroup = (function (superClass) {\n    extend(RadioButtonGroup, superClass);\n    function RadioButtonGroup() {\n        return RadioButtonGroup.__super__.constructor.apply(this, arguments);\n    }\n    RadioButtonGroup.prototype.type = \"RadioButtonGroup\";\n    RadioButtonGroup.prototype.default_view = exports.RadioButtonGroupView;\n    RadioButtonGroup.define({\n        active: [p.Any, null],\n        labels: [p.Array, []],\n        button_type: [p.String, \"default\"],\n        callback: [p.Instance]\n    });\n    return RadioButtonGroup;\n})(widget_1.Widget);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar _ = require(\"underscore\");\nvar $ = require(\"jquery\");\nvar p = require(\"../../core/properties\");\nvar widget_1 = require(\"./widget\");\nexports.RadioGroupView = (function (superClass) {\n    extend(RadioGroupView, superClass);\n    function RadioGroupView() {\n        return RadioGroupView.__super__.constructor.apply(this, arguments);\n    }\n    RadioGroupView.prototype.tagName = \"div\";\n    RadioGroupView.prototype.events = {\n        \"change input\": \"change_input\"\n    };\n    RadioGroupView.prototype.initialize = function (options) {\n        RadioGroupView.__super__.initialize.call(this, options);\n        this.render();\n        return this.listenTo(this.model, 'change', this.render);\n    };\n    RadioGroupView.prototype.render = function () {\n        var $div, $input, $label, active, i, j, label, len, name, ref;\n        RadioGroupView.__super__.render.call(this);\n        this.$el.empty();\n        name = _.uniqueId(\"RadioGroup\");\n        active = this.model.active;\n        ref = this.model.labels;\n        for (i = j = 0, len = ref.length; j < len; i = ++j) {\n            label = ref[i];\n            $input = $('<input type=\"radio\">').attr({\n                name: name,\n                value: \"\" + i\n            });\n            if (this.model.disabled) {\n                $input.prop(\"disabled\", true);\n            }\n            if (i === active) {\n                $input.prop(\"checked\", true);\n            }\n            $label = $('<label></label>').text(label).prepend($input);\n            if (this.model.inline) {\n                $label.addClass(\"bk-bs-radio-inline\");\n                this.$el.append($label);\n            }\n            else {\n                $div = $('<div class=\"bk-bs-radio\"></div>').append($label);\n                this.$el.append($div);\n            }\n        }\n        return this;\n    };\n    RadioGroupView.prototype.change_input = function () {\n        var active, i, radio, ref;\n        active = (function () {\n            var j, len, ref, results;\n            ref = this.$el.find(\"input\");\n            results = [];\n            for (i = j = 0, len = ref.length; j < len; i = ++j) {\n                radio = ref[i];\n                if (radio.checked) {\n                    results.push(i);\n                }\n            }\n            return results;\n        }).call(this);\n        this.model.active = active[0];\n        return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n    };\n    return RadioGroupView;\n})(widget_1.WidgetView);\nexports.RadioGroup = (function (superClass) {\n    extend(RadioGroup, superClass);\n    function RadioGroup() {\n        return RadioGroup.__super__.constructor.apply(this, arguments);\n    }\n    RadioGroup.prototype.type = \"RadioGroup\";\n    RadioGroup.prototype.default_view = exports.RadioGroupView;\n    RadioGroup.define({\n        active: [p.Any, null],\n        labels: [p.Array, []],\n        inline: [p.Bool, false],\n        callback: [p.Instance]\n    });\n    return RadioGroup;\n})(widget_1.Widget);\n","\"use strict\";\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar _ = require(\"underscore\");\nrequire(\"jquery-ui/slider\");\nvar logging_1 = require(\"../../core/logging\");\nvar p = require(\"../../core/properties\");\nvar input_widget_1 = require(\"./input_widget\");\nvar slidertemplate_1 = require(\"./slidertemplate\");\nexports.RangeSliderView = (function (superClass) {\n    extend(RangeSliderView, superClass);\n    function RangeSliderView() {\n        this.slide = bind(this.slide, this);\n        this.slidestop = bind(this.slidestop, this);\n        return RangeSliderView.__super__.constructor.apply(this, arguments);\n    }\n    RangeSliderView.prototype.tagName = \"div\";\n    RangeSliderView.prototype.template = slidertemplate_1.default;\n    RangeSliderView.prototype.initialize = function (options) {\n        var html;\n        RangeSliderView.__super__.initialize.call(this, options);\n        this.listenTo(this.model, 'change', this.render);\n        this.$el.empty();\n        html = this.template(this.model.attributes);\n        this.$el.html(html);\n        this.callbackWrapper = null;\n        if (this.model.callback_policy === 'continuous') {\n            this.callbackWrapper = function () {\n                var ref;\n                return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n            };\n        }\n        if (this.model.callback_policy === 'throttle' && this.model.callback) {\n            this.callbackWrapper = _.throttle(function () {\n                var ref;\n                return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n            }, this.model.callback_throttle);\n        }\n        return this.render();\n    };\n    RangeSliderView.prototype.render = function () {\n        var bk_handle, max, min, opts, step;\n        RangeSliderView.__super__.render.call(this);\n        max = this.model.end;\n        min = this.model.start;\n        step = this.model.step || ((max - min) / 50);\n        logging_1.logger.debug(\"range-slider render: min, max, step = (\" + min + \", \" + max + \", \" + step + \")\");\n        opts = {\n            range: true,\n            orientation: this.model.orientation,\n            animate: \"fast\",\n            values: this.model.range,\n            min: min,\n            max: max,\n            step: step,\n            stop: this.slidestop,\n            slide: this.slide\n        };\n        this.$el.find('.slider').slider(opts);\n        if (this.model.title != null) {\n            this.$el.find(\"#\" + this.model.id).val(this.$el.find('.slider').slider('values').join(' - '));\n        }\n        this.$el.find('.bk-slider-parent').height(this.model.height);\n        bk_handle = this.$el.find('.bk-ui-slider-handle');\n        if (bk_handle.length === 2) {\n            bk_handle[0].style.left = this.$el.find('.ui-slider-handle')[0].style.left;\n            bk_handle[1].style.left = this.$el.find('.ui-slider-handle')[1].style.left;\n        }\n        return this;\n    };\n    RangeSliderView.prototype.slidestop = function (event, ui) {\n        var ref;\n        if (this.model.callback_policy === 'mouseup' || this.model.callback_policy === 'throttle') {\n            return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n        }\n    };\n    RangeSliderView.prototype.slide = function (event, ui) {\n        var values, values_str;\n        values = ui.values;\n        values_str = values.join(' - ');\n        logging_1.logger.debug(\"range-slide value = \" + values_str);\n        if (this.model.title != null) {\n            this.$el.find(\"#\" + this.model.id).val(values_str);\n        }\n        this.model.range = values;\n        if (this.callbackWrapper) {\n            return this.callbackWrapper();\n        }\n    };\n    return RangeSliderView;\n})(input_widget_1.InputWidgetView);\nexports.RangeSlider = (function (superClass) {\n    extend(RangeSlider, superClass);\n    function RangeSlider() {\n        return RangeSlider.__super__.constructor.apply(this, arguments);\n    }\n    RangeSlider.prototype.type = \"RangeSlider\";\n    RangeSlider.prototype.default_view = exports.RangeSliderView;\n    RangeSlider.define({\n        range: [p.Any, [0.1, 0.9]],\n        start: [p.Number, 0],\n        end: [p.Number, 1],\n        step: [p.Number, 0.1],\n        orientation: [p.Orientation, \"horizontal\"],\n        callback_throttle: [p.Number, 200],\n        callback_policy: [p.String, \"throttle\"]\n    });\n    return RangeSlider;\n})(input_widget_1.InputWidget);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar logging_1 = require(\"../../core/logging\");\nvar p = require(\"../../core/properties\");\nvar input_widget_1 = require(\"./input_widget\");\nvar selecttemplate_1 = require(\"./selecttemplate\");\nexports.SelectView = (function (superClass) {\n    extend(SelectView, superClass);\n    function SelectView() {\n        return SelectView.__super__.constructor.apply(this, arguments);\n    }\n    SelectView.prototype.template = selecttemplate_1.default;\n    SelectView.prototype.events = {\n        \"change select\": \"change_input\"\n    };\n    SelectView.prototype.initialize = function (options) {\n        SelectView.__super__.initialize.call(this, options);\n        this.render();\n        return this.listenTo(this.model, 'change', this.render);\n    };\n    SelectView.prototype.render = function () {\n        var html;\n        SelectView.__super__.render.call(this);\n        this.$el.empty();\n        html = this.template(this.model.attributes);\n        this.$el.html(html);\n        return this;\n    };\n    SelectView.prototype.change_input = function () {\n        var value;\n        value = this.$el.find('select').val();\n        logging_1.logger.debug(\"selectbox: value = \" + value);\n        this.model.value = value;\n        return SelectView.__super__.change_input.call(this);\n    };\n    return SelectView;\n})(input_widget_1.InputWidgetView);\nexports.Select = (function (superClass) {\n    extend(Select, superClass);\n    function Select() {\n        return Select.__super__.constructor.apply(this, arguments);\n    }\n    Select.prototype.type = \"Select\";\n    Select.prototype.default_view = exports.SelectView;\n    Select.define({\n        value: [p.String, ''],\n        options: [p.Any, []]\n    });\n    return Select;\n})(input_widget_1.InputWidget);\n","\"use strict\";\nvar _ = require(\"underscore\");\nvar DOM = require(\"../../core/util/dom\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = function (props) {\n    return (DOM.createElement(\"fragment\", null,\n        DOM.createElement(\"label\", { for: props.id },\n            \" \",\n            props.title,\n            \" \"),\n        DOM.createElement(\"select\", { class: \"bk-widget-form-input\", id: props.id, name: props.name }, props.options.map(function (option) {\n            var value, label;\n            if (_.isString(option)) {\n                value = label = option;\n            }\n            else {\n                value = option[0], label = option[1];\n            }\n            var selected = props.value == value;\n            return DOM.createElement(\"option\", { selected: selected, value: value }, label);\n        }))));\n};\n","\"use strict\";\nvar bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar _ = require(\"underscore\");\nrequire(\"jquery-ui/slider\");\nvar logging_1 = require(\"../../core/logging\");\nvar p = require(\"../../core/properties\");\nvar input_widget_1 = require(\"./input_widget\");\nvar slidertemplate_1 = require(\"./slidertemplate\");\nexports.SliderView = (function (superClass) {\n    extend(SliderView, superClass);\n    function SliderView() {\n        this.slide = bind(this.slide, this);\n        this.slidestop = bind(this.slidestop, this);\n        return SliderView.__super__.constructor.apply(this, arguments);\n    }\n    SliderView.prototype.tagName = \"div\";\n    SliderView.prototype.template = slidertemplate_1.default;\n    SliderView.prototype.initialize = function (options) {\n        var html;\n        SliderView.__super__.initialize.call(this, options);\n        this.listenTo(this.model, 'change', this.render);\n        this.$el.empty();\n        html = this.template(this.model.attributes);\n        this.$el.html(html);\n        this.callbackWrapper = null;\n        if (this.model.callback_policy === 'continuous') {\n            this.callbackWrapper = function () {\n                var ref;\n                return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n            };\n        }\n        if (this.model.callback_policy === 'throttle' && this.model.callback) {\n            this.callbackWrapper = _.throttle(function () {\n                var ref;\n                return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n            }, this.model.callback_throttle);\n        }\n        return this.render();\n    };\n    SliderView.prototype.render = function () {\n        var max, min, opts, step;\n        SliderView.__super__.render.call(this);\n        max = this.model.end;\n        min = this.model.start;\n        step = this.model.step || ((max - min) / 50);\n        logging_1.logger.debug(\"slider render: min, max, step = (\" + min + \", \" + max + \", \" + step + \")\");\n        opts = {\n            orientation: this.model.orientation,\n            animate: \"fast\",\n            value: this.model.value,\n            min: min,\n            max: max,\n            step: step,\n            stop: this.slidestop,\n            slide: this.slide\n        };\n        this.$el.find('.slider').slider(opts);\n        if (this.model.title != null) {\n            this.$el.find(\"#\" + this.model.id).val(this.$el.find('.slider').slider('value'));\n        }\n        this.$el.find('.bk-slider-parent').height(this.model.height);\n        return this;\n    };\n    SliderView.prototype.slidestop = function (event, ui) {\n        var ref;\n        if (this.model.callback_policy === 'mouseup' || this.model.callback_policy === 'throttle') {\n            return (ref = this.model.callback) != null ? ref.execute(this.model) : void 0;\n        }\n    };\n    SliderView.prototype.slide = function (event, ui) {\n        var value;\n        value = ui.value;\n        logging_1.logger.debug(\"slide value = \" + value);\n        if (this.model.title != null) {\n            this.$el.find(\"#\" + this.model.id).val(ui.value);\n        }\n        this.model.value = value;\n        if (this.callbackWrapper) {\n            return this.callbackWrapper();\n        }\n    };\n    return SliderView;\n})(input_widget_1.InputWidgetView);\nexports.Slider = (function (superClass) {\n    extend(Slider, superClass);\n    function Slider() {\n        return Slider.__super__.constructor.apply(this, arguments);\n    }\n    Slider.prototype.type = \"Slider\";\n    Slider.prototype.default_view = exports.SliderView;\n    Slider.define({\n        value: [p.Number, 0.5],\n        start: [p.Number, 0],\n        end: [p.Number, 1],\n        step: [p.Number, 0.1],\n        orientation: [p.Orientation, \"horizontal\"],\n        callback_throttle: [p.Number, 200],\n        callback_policy: [p.String, \"throttle\"]\n    });\n    return Slider;\n})(input_widget_1.InputWidget);\n","\"use strict\";\nvar DOM = require(\"../../core/util/dom\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = function (props) {\n    var title, value;\n    if (props.title != null) {\n        if (props.title.length != 0) {\n            title = DOM.createElement(\"label\", { for: props.id },\n                \" \",\n                props.title,\n                \": \");\n        }\n        value = DOM.createElement(\"input\", { type: \"text\", id: props.id, readonly: true });\n    }\n    return (DOM.createElement(\"div\", { class: \"bk-slider-parent\" },\n        title,\n        value,\n        DOM.createElement(\"div\", { class: \"bk-slider-\" + props.orientation },\n            DOM.createElement(\"div\", { class: \"slider\", id: props.id }))));\n};\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar _ = require(\"underscore\");\nvar cell_formatters_1 = require(\"./cell_formatters\");\nvar cell_editors_1 = require(\"./cell_editors\");\nvar p = require(\"../../core/properties\");\nvar model_1 = require(\"../../model\");\nexports.TableColumn = (function (superClass) {\n    extend(TableColumn, superClass);\n    function TableColumn() {\n        return TableColumn.__super__.constructor.apply(this, arguments);\n    }\n    TableColumn.prototype.type = 'TableColumn';\n    TableColumn.prototype.default_view = null;\n    TableColumn.define({\n        field: [p.String],\n        title: [p.String],\n        width: [p.Number, 300],\n        formatter: [\n            p.Instance, function () {\n                return new cell_formatters_1.StringFormatter();\n            }\n        ],\n        editor: [\n            p.Instance, function () {\n                return new cell_editors_1.StringEditor();\n            }\n        ],\n        sortable: [p.Bool, true],\n        default_sort: [p.String, \"ascending\"]\n    });\n    TableColumn.prototype.toColumn = function () {\n        var ref;\n        return {\n            id: _.uniqueId(),\n            field: this.field,\n            name: this.title,\n            width: this.width,\n            formatter: (ref = this.formatter) != null ? ref.doFormat.bind(this.formatter) : void 0,\n            editor: this.editor,\n            sortable: this.sortable,\n            defaultSortAsc: this.default_sort === \"ascending\"\n        };\n    };\n    return TableColumn;\n})(model_1.Model);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar widget_1 = require(\"./widget\");\nvar p = require(\"../../core/properties\");\nexports.TableWidget = (function (superClass) {\n    extend(TableWidget, superClass);\n    function TableWidget() {\n        return TableWidget.__super__.constructor.apply(this, arguments);\n    }\n    TableWidget.prototype.type = \"TableWidget\";\n    TableWidget.define({\n        source: [p.Instance]\n    });\n    return TableWidget;\n})(widget_1.Widget);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar _ = require(\"underscore\");\nvar $ = require(\"jquery\");\nrequire(\"bootstrap/tab\");\nvar p = require(\"../../core/properties\");\nvar tabs_template_1 = require(\"./tabs_template\");\nvar widget_1 = require(\"./widget\");\nexports.TabsView = (function (superClass) {\n    extend(TabsView, superClass);\n    function TabsView() {\n        return TabsView.__super__.constructor.apply(this, arguments);\n    }\n    TabsView.prototype.render = function () {\n        var $panels, active, child, children, html, i, key, len, panel, ref, ref1, ref2, tabs, that, val;\n        TabsView.__super__.render.call(this);\n        ref = this.child_views;\n        for (key in ref) {\n            if (!hasProp.call(ref, key))\n                continue;\n            val = ref[key];\n            val.$el.detach();\n        }\n        this.$el.empty();\n        tabs = this.model.tabs;\n        active = this.model.active;\n        children = this.model.children;\n        html = $(tabs_template_1.default({\n            tabs: tabs,\n            active_tab_id: tabs[active].id\n        }));\n        that = this;\n        html.find(\".bk-bs-nav a\").click(function (event) {\n            var panelId, panelIdx, ref1;\n            event.preventDefault();\n            $(this).tab('show');\n            panelId = $(this).attr('href').replace('#tab-', '');\n            tabs = that.model.tabs;\n            panelIdx = _.findIndex(tabs, function (panel) {\n                return panel.id === panelId;\n            });\n            that.model.active = panelIdx;\n            return (ref1 = that.model.callback) != null ? ref1.execute(that.model) : void 0;\n        });\n        $panels = html.find(\".bk-bs-tab-pane\");\n        ref1 = _.zip(children, $panels);\n        for (i = 0, len = ref1.length; i < len; i++) {\n            ref2 = ref1[i], child = ref2[0], panel = ref2[1];\n            $(panel).html(this.child_views[child.id].$el);\n        }\n        this.$el.append(html);\n        return this;\n    };\n    return TabsView;\n})(widget_1.WidgetView);\nexports.Tabs = (function (superClass) {\n    extend(Tabs, superClass);\n    function Tabs() {\n        return Tabs.__super__.constructor.apply(this, arguments);\n    }\n    Tabs.prototype.type = \"Tabs\";\n    Tabs.prototype.default_view = exports.TabsView;\n    Tabs.define({\n        tabs: [p.Array, []],\n        active: [p.Number, 0],\n        callback: [p.Instance]\n    });\n    Tabs.getters({\n        children: function () {\n            var i, len, ref, results, tab;\n            ref = this.tabs;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n                tab = ref[i];\n                results.push(tab.child);\n            }\n            return results;\n        }\n    });\n    Tabs.prototype.get_layoutable_children = function () {\n        return this.children;\n    };\n    Tabs.prototype.get_edit_variables = function () {\n        var child, edit_variables, i, len, ref;\n        edit_variables = Tabs.__super__.get_edit_variables.call(this);\n        ref = this.get_layoutable_children();\n        for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            edit_variables = edit_variables.concat(child.get_edit_variables());\n        }\n        return edit_variables;\n    };\n    Tabs.prototype.get_constraints = function () {\n        var child, constraints, i, len, ref;\n        constraints = Tabs.__super__.get_constraints.call(this);\n        ref = this.get_layoutable_children();\n        for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            constraints = constraints.concat(child.get_constraints());\n        }\n        return constraints;\n    };\n    return Tabs;\n})(widget_1.Widget);\n","\"use strict\";\nvar DOM = require(\"../../core/util/dom\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = function (props) {\n    var active = function (tab) { return tab.id === props.active_tab_id ? \"bk-bs-active\" : null; };\n    return (DOM.createElement(\"fragment\", null,\n        DOM.createElement(\"ul\", { class: \"bk-bs-nav bk-bs-nav-tabs\" }, props.tabs.map(function (tab) {\n            return DOM.createElement(\"li\", { class: active(tab) },\n                DOM.createElement(\"a\", { href: \"#tab-\" + tab.id }, tab.title));\n        })),\n        DOM.createElement(\"div\", { class: \"bk-bs-tab-content\" }, props.tabs.map(function (tab) { return DOM.createElement(\"div\", { class: [\"bk-bs-tab-pane\", active(tab)], id: \"tab-\" + tab.id }); }))));\n};\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar logging_1 = require(\"../../core/logging\");\nvar p = require(\"../../core/properties\");\nvar input_widget_1 = require(\"./input_widget\");\nvar text_input_template_1 = require(\"./text_input_template\");\nexports.TextInputView = (function (superClass) {\n    extend(TextInputView, superClass);\n    function TextInputView() {\n        return TextInputView.__super__.constructor.apply(this, arguments);\n    }\n    TextInputView.prototype.tagName = \"div\";\n    TextInputView.prototype.className = \"bk-widget-form-group\";\n    TextInputView.prototype.template = text_input_template_1.default;\n    TextInputView.prototype.events = {\n        \"change input\": \"change_input\"\n    };\n    TextInputView.prototype.initialize = function (options) {\n        TextInputView.__super__.initialize.call(this, options);\n        this.render();\n        return this.listenTo(this.model, 'change', this.render);\n    };\n    TextInputView.prototype.render = function () {\n        TextInputView.__super__.render.call(this);\n        this.$el.html(this.template(this.model.attributes));\n        if (this.model.height) {\n            this.$el.find('input').height(this.model.height - 35);\n        }\n        return this;\n    };\n    TextInputView.prototype.change_input = function () {\n        var value;\n        value = this.$el.find('input').val();\n        logging_1.logger.debug(\"widget/text_input: value = \" + value);\n        this.model.value = value;\n        return TextInputView.__super__.change_input.call(this);\n    };\n    return TextInputView;\n})(input_widget_1.InputWidgetView);\nexports.TextInput = (function (superClass) {\n    extend(TextInput, superClass);\n    function TextInput() {\n        return TextInput.__super__.constructor.apply(this, arguments);\n    }\n    TextInput.prototype.type = \"TextInput\";\n    TextInput.prototype.default_view = exports.TextInputView;\n    TextInput.define({\n        value: [p.String, \"\"],\n        placeholder: [p.String, \"\"]\n    });\n    return TextInput;\n})(input_widget_1.InputWidget);\n","\"use strict\";\nvar DOM = require(\"../../core/util/dom\");\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = function (props) {\n    return (DOM.createElement(\"fragment\", null,\n        DOM.createElement(\"label\", { for: props.id },\n            \" \",\n            props.title,\n            \" \"),\n        DOM.createElement(\"input\", { class: \"bk-widget-form-input\", type: \"text\", id: props.id, name: props.name, value: props.value, placeholder: props.placeholder })));\n};\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar p = require(\"../../core/properties\");\nvar abstract_button_1 = require(\"./abstract_button\");\nexports.ToggleView = (function (superClass) {\n    extend(ToggleView, superClass);\n    function ToggleView() {\n        return ToggleView.__super__.constructor.apply(this, arguments);\n    }\n    ToggleView.prototype.render = function () {\n        ToggleView.__super__.render.call(this);\n        if (this.model.active) {\n            this.$el.find('button').addClass(\"bk-bs-active\");\n        }\n        else {\n            this.$el.find('button').removeClass(\"bk-bs-active\");\n        }\n        return this;\n    };\n    ToggleView.prototype.change_input = function () {\n        ToggleView.__super__.change_input.call(this);\n        return this.model.active = !this.model.active;\n    };\n    return ToggleView;\n})(abstract_button_1.AbstractButtonView);\nexports.Toggle = (function (superClass) {\n    extend(Toggle, superClass);\n    function Toggle() {\n        return Toggle.__super__.constructor.apply(this, arguments);\n    }\n    Toggle.prototype.type = \"Toggle\";\n    Toggle.prototype.default_view = exports.ToggleView;\n    Toggle.define({\n        active: [p.Bool, false]\n    });\n    Toggle.override({\n        label: \"Toggle\"\n    });\n    return Toggle;\n})(abstract_button_1.AbstractButton);\n","\"use strict\";\nvar extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar layout_dom_1 = require(\"../layouts/layout_dom\");\nexports.WidgetView = (function (superClass) {\n    extend(WidgetView, superClass);\n    function WidgetView() {\n        return WidgetView.__super__.constructor.apply(this, arguments);\n    }\n    WidgetView.prototype.className = \"bk-widget\";\n    WidgetView.prototype.render = function () {\n        if (this.model.height) {\n            this.$el.height(this.model.height);\n        }\n        if (this.model.width) {\n            return this.$el.width(this.model.width);\n        }\n    };\n    return WidgetView;\n})(layout_dom_1.LayoutDOMView);\nexports.Widget = (function (superClass) {\n    extend(Widget, superClass);\n    function Widget() {\n        return Widget.__super__.constructor.apply(this, arguments);\n    }\n    Widget.prototype.type = \"Widget\";\n    Widget.prototype.default_view = exports.WidgetView;\n    return Widget;\n})(layout_dom_1.LayoutDOM);\n","var jQuery = require('jquery');\nrequire('./core');\nrequire('./widget');\nrequire('./position');\nrequire('./menu');\n\n/*!\n * jQuery UI Autocomplete 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/autocomplete/\n *\n * Depends:\n *\tjquery.ui.core.js\n *\tjquery.ui.widget.js\n *\tjquery.ui.position.js\n *\tjquery.ui.menu.js\n */\n(function( $, undefined ) {\n\n$.widget( \"ui.autocomplete\", {\n\tversion: \"1.10.4\",\n\tdefaultElement: \"<input>\",\n\toptions: {\n\t\tappendTo: null,\n\t\tautoFocus: false,\n\t\tdelay: 300,\n\t\tminLength: 1,\n\t\tposition: {\n\t\t\tmy: \"left top\",\n\t\t\tat: \"left bottom\",\n\t\t\tcollision: \"none\"\n\t\t},\n\t\tsource: null,\n\n\t\t// callbacks\n\t\tchange: null,\n\t\tclose: null,\n\t\tfocus: null,\n\t\topen: null,\n\t\tresponse: null,\n\t\tsearch: null,\n\t\tselect: null\n\t},\n\n\trequestIndex: 0,\n\tpending: 0,\n\n\t_create: function() {\n\t\t// Some browsers only repeat keydown events, not keypress events,\n\t\t// so we use the suppressKeyPress flag to determine if we've already\n\t\t// handled the keydown event. #7269\n\t\t// Unfortunately the code for & in keypress is the same as the up arrow,\n\t\t// so we use the suppressKeyPressRepeat flag to avoid handling keypress\n\t\t// events when we know the keydown event was used to modify the\n\t\t// search term. #7799\n\t\tvar suppressKeyPress, suppressKeyPressRepeat, suppressInput,\n\t\t\tnodeName = this.element[0].nodeName.toLowerCase(),\n\t\t\tisTextarea = nodeName === \"textarea\",\n\t\t\tisInput = nodeName === \"input\";\n\n\t\tthis.isMultiLine =\n\t\t\t// Textareas are always multi-line\n\t\t\tisTextarea ? true :\n\t\t\t// Inputs are always single-line, even if inside a contentEditable element\n\t\t\t// IE also treats inputs as contentEditable\n\t\t\tisInput ? false :\n\t\t\t// All other element types are determined by whether or not they're contentEditable\n\t\t\tthis.element.prop( \"isContentEditable\" );\n\n\t\tthis.valueMethod = this.element[ isTextarea || isInput ? \"val\" : \"text\" ];\n\t\tthis.isNewMenu = true;\n\n\t\tthis.element\n\t\t\t.addClass( \"ui-autocomplete-input\" )\n\t\t\t.attr( \"autocomplete\", \"off\" );\n\n\t\tthis._on( this.element, {\n\t\t\tkeydown: function( event ) {\n\t\t\t\tif ( this.element.prop( \"readOnly\" ) ) {\n\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\tsuppressInput = true;\n\t\t\t\t\tsuppressKeyPressRepeat = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tsuppressKeyPress = false;\n\t\t\t\tsuppressInput = false;\n\t\t\t\tsuppressKeyPressRepeat = false;\n\t\t\t\tvar keyCode = $.ui.keyCode;\n\t\t\t\tswitch( event.keyCode ) {\n\t\t\t\tcase keyCode.PAGE_UP:\n\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\tthis._move( \"previousPage\", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.PAGE_DOWN:\n\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\tthis._move( \"nextPage\", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.UP:\n\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\tthis._keyEvent( \"previous\", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.DOWN:\n\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\tthis._keyEvent( \"next\", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.ENTER:\n\t\t\t\tcase keyCode.NUMPAD_ENTER:\n\t\t\t\t\t// when menu is open and has focus\n\t\t\t\t\tif ( this.menu.active ) {\n\t\t\t\t\t\t// #6055 - Opera still allows the keypress to occur\n\t\t\t\t\t\t// which causes forms to submit\n\t\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tthis.menu.select( event );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.TAB:\n\t\t\t\t\tif ( this.menu.active ) {\n\t\t\t\t\t\tthis.menu.select( event );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.ESCAPE:\n\t\t\t\t\tif ( this.menu.element.is( \":visible\" ) ) {\n\t\t\t\t\t\tthis._value( this.term );\n\t\t\t\t\t\tthis.close( event );\n\t\t\t\t\t\t// Different browsers have different default behavior for escape\n\t\t\t\t\t\t// Single press can mean undo or clear\n\t\t\t\t\t\t// Double press in IE means clear the whole form\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsuppressKeyPressRepeat = true;\n\t\t\t\t\t// search timeout should be triggered before the input value is changed\n\t\t\t\t\tthis._searchTimeout( event );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeypress: function( event ) {\n\t\t\t\tif ( suppressKeyPress ) {\n\t\t\t\t\tsuppressKeyPress = false;\n\t\t\t\t\tif ( !this.isMultiLine || this.menu.element.is( \":visible\" ) ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( suppressKeyPressRepeat ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// replicate some key handlers to allow them to repeat in Firefox and Opera\n\t\t\t\tvar keyCode = $.ui.keyCode;\n\t\t\t\tswitch( event.keyCode ) {\n\t\t\t\tcase keyCode.PAGE_UP:\n\t\t\t\t\tthis._move( \"previousPage\", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.PAGE_DOWN:\n\t\t\t\t\tthis._move( \"nextPage\", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.UP:\n\t\t\t\t\tthis._keyEvent( \"previous\", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.DOWN:\n\t\t\t\t\tthis._keyEvent( \"next\", event );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t},\n\t\t\tinput: function( event ) {\n\t\t\t\tif ( suppressInput ) {\n\t\t\t\t\tsuppressInput = false;\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._searchTimeout( event );\n\t\t\t},\n\t\t\tfocus: function() {\n\t\t\t\tthis.selectedItem = null;\n\t\t\t\tthis.previous = this._value();\n\t\t\t},\n\t\t\tblur: function( event ) {\n\t\t\t\tif ( this.cancelBlur ) {\n\t\t\t\t\tdelete this.cancelBlur;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tclearTimeout( this.searching );\n\t\t\t\tthis.close( event );\n\t\t\t\tthis._change( event );\n\t\t\t}\n\t\t});\n\n\t\tthis._initSource();\n\t\tthis.menu = $( \"<ul>\" )\n\t\t\t.addClass( \"ui-autocomplete ui-front\" )\n\t\t\t.appendTo( this._appendTo() )\n\t\t\t.menu({\n\t\t\t\t// disable ARIA support, the live region takes care of that\n\t\t\t\trole: null\n\t\t\t})\n\t\t\t.hide()\n\t\t\t.data( \"ui-menu\" );\n\n\t\tthis._on( this.menu.element, {\n\t\t\tmousedown: function( event ) {\n\t\t\t\t// prevent moving focus out of the text field\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\t// IE doesn't prevent moving focus even with event.preventDefault()\n\t\t\t\t// so we set a flag to know when we should ignore the blur event\n\t\t\t\tthis.cancelBlur = true;\n\t\t\t\tthis._delay(function() {\n\t\t\t\t\tdelete this.cancelBlur;\n\t\t\t\t});\n\n\t\t\t\t// clicking on the scrollbar causes focus to shift to the body\n\t\t\t\t// but we can't detect a mouseup or a click immediately afterward\n\t\t\t\t// so we have to track the next mousedown and close the menu if\n\t\t\t\t// the user clicks somewhere outside of the autocomplete\n\t\t\t\tvar menuElement = this.menu.element[ 0 ];\n\t\t\t\tif ( !$( event.target ).closest( \".ui-menu-item\" ).length ) {\n\t\t\t\t\tthis._delay(function() {\n\t\t\t\t\t\tvar that = this;\n\t\t\t\t\t\tthis.document.one( \"mousedown\", function( event ) {\n\t\t\t\t\t\t\tif ( event.target !== that.element[ 0 ] &&\n\t\t\t\t\t\t\t\t\tevent.target !== menuElement &&\n\t\t\t\t\t\t\t\t\t!$.contains( menuElement, event.target ) ) {\n\t\t\t\t\t\t\t\tthat.close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\tmenufocus: function( event, ui ) {\n\t\t\t\t// support: Firefox\n\t\t\t\t// Prevent accidental activation of menu items in Firefox (#7024 #9118)\n\t\t\t\tif ( this.isNewMenu ) {\n\t\t\t\t\tthis.isNewMenu = false;\n\t\t\t\t\tif ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {\n\t\t\t\t\t\tthis.menu.blur();\n\n\t\t\t\t\t\tthis.document.one( \"mousemove\", function() {\n\t\t\t\t\t\t\t$( event.target ).trigger( event.originalEvent );\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar item = ui.item.data( \"ui-autocomplete-item\" );\n\t\t\t\tif ( false !== this._trigger( \"focus\", event, { item: item } ) ) {\n\t\t\t\t\t// use value to match what will end up in the input, if it was a key event\n\t\t\t\t\tif ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {\n\t\t\t\t\t\tthis._value( item.value );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Normally the input is populated with the item's value as the\n\t\t\t\t\t// menu is navigated, causing screen readers to notice a change and\n\t\t\t\t\t// announce the item. Since the focus event was canceled, this doesn't\n\t\t\t\t\t// happen, so we update the live region so that screen readers can\n\t\t\t\t\t// still notice the change and announce it.\n\t\t\t\t\tthis.liveRegion.text( item.value );\n\t\t\t\t}\n\t\t\t},\n\t\t\tmenuselect: function( event, ui ) {\n\t\t\t\tvar item = ui.item.data( \"ui-autocomplete-item\" ),\n\t\t\t\t\tprevious = this.previous;\n\n\t\t\t\t// only trigger when focus was lost (click on menu)\n\t\t\t\tif ( this.element[0] !== this.document[0].activeElement ) {\n\t\t\t\t\tthis.element.focus();\n\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t// #6109 - IE triggers two focus events and the second\n\t\t\t\t\t// is asynchronous, so we need to reset the previous\n\t\t\t\t\t// term synchronously and asynchronously :-(\n\t\t\t\t\tthis._delay(function() {\n\t\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t\tthis.selectedItem = item;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif ( false !== this._trigger( \"select\", event, { item: item } ) ) {\n\t\t\t\t\tthis._value( item.value );\n\t\t\t\t}\n\t\t\t\t// reset the term after the select event\n\t\t\t\t// this allows custom select handling to work properly\n\t\t\t\tthis.term = this._value();\n\n\t\t\t\tthis.close( event );\n\t\t\t\tthis.selectedItem = item;\n\t\t\t}\n\t\t});\n\n\t\tthis.liveRegion = $( \"<span>\", {\n\t\t\t\trole: \"status\",\n\t\t\t\t\"aria-live\": \"polite\"\n\t\t\t})\n\t\t\t.addClass( \"ui-helper-hidden-accessible\" )\n\t\t\t.insertBefore( this.element );\n\n\t\t// turning off autocomplete prevents the browser from remembering the\n\t\t// value when navigating through history, so we re-enable autocomplete\n\t\t// if the page is unloaded before the widget is destroyed. #7790\n\t\tthis._on( this.window, {\n\t\t\tbeforeunload: function() {\n\t\t\t\tthis.element.removeAttr( \"autocomplete\" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_destroy: function() {\n\t\tclearTimeout( this.searching );\n\t\tthis.element\n\t\t\t.removeClass( \"ui-autocomplete-input\" )\n\t\t\t.removeAttr( \"autocomplete\" );\n\t\tthis.menu.element.remove();\n\t\tthis.liveRegion.remove();\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tthis._super( key, value );\n\t\tif ( key === \"source\" ) {\n\t\t\tthis._initSource();\n\t\t}\n\t\tif ( key === \"appendTo\" ) {\n\t\t\tthis.menu.element.appendTo( this._appendTo() );\n\t\t}\n\t\tif ( key === \"disabled\" && value && this.xhr ) {\n\t\t\tthis.xhr.abort();\n\t\t}\n\t},\n\n\t_appendTo: function() {\n\t\tvar element = this.options.appendTo;\n\n\t\tif ( element ) {\n\t\t\telement = element.jquery || element.nodeType ?\n\t\t\t\t$( element ) :\n\t\t\t\tthis.document.find( element ).eq( 0 );\n\t\t}\n\n\t\tif ( !element ) {\n\t\t\telement = this.element.closest( \".ui-front\" );\n\t\t}\n\n\t\tif ( !element.length ) {\n\t\t\telement = this.document[0].body;\n\t\t}\n\n\t\treturn element;\n\t},\n\n\t_initSource: function() {\n\t\tvar array, url,\n\t\t\tthat = this;\n\t\tif ( $.isArray(this.options.source) ) {\n\t\t\tarray = this.options.source;\n\t\t\tthis.source = function( request, response ) {\n\t\t\t\tresponse( $.ui.autocomplete.filter( array, request.term ) );\n\t\t\t};\n\t\t} else if ( typeof this.options.source === \"string\" ) {\n\t\t\turl = this.options.source;\n\t\t\tthis.source = function( request, response ) {\n\t\t\t\tif ( that.xhr ) {\n\t\t\t\t\tthat.xhr.abort();\n\t\t\t\t}\n\t\t\t\tthat.xhr = $.ajax({\n\t\t\t\t\turl: url,\n\t\t\t\t\tdata: request,\n\t\t\t\t\tdataType: \"json\",\n\t\t\t\t\tsuccess: function( data ) {\n\t\t\t\t\t\tresponse( data );\n\t\t\t\t\t},\n\t\t\t\t\terror: function() {\n\t\t\t\t\t\tresponse( [] );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t} else {\n\t\t\tthis.source = this.options.source;\n\t\t}\n\t},\n\n\t_searchTimeout: function( event ) {\n\t\tclearTimeout( this.searching );\n\t\tthis.searching = this._delay(function() {\n\t\t\t// only search if the value has changed\n\t\t\tif ( this.term !== this._value() ) {\n\t\t\t\tthis.selectedItem = null;\n\t\t\t\tthis.search( null, event );\n\t\t\t}\n\t\t}, this.options.delay );\n\t},\n\n\tsearch: function( value, event ) {\n\t\tvalue = value != null ? value : this._value();\n\n\t\t// always save the actual value, not the one passed as an argument\n\t\tthis.term = this._value();\n\n\t\tif ( value.length < this.options.minLength ) {\n\t\t\treturn this.close( event );\n\t\t}\n\n\t\tif ( this._trigger( \"search\", event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this._search( value );\n\t},\n\n\t_search: function( value ) {\n\t\tthis.pending++;\n\t\tthis.element.addClass( \"ui-autocomplete-loading\" );\n\t\tthis.cancelSearch = false;\n\n\t\tthis.source( { term: value }, this._response() );\n\t},\n\n\t_response: function() {\n\t\tvar index = ++this.requestIndex;\n\n\t\treturn $.proxy(function( content ) {\n\t\t\tif ( index === this.requestIndex ) {\n\t\t\t\tthis.__response( content );\n\t\t\t}\n\n\t\t\tthis.pending--;\n\t\t\tif ( !this.pending ) {\n\t\t\t\tthis.element.removeClass( \"ui-autocomplete-loading\" );\n\t\t\t}\n\t\t}, this );\n\t},\n\n\t__response: function( content ) {\n\t\tif ( content ) {\n\t\t\tcontent = this._normalize( content );\n\t\t}\n\t\tthis._trigger( \"response\", null, { content: content } );\n\t\tif ( !this.options.disabled && content && content.length && !this.cancelSearch ) {\n\t\t\tthis._suggest( content );\n\t\t\tthis._trigger( \"open\" );\n\t\t} else {\n\t\t\t// use ._close() instead of .close() so we don't cancel future searches\n\t\t\tthis._close();\n\t\t}\n\t},\n\n\tclose: function( event ) {\n\t\tthis.cancelSearch = true;\n\t\tthis._close( event );\n\t},\n\n\t_close: function( event ) {\n\t\tif ( this.menu.element.is( \":visible\" ) ) {\n\t\t\tthis.menu.element.hide();\n\t\t\tthis.menu.blur();\n\t\t\tthis.isNewMenu = true;\n\t\t\tthis._trigger( \"close\", event );\n\t\t}\n\t},\n\n\t_change: function( event ) {\n\t\tif ( this.previous !== this._value() ) {\n\t\t\tthis._trigger( \"change\", event, { item: this.selectedItem } );\n\t\t}\n\t},\n\n\t_normalize: function( items ) {\n\t\t// assume all items have the right format when the first item is complete\n\t\tif ( items.length && items[0].label && items[0].value ) {\n\t\t\treturn items;\n\t\t}\n\t\treturn $.map( items, function( item ) {\n\t\t\tif ( typeof item === \"string\" ) {\n\t\t\t\treturn {\n\t\t\t\t\tlabel: item,\n\t\t\t\t\tvalue: item\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn $.extend({\n\t\t\t\tlabel: item.label || item.value,\n\t\t\t\tvalue: item.value || item.label\n\t\t\t}, item );\n\t\t});\n\t},\n\n\t_suggest: function( items ) {\n\t\tvar ul = this.menu.element.empty();\n\t\tthis._renderMenu( ul, items );\n\t\tthis.isNewMenu = true;\n\t\tthis.menu.refresh();\n\n\t\t// size and position menu\n\t\tul.show();\n\t\tthis._resizeMenu();\n\t\tul.position( $.extend({\n\t\t\tof: this.element\n\t\t}, this.options.position ));\n\n\t\tif ( this.options.autoFocus ) {\n\t\t\tthis.menu.next();\n\t\t}\n\t},\n\n\t_resizeMenu: function() {\n\t\tvar ul = this.menu.element;\n\t\tul.outerWidth( Math.max(\n\t\t\t// Firefox wraps long text (possibly a rounding bug)\n\t\t\t// so we add 1px to avoid the wrapping (#7513)\n\t\t\tul.width( \"\" ).outerWidth() + 1,\n\t\t\tthis.element.outerWidth()\n\t\t) );\n\t},\n\n\t_renderMenu: function( ul, items ) {\n\t\tvar that = this;\n\t\t$.each( items, function( index, item ) {\n\t\t\tthat._renderItemData( ul, item );\n\t\t});\n\t},\n\n\t_renderItemData: function( ul, item ) {\n\t\treturn this._renderItem( ul, item ).data( \"ui-autocomplete-item\", item );\n\t},\n\n\t_renderItem: function( ul, item ) {\n\t\treturn $( \"<li>\" )\n\t\t\t.append( $( \"<a>\" ).text( item.label ) )\n\t\t\t.appendTo( ul );\n\t},\n\n\t_move: function( direction, event ) {\n\t\tif ( !this.menu.element.is( \":visible\" ) ) {\n\t\t\tthis.search( null, event );\n\t\t\treturn;\n\t\t}\n\t\tif ( this.menu.isFirstItem() && /^previous/.test( direction ) ||\n\t\t\t\tthis.menu.isLastItem() && /^next/.test( direction ) ) {\n\t\t\tthis._value( this.term );\n\t\t\tthis.menu.blur();\n\t\t\treturn;\n\t\t}\n\t\tthis.menu[ direction ]( event );\n\t},\n\n\twidget: function() {\n\t\treturn this.menu.element;\n\t},\n\n\t_value: function() {\n\t\treturn this.valueMethod.apply( this.element, arguments );\n\t},\n\n\t_keyEvent: function( keyEvent, event ) {\n\t\tif ( !this.isMultiLine || this.menu.element.is( \":visible\" ) ) {\n\t\t\tthis._move( keyEvent, event );\n\n\t\t\t// prevents moving cursor to beginning/end of the text field in some browsers\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n});\n\n$.extend( $.ui.autocomplete, {\n\tescapeRegex: function( value ) {\n\t\treturn value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n\t},\n\tfilter: function(array, term) {\n\t\tvar matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), \"i\" );\n\t\treturn $.grep( array, function(value) {\n\t\t\treturn matcher.test( value.label || value.value || value );\n\t\t});\n\t}\n});\n\n\n// live region extension, adding a `messages` option\n// NOTE: This is an experimental API. We are still investigating\n// a full solution for string manipulation and internationalization.\n$.widget( \"ui.autocomplete\", $.ui.autocomplete, {\n\toptions: {\n\t\tmessages: {\n\t\t\tnoResults: \"No search results.\",\n\t\t\tresults: function( amount ) {\n\t\t\t\treturn amount + ( amount > 1 ? \" results are\" : \" result is\" ) +\n\t\t\t\t\t\" available, use up and down arrow keys to navigate.\";\n\t\t\t}\n\t\t}\n\t},\n\n\t__response: function( content ) {\n\t\tvar message;\n\t\tthis._superApply( arguments );\n\t\tif ( this.options.disabled || this.cancelSearch ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( content && content.length ) {\n\t\t\tmessage = this.options.messages.results( content.length );\n\t\t} else {\n\t\t\tmessage = this.options.messages.noResults;\n\t\t}\n\t\tthis.liveRegion.text( message );\n\t}\n});\n\n}( jQuery ));\n","var jQuery = require('jquery');\nrequire('./core');\nrequire('./widget');\n\n/*!\n * jQuery UI Button 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/button/\n *\n * Depends:\n *\tjquery.ui.core.js\n *\tjquery.ui.widget.js\n */\n(function( $, undefined ) {\n\nvar lastActive,\n\tbaseClasses = \"ui-button ui-widget ui-state-default ui-corner-all\",\n\ttypeClasses = \"ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only\",\n\tformResetHandler = function() {\n\t\tvar form = $( this );\n\t\tsetTimeout(function() {\n\t\t\tform.find( \":ui-button\" ).button( \"refresh\" );\n\t\t}, 1 );\n\t},\n\tradioGroup = function( radio ) {\n\t\tvar name = radio.name,\n\t\t\tform = radio.form,\n\t\t\tradios = $( [] );\n\t\tif ( name ) {\n\t\t\tname = name.replace( /'/g, \"\\\\'\" );\n\t\t\tif ( form ) {\n\t\t\t\tradios = $( form ).find( \"[name='\" + name + \"']\" );\n\t\t\t} else {\n\t\t\t\tradios = $( \"[name='\" + name + \"']\", radio.ownerDocument )\n\t\t\t\t\t.filter(function() {\n\t\t\t\t\t\treturn !this.form;\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn radios;\n\t};\n\n$.widget( \"ui.button\", {\n\tversion: \"1.10.4\",\n\tdefaultElement: \"<button>\",\n\toptions: {\n\t\tdisabled: null,\n\t\ttext: true,\n\t\tlabel: null,\n\t\ticons: {\n\t\t\tprimary: null,\n\t\t\tsecondary: null\n\t\t}\n\t},\n\t_create: function() {\n\t\tthis.element.closest( \"form\" )\n\t\t\t.unbind( \"reset\" + this.eventNamespace )\n\t\t\t.bind( \"reset\" + this.eventNamespace, formResetHandler );\n\n\t\tif ( typeof this.options.disabled !== \"boolean\" ) {\n\t\t\tthis.options.disabled = !!this.element.prop( \"disabled\" );\n\t\t} else {\n\t\t\tthis.element.prop( \"disabled\", this.options.disabled );\n\t\t}\n\n\t\tthis._determineButtonType();\n\t\tthis.hasTitle = !!this.buttonElement.attr( \"title\" );\n\n\t\tvar that = this,\n\t\t\toptions = this.options,\n\t\t\ttoggleButton = this.type === \"checkbox\" || this.type === \"radio\",\n\t\t\tactiveClass = !toggleButton ? \"ui-state-active\" : \"\";\n\n\t\tif ( options.label === null ) {\n\t\t\toptions.label = (this.type === \"input\" ? this.buttonElement.val() : this.buttonElement.html());\n\t\t}\n\n\t\tthis._hoverable( this.buttonElement );\n\n\t\tthis.buttonElement\n\t\t\t.addClass( baseClasses )\n\t\t\t.attr( \"role\", \"button\" )\n\t\t\t.bind( \"mouseenter\" + this.eventNamespace, function() {\n\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( this === lastActive ) {\n\t\t\t\t\t$( this ).addClass( \"ui-state-active\" );\n\t\t\t\t}\n\t\t\t})\n\t\t\t.bind( \"mouseleave\" + this.eventNamespace, function() {\n\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t$( this ).removeClass( activeClass );\n\t\t\t})\n\t\t\t.bind( \"click\" + this.eventNamespace, function( event ) {\n\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t}\n\t\t\t});\n\n\t\t// Can't use _focusable() because the element that receives focus\n\t\t// and the element that gets the ui-state-focus class are different\n\t\tthis._on({\n\t\t\tfocus: function() {\n\t\t\t\tthis.buttonElement.addClass( \"ui-state-focus\" );\n\t\t\t},\n\t\t\tblur: function() {\n\t\t\t\tthis.buttonElement.removeClass( \"ui-state-focus\" );\n\t\t\t}\n\t\t});\n\n\t\tif ( toggleButton ) {\n\t\t\tthis.element.bind( \"change\" + this.eventNamespace, function() {\n\t\t\t\tthat.refresh();\n\t\t\t});\n\t\t}\n\n\t\tif ( this.type === \"checkbox\" ) {\n\t\t\tthis.buttonElement.bind( \"click\" + this.eventNamespace, function() {\n\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t} else if ( this.type === \"radio\" ) {\n\t\t\tthis.buttonElement.bind( \"click\" + this.eventNamespace, function() {\n\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t$( this ).addClass( \"ui-state-active\" );\n\t\t\t\tthat.buttonElement.attr( \"aria-pressed\", \"true\" );\n\n\t\t\t\tvar radio = that.element[ 0 ];\n\t\t\t\tradioGroup( radio )\n\t\t\t\t\t.not( radio )\n\t\t\t\t\t.map(function() {\n\t\t\t\t\t\treturn $( this ).button( \"widget\" )[ 0 ];\n\t\t\t\t\t})\n\t\t\t\t\t.removeClass( \"ui-state-active\" )\n\t\t\t\t\t.attr( \"aria-pressed\", \"false\" );\n\t\t\t});\n\t\t} else {\n\t\t\tthis.buttonElement\n\t\t\t\t.bind( \"mousedown\" + this.eventNamespace, function() {\n\t\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$( this ).addClass( \"ui-state-active\" );\n\t\t\t\t\tlastActive = this;\n\t\t\t\t\tthat.document.one( \"mouseup\", function() {\n\t\t\t\t\t\tlastActive = null;\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.bind( \"mouseup\" + this.eventNamespace, function() {\n\t\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$( this ).removeClass( \"ui-state-active\" );\n\t\t\t\t})\n\t\t\t\t.bind( \"keydown\" + this.eventNamespace, function(event) {\n\t\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {\n\t\t\t\t\t\t$( this ).addClass( \"ui-state-active\" );\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t// see #8559, we bind to blur here in case the button element loses\n\t\t\t\t// focus between keydown and keyup, it would be left in an \"active\" state\n\t\t\t\t.bind( \"keyup\" + this.eventNamespace + \" blur\" + this.eventNamespace, function() {\n\t\t\t\t\t$( this ).removeClass( \"ui-state-active\" );\n\t\t\t\t});\n\n\t\t\tif ( this.buttonElement.is(\"a\") ) {\n\t\t\t\tthis.buttonElement.keyup(function(event) {\n\t\t\t\t\tif ( event.keyCode === $.ui.keyCode.SPACE ) {\n\t\t\t\t\t\t// TODO pass through original event correctly (just as 2nd argument doesn't work)\n\t\t\t\t\t\t$( this ).click();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// TODO: pull out $.Widget's handling for the disabled option into\n\t\t// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can\n\t\t// be overridden by individual plugins\n\t\tthis._setOption( \"disabled\", options.disabled );\n\t\tthis._resetButton();\n\t},\n\n\t_determineButtonType: function() {\n\t\tvar ancestor, labelSelector, checked;\n\n\t\tif ( this.element.is(\"[type=checkbox]\") ) {\n\t\t\tthis.type = \"checkbox\";\n\t\t} else if ( this.element.is(\"[type=radio]\") ) {\n\t\t\tthis.type = \"radio\";\n\t\t} else if ( this.element.is(\"input\") ) {\n\t\t\tthis.type = \"input\";\n\t\t} else {\n\t\t\tthis.type = \"button\";\n\t\t}\n\n\t\tif ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n\t\t\t// we don't search against the document in case the element\n\t\t\t// is disconnected from the DOM\n\t\t\tancestor = this.element.parents().last();\n\t\t\tlabelSelector = \"label[for='\" + this.element.attr(\"id\") + \"']\";\n\t\t\tthis.buttonElement = ancestor.find( labelSelector );\n\t\t\tif ( !this.buttonElement.length ) {\n\t\t\t\tancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();\n\t\t\t\tthis.buttonElement = ancestor.filter( labelSelector );\n\t\t\t\tif ( !this.buttonElement.length ) {\n\t\t\t\t\tthis.buttonElement = ancestor.find( labelSelector );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.element.addClass( \"ui-helper-hidden-accessible\" );\n\n\t\t\tchecked = this.element.is( \":checked\" );\n\t\t\tif ( checked ) {\n\t\t\t\tthis.buttonElement.addClass( \"ui-state-active\" );\n\t\t\t}\n\t\t\tthis.buttonElement.prop( \"aria-pressed\", checked );\n\t\t} else {\n\t\t\tthis.buttonElement = this.element;\n\t\t}\n\t},\n\n\twidget: function() {\n\t\treturn this.buttonElement;\n\t},\n\n\t_destroy: function() {\n\t\tthis.element\n\t\t\t.removeClass( \"ui-helper-hidden-accessible\" );\n\t\tthis.buttonElement\n\t\t\t.removeClass( baseClasses + \" ui-state-active \" + typeClasses )\n\t\t\t.removeAttr( \"role\" )\n\t\t\t.removeAttr( \"aria-pressed\" )\n\t\t\t.html( this.buttonElement.find(\".ui-button-text\").html() );\n\n\t\tif ( !this.hasTitle ) {\n\t\t\tthis.buttonElement.removeAttr( \"title\" );\n\t\t}\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tthis._super( key, value );\n\t\tif ( key === \"disabled\" ) {\n\t\t\tthis.element.prop( \"disabled\", !!value );\n\t\t\tif ( value ) {\n\t\t\t\tthis.buttonElement.removeClass( \"ui-state-focus\" );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._resetButton();\n\t},\n\n\trefresh: function() {\n\t\t//See #8237 & #8828\n\t\tvar isDisabled = this.element.is( \"input, button\" ) ? this.element.is( \":disabled\" ) : this.element.hasClass( \"ui-button-disabled\" );\n\n\t\tif ( isDisabled !== this.options.disabled ) {\n\t\t\tthis._setOption( \"disabled\", isDisabled );\n\t\t}\n\t\tif ( this.type === \"radio\" ) {\n\t\t\tradioGroup( this.element[0] ).each(function() {\n\t\t\t\tif ( $( this ).is( \":checked\" ) ) {\n\t\t\t\t\t$( this ).button( \"widget\" )\n\t\t\t\t\t\t.addClass( \"ui-state-active\" )\n\t\t\t\t\t\t.attr( \"aria-pressed\", \"true\" );\n\t\t\t\t} else {\n\t\t\t\t\t$( this ).button( \"widget\" )\n\t\t\t\t\t\t.removeClass( \"ui-state-active\" )\n\t\t\t\t\t\t.attr( \"aria-pressed\", \"false\" );\n\t\t\t\t}\n\t\t\t});\n\t\t} else if ( this.type === \"checkbox\" ) {\n\t\t\tif ( this.element.is( \":checked\" ) ) {\n\t\t\t\tthis.buttonElement\n\t\t\t\t\t.addClass( \"ui-state-active\" )\n\t\t\t\t\t.attr( \"aria-pressed\", \"true\" );\n\t\t\t} else {\n\t\t\t\tthis.buttonElement\n\t\t\t\t\t.removeClass( \"ui-state-active\" )\n\t\t\t\t\t.attr( \"aria-pressed\", \"false\" );\n\t\t\t}\n\t\t}\n\t},\n\n\t_resetButton: function() {\n\t\tif ( this.type === \"input\" ) {\n\t\t\tif ( this.options.label ) {\n\t\t\t\tthis.element.val( this.options.label );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tvar buttonElement = this.buttonElement.removeClass( typeClasses ),\n\t\t\tbuttonText = $( \"<span></span>\", this.document[0] )\n\t\t\t\t.addClass( \"ui-button-text\" )\n\t\t\t\t.html( this.options.label )\n\t\t\t\t.appendTo( buttonElement.empty() )\n\t\t\t\t.text(),\n\t\t\ticons = this.options.icons,\n\t\t\tmultipleIcons = icons.primary && icons.secondary,\n\t\t\tbuttonClasses = [];\n\n\t\tif ( icons.primary || icons.secondary ) {\n\t\t\tif ( this.options.text ) {\n\t\t\t\tbuttonClasses.push( \"ui-button-text-icon\" + ( multipleIcons ? \"s\" : ( icons.primary ? \"-primary\" : \"-secondary\" ) ) );\n\t\t\t}\n\n\t\t\tif ( icons.primary ) {\n\t\t\t\tbuttonElement.prepend( \"<span class='ui-button-icon-primary ui-icon \" + icons.primary + \"'></span>\" );\n\t\t\t}\n\n\t\t\tif ( icons.secondary ) {\n\t\t\t\tbuttonElement.append( \"<span class='ui-button-icon-secondary ui-icon \" + icons.secondary + \"'></span>\" );\n\t\t\t}\n\n\t\t\tif ( !this.options.text ) {\n\t\t\t\tbuttonClasses.push( multipleIcons ? \"ui-button-icons-only\" : \"ui-button-icon-only\" );\n\n\t\t\t\tif ( !this.hasTitle ) {\n\t\t\t\t\tbuttonElement.attr( \"title\", $.trim( buttonText ) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbuttonClasses.push( \"ui-button-text-only\" );\n\t\t}\n\t\tbuttonElement.addClass( buttonClasses.join( \" \" ) );\n\t}\n});\n\n$.widget( \"ui.buttonset\", {\n\tversion: \"1.10.4\",\n\toptions: {\n\t\titems: \"button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)\"\n\t},\n\n\t_create: function() {\n\t\tthis.element.addClass( \"ui-buttonset\" );\n\t},\n\n\t_init: function() {\n\t\tthis.refresh();\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === \"disabled\" ) {\n\t\t\tthis.buttons.button( \"option\", key, value );\n\t\t}\n\n\t\tthis._super( key, value );\n\t},\n\n\trefresh: function() {\n\t\tvar rtl = this.element.css( \"direction\" ) === \"rtl\";\n\n\t\tthis.buttons = this.element.find( this.options.items )\n\t\t\t.filter( \":ui-button\" )\n\t\t\t\t.button( \"refresh\" )\n\t\t\t.end()\n\t\t\t.not( \":ui-button\" )\n\t\t\t\t.button()\n\t\t\t.end()\n\t\t\t.map(function() {\n\t\t\t\treturn $( this ).button( \"widget\" )[ 0 ];\n\t\t\t})\n\t\t\t\t.removeClass( \"ui-corner-all ui-corner-left ui-corner-right\" )\n\t\t\t\t.filter( \":first\" )\n\t\t\t\t\t.addClass( rtl ? \"ui-corner-right\" : \"ui-corner-left\" )\n\t\t\t\t.end()\n\t\t\t\t.filter( \":last\" )\n\t\t\t\t\t.addClass( rtl ? \"ui-corner-left\" : \"ui-corner-right\" )\n\t\t\t\t.end()\n\t\t\t.end();\n\t},\n\n\t_destroy: function() {\n\t\tthis.element.removeClass( \"ui-buttonset\" );\n\t\tthis.buttons\n\t\t\t.map(function() {\n\t\t\t\treturn $( this ).button( \"widget\" )[ 0 ];\n\t\t\t})\n\t\t\t\t.removeClass( \"ui-corner-left ui-corner-right\" )\n\t\t\t.end()\n\t\t\t.button( \"destroy\" );\n\t}\n});\n\n}( jQuery ) );\n","var jQuery = require('jquery');\n\n/*!\n * jQuery UI Core 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/ui-core/\n */\n(function( $, undefined ) {\n\nvar uuid = 0,\n\truniqueId = /^ui-id-\\d+$/;\n\n// $.ui might exist from components with no dependencies, e.g., $.ui.position\n$.ui = $.ui || {};\n\n$.extend( $.ui, {\n\tversion: \"1.10.4\",\n\n\tkeyCode: {\n\t\tBACKSPACE: 8,\n\t\tCOMMA: 188,\n\t\tDELETE: 46,\n\t\tDOWN: 40,\n\t\tEND: 35,\n\t\tENTER: 13,\n\t\tESCAPE: 27,\n\t\tHOME: 36,\n\t\tLEFT: 37,\n\t\tNUMPAD_ADD: 107,\n\t\tNUMPAD_DECIMAL: 110,\n\t\tNUMPAD_DIVIDE: 111,\n\t\tNUMPAD_ENTER: 108,\n\t\tNUMPAD_MULTIPLY: 106,\n\t\tNUMPAD_SUBTRACT: 109,\n\t\tPAGE_DOWN: 34,\n\t\tPAGE_UP: 33,\n\t\tPERIOD: 190,\n\t\tRIGHT: 39,\n\t\tSPACE: 32,\n\t\tTAB: 9,\n\t\tUP: 38\n\t}\n});\n\n// plugins\n$.fn.extend({\n\tfocus: (function( orig ) {\n\t\treturn function( delay, fn ) {\n\t\t\treturn typeof delay === \"number\" ?\n\t\t\t\tthis.each(function() {\n\t\t\t\t\tvar elem = this;\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t$( elem ).focus();\n\t\t\t\t\t\tif ( fn ) {\n\t\t\t\t\t\t\tfn.call( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay );\n\t\t\t\t}) :\n\t\t\t\torig.apply( this, arguments );\n\t\t};\n\t})( $.fn.focus ),\n\n\tscrollParent: function() {\n\t\tvar scrollParent;\n\t\tif (($.ui.ie && (/(static|relative)/).test(this.css(\"position\"))) || (/absolute/).test(this.css(\"position\"))) {\n\t\t\tscrollParent = this.parents().filter(function() {\n\t\t\t\treturn (/(relative|absolute|fixed)/).test($.css(this,\"position\")) && (/(auto|scroll)/).test($.css(this,\"overflow\")+$.css(this,\"overflow-y\")+$.css(this,\"overflow-x\"));\n\t\t\t}).eq(0);\n\t\t} else {\n\t\t\tscrollParent = this.parents().filter(function() {\n\t\t\t\treturn (/(auto|scroll)/).test($.css(this,\"overflow\")+$.css(this,\"overflow-y\")+$.css(this,\"overflow-x\"));\n\t\t\t}).eq(0);\n\t\t}\n\n\t\treturn (/fixed/).test(this.css(\"position\")) || !scrollParent.length ? $(document) : scrollParent;\n\t},\n\n\tzIndex: function( zIndex ) {\n\t\tif ( zIndex !== undefined ) {\n\t\t\treturn this.css( \"zIndex\", zIndex );\n\t\t}\n\n\t\tif ( this.length ) {\n\t\t\tvar elem = $( this[ 0 ] ), position, value;\n\t\t\twhile ( elem.length && elem[ 0 ] !== document ) {\n\t\t\t\t// Ignore z-index if position is set to a value where z-index is ignored by the browser\n\t\t\t\t// This makes behavior of this function consistent across browsers\n\t\t\t\t// WebKit always returns auto if the element is positioned\n\t\t\t\tposition = elem.css( \"position\" );\n\t\t\t\tif ( position === \"absolute\" || position === \"relative\" || position === \"fixed\" ) {\n\t\t\t\t\t// IE returns 0 when zIndex is not specified\n\t\t\t\t\t// other browsers return a string\n\t\t\t\t\t// we ignore the case of nested elements with an explicit value of 0\n\t\t\t\t\t// <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n\t\t\t\t\tvalue = parseInt( elem.css( \"zIndex\" ), 10 );\n\t\t\t\t\tif ( !isNaN( value ) && value !== 0 ) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telem = elem.parent();\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t},\n\n\tuniqueId: function() {\n\t\treturn this.each(function() {\n\t\t\tif ( !this.id ) {\n\t\t\t\tthis.id = \"ui-id-\" + (++uuid);\n\t\t\t}\n\t\t});\n\t},\n\n\tremoveUniqueId: function() {\n\t\treturn this.each(function() {\n\t\t\tif ( runiqueId.test( this.id ) ) {\n\t\t\t\t$( this ).removeAttr( \"id\" );\n\t\t\t}\n\t\t});\n\t}\n});\n\n// selectors\nfunction focusable( element, isTabIndexNotNaN ) {\n\tvar map, mapName, img,\n\t\tnodeName = element.nodeName.toLowerCase();\n\tif ( \"area\" === nodeName ) {\n\t\tmap = element.parentNode;\n\t\tmapName = map.name;\n\t\tif ( !element.href || !mapName || map.nodeName.toLowerCase() !== \"map\" ) {\n\t\t\treturn false;\n\t\t}\n\t\timg = $( \"img[usemap=#\" + mapName + \"]\" )[0];\n\t\treturn !!img && visible( img );\n\t}\n\treturn ( /input|select|textarea|button|object/.test( nodeName ) ?\n\t\t!element.disabled :\n\t\t\"a\" === nodeName ?\n\t\t\telement.href || isTabIndexNotNaN :\n\t\t\tisTabIndexNotNaN) &&\n\t\t// the element and all of its ancestors must be visible\n\t\tvisible( element );\n}\n\nfunction visible( element ) {\n\treturn $.expr.filters.visible( element ) &&\n\t\t!$( element ).parents().addBack().filter(function() {\n\t\t\treturn $.css( this, \"visibility\" ) === \"hidden\";\n\t\t}).length;\n}\n\n$.extend( $.expr[ \":\" ], {\n\tdata: $.expr.createPseudo ?\n\t\t$.expr.createPseudo(function( dataName ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn !!$.data( elem, dataName );\n\t\t\t};\n\t\t}) :\n\t\t// support: jQuery <1.8\n\t\tfunction( elem, i, match ) {\n\t\t\treturn !!$.data( elem, match[ 3 ] );\n\t\t},\n\n\tfocusable: function( element ) {\n\t\treturn focusable( element, !isNaN( $.attr( element, \"tabindex\" ) ) );\n\t},\n\n\ttabbable: function( element ) {\n\t\tvar tabIndex = $.attr( element, \"tabindex\" ),\n\t\t\tisTabIndexNaN = isNaN( tabIndex );\n\t\treturn ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\n\t}\n});\n\n// support: jQuery <1.8\nif ( !$( \"<a>\" ).outerWidth( 1 ).jquery ) {\n\t$.each( [ \"Width\", \"Height\" ], function( i, name ) {\n\t\tvar side = name === \"Width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ],\n\t\t\ttype = name.toLowerCase(),\n\t\t\torig = {\n\t\t\t\tinnerWidth: $.fn.innerWidth,\n\t\t\t\tinnerHeight: $.fn.innerHeight,\n\t\t\t\touterWidth: $.fn.outerWidth,\n\t\t\t\touterHeight: $.fn.outerHeight\n\t\t\t};\n\n\t\tfunction reduce( elem, size, border, margin ) {\n\t\t\t$.each( side, function() {\n\t\t\t\tsize -= parseFloat( $.css( elem, \"padding\" + this ) ) || 0;\n\t\t\t\tif ( border ) {\n\t\t\t\t\tsize -= parseFloat( $.css( elem, \"border\" + this + \"Width\" ) ) || 0;\n\t\t\t\t}\n\t\t\t\tif ( margin ) {\n\t\t\t\t\tsize -= parseFloat( $.css( elem, \"margin\" + this ) ) || 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn size;\n\t\t}\n\n\t\t$.fn[ \"inner\" + name ] = function( size ) {\n\t\t\tif ( size === undefined ) {\n\t\t\t\treturn orig[ \"inner\" + name ].call( this );\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\t$( this ).css( type, reduce( this, size ) + \"px\" );\n\t\t\t});\n\t\t};\n\n\t\t$.fn[ \"outer\" + name] = function( size, margin ) {\n\t\t\tif ( typeof size !== \"number\" ) {\n\t\t\t\treturn orig[ \"outer\" + name ].call( this, size );\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\t$( this).css( type, reduce( this, size, true, margin ) + \"px\" );\n\t\t\t});\n\t\t};\n\t});\n}\n\n// support: jQuery <1.8\nif ( !$.fn.addBack ) {\n\t$.fn.addBack = function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t};\n}\n\n// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\nif ( $( \"<a>\" ).data( \"a-b\", \"a\" ).removeData( \"a-b\" ).data( \"a-b\" ) ) {\n\t$.fn.removeData = (function( removeData ) {\n\t\treturn function( key ) {\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn removeData.call( this, $.camelCase( key ) );\n\t\t\t} else {\n\t\t\t\treturn removeData.call( this );\n\t\t\t}\n\t\t};\n\t})( $.fn.removeData );\n}\n\n\n\n\n\n// deprecated\n$.ui.ie = !!/msie [\\w.]+/.exec( navigator.userAgent.toLowerCase() );\n\n$.support.selectstart = \"onselectstart\" in document.createElement( \"div\" );\n$.fn.extend({\n\tdisableSelection: function() {\n\t\treturn this.bind( ( $.support.selectstart ? \"selectstart\" : \"mousedown\" ) +\n\t\t\t\".ui-disableSelection\", function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\t},\n\n\tenableSelection: function() {\n\t\treturn this.unbind( \".ui-disableSelection\" );\n\t}\n});\n\n$.extend( $.ui, {\n\t// $.ui.plugin is deprecated. Use $.widget() extensions instead.\n\tplugin: {\n\t\tadd: function( module, option, set ) {\n\t\t\tvar i,\n\t\t\t\tproto = $.ui[ module ].prototype;\n\t\t\tfor ( i in set ) {\n\t\t\t\tproto.plugins[ i ] = proto.plugins[ i ] || [];\n\t\t\t\tproto.plugins[ i ].push( [ option, set[ i ] ] );\n\t\t\t}\n\t\t},\n\t\tcall: function( instance, name, args ) {\n\t\t\tvar i,\n\t\t\t\tset = instance.plugins[ name ];\n\t\t\tif ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < set.length; i++ ) {\n\t\t\t\tif ( instance.options[ set[ i ][ 0 ] ] ) {\n\t\t\t\t\tset[ i ][ 1 ].apply( instance.element, args );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// only used by resizable\n\thasScroll: function( el, a ) {\n\n\t\t//If overflow is hidden, the element might have extra content, but the user wants to hide it\n\t\tif ( $( el ).css( \"overflow\" ) === \"hidden\") {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar scroll = ( a && a === \"left\" ) ? \"scrollLeft\" : \"scrollTop\",\n\t\t\thas = false;\n\n\t\tif ( el[ scroll ] > 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// TODO: determine which cases actually cause this to happen\n\t\t// if the element doesn't have the scroll set, see if it's possible to\n\t\t// set the scroll\n\t\tel[ scroll ] = 1;\n\t\thas = ( el[ scroll ] > 0 );\n\t\tel[ scroll ] = 0;\n\t\treturn has;\n\t}\n});\n\n})( jQuery );\n","var jQuery = require('jquery');\nrequire('./core');\n\n/*!\n * jQuery UI Datepicker 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/datepicker/\n *\n * Depends:\n *\tjquery.ui.core.js\n */\n(function( $, undefined ) {\n\n$.extend($.ui, { datepicker: { version: \"1.10.4\" } });\n\nvar PROP_NAME = \"datepicker\",\n\tinstActive;\n\n/* Date picker manager.\n   Use the singleton instance of this class, $.datepicker, to interact with the date picker.\n   Settings for (groups of) date pickers are maintained in an instance object,\n   allowing multiple different settings on the same page. */\n\nfunction Datepicker() {\n\tthis._curInst = null; // The current instance in use\n\tthis._keyEvent = false; // If the last event was a key event\n\tthis._disabledInputs = []; // List of date picker inputs that have been disabled\n\tthis._datepickerShowing = false; // True if the popup picker is showing , false if not\n\tthis._inDialog = false; // True if showing within a \"dialog\", false if not\n\tthis._mainDivId = \"ui-datepicker-div\"; // The ID of the main datepicker division\n\tthis._inlineClass = \"ui-datepicker-inline\"; // The name of the inline marker class\n\tthis._appendClass = \"ui-datepicker-append\"; // The name of the append marker class\n\tthis._triggerClass = \"ui-datepicker-trigger\"; // The name of the trigger marker class\n\tthis._dialogClass = \"ui-datepicker-dialog\"; // The name of the dialog marker class\n\tthis._disableClass = \"ui-datepicker-disabled\"; // The name of the disabled covering marker class\n\tthis._unselectableClass = \"ui-datepicker-unselectable\"; // The name of the unselectable cell marker class\n\tthis._currentClass = \"ui-datepicker-current-day\"; // The name of the current day marker class\n\tthis._dayOverClass = \"ui-datepicker-days-cell-over\"; // The name of the day hover marker class\n\tthis.regional = []; // Available regional settings, indexed by language code\n\tthis.regional[\"\"] = { // Default regional settings\n\t\tcloseText: \"Done\", // Display text for close link\n\t\tprevText: \"Prev\", // Display text for previous month link\n\t\tnextText: \"Next\", // Display text for next month link\n\t\tcurrentText: \"Today\", // Display text for current month link\n\t\tmonthNames: [\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\n\t\t\t\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"], // Names of months for drop-down and formatting\n\t\tmonthNamesShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], // For formatting\n\t\tdayNames: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], // For formatting\n\t\tdayNamesShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"], // For formatting\n\t\tdayNamesMin: [\"Su\",\"Mo\",\"Tu\",\"We\",\"Th\",\"Fr\",\"Sa\"], // Column headings for days starting at Sunday\n\t\tweekHeader: \"Wk\", // Column header for week of the year\n\t\tdateFormat: \"mm/dd/yy\", // See format options on parseDate\n\t\tfirstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...\n\t\tisRTL: false, // True if right-to-left language, false if left-to-right\n\t\tshowMonthAfterYear: false, // True if the year select precedes month, false for month then year\n\t\tyearSuffix: \"\" // Additional text to append to the year in the month headers\n\t};\n\tthis._defaults = { // Global defaults for all the date picker instances\n\t\tshowOn: \"focus\", // \"focus\" for popup on focus,\n\t\t\t// \"button\" for trigger button, or \"both\" for either\n\t\tshowAnim: \"fadeIn\", // Name of jQuery animation for popup\n\t\tshowOptions: {}, // Options for enhanced animations\n\t\tdefaultDate: null, // Used when field is blank: actual date,\n\t\t\t// +/-number for offset from today, null for today\n\t\tappendText: \"\", // Display text following the input box, e.g. showing the format\n\t\tbuttonText: \"...\", // Text for trigger button\n\t\tbuttonImage: \"\", // URL for trigger button image\n\t\tbuttonImageOnly: false, // True if the image appears alone, false if it appears on a button\n\t\thideIfNoPrevNext: false, // True to hide next/previous month links\n\t\t\t// if not applicable, false to just disable them\n\t\tnavigationAsDateFormat: false, // True if date formatting applied to prev/today/next links\n\t\tgotoCurrent: false, // True if today link goes back to current selection instead\n\t\tchangeMonth: false, // True if month can be selected directly, false if only prev/next\n\t\tchangeYear: false, // True if year can be selected directly, false if only prev/next\n\t\tyearRange: \"c-10:c+10\", // Range of years to display in drop-down,\n\t\t\t// either relative to today's year (-nn:+nn), relative to currently displayed year\n\t\t\t// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)\n\t\tshowOtherMonths: false, // True to show dates in other months, false to leave blank\n\t\tselectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable\n\t\tshowWeek: false, // True to show week of the year, false to not show it\n\t\tcalculateWeek: this.iso8601Week, // How to calculate the week of the year,\n\t\t\t// takes a Date and returns the number of the week for it\n\t\tshortYearCutoff: \"+10\", // Short year values < this are in the current century,\n\t\t\t// > this are in the previous century,\n\t\t\t// string value starting with \"+\" for current year + value\n\t\tminDate: null, // The earliest selectable date, or null for no limit\n\t\tmaxDate: null, // The latest selectable date, or null for no limit\n\t\tduration: \"fast\", // Duration of display/closure\n\t\tbeforeShowDay: null, // Function that takes a date and returns an array with\n\t\t\t// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or \"\",\n\t\t\t// [2] = cell title (optional), e.g. $.datepicker.noWeekends\n\t\tbeforeShow: null, // Function that takes an input field and\n\t\t\t// returns a set of custom settings for the date picker\n\t\tonSelect: null, // Define a callback function when a date is selected\n\t\tonChangeMonthYear: null, // Define a callback function when the month or year is changed\n\t\tonClose: null, // Define a callback function when the datepicker is closed\n\t\tnumberOfMonths: 1, // Number of months to show at a time\n\t\tshowCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)\n\t\tstepMonths: 1, // Number of months to step back/forward\n\t\tstepBigMonths: 12, // Number of months to step back/forward for the big links\n\t\taltField: \"\", // Selector for an alternate field to store selected dates into\n\t\taltFormat: \"\", // The date format to use for the alternate field\n\t\tconstrainInput: true, // The input is constrained by the current date format\n\t\tshowButtonPanel: false, // True to show button panel, false to not show it\n\t\tautoSize: false, // True to size the input for the date format, false to leave as is\n\t\tdisabled: false // The initial disabled state\n\t};\n\t$.extend(this._defaults, this.regional[\"\"]);\n\tthis.dpDiv = bindHover($(\"<div id='\" + this._mainDivId + \"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>\"));\n}\n\n$.extend(Datepicker.prototype, {\n\t/* Class name added to elements to indicate already configured with a date picker. */\n\tmarkerClassName: \"hasDatepicker\",\n\n\t//Keep track of the maximum number of rows displayed (see #7043)\n\tmaxRows: 4,\n\n\t// TODO rename to \"widget\" when switching to widget factory\n\t_widgetDatepicker: function() {\n\t\treturn this.dpDiv;\n\t},\n\n\t/* Override the default settings for all instances of the date picker.\n\t * @param  settings  object - the new settings to use as defaults (anonymous object)\n\t * @return the manager object\n\t */\n\tsetDefaults: function(settings) {\n\t\textendRemove(this._defaults, settings || {});\n\t\treturn this;\n\t},\n\n\t/* Attach the date picker to a jQuery selection.\n\t * @param  target\telement - the target input field or division or span\n\t * @param  settings  object - the new settings to use for this date picker instance (anonymous)\n\t */\n\t_attachDatepicker: function(target, settings) {\n\t\tvar nodeName, inline, inst;\n\t\tnodeName = target.nodeName.toLowerCase();\n\t\tinline = (nodeName === \"div\" || nodeName === \"span\");\n\t\tif (!target.id) {\n\t\t\tthis.uuid += 1;\n\t\t\ttarget.id = \"dp\" + this.uuid;\n\t\t}\n\t\tinst = this._newInst($(target), inline);\n\t\tinst.settings = $.extend({}, settings || {});\n\t\tif (nodeName === \"input\") {\n\t\t\tthis._connectDatepicker(target, inst);\n\t\t} else if (inline) {\n\t\t\tthis._inlineDatepicker(target, inst);\n\t\t}\n\t},\n\n\t/* Create a new instance object. */\n\t_newInst: function(target, inline) {\n\t\tvar id = target[0].id.replace(/([^A-Za-z0-9_\\-])/g, \"\\\\\\\\$1\"); // escape jQuery meta chars\n\t\treturn {id: id, input: target, // associated target\n\t\t\tselectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection\n\t\t\tdrawMonth: 0, drawYear: 0, // month being drawn\n\t\t\tinline: inline, // is datepicker inline or not\n\t\t\tdpDiv: (!inline ? this.dpDiv : // presentation div\n\t\t\tbindHover($(\"<div class='\" + this._inlineClass + \" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>\")))};\n\t},\n\n\t/* Attach the date picker to an input field. */\n\t_connectDatepicker: function(target, inst) {\n\t\tvar input = $(target);\n\t\tinst.append = $([]);\n\t\tinst.trigger = $([]);\n\t\tif (input.hasClass(this.markerClassName)) {\n\t\t\treturn;\n\t\t}\n\t\tthis._attachments(input, inst);\n\t\tinput.addClass(this.markerClassName).keydown(this._doKeyDown).\n\t\t\tkeypress(this._doKeyPress).keyup(this._doKeyUp);\n\t\tthis._autoSize(inst);\n\t\t$.data(target, PROP_NAME, inst);\n\t\t//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)\n\t\tif( inst.settings.disabled ) {\n\t\t\tthis._disableDatepicker( target );\n\t\t}\n\t},\n\n\t/* Make attachments based on settings. */\n\t_attachments: function(input, inst) {\n\t\tvar showOn, buttonText, buttonImage,\n\t\t\tappendText = this._get(inst, \"appendText\"),\n\t\t\tisRTL = this._get(inst, \"isRTL\");\n\n\t\tif (inst.append) {\n\t\t\tinst.append.remove();\n\t\t}\n\t\tif (appendText) {\n\t\t\tinst.append = $(\"<span class='\" + this._appendClass + \"'>\" + appendText + \"</span>\");\n\t\t\tinput[isRTL ? \"before\" : \"after\"](inst.append);\n\t\t}\n\n\t\tinput.unbind(\"focus\", this._showDatepicker);\n\n\t\tif (inst.trigger) {\n\t\t\tinst.trigger.remove();\n\t\t}\n\n\t\tshowOn = this._get(inst, \"showOn\");\n\t\tif (showOn === \"focus\" || showOn === \"both\") { // pop-up date picker when in the marked field\n\t\t\tinput.focus(this._showDatepicker);\n\t\t}\n\t\tif (showOn === \"button\" || showOn === \"both\") { // pop-up date picker when button clicked\n\t\t\tbuttonText = this._get(inst, \"buttonText\");\n\t\t\tbuttonImage = this._get(inst, \"buttonImage\");\n\t\t\tinst.trigger = $(this._get(inst, \"buttonImageOnly\") ?\n\t\t\t\t$(\"<img/>\").addClass(this._triggerClass).\n\t\t\t\t\tattr({ src: buttonImage, alt: buttonText, title: buttonText }) :\n\t\t\t\t$(\"<button type='button'></button>\").addClass(this._triggerClass).\n\t\t\t\t\thtml(!buttonImage ? buttonText : $(\"<img/>\").attr(\n\t\t\t\t\t{ src:buttonImage, alt:buttonText, title:buttonText })));\n\t\t\tinput[isRTL ? \"before\" : \"after\"](inst.trigger);\n\t\t\tinst.trigger.click(function() {\n\t\t\t\tif ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {\n\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {\n\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t\t$.datepicker._showDatepicker(input[0]);\n\t\t\t\t} else {\n\t\t\t\t\t$.datepicker._showDatepicker(input[0]);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}\n\t},\n\n\t/* Apply the maximum length for the date format. */\n\t_autoSize: function(inst) {\n\t\tif (this._get(inst, \"autoSize\") && !inst.inline) {\n\t\t\tvar findMax, max, maxI, i,\n\t\t\t\tdate = new Date(2009, 12 - 1, 20), // Ensure double digits\n\t\t\t\tdateFormat = this._get(inst, \"dateFormat\");\n\n\t\t\tif (dateFormat.match(/[DM]/)) {\n\t\t\t\tfindMax = function(names) {\n\t\t\t\t\tmax = 0;\n\t\t\t\t\tmaxI = 0;\n\t\t\t\t\tfor (i = 0; i < names.length; i++) {\n\t\t\t\t\t\tif (names[i].length > max) {\n\t\t\t\t\t\t\tmax = names[i].length;\n\t\t\t\t\t\t\tmaxI = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn maxI;\n\t\t\t\t};\n\t\t\t\tdate.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?\n\t\t\t\t\t\"monthNames\" : \"monthNamesShort\"))));\n\t\t\t\tdate.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?\n\t\t\t\t\t\"dayNames\" : \"dayNamesShort\"))) + 20 - date.getDay());\n\t\t\t}\n\t\t\tinst.input.attr(\"size\", this._formatDate(inst, date).length);\n\t\t}\n\t},\n\n\t/* Attach an inline date picker to a div. */\n\t_inlineDatepicker: function(target, inst) {\n\t\tvar divSpan = $(target);\n\t\tif (divSpan.hasClass(this.markerClassName)) {\n\t\t\treturn;\n\t\t}\n\t\tdivSpan.addClass(this.markerClassName).append(inst.dpDiv);\n\t\t$.data(target, PROP_NAME, inst);\n\t\tthis._setDate(inst, this._getDefaultDate(inst), true);\n\t\tthis._updateDatepicker(inst);\n\t\tthis._updateAlternate(inst);\n\t\t//If disabled option is true, disable the datepicker before showing it (see ticket #5665)\n\t\tif( inst.settings.disabled ) {\n\t\t\tthis._disableDatepicker( target );\n\t\t}\n\t\t// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements\n\t\t// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height\n\t\tinst.dpDiv.css( \"display\", \"block\" );\n\t},\n\n\t/* Pop-up the date picker in a \"dialog\" box.\n\t * @param  input element - ignored\n\t * @param  date\tstring or Date - the initial date to display\n\t * @param  onSelect  function - the function to call when a date is selected\n\t * @param  settings  object - update the dialog date picker instance's settings (anonymous object)\n\t * @param  pos int[2] - coordinates for the dialog's position within the screen or\n\t *\t\t\t\t\tevent - with x/y coordinates or\n\t *\t\t\t\t\tleave empty for default (screen centre)\n\t * @return the manager object\n\t */\n\t_dialogDatepicker: function(input, date, onSelect, settings, pos) {\n\t\tvar id, browserWidth, browserHeight, scrollX, scrollY,\n\t\t\tinst = this._dialogInst; // internal instance\n\n\t\tif (!inst) {\n\t\t\tthis.uuid += 1;\n\t\t\tid = \"dp\" + this.uuid;\n\t\t\tthis._dialogInput = $(\"<input type='text' id='\" + id +\n\t\t\t\t\"' style='position: absolute; top: -100px; width: 0px;'/>\");\n\t\t\tthis._dialogInput.keydown(this._doKeyDown);\n\t\t\t$(\"body\").append(this._dialogInput);\n\t\t\tinst = this._dialogInst = this._newInst(this._dialogInput, false);\n\t\t\tinst.settings = {};\n\t\t\t$.data(this._dialogInput[0], PROP_NAME, inst);\n\t\t}\n\t\textendRemove(inst.settings, settings || {});\n\t\tdate = (date && date.constructor === Date ? this._formatDate(inst, date) : date);\n\t\tthis._dialogInput.val(date);\n\n\t\tthis._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);\n\t\tif (!this._pos) {\n\t\t\tbrowserWidth = document.documentElement.clientWidth;\n\t\t\tbrowserHeight = document.documentElement.clientHeight;\n\t\t\tscrollX = document.documentElement.scrollLeft || document.body.scrollLeft;\n\t\t\tscrollY = document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\tthis._pos = // should use actual width/height below\n\t\t\t\t[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];\n\t\t}\n\n\t\t// move input on screen for focus, but hidden behind dialog\n\t\tthis._dialogInput.css(\"left\", (this._pos[0] + 20) + \"px\").css(\"top\", this._pos[1] + \"px\");\n\t\tinst.settings.onSelect = onSelect;\n\t\tthis._inDialog = true;\n\t\tthis.dpDiv.addClass(this._dialogClass);\n\t\tthis._showDatepicker(this._dialogInput[0]);\n\t\tif ($.blockUI) {\n\t\t\t$.blockUI(this.dpDiv);\n\t\t}\n\t\t$.data(this._dialogInput[0], PROP_NAME, inst);\n\t\treturn this;\n\t},\n\n\t/* Detach a datepicker from its control.\n\t * @param  target\telement - the target input field or division or span\n\t */\n\t_destroyDatepicker: function(target) {\n\t\tvar nodeName,\n\t\t\t$target = $(target),\n\t\t\tinst = $.data(target, PROP_NAME);\n\n\t\tif (!$target.hasClass(this.markerClassName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tnodeName = target.nodeName.toLowerCase();\n\t\t$.removeData(target, PROP_NAME);\n\t\tif (nodeName === \"input\") {\n\t\t\tinst.append.remove();\n\t\t\tinst.trigger.remove();\n\t\t\t$target.removeClass(this.markerClassName).\n\t\t\t\tunbind(\"focus\", this._showDatepicker).\n\t\t\t\tunbind(\"keydown\", this._doKeyDown).\n\t\t\t\tunbind(\"keypress\", this._doKeyPress).\n\t\t\t\tunbind(\"keyup\", this._doKeyUp);\n\t\t} else if (nodeName === \"div\" || nodeName === \"span\") {\n\t\t\t$target.removeClass(this.markerClassName).empty();\n\t\t}\n\t},\n\n\t/* Enable the date picker to a jQuery selection.\n\t * @param  target\telement - the target input field or division or span\n\t */\n\t_enableDatepicker: function(target) {\n\t\tvar nodeName, inline,\n\t\t\t$target = $(target),\n\t\t\tinst = $.data(target, PROP_NAME);\n\n\t\tif (!$target.hasClass(this.markerClassName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tnodeName = target.nodeName.toLowerCase();\n\t\tif (nodeName === \"input\") {\n\t\t\ttarget.disabled = false;\n\t\t\tinst.trigger.filter(\"button\").\n\t\t\t\teach(function() { this.disabled = false; }).end().\n\t\t\t\tfilter(\"img\").css({opacity: \"1.0\", cursor: \"\"});\n\t\t} else if (nodeName === \"div\" || nodeName === \"span\") {\n\t\t\tinline = $target.children(\".\" + this._inlineClass);\n\t\t\tinline.children().removeClass(\"ui-state-disabled\");\n\t\t\tinline.find(\"select.ui-datepicker-month, select.ui-datepicker-year\").\n\t\t\t\tprop(\"disabled\", false);\n\t\t}\n\t\tthis._disabledInputs = $.map(this._disabledInputs,\n\t\t\tfunction(value) { return (value === target ? null : value); }); // delete entry\n\t},\n\n\t/* Disable the date picker to a jQuery selection.\n\t * @param  target\telement - the target input field or division or span\n\t */\n\t_disableDatepicker: function(target) {\n\t\tvar nodeName, inline,\n\t\t\t$target = $(target),\n\t\t\tinst = $.data(target, PROP_NAME);\n\n\t\tif (!$target.hasClass(this.markerClassName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tnodeName = target.nodeName.toLowerCase();\n\t\tif (nodeName === \"input\") {\n\t\t\ttarget.disabled = true;\n\t\t\tinst.trigger.filter(\"button\").\n\t\t\t\teach(function() { this.disabled = true; }).end().\n\t\t\t\tfilter(\"img\").css({opacity: \"0.5\", cursor: \"default\"});\n\t\t} else if (nodeName === \"div\" || nodeName === \"span\") {\n\t\t\tinline = $target.children(\".\" + this._inlineClass);\n\t\t\tinline.children().addClass(\"ui-state-disabled\");\n\t\t\tinline.find(\"select.ui-datepicker-month, select.ui-datepicker-year\").\n\t\t\t\tprop(\"disabled\", true);\n\t\t}\n\t\tthis._disabledInputs = $.map(this._disabledInputs,\n\t\t\tfunction(value) { return (value === target ? null : value); }); // delete entry\n\t\tthis._disabledInputs[this._disabledInputs.length] = target;\n\t},\n\n\t/* Is the first field in a jQuery collection disabled as a datepicker?\n\t * @param  target\telement - the target input field or division or span\n\t * @return boolean - true if disabled, false if enabled\n\t */\n\t_isDisabledDatepicker: function(target) {\n\t\tif (!target) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0; i < this._disabledInputs.length; i++) {\n\t\t\tif (this._disabledInputs[i] === target) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\t/* Retrieve the instance data for the target control.\n\t * @param  target  element - the target input field or division or span\n\t * @return  object - the associated instance data\n\t * @throws  error if a jQuery problem getting data\n\t */\n\t_getInst: function(target) {\n\t\ttry {\n\t\t\treturn $.data(target, PROP_NAME);\n\t\t}\n\t\tcatch (err) {\n\t\t\tthrow \"Missing instance data for this datepicker\";\n\t\t}\n\t},\n\n\t/* Update or retrieve the settings for a date picker attached to an input field or division.\n\t * @param  target  element - the target input field or division or span\n\t * @param  name\tobject - the new settings to update or\n\t *\t\t\t\tstring - the name of the setting to change or retrieve,\n\t *\t\t\t\twhen retrieving also \"all\" for all instance settings or\n\t *\t\t\t\t\"defaults\" for all global defaults\n\t * @param  value   any - the new value for the setting\n\t *\t\t\t\t(omit if above is an object or to retrieve a value)\n\t */\n\t_optionDatepicker: function(target, name, value) {\n\t\tvar settings, date, minDate, maxDate,\n\t\t\tinst = this._getInst(target);\n\n\t\tif (arguments.length === 2 && typeof name === \"string\") {\n\t\t\treturn (name === \"defaults\" ? $.extend({}, $.datepicker._defaults) :\n\t\t\t\t(inst ? (name === \"all\" ? $.extend({}, inst.settings) :\n\t\t\t\tthis._get(inst, name)) : null));\n\t\t}\n\n\t\tsettings = name || {};\n\t\tif (typeof name === \"string\") {\n\t\t\tsettings = {};\n\t\t\tsettings[name] = value;\n\t\t}\n\n\t\tif (inst) {\n\t\t\tif (this._curInst === inst) {\n\t\t\t\tthis._hideDatepicker();\n\t\t\t}\n\n\t\t\tdate = this._getDateDatepicker(target, true);\n\t\t\tminDate = this._getMinMaxDate(inst, \"min\");\n\t\t\tmaxDate = this._getMinMaxDate(inst, \"max\");\n\t\t\textendRemove(inst.settings, settings);\n\t\t\t// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided\n\t\t\tif (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {\n\t\t\t\tinst.settings.minDate = this._formatDate(inst, minDate);\n\t\t\t}\n\t\t\tif (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {\n\t\t\t\tinst.settings.maxDate = this._formatDate(inst, maxDate);\n\t\t\t}\n\t\t\tif ( \"disabled\" in settings ) {\n\t\t\t\tif ( settings.disabled ) {\n\t\t\t\t\tthis._disableDatepicker(target);\n\t\t\t\t} else {\n\t\t\t\t\tthis._enableDatepicker(target);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._attachments($(target), inst);\n\t\t\tthis._autoSize(inst);\n\t\t\tthis._setDate(inst, date);\n\t\t\tthis._updateAlternate(inst);\n\t\t\tthis._updateDatepicker(inst);\n\t\t}\n\t},\n\n\t// change method deprecated\n\t_changeDatepicker: function(target, name, value) {\n\t\tthis._optionDatepicker(target, name, value);\n\t},\n\n\t/* Redraw the date picker attached to an input field or division.\n\t * @param  target  element - the target input field or division or span\n\t */\n\t_refreshDatepicker: function(target) {\n\t\tvar inst = this._getInst(target);\n\t\tif (inst) {\n\t\t\tthis._updateDatepicker(inst);\n\t\t}\n\t},\n\n\t/* Set the dates for a jQuery selection.\n\t * @param  target element - the target input field or division or span\n\t * @param  date\tDate - the new date\n\t */\n\t_setDateDatepicker: function(target, date) {\n\t\tvar inst = this._getInst(target);\n\t\tif (inst) {\n\t\t\tthis._setDate(inst, date);\n\t\t\tthis._updateDatepicker(inst);\n\t\t\tthis._updateAlternate(inst);\n\t\t}\n\t},\n\n\t/* Get the date(s) for the first entry in a jQuery selection.\n\t * @param  target element - the target input field or division or span\n\t * @param  noDefault boolean - true if no default date is to be used\n\t * @return Date - the current date\n\t */\n\t_getDateDatepicker: function(target, noDefault) {\n\t\tvar inst = this._getInst(target);\n\t\tif (inst && !inst.inline) {\n\t\t\tthis._setDateFromField(inst, noDefault);\n\t\t}\n\t\treturn (inst ? this._getDate(inst) : null);\n\t},\n\n\t/* Handle keystrokes. */\n\t_doKeyDown: function(event) {\n\t\tvar onSelect, dateStr, sel,\n\t\t\tinst = $.datepicker._getInst(event.target),\n\t\t\thandled = true,\n\t\t\tisRTL = inst.dpDiv.is(\".ui-datepicker-rtl\");\n\n\t\tinst._keyEvent = true;\n\t\tif ($.datepicker._datepickerShowing) {\n\t\t\tswitch (event.keyCode) {\n\t\t\t\tcase 9: $.datepicker._hideDatepicker();\n\t\t\t\t\t\thandled = false;\n\t\t\t\t\t\tbreak; // hide on tab out\n\t\t\t\tcase 13: sel = $(\"td.\" + $.datepicker._dayOverClass + \":not(.\" +\n\t\t\t\t\t\t\t\t\t$.datepicker._currentClass + \")\", inst.dpDiv);\n\t\t\t\t\t\tif (sel[0]) {\n\t\t\t\t\t\t\t$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tonSelect = $.datepicker._get(inst, \"onSelect\");\n\t\t\t\t\t\tif (onSelect) {\n\t\t\t\t\t\t\tdateStr = $.datepicker._formatDate(inst);\n\n\t\t\t\t\t\t\t// trigger custom callback\n\t\t\t\t\t\t\tonSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false; // don't submit the form\n\t\t\t\tcase 27: $.datepicker._hideDatepicker();\n\t\t\t\t\t\tbreak; // hide on escape\n\t\t\t\tcase 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n\t\t\t\t\t\t\t-$.datepicker._get(inst, \"stepBigMonths\") :\n\t\t\t\t\t\t\t-$.datepicker._get(inst, \"stepMonths\")), \"M\");\n\t\t\t\t\t\tbreak; // previous month/year on page up/+ ctrl\n\t\t\t\tcase 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n\t\t\t\t\t\t\t+$.datepicker._get(inst, \"stepBigMonths\") :\n\t\t\t\t\t\t\t+$.datepicker._get(inst, \"stepMonths\")), \"M\");\n\t\t\t\t\t\tbreak; // next month/year on page down/+ ctrl\n\t\t\t\tcase 35: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._clearDate(event.target);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // clear on ctrl or command +end\n\t\t\t\tcase 36: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._gotoToday(event.target);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // current on ctrl or command +home\n\t\t\t\tcase 37: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), \"D\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\t// -1 day on ctrl or command +left\n\t\t\t\t\t\tif (event.originalEvent.altKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, (event.ctrlKey ?\n\t\t\t\t\t\t\t\t-$.datepicker._get(inst, \"stepBigMonths\") :\n\t\t\t\t\t\t\t\t-$.datepicker._get(inst, \"stepMonths\")), \"M\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// next month/year on alt +left on Mac\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase 38: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, -7, \"D\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // -1 week on ctrl or command +up\n\t\t\t\tcase 39: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), \"D\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\t// +1 day on ctrl or command +right\n\t\t\t\t\t\tif (event.originalEvent.altKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, (event.ctrlKey ?\n\t\t\t\t\t\t\t\t+$.datepicker._get(inst, \"stepBigMonths\") :\n\t\t\t\t\t\t\t\t+$.datepicker._get(inst, \"stepMonths\")), \"M\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// next month/year on alt +right\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase 40: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, +7, \"D\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // +1 week on ctrl or command +down\n\t\t\t\tdefault: handled = false;\n\t\t\t}\n\t\t} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home\n\t\t\t$.datepicker._showDatepicker(this);\n\t\t} else {\n\t\t\thandled = false;\n\t\t}\n\n\t\tif (handled) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t}\n\t},\n\n\t/* Filter entered characters - based on date format. */\n\t_doKeyPress: function(event) {\n\t\tvar chars, chr,\n\t\t\tinst = $.datepicker._getInst(event.target);\n\n\t\tif ($.datepicker._get(inst, \"constrainInput\")) {\n\t\t\tchars = $.datepicker._possibleChars($.datepicker._get(inst, \"dateFormat\"));\n\t\t\tchr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);\n\t\t\treturn event.ctrlKey || event.metaKey || (chr < \" \" || !chars || chars.indexOf(chr) > -1);\n\t\t}\n\t},\n\n\t/* Synchronise manual entry and field/alternate field. */\n\t_doKeyUp: function(event) {\n\t\tvar date,\n\t\t\tinst = $.datepicker._getInst(event.target);\n\n\t\tif (inst.input.val() !== inst.lastVal) {\n\t\t\ttry {\n\t\t\t\tdate = $.datepicker.parseDate($.datepicker._get(inst, \"dateFormat\"),\n\t\t\t\t\t(inst.input ? inst.input.val() : null),\n\t\t\t\t\t$.datepicker._getFormatConfig(inst));\n\n\t\t\t\tif (date) { // only if valid\n\t\t\t\t\t$.datepicker._setDateFromField(inst);\n\t\t\t\t\t$.datepicker._updateAlternate(inst);\n\t\t\t\t\t$.datepicker._updateDatepicker(inst);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\t/* Pop-up the date picker for a given input field.\n\t * If false returned from beforeShow event handler do not show.\n\t * @param  input  element - the input field attached to the date picker or\n\t *\t\t\t\t\tevent - if triggered by focus\n\t */\n\t_showDatepicker: function(input) {\n\t\tinput = input.target || input;\n\t\tif (input.nodeName.toLowerCase() !== \"input\") { // find from button/image trigger\n\t\t\tinput = $(\"input\", input.parentNode)[0];\n\t\t}\n\n\t\tif ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here\n\t\t\treturn;\n\t\t}\n\n\t\tvar inst, beforeShow, beforeShowSettings, isFixed,\n\t\t\toffset, showAnim, duration;\n\n\t\tinst = $.datepicker._getInst(input);\n\t\tif ($.datepicker._curInst && $.datepicker._curInst !== inst) {\n\t\t\t$.datepicker._curInst.dpDiv.stop(true, true);\n\t\t\tif ( inst && $.datepicker._datepickerShowing ) {\n\t\t\t\t$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );\n\t\t\t}\n\t\t}\n\n\t\tbeforeShow = $.datepicker._get(inst, \"beforeShow\");\n\t\tbeforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};\n\t\tif(beforeShowSettings === false){\n\t\t\treturn;\n\t\t}\n\t\textendRemove(inst.settings, beforeShowSettings);\n\n\t\tinst.lastVal = null;\n\t\t$.datepicker._lastInput = input;\n\t\t$.datepicker._setDateFromField(inst);\n\n\t\tif ($.datepicker._inDialog) { // hide cursor\n\t\t\tinput.value = \"\";\n\t\t}\n\t\tif (!$.datepicker._pos) { // position below input\n\t\t\t$.datepicker._pos = $.datepicker._findPos(input);\n\t\t\t$.datepicker._pos[1] += input.offsetHeight; // add the height\n\t\t}\n\n\t\tisFixed = false;\n\t\t$(input).parents().each(function() {\n\t\t\tisFixed |= $(this).css(\"position\") === \"fixed\";\n\t\t\treturn !isFixed;\n\t\t});\n\n\t\toffset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};\n\t\t$.datepicker._pos = null;\n\t\t//to avoid flashes on Firefox\n\t\tinst.dpDiv.empty();\n\t\t// determine sizing offscreen\n\t\tinst.dpDiv.css({position: \"absolute\", display: \"block\", top: \"-1000px\"});\n\t\t$.datepicker._updateDatepicker(inst);\n\t\t// fix width for dynamic number of date pickers\n\t\t// and adjust position before showing\n\t\toffset = $.datepicker._checkOffset(inst, offset, isFixed);\n\t\tinst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?\n\t\t\t\"static\" : (isFixed ? \"fixed\" : \"absolute\")), display: \"none\",\n\t\t\tleft: offset.left + \"px\", top: offset.top + \"px\"});\n\n\t\tif (!inst.inline) {\n\t\t\tshowAnim = $.datepicker._get(inst, \"showAnim\");\n\t\t\tduration = $.datepicker._get(inst, \"duration\");\n\t\t\tinst.dpDiv.zIndex($(input).zIndex()+1);\n\t\t\t$.datepicker._datepickerShowing = true;\n\n\t\t\tif ( $.effects && $.effects.effect[ showAnim ] ) {\n\t\t\t\tinst.dpDiv.show(showAnim, $.datepicker._get(inst, \"showOptions\"), duration);\n\t\t\t} else {\n\t\t\t\tinst.dpDiv[showAnim || \"show\"](showAnim ? duration : null);\n\t\t\t}\n\n\t\t\tif ( $.datepicker._shouldFocusInput( inst ) ) {\n\t\t\t\tinst.input.focus();\n\t\t\t}\n\n\t\t\t$.datepicker._curInst = inst;\n\t\t}\n\t},\n\n\t/* Generate the date picker content. */\n\t_updateDatepicker: function(inst) {\n\t\tthis.maxRows = 4; //Reset the max number of rows being displayed (see #7043)\n\t\tinstActive = inst; // for delegate hover events\n\t\tinst.dpDiv.empty().append(this._generateHTML(inst));\n\t\tthis._attachHandlers(inst);\n\t\tinst.dpDiv.find(\".\" + this._dayOverClass + \" a\").mouseover();\n\n\t\tvar origyearshtml,\n\t\t\tnumMonths = this._getNumberOfMonths(inst),\n\t\t\tcols = numMonths[1],\n\t\t\twidth = 17;\n\n\t\tinst.dpDiv.removeClass(\"ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4\").width(\"\");\n\t\tif (cols > 1) {\n\t\t\tinst.dpDiv.addClass(\"ui-datepicker-multi-\" + cols).css(\"width\", (width * cols) + \"em\");\n\t\t}\n\t\tinst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? \"add\" : \"remove\") +\n\t\t\t\"Class\"](\"ui-datepicker-multi\");\n\t\tinst.dpDiv[(this._get(inst, \"isRTL\") ? \"add\" : \"remove\") +\n\t\t\t\"Class\"](\"ui-datepicker-rtl\");\n\n\t\tif (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {\n\t\t\tinst.input.focus();\n\t\t}\n\n\t\t// deffered render of the years select (to avoid flashes on Firefox)\n\t\tif( inst.yearshtml ){\n\t\t\torigyearshtml = inst.yearshtml;\n\t\t\tsetTimeout(function(){\n\t\t\t\t//assure that inst.yearshtml didn't change.\n\t\t\t\tif( origyearshtml === inst.yearshtml && inst.yearshtml ){\n\t\t\t\t\tinst.dpDiv.find(\"select.ui-datepicker-year:first\").replaceWith(inst.yearshtml);\n\t\t\t\t}\n\t\t\t\torigyearshtml = inst.yearshtml = null;\n\t\t\t}, 0);\n\t\t}\n\t},\n\n\t// #6694 - don't focus the input if it's already focused\n\t// this breaks the change event in IE\n\t// Support: IE and jQuery <1.9\n\t_shouldFocusInput: function( inst ) {\n\t\treturn inst.input && inst.input.is( \":visible\" ) && !inst.input.is( \":disabled\" ) && !inst.input.is( \":focus\" );\n\t},\n\n\t/* Check positioning to remain on screen. */\n\t_checkOffset: function(inst, offset, isFixed) {\n\t\tvar dpWidth = inst.dpDiv.outerWidth(),\n\t\t\tdpHeight = inst.dpDiv.outerHeight(),\n\t\t\tinputWidth = inst.input ? inst.input.outerWidth() : 0,\n\t\t\tinputHeight = inst.input ? inst.input.outerHeight() : 0,\n\t\t\tviewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),\n\t\t\tviewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());\n\n\t\toffset.left -= (this._get(inst, \"isRTL\") ? (dpWidth - inputWidth) : 0);\n\t\toffset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;\n\t\toffset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;\n\n\t\t// now check if datepicker is showing outside window viewport - move to a better place if so.\n\t\toffset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?\n\t\t\tMath.abs(offset.left + dpWidth - viewWidth) : 0);\n\t\toffset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?\n\t\t\tMath.abs(dpHeight + inputHeight) : 0);\n\n\t\treturn offset;\n\t},\n\n\t/* Find an object's position on the screen. */\n\t_findPos: function(obj) {\n\t\tvar position,\n\t\t\tinst = this._getInst(obj),\n\t\t\tisRTL = this._get(inst, \"isRTL\");\n\n\t\twhile (obj && (obj.type === \"hidden\" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {\n\t\t\tobj = obj[isRTL ? \"previousSibling\" : \"nextSibling\"];\n\t\t}\n\n\t\tposition = $(obj).offset();\n\t\treturn [position.left, position.top];\n\t},\n\n\t/* Hide the date picker from view.\n\t * @param  input  element - the input field attached to the date picker\n\t */\n\t_hideDatepicker: function(input) {\n\t\tvar showAnim, duration, postProcess, onClose,\n\t\t\tinst = this._curInst;\n\n\t\tif (!inst || (input && inst !== $.data(input, PROP_NAME))) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._datepickerShowing) {\n\t\t\tshowAnim = this._get(inst, \"showAnim\");\n\t\t\tduration = this._get(inst, \"duration\");\n\t\t\tpostProcess = function() {\n\t\t\t\t$.datepicker._tidyDialog(inst);\n\t\t\t};\n\n\t\t\t// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed\n\t\t\tif ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {\n\t\t\t\tinst.dpDiv.hide(showAnim, $.datepicker._get(inst, \"showOptions\"), duration, postProcess);\n\t\t\t} else {\n\t\t\t\tinst.dpDiv[(showAnim === \"slideDown\" ? \"slideUp\" :\n\t\t\t\t\t(showAnim === \"fadeIn\" ? \"fadeOut\" : \"hide\"))]((showAnim ? duration : null), postProcess);\n\t\t\t}\n\n\t\t\tif (!showAnim) {\n\t\t\t\tpostProcess();\n\t\t\t}\n\t\t\tthis._datepickerShowing = false;\n\n\t\t\tonClose = this._get(inst, \"onClose\");\n\t\t\tif (onClose) {\n\t\t\t\tonClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : \"\"), inst]);\n\t\t\t}\n\n\t\t\tthis._lastInput = null;\n\t\t\tif (this._inDialog) {\n\t\t\t\tthis._dialogInput.css({ position: \"absolute\", left: \"0\", top: \"-100px\" });\n\t\t\t\tif ($.blockUI) {\n\t\t\t\t\t$.unblockUI();\n\t\t\t\t\t$(\"body\").append(this.dpDiv);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._inDialog = false;\n\t\t}\n\t},\n\n\t/* Tidy up after a dialog display. */\n\t_tidyDialog: function(inst) {\n\t\tinst.dpDiv.removeClass(this._dialogClass).unbind(\".ui-datepicker-calendar\");\n\t},\n\n\t/* Close date picker if clicked elsewhere. */\n\t_checkExternalClick: function(event) {\n\t\tif (!$.datepicker._curInst) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar $target = $(event.target),\n\t\t\tinst = $.datepicker._getInst($target[0]);\n\n\t\tif ( ( ( $target[0].id !== $.datepicker._mainDivId &&\n\t\t\t\t$target.parents(\"#\" + $.datepicker._mainDivId).length === 0 &&\n\t\t\t\t!$target.hasClass($.datepicker.markerClassName) &&\n\t\t\t\t!$target.closest(\".\" + $.datepicker._triggerClass).length &&\n\t\t\t\t$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||\n\t\t\t( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {\n\t\t\t\t$.datepicker._hideDatepicker();\n\t\t}\n\t},\n\n\t/* Adjust one of the date sub-fields. */\n\t_adjustDate: function(id, offset, period) {\n\t\tvar target = $(id),\n\t\t\tinst = this._getInst(target[0]);\n\n\t\tif (this._isDisabledDatepicker(target[0])) {\n\t\t\treturn;\n\t\t}\n\t\tthis._adjustInstDate(inst, offset +\n\t\t\t(period === \"M\" ? this._get(inst, \"showCurrentAtPos\") : 0), // undo positioning\n\t\t\tperiod);\n\t\tthis._updateDatepicker(inst);\n\t},\n\n\t/* Action for current link. */\n\t_gotoToday: function(id) {\n\t\tvar date,\n\t\t\ttarget = $(id),\n\t\t\tinst = this._getInst(target[0]);\n\n\t\tif (this._get(inst, \"gotoCurrent\") && inst.currentDay) {\n\t\t\tinst.selectedDay = inst.currentDay;\n\t\t\tinst.drawMonth = inst.selectedMonth = inst.currentMonth;\n\t\t\tinst.drawYear = inst.selectedYear = inst.currentYear;\n\t\t} else {\n\t\t\tdate = new Date();\n\t\t\tinst.selectedDay = date.getDate();\n\t\t\tinst.drawMonth = inst.selectedMonth = date.getMonth();\n\t\t\tinst.drawYear = inst.selectedYear = date.getFullYear();\n\t\t}\n\t\tthis._notifyChange(inst);\n\t\tthis._adjustDate(target);\n\t},\n\n\t/* Action for selecting a new month/year. */\n\t_selectMonthYear: function(id, select, period) {\n\t\tvar target = $(id),\n\t\t\tinst = this._getInst(target[0]);\n\n\t\tinst[\"selected\" + (period === \"M\" ? \"Month\" : \"Year\")] =\n\t\tinst[\"draw\" + (period === \"M\" ? \"Month\" : \"Year\")] =\n\t\t\tparseInt(select.options[select.selectedIndex].value,10);\n\n\t\tthis._notifyChange(inst);\n\t\tthis._adjustDate(target);\n\t},\n\n\t/* Action for selecting a day. */\n\t_selectDay: function(id, month, year, td) {\n\t\tvar inst,\n\t\t\ttarget = $(id);\n\n\t\tif ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {\n\t\t\treturn;\n\t\t}\n\n\t\tinst = this._getInst(target[0]);\n\t\tinst.selectedDay = inst.currentDay = $(\"a\", td).html();\n\t\tinst.selectedMonth = inst.currentMonth = month;\n\t\tinst.selectedYear = inst.currentYear = year;\n\t\tthis._selectDate(id, this._formatDate(inst,\n\t\t\tinst.currentDay, inst.currentMonth, inst.currentYear));\n\t},\n\n\t/* Erase the input field and hide the date picker. */\n\t_clearDate: function(id) {\n\t\tvar target = $(id);\n\t\tthis._selectDate(target, \"\");\n\t},\n\n\t/* Update the input field with the selected date. */\n\t_selectDate: function(id, dateStr) {\n\t\tvar onSelect,\n\t\t\ttarget = $(id),\n\t\t\tinst = this._getInst(target[0]);\n\n\t\tdateStr = (dateStr != null ? dateStr : this._formatDate(inst));\n\t\tif (inst.input) {\n\t\t\tinst.input.val(dateStr);\n\t\t}\n\t\tthis._updateAlternate(inst);\n\n\t\tonSelect = this._get(inst, \"onSelect\");\n\t\tif (onSelect) {\n\t\t\tonSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback\n\t\t} else if (inst.input) {\n\t\t\tinst.input.trigger(\"change\"); // fire the change event\n\t\t}\n\n\t\tif (inst.inline){\n\t\t\tthis._updateDatepicker(inst);\n\t\t} else {\n\t\t\tthis._hideDatepicker();\n\t\t\tthis._lastInput = inst.input[0];\n\t\t\tif (typeof(inst.input[0]) !== \"object\") {\n\t\t\t\tinst.input.focus(); // restore focus\n\t\t\t}\n\t\t\tthis._lastInput = null;\n\t\t}\n\t},\n\n\t/* Update any alternate field to synchronise with the main field. */\n\t_updateAlternate: function(inst) {\n\t\tvar altFormat, date, dateStr,\n\t\t\taltField = this._get(inst, \"altField\");\n\n\t\tif (altField) { // update alternate field too\n\t\t\taltFormat = this._get(inst, \"altFormat\") || this._get(inst, \"dateFormat\");\n\t\t\tdate = this._getDate(inst);\n\t\t\tdateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));\n\t\t\t$(altField).each(function() { $(this).val(dateStr); });\n\t\t}\n\t},\n\n\t/* Set as beforeShowDay function to prevent selection of weekends.\n\t * @param  date  Date - the date to customise\n\t * @return [boolean, string] - is this date selectable?, what is its CSS class?\n\t */\n\tnoWeekends: function(date) {\n\t\tvar day = date.getDay();\n\t\treturn [(day > 0 && day < 6), \"\"];\n\t},\n\n\t/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.\n\t * @param  date  Date - the date to get the week for\n\t * @return  number - the number of the week within the year that contains this date\n\t */\n\tiso8601Week: function(date) {\n\t\tvar time,\n\t\t\tcheckDate = new Date(date.getTime());\n\n\t\t// Find Thursday of this week starting on Monday\n\t\tcheckDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));\n\n\t\ttime = checkDate.getTime();\n\t\tcheckDate.setMonth(0); // Compare with Jan 1\n\t\tcheckDate.setDate(1);\n\t\treturn Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t},\n\n\t/* Parse a string value into a date object.\n\t * See formatDate below for the possible formats.\n\t *\n\t * @param  format string - the expected format of the date\n\t * @param  value string - the date in the above format\n\t * @param  settings Object - attributes include:\n\t *\t\t\t\t\tshortYearCutoff  number - the cutoff year for determining the century (optional)\n\t *\t\t\t\t\tdayNamesShort\tstring[7] - abbreviated names of the days from Sunday (optional)\n\t *\t\t\t\t\tdayNames\t\tstring[7] - names of the days from Sunday (optional)\n\t *\t\t\t\t\tmonthNamesShort string[12] - abbreviated names of the months (optional)\n\t *\t\t\t\t\tmonthNames\t\tstring[12] - names of the months (optional)\n\t * @return  Date - the extracted date value or null if value is blank\n\t */\n\tparseDate: function (format, value, settings) {\n\t\tif (format == null || value == null) {\n\t\t\tthrow \"Invalid arguments\";\n\t\t}\n\n\t\tvalue = (typeof value === \"object\" ? value.toString() : value + \"\");\n\t\tif (value === \"\") {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar iFormat, dim, extra,\n\t\t\tiValue = 0,\n\t\t\tshortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,\n\t\t\tshortYearCutoff = (typeof shortYearCutoffTemp !== \"string\" ? shortYearCutoffTemp :\n\t\t\t\tnew Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),\n\t\t\tdayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\n\t\t\tdayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\n\t\t\tmonthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\n\t\t\tmonthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\n\t\t\tyear = -1,\n\t\t\tmonth = -1,\n\t\t\tday = -1,\n\t\t\tdoy = -1,\n\t\t\tliteral = false,\n\t\t\tdate,\n\t\t\t// Check whether a format character is doubled\n\t\t\tlookAhead = function(match) {\n\t\t\t\tvar matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\n\t\t\t\tif (matches) {\n\t\t\t\t\tiFormat++;\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t},\n\t\t\t// Extract a number from the string value\n\t\t\tgetNumber = function(match) {\n\t\t\t\tvar isDoubled = lookAhead(match),\n\t\t\t\t\tsize = (match === \"@\" ? 14 : (match === \"!\" ? 20 :\n\t\t\t\t\t(match === \"y\" && isDoubled ? 4 : (match === \"o\" ? 3 : 2)))),\n\t\t\t\t\tdigits = new RegExp(\"^\\\\d{1,\" + size + \"}\"),\n\t\t\t\t\tnum = value.substring(iValue).match(digits);\n\t\t\t\tif (!num) {\n\t\t\t\t\tthrow \"Missing number at position \" + iValue;\n\t\t\t\t}\n\t\t\t\tiValue += num[0].length;\n\t\t\t\treturn parseInt(num[0], 10);\n\t\t\t},\n\t\t\t// Extract a name from the string value and convert to an index\n\t\t\tgetName = function(match, shortNames, longNames) {\n\t\t\t\tvar index = -1,\n\t\t\t\t\tnames = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {\n\t\t\t\t\t\treturn [ [k, v] ];\n\t\t\t\t\t}).sort(function (a, b) {\n\t\t\t\t\t\treturn -(a[1].length - b[1].length);\n\t\t\t\t\t});\n\n\t\t\t\t$.each(names, function (i, pair) {\n\t\t\t\t\tvar name = pair[1];\n\t\t\t\t\tif (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {\n\t\t\t\t\t\tindex = pair[0];\n\t\t\t\t\t\tiValue += name.length;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\treturn index + 1;\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"Unknown name at position \" + iValue;\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Confirm that a literal character matches the string value\n\t\t\tcheckLiteral = function() {\n\t\t\t\tif (value.charAt(iValue) !== format.charAt(iFormat)) {\n\t\t\t\t\tthrow \"Unexpected literal at position \" + iValue;\n\t\t\t\t}\n\t\t\t\tiValue++;\n\t\t\t};\n\n\t\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\n\t\t\tif (literal) {\n\t\t\t\tif (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n\t\t\t\t\tliteral = false;\n\t\t\t\t} else {\n\t\t\t\t\tcheckLiteral();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (format.charAt(iFormat)) {\n\t\t\t\t\tcase \"d\":\n\t\t\t\t\t\tday = getNumber(\"d\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"D\":\n\t\t\t\t\t\tgetName(\"D\", dayNamesShort, dayNames);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"o\":\n\t\t\t\t\t\tdoy = getNumber(\"o\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"m\":\n\t\t\t\t\t\tmonth = getNumber(\"m\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"M\":\n\t\t\t\t\t\tmonth = getName(\"M\", monthNamesShort, monthNames);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"y\":\n\t\t\t\t\t\tyear = getNumber(\"y\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"@\":\n\t\t\t\t\t\tdate = new Date(getNumber(\"@\"));\n\t\t\t\t\t\tyear = date.getFullYear();\n\t\t\t\t\t\tmonth = date.getMonth() + 1;\n\t\t\t\t\t\tday = date.getDate();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"!\":\n\t\t\t\t\t\tdate = new Date((getNumber(\"!\") - this._ticksTo1970) / 10000);\n\t\t\t\t\t\tyear = date.getFullYear();\n\t\t\t\t\t\tmonth = date.getMonth() + 1;\n\t\t\t\t\t\tday = date.getDate();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"'\":\n\t\t\t\t\t\tif (lookAhead(\"'\")){\n\t\t\t\t\t\t\tcheckLiteral();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tliteral = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcheckLiteral();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (iValue < value.length){\n\t\t\textra = value.substr(iValue);\n\t\t\tif (!/^\\s+/.test(extra)) {\n\t\t\t\tthrow \"Extra/unparsed characters found in date: \" + extra;\n\t\t\t}\n\t\t}\n\n\t\tif (year === -1) {\n\t\t\tyear = new Date().getFullYear();\n\t\t} else if (year < 100) {\n\t\t\tyear += new Date().getFullYear() - new Date().getFullYear() % 100 +\n\t\t\t\t(year <= shortYearCutoff ? 0 : -100);\n\t\t}\n\n\t\tif (doy > -1) {\n\t\t\tmonth = 1;\n\t\t\tday = doy;\n\t\t\tdo {\n\t\t\t\tdim = this._getDaysInMonth(year, month - 1);\n\t\t\t\tif (day <= dim) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmonth++;\n\t\t\t\tday -= dim;\n\t\t\t} while (true);\n\t\t}\n\n\t\tdate = this._daylightSavingAdjust(new Date(year, month - 1, day));\n\t\tif (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {\n\t\t\tthrow \"Invalid date\"; // E.g. 31/02/00\n\t\t}\n\t\treturn date;\n\t},\n\n\t/* Standard date formats. */\n\tATOM: \"yy-mm-dd\", // RFC 3339 (ISO 8601)\n\tCOOKIE: \"D, dd M yy\",\n\tISO_8601: \"yy-mm-dd\",\n\tRFC_822: \"D, d M y\",\n\tRFC_850: \"DD, dd-M-y\",\n\tRFC_1036: \"D, d M y\",\n\tRFC_1123: \"D, d M yy\",\n\tRFC_2822: \"D, d M yy\",\n\tRSS: \"D, d M y\", // RFC 822\n\tTICKS: \"!\",\n\tTIMESTAMP: \"@\",\n\tW3C: \"yy-mm-dd\", // ISO 8601\n\n\t_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +\n\t\tMath.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),\n\n\t/* Format a date object into a string value.\n\t * The format can be combinations of the following:\n\t * d  - day of month (no leading zero)\n\t * dd - day of month (two digit)\n\t * o  - day of year (no leading zeros)\n\t * oo - day of year (three digit)\n\t * D  - day name short\n\t * DD - day name long\n\t * m  - month of year (no leading zero)\n\t * mm - month of year (two digit)\n\t * M  - month name short\n\t * MM - month name long\n\t * y  - year (two digit)\n\t * yy - year (four digit)\n\t * @ - Unix timestamp (ms since 01/01/1970)\n\t * ! - Windows ticks (100ns since 01/01/0001)\n\t * \"...\" - literal text\n\t * '' - single quote\n\t *\n\t * @param  format string - the desired format of the date\n\t * @param  date Date - the date value to format\n\t * @param  settings Object - attributes include:\n\t *\t\t\t\t\tdayNamesShort\tstring[7] - abbreviated names of the days from Sunday (optional)\n\t *\t\t\t\t\tdayNames\t\tstring[7] - names of the days from Sunday (optional)\n\t *\t\t\t\t\tmonthNamesShort string[12] - abbreviated names of the months (optional)\n\t *\t\t\t\t\tmonthNames\t\tstring[12] - names of the months (optional)\n\t * @return  string - the date in the above format\n\t */\n\tformatDate: function (format, date, settings) {\n\t\tif (!date) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tvar iFormat,\n\t\t\tdayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\n\t\t\tdayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\n\t\t\tmonthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\n\t\t\tmonthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\n\t\t\t// Check whether a format character is doubled\n\t\t\tlookAhead = function(match) {\n\t\t\t\tvar matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\n\t\t\t\tif (matches) {\n\t\t\t\t\tiFormat++;\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t},\n\t\t\t// Format a number, with leading zero if necessary\n\t\t\tformatNumber = function(match, value, len) {\n\t\t\t\tvar num = \"\" + value;\n\t\t\t\tif (lookAhead(match)) {\n\t\t\t\t\twhile (num.length < len) {\n\t\t\t\t\t\tnum = \"0\" + num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn num;\n\t\t\t},\n\t\t\t// Format a name, short or long as requested\n\t\t\tformatName = function(match, value, shortNames, longNames) {\n\t\t\t\treturn (lookAhead(match) ? longNames[value] : shortNames[value]);\n\t\t\t},\n\t\t\toutput = \"\",\n\t\t\tliteral = false;\n\n\t\tif (date) {\n\t\t\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\n\t\t\t\tif (literal) {\n\t\t\t\t\tif (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n\t\t\t\t\t\tliteral = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput += format.charAt(iFormat);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (format.charAt(iFormat)) {\n\t\t\t\t\t\tcase \"d\":\n\t\t\t\t\t\t\toutput += formatNumber(\"d\", date.getDate(), 2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"D\":\n\t\t\t\t\t\t\toutput += formatName(\"D\", date.getDay(), dayNamesShort, dayNames);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"o\":\n\t\t\t\t\t\t\toutput += formatNumber(\"o\",\n\t\t\t\t\t\t\t\tMath.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"m\":\n\t\t\t\t\t\t\toutput += formatNumber(\"m\", date.getMonth() + 1, 2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"M\":\n\t\t\t\t\t\t\toutput += formatName(\"M\", date.getMonth(), monthNamesShort, monthNames);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"y\":\n\t\t\t\t\t\t\toutput += (lookAhead(\"y\") ? date.getFullYear() :\n\t\t\t\t\t\t\t\t(date.getYear() % 100 < 10 ? \"0\" : \"\") + date.getYear() % 100);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"@\":\n\t\t\t\t\t\t\toutput += date.getTime();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"!\":\n\t\t\t\t\t\t\toutput += date.getTime() * 10000 + this._ticksTo1970;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"'\":\n\t\t\t\t\t\t\tif (lookAhead(\"'\")) {\n\t\t\t\t\t\t\t\toutput += \"'\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tliteral = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\toutput += format.charAt(iFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t},\n\n\t/* Extract all possible characters from the date format. */\n\t_possibleChars: function (format) {\n\t\tvar iFormat,\n\t\t\tchars = \"\",\n\t\t\tliteral = false,\n\t\t\t// Check whether a format character is doubled\n\t\t\tlookAhead = function(match) {\n\t\t\t\tvar matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\n\t\t\t\tif (matches) {\n\t\t\t\t\tiFormat++;\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t};\n\n\t\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\n\t\t\tif (literal) {\n\t\t\t\tif (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n\t\t\t\t\tliteral = false;\n\t\t\t\t} else {\n\t\t\t\t\tchars += format.charAt(iFormat);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (format.charAt(iFormat)) {\n\t\t\t\t\tcase \"d\": case \"m\": case \"y\": case \"@\":\n\t\t\t\t\t\tchars += \"0123456789\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"D\": case \"M\":\n\t\t\t\t\t\treturn null; // Accept anything\n\t\t\t\t\tcase \"'\":\n\t\t\t\t\t\tif (lookAhead(\"'\")) {\n\t\t\t\t\t\t\tchars += \"'\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tliteral = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tchars += format.charAt(iFormat);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn chars;\n\t},\n\n\t/* Get a setting value, defaulting if necessary. */\n\t_get: function(inst, name) {\n\t\treturn inst.settings[name] !== undefined ?\n\t\t\tinst.settings[name] : this._defaults[name];\n\t},\n\n\t/* Parse existing date and initialise date picker. */\n\t_setDateFromField: function(inst, noDefault) {\n\t\tif (inst.input.val() === inst.lastVal) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar dateFormat = this._get(inst, \"dateFormat\"),\n\t\t\tdates = inst.lastVal = inst.input ? inst.input.val() : null,\n\t\t\tdefaultDate = this._getDefaultDate(inst),\n\t\t\tdate = defaultDate,\n\t\t\tsettings = this._getFormatConfig(inst);\n\n\t\ttry {\n\t\t\tdate = this.parseDate(dateFormat, dates, settings) || defaultDate;\n\t\t} catch (event) {\n\t\t\tdates = (noDefault ? \"\" : dates);\n\t\t}\n\t\tinst.selectedDay = date.getDate();\n\t\tinst.drawMonth = inst.selectedMonth = date.getMonth();\n\t\tinst.drawYear = inst.selectedYear = date.getFullYear();\n\t\tinst.currentDay = (dates ? date.getDate() : 0);\n\t\tinst.currentMonth = (dates ? date.getMonth() : 0);\n\t\tinst.currentYear = (dates ? date.getFullYear() : 0);\n\t\tthis._adjustInstDate(inst);\n\t},\n\n\t/* Retrieve the default date shown on opening. */\n\t_getDefaultDate: function(inst) {\n\t\treturn this._restrictMinMax(inst,\n\t\t\tthis._determineDate(inst, this._get(inst, \"defaultDate\"), new Date()));\n\t},\n\n\t/* A date may be specified as an exact value or a relative one. */\n\t_determineDate: function(inst, date, defaultDate) {\n\t\tvar offsetNumeric = function(offset) {\n\t\t\t\tvar date = new Date();\n\t\t\t\tdate.setDate(date.getDate() + offset);\n\t\t\t\treturn date;\n\t\t\t},\n\t\t\toffsetString = function(offset) {\n\t\t\t\ttry {\n\t\t\t\t\treturn $.datepicker.parseDate($.datepicker._get(inst, \"dateFormat\"),\n\t\t\t\t\t\toffset, $.datepicker._getFormatConfig(inst));\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\n\t\t\t\tvar date = (offset.toLowerCase().match(/^c/) ?\n\t\t\t\t\t$.datepicker._getDate(inst) : null) || new Date(),\n\t\t\t\t\tyear = date.getFullYear(),\n\t\t\t\t\tmonth = date.getMonth(),\n\t\t\t\t\tday = date.getDate(),\n\t\t\t\t\tpattern = /([+\\-]?[0-9]+)\\s*(d|D|w|W|m|M|y|Y)?/g,\n\t\t\t\t\tmatches = pattern.exec(offset);\n\n\t\t\t\twhile (matches) {\n\t\t\t\t\tswitch (matches[2] || \"d\") {\n\t\t\t\t\t\tcase \"d\" : case \"D\" :\n\t\t\t\t\t\t\tday += parseInt(matches[1],10); break;\n\t\t\t\t\t\tcase \"w\" : case \"W\" :\n\t\t\t\t\t\t\tday += parseInt(matches[1],10) * 7; break;\n\t\t\t\t\t\tcase \"m\" : case \"M\" :\n\t\t\t\t\t\t\tmonth += parseInt(matches[1],10);\n\t\t\t\t\t\t\tday = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"y\": case \"Y\" :\n\t\t\t\t\t\t\tyear += parseInt(matches[1],10);\n\t\t\t\t\t\t\tday = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmatches = pattern.exec(offset);\n\t\t\t\t}\n\t\t\t\treturn new Date(year, month, day);\n\t\t\t},\n\t\t\tnewDate = (date == null || date === \"\" ? defaultDate : (typeof date === \"string\" ? offsetString(date) :\n\t\t\t\t(typeof date === \"number\" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));\n\n\t\tnewDate = (newDate && newDate.toString() === \"Invalid Date\" ? defaultDate : newDate);\n\t\tif (newDate) {\n\t\t\tnewDate.setHours(0);\n\t\t\tnewDate.setMinutes(0);\n\t\t\tnewDate.setSeconds(0);\n\t\t\tnewDate.setMilliseconds(0);\n\t\t}\n\t\treturn this._daylightSavingAdjust(newDate);\n\t},\n\n\t/* Handle switch to/from daylight saving.\n\t * Hours may be non-zero on daylight saving cut-over:\n\t * > 12 when midnight changeover, but then cannot generate\n\t * midnight datetime, so jump to 1AM, otherwise reset.\n\t * @param  date  (Date) the date to check\n\t * @return  (Date) the corrected date\n\t */\n\t_daylightSavingAdjust: function(date) {\n\t\tif (!date) {\n\t\t\treturn null;\n\t\t}\n\t\tdate.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n\t\treturn date;\n\t},\n\n\t/* Set the date(s) directly. */\n\t_setDate: function(inst, date, noChange) {\n\t\tvar clear = !date,\n\t\t\torigMonth = inst.selectedMonth,\n\t\t\torigYear = inst.selectedYear,\n\t\t\tnewDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));\n\n\t\tinst.selectedDay = inst.currentDay = newDate.getDate();\n\t\tinst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();\n\t\tinst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();\n\t\tif ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {\n\t\t\tthis._notifyChange(inst);\n\t\t}\n\t\tthis._adjustInstDate(inst);\n\t\tif (inst.input) {\n\t\t\tinst.input.val(clear ? \"\" : this._formatDate(inst));\n\t\t}\n\t},\n\n\t/* Retrieve the date(s) directly. */\n\t_getDate: function(inst) {\n\t\tvar startDate = (!inst.currentYear || (inst.input && inst.input.val() === \"\") ? null :\n\t\t\tthis._daylightSavingAdjust(new Date(\n\t\t\tinst.currentYear, inst.currentMonth, inst.currentDay)));\n\t\t\treturn startDate;\n\t},\n\n\t/* Attach the onxxx handlers.  These are declared statically so\n\t * they work with static code transformers like Caja.\n\t */\n\t_attachHandlers: function(inst) {\n\t\tvar stepMonths = this._get(inst, \"stepMonths\"),\n\t\t\tid = \"#\" + inst.id.replace( /\\\\\\\\/g, \"\\\\\" );\n\t\tinst.dpDiv.find(\"[data-handler]\").map(function () {\n\t\t\tvar handler = {\n\t\t\t\tprev: function () {\n\t\t\t\t\t$.datepicker._adjustDate(id, -stepMonths, \"M\");\n\t\t\t\t},\n\t\t\t\tnext: function () {\n\t\t\t\t\t$.datepicker._adjustDate(id, +stepMonths, \"M\");\n\t\t\t\t},\n\t\t\t\thide: function () {\n\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t},\n\t\t\t\ttoday: function () {\n\t\t\t\t\t$.datepicker._gotoToday(id);\n\t\t\t\t},\n\t\t\t\tselectDay: function () {\n\t\t\t\t\t$.datepicker._selectDay(id, +this.getAttribute(\"data-month\"), +this.getAttribute(\"data-year\"), this);\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tselectMonth: function () {\n\t\t\t\t\t$.datepicker._selectMonthYear(id, this, \"M\");\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tselectYear: function () {\n\t\t\t\t\t$.datepicker._selectMonthYear(id, this, \"Y\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t};\n\t\t\t$(this).bind(this.getAttribute(\"data-event\"), handler[this.getAttribute(\"data-handler\")]);\n\t\t});\n\t},\n\n\t/* Generate the HTML for the current state of the date picker. */\n\t_generateHTML: function(inst) {\n\t\tvar maxDraw, prevText, prev, nextText, next, currentText, gotoDate,\n\t\t\tcontrols, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,\n\t\t\tmonthNames, monthNamesShort, beforeShowDay, showOtherMonths,\n\t\t\tselectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,\n\t\t\tcornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,\n\t\t\tprintDate, dRow, tbody, daySettings, otherMonth, unselectable,\n\t\t\ttempDate = new Date(),\n\t\t\ttoday = this._daylightSavingAdjust(\n\t\t\t\tnew Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time\n\t\t\tisRTL = this._get(inst, \"isRTL\"),\n\t\t\tshowButtonPanel = this._get(inst, \"showButtonPanel\"),\n\t\t\thideIfNoPrevNext = this._get(inst, \"hideIfNoPrevNext\"),\n\t\t\tnavigationAsDateFormat = this._get(inst, \"navigationAsDateFormat\"),\n\t\t\tnumMonths = this._getNumberOfMonths(inst),\n\t\t\tshowCurrentAtPos = this._get(inst, \"showCurrentAtPos\"),\n\t\t\tstepMonths = this._get(inst, \"stepMonths\"),\n\t\t\tisMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),\n\t\t\tcurrentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :\n\t\t\t\tnew Date(inst.currentYear, inst.currentMonth, inst.currentDay))),\n\t\t\tminDate = this._getMinMaxDate(inst, \"min\"),\n\t\t\tmaxDate = this._getMinMaxDate(inst, \"max\"),\n\t\t\tdrawMonth = inst.drawMonth - showCurrentAtPos,\n\t\t\tdrawYear = inst.drawYear;\n\n\t\tif (drawMonth < 0) {\n\t\t\tdrawMonth += 12;\n\t\t\tdrawYear--;\n\t\t}\n\t\tif (maxDate) {\n\t\t\tmaxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),\n\t\t\t\tmaxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));\n\t\t\tmaxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);\n\t\t\twhile (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {\n\t\t\t\tdrawMonth--;\n\t\t\t\tif (drawMonth < 0) {\n\t\t\t\t\tdrawMonth = 11;\n\t\t\t\t\tdrawYear--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinst.drawMonth = drawMonth;\n\t\tinst.drawYear = drawYear;\n\n\t\tprevText = this._get(inst, \"prevText\");\n\t\tprevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,\n\t\t\tthis._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),\n\t\t\tthis._getFormatConfig(inst)));\n\n\t\tprev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?\n\t\t\t\"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'\" +\n\t\t\t\" title='\" + prevText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + ( isRTL ? \"e\" : \"w\") + \"'>\" + prevText + \"</span></a>\" :\n\t\t\t(hideIfNoPrevNext ? \"\" : \"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='\"+ prevText +\"'><span class='ui-icon ui-icon-circle-triangle-\" + ( isRTL ? \"e\" : \"w\") + \"'>\" + prevText + \"</span></a>\"));\n\n\t\tnextText = this._get(inst, \"nextText\");\n\t\tnextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,\n\t\t\tthis._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),\n\t\t\tthis._getFormatConfig(inst)));\n\n\t\tnext = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?\n\t\t\t\"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'\" +\n\t\t\t\" title='\" + nextText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + ( isRTL ? \"w\" : \"e\") + \"'>\" + nextText + \"</span></a>\" :\n\t\t\t(hideIfNoPrevNext ? \"\" : \"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='\"+ nextText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + ( isRTL ? \"w\" : \"e\") + \"'>\" + nextText + \"</span></a>\"));\n\n\t\tcurrentText = this._get(inst, \"currentText\");\n\t\tgotoDate = (this._get(inst, \"gotoCurrent\") && inst.currentDay ? currentDate : today);\n\t\tcurrentText = (!navigationAsDateFormat ? currentText :\n\t\t\tthis.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));\n\n\t\tcontrols = (!inst.inline ? \"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>\" +\n\t\t\tthis._get(inst, \"closeText\") + \"</button>\" : \"\");\n\n\t\tbuttonPanel = (showButtonPanel) ? \"<div class='ui-datepicker-buttonpane ui-widget-content'>\" + (isRTL ? controls : \"\") +\n\t\t\t(this._isInRange(inst, gotoDate) ? \"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'\" +\n\t\t\t\">\" + currentText + \"</button>\" : \"\") + (isRTL ? \"\" : controls) + \"</div>\" : \"\";\n\n\t\tfirstDay = parseInt(this._get(inst, \"firstDay\"),10);\n\t\tfirstDay = (isNaN(firstDay) ? 0 : firstDay);\n\n\t\tshowWeek = this._get(inst, \"showWeek\");\n\t\tdayNames = this._get(inst, \"dayNames\");\n\t\tdayNamesMin = this._get(inst, \"dayNamesMin\");\n\t\tmonthNames = this._get(inst, \"monthNames\");\n\t\tmonthNamesShort = this._get(inst, \"monthNamesShort\");\n\t\tbeforeShowDay = this._get(inst, \"beforeShowDay\");\n\t\tshowOtherMonths = this._get(inst, \"showOtherMonths\");\n\t\tselectOtherMonths = this._get(inst, \"selectOtherMonths\");\n\t\tdefaultDate = this._getDefaultDate(inst);\n\t\thtml = \"\";\n\t\tdow;\n\t\tfor (row = 0; row < numMonths[0]; row++) {\n\t\t\tgroup = \"\";\n\t\t\tthis.maxRows = 4;\n\t\t\tfor (col = 0; col < numMonths[1]; col++) {\n\t\t\t\tselectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));\n\t\t\t\tcornerClass = \" ui-corner-all\";\n\t\t\t\tcalender = \"\";\n\t\t\t\tif (isMultiMonth) {\n\t\t\t\t\tcalender += \"<div class='ui-datepicker-group\";\n\t\t\t\t\tif (numMonths[1] > 1) {\n\t\t\t\t\t\tswitch (col) {\n\t\t\t\t\t\t\tcase 0: calender += \" ui-datepicker-group-first\";\n\t\t\t\t\t\t\t\tcornerClass = \" ui-corner-\" + (isRTL ? \"right\" : \"left\"); break;\n\t\t\t\t\t\t\tcase numMonths[1]-1: calender += \" ui-datepicker-group-last\";\n\t\t\t\t\t\t\t\tcornerClass = \" ui-corner-\" + (isRTL ? \"left\" : \"right\"); break;\n\t\t\t\t\t\t\tdefault: calender += \" ui-datepicker-group-middle\"; cornerClass = \"\"; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcalender += \"'>\";\n\t\t\t\t}\n\t\t\t\tcalender += \"<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix\" + cornerClass + \"'>\" +\n\t\t\t\t\t(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : \"\") +\n\t\t\t\t\t(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : \"\") +\n\t\t\t\t\tthis._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,\n\t\t\t\t\trow > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers\n\t\t\t\t\t\"</div><table class='ui-datepicker-calendar'><thead>\" +\n\t\t\t\t\t\"<tr>\";\n\t\t\t\tthead = (showWeek ? \"<th class='ui-datepicker-week-col'>\" + this._get(inst, \"weekHeader\") + \"</th>\" : \"\");\n\t\t\t\tfor (dow = 0; dow < 7; dow++) { // days of the week\n\t\t\t\t\tday = (dow + firstDay) % 7;\n\t\t\t\t\tthead += \"<th\" + ((dow + firstDay + 6) % 7 >= 5 ? \" class='ui-datepicker-week-end'\" : \"\") + \">\" +\n\t\t\t\t\t\t\"<span title='\" + dayNames[day] + \"'>\" + dayNamesMin[day] + \"</span></th>\";\n\t\t\t\t}\n\t\t\t\tcalender += thead + \"</tr></thead><tbody>\";\n\t\t\t\tdaysInMonth = this._getDaysInMonth(drawYear, drawMonth);\n\t\t\t\tif (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {\n\t\t\t\t\tinst.selectedDay = Math.min(inst.selectedDay, daysInMonth);\n\t\t\t\t}\n\t\t\t\tleadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;\n\t\t\t\tcurRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate\n\t\t\t\tnumRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)\n\t\t\t\tthis.maxRows = numRows;\n\t\t\t\tprintDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));\n\t\t\t\tfor (dRow = 0; dRow < numRows; dRow++) { // create date picker rows\n\t\t\t\t\tcalender += \"<tr>\";\n\t\t\t\t\ttbody = (!showWeek ? \"\" : \"<td class='ui-datepicker-week-col'>\" +\n\t\t\t\t\t\tthis._get(inst, \"calculateWeek\")(printDate) + \"</td>\");\n\t\t\t\t\tfor (dow = 0; dow < 7; dow++) { // create date picker days\n\t\t\t\t\t\tdaySettings = (beforeShowDay ?\n\t\t\t\t\t\t\tbeforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, \"\"]);\n\t\t\t\t\t\totherMonth = (printDate.getMonth() !== drawMonth);\n\t\t\t\t\t\tunselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||\n\t\t\t\t\t\t\t(minDate && printDate < minDate) || (maxDate && printDate > maxDate);\n\t\t\t\t\t\ttbody += \"<td class='\" +\n\t\t\t\t\t\t\t((dow + firstDay + 6) % 7 >= 5 ? \" ui-datepicker-week-end\" : \"\") + // highlight weekends\n\t\t\t\t\t\t\t(otherMonth ? \" ui-datepicker-other-month\" : \"\") + // highlight days from other months\n\t\t\t\t\t\t\t((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key\n\t\t\t\t\t\t\t(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?\n\t\t\t\t\t\t\t// or defaultDate is current printedDate and defaultDate is selectedDate\n\t\t\t\t\t\t\t\" \" + this._dayOverClass : \"\") + // highlight selected day\n\t\t\t\t\t\t\t(unselectable ? \" \" + this._unselectableClass + \" ui-state-disabled\": \"\") +  // highlight unselectable days\n\t\t\t\t\t\t\t(otherMonth && !showOtherMonths ? \"\" : \" \" + daySettings[1] + // highlight custom dates\n\t\t\t\t\t\t\t(printDate.getTime() === currentDate.getTime() ? \" \" + this._currentClass : \"\") + // highlight selected day\n\t\t\t\t\t\t\t(printDate.getTime() === today.getTime() ? \" ui-datepicker-today\" : \"\")) + \"'\" + // highlight today (if different)\n\t\t\t\t\t\t\t((!otherMonth || showOtherMonths) && daySettings[2] ? \" title='\" + daySettings[2].replace(/'/g, \"&#39;\") + \"'\" : \"\") + // cell title\n\t\t\t\t\t\t\t(unselectable ? \"\" : \" data-handler='selectDay' data-event='click' data-month='\" + printDate.getMonth() + \"' data-year='\" + printDate.getFullYear() + \"'\") + \">\" + // actions\n\t\t\t\t\t\t\t(otherMonth && !showOtherMonths ? \"&#xa0;\" : // display for other months\n\t\t\t\t\t\t\t(unselectable ? \"<span class='ui-state-default'>\" + printDate.getDate() + \"</span>\" : \"<a class='ui-state-default\" +\n\t\t\t\t\t\t\t(printDate.getTime() === today.getTime() ? \" ui-state-highlight\" : \"\") +\n\t\t\t\t\t\t\t(printDate.getTime() === currentDate.getTime() ? \" ui-state-active\" : \"\") + // highlight selected day\n\t\t\t\t\t\t\t(otherMonth ? \" ui-priority-secondary\" : \"\") + // distinguish dates from other months\n\t\t\t\t\t\t\t\"' href='#'>\" + printDate.getDate() + \"</a>\")) + \"</td>\"; // display selectable date\n\t\t\t\t\t\tprintDate.setDate(printDate.getDate() + 1);\n\t\t\t\t\t\tprintDate = this._daylightSavingAdjust(printDate);\n\t\t\t\t\t}\n\t\t\t\t\tcalender += tbody + \"</tr>\";\n\t\t\t\t}\n\t\t\t\tdrawMonth++;\n\t\t\t\tif (drawMonth > 11) {\n\t\t\t\t\tdrawMonth = 0;\n\t\t\t\t\tdrawYear++;\n\t\t\t\t}\n\t\t\t\tcalender += \"</tbody></table>\" + (isMultiMonth ? \"</div>\" +\n\t\t\t\t\t\t\t((numMonths[0] > 0 && col === numMonths[1]-1) ? \"<div class='ui-datepicker-row-break'></div>\" : \"\") : \"\");\n\t\t\t\tgroup += calender;\n\t\t\t}\n\t\t\thtml += group;\n\t\t}\n\t\thtml += buttonPanel;\n\t\tinst._keyEvent = false;\n\t\treturn html;\n\t},\n\n\t/* Generate the month and year header. */\n\t_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,\n\t\t\tsecondary, monthNames, monthNamesShort) {\n\n\t\tvar inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,\n\t\t\tchangeMonth = this._get(inst, \"changeMonth\"),\n\t\t\tchangeYear = this._get(inst, \"changeYear\"),\n\t\t\tshowMonthAfterYear = this._get(inst, \"showMonthAfterYear\"),\n\t\t\thtml = \"<div class='ui-datepicker-title'>\",\n\t\t\tmonthHtml = \"\";\n\n\t\t// month selection\n\t\tif (secondary || !changeMonth) {\n\t\t\tmonthHtml += \"<span class='ui-datepicker-month'>\" + monthNames[drawMonth] + \"</span>\";\n\t\t} else {\n\t\t\tinMinYear = (minDate && minDate.getFullYear() === drawYear);\n\t\t\tinMaxYear = (maxDate && maxDate.getFullYear() === drawYear);\n\t\t\tmonthHtml += \"<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>\";\n\t\t\tfor ( month = 0; month < 12; month++) {\n\t\t\t\tif ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {\n\t\t\t\t\tmonthHtml += \"<option value='\" + month + \"'\" +\n\t\t\t\t\t\t(month === drawMonth ? \" selected='selected'\" : \"\") +\n\t\t\t\t\t\t\">\" + monthNamesShort[month] + \"</option>\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tmonthHtml += \"</select>\";\n\t\t}\n\n\t\tif (!showMonthAfterYear) {\n\t\t\thtml += monthHtml + (secondary || !(changeMonth && changeYear) ? \"&#xa0;\" : \"\");\n\t\t}\n\n\t\t// year selection\n\t\tif ( !inst.yearshtml ) {\n\t\t\tinst.yearshtml = \"\";\n\t\t\tif (secondary || !changeYear) {\n\t\t\t\thtml += \"<span class='ui-datepicker-year'>\" + drawYear + \"</span>\";\n\t\t\t} else {\n\t\t\t\t// determine range of years to display\n\t\t\t\tyears = this._get(inst, \"yearRange\").split(\":\");\n\t\t\t\tthisYear = new Date().getFullYear();\n\t\t\t\tdetermineYear = function(value) {\n\t\t\t\t\tvar year = (value.match(/c[+\\-].*/) ? drawYear + parseInt(value.substring(1), 10) :\n\t\t\t\t\t\t(value.match(/[+\\-].*/) ? thisYear + parseInt(value, 10) :\n\t\t\t\t\t\tparseInt(value, 10)));\n\t\t\t\t\treturn (isNaN(year) ? thisYear : year);\n\t\t\t\t};\n\t\t\t\tyear = determineYear(years[0]);\n\t\t\t\tendYear = Math.max(year, determineYear(years[1] || \"\"));\n\t\t\t\tyear = (minDate ? Math.max(year, minDate.getFullYear()) : year);\n\t\t\t\tendYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);\n\t\t\t\tinst.yearshtml += \"<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>\";\n\t\t\t\tfor (; year <= endYear; year++) {\n\t\t\t\t\tinst.yearshtml += \"<option value='\" + year + \"'\" +\n\t\t\t\t\t\t(year === drawYear ? \" selected='selected'\" : \"\") +\n\t\t\t\t\t\t\">\" + year + \"</option>\";\n\t\t\t\t}\n\t\t\t\tinst.yearshtml += \"</select>\";\n\n\t\t\t\thtml += inst.yearshtml;\n\t\t\t\tinst.yearshtml = null;\n\t\t\t}\n\t\t}\n\n\t\thtml += this._get(inst, \"yearSuffix\");\n\t\tif (showMonthAfterYear) {\n\t\t\thtml += (secondary || !(changeMonth && changeYear) ? \"&#xa0;\" : \"\") + monthHtml;\n\t\t}\n\t\thtml += \"</div>\"; // Close datepicker_header\n\t\treturn html;\n\t},\n\n\t/* Adjust one of the date sub-fields. */\n\t_adjustInstDate: function(inst, offset, period) {\n\t\tvar year = inst.drawYear + (period === \"Y\" ? offset : 0),\n\t\t\tmonth = inst.drawMonth + (period === \"M\" ? offset : 0),\n\t\t\tday = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === \"D\" ? offset : 0),\n\t\t\tdate = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));\n\n\t\tinst.selectedDay = date.getDate();\n\t\tinst.drawMonth = inst.selectedMonth = date.getMonth();\n\t\tinst.drawYear = inst.selectedYear = date.getFullYear();\n\t\tif (period === \"M\" || period === \"Y\") {\n\t\t\tthis._notifyChange(inst);\n\t\t}\n\t},\n\n\t/* Ensure a date is within any min/max bounds. */\n\t_restrictMinMax: function(inst, date) {\n\t\tvar minDate = this._getMinMaxDate(inst, \"min\"),\n\t\t\tmaxDate = this._getMinMaxDate(inst, \"max\"),\n\t\t\tnewDate = (minDate && date < minDate ? minDate : date);\n\t\treturn (maxDate && newDate > maxDate ? maxDate : newDate);\n\t},\n\n\t/* Notify change of month/year. */\n\t_notifyChange: function(inst) {\n\t\tvar onChange = this._get(inst, \"onChangeMonthYear\");\n\t\tif (onChange) {\n\t\t\tonChange.apply((inst.input ? inst.input[0] : null),\n\t\t\t\t[inst.selectedYear, inst.selectedMonth + 1, inst]);\n\t\t}\n\t},\n\n\t/* Determine the number of months to show. */\n\t_getNumberOfMonths: function(inst) {\n\t\tvar numMonths = this._get(inst, \"numberOfMonths\");\n\t\treturn (numMonths == null ? [1, 1] : (typeof numMonths === \"number\" ? [1, numMonths] : numMonths));\n\t},\n\n\t/* Determine the current maximum date - ensure no time components are set. */\n\t_getMinMaxDate: function(inst, minMax) {\n\t\treturn this._determineDate(inst, this._get(inst, minMax + \"Date\"), null);\n\t},\n\n\t/* Find the number of days in a given month. */\n\t_getDaysInMonth: function(year, month) {\n\t\treturn 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();\n\t},\n\n\t/* Find the day of the week of the first of a month. */\n\t_getFirstDayOfMonth: function(year, month) {\n\t\treturn new Date(year, month, 1).getDay();\n\t},\n\n\t/* Determines if we should allow a \"next/prev\" month display change. */\n\t_canAdjustMonth: function(inst, offset, curYear, curMonth) {\n\t\tvar numMonths = this._getNumberOfMonths(inst),\n\t\t\tdate = this._daylightSavingAdjust(new Date(curYear,\n\t\t\tcurMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));\n\n\t\tif (offset < 0) {\n\t\t\tdate.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));\n\t\t}\n\t\treturn this._isInRange(inst, date);\n\t},\n\n\t/* Is the given date in the accepted range? */\n\t_isInRange: function(inst, date) {\n\t\tvar yearSplit, currentYear,\n\t\t\tminDate = this._getMinMaxDate(inst, \"min\"),\n\t\t\tmaxDate = this._getMinMaxDate(inst, \"max\"),\n\t\t\tminYear = null,\n\t\t\tmaxYear = null,\n\t\t\tyears = this._get(inst, \"yearRange\");\n\t\t\tif (years){\n\t\t\t\tyearSplit = years.split(\":\");\n\t\t\t\tcurrentYear = new Date().getFullYear();\n\t\t\t\tminYear = parseInt(yearSplit[0], 10);\n\t\t\t\tmaxYear = parseInt(yearSplit[1], 10);\n\t\t\t\tif ( yearSplit[0].match(/[+\\-].*/) ) {\n\t\t\t\t\tminYear += currentYear;\n\t\t\t\t}\n\t\t\t\tif ( yearSplit[1].match(/[+\\-].*/) ) {\n\t\t\t\t\tmaxYear += currentYear;\n\t\t\t\t}\n\t\t\t}\n\n\t\treturn ((!minDate || date.getTime() >= minDate.getTime()) &&\n\t\t\t(!maxDate || date.getTime() <= maxDate.getTime()) &&\n\t\t\t(!minYear || date.getFullYear() >= minYear) &&\n\t\t\t(!maxYear || date.getFullYear() <= maxYear));\n\t},\n\n\t/* Provide the configuration settings for formatting/parsing. */\n\t_getFormatConfig: function(inst) {\n\t\tvar shortYearCutoff = this._get(inst, \"shortYearCutoff\");\n\t\tshortYearCutoff = (typeof shortYearCutoff !== \"string\" ? shortYearCutoff :\n\t\t\tnew Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));\n\t\treturn {shortYearCutoff: shortYearCutoff,\n\t\t\tdayNamesShort: this._get(inst, \"dayNamesShort\"), dayNames: this._get(inst, \"dayNames\"),\n\t\t\tmonthNamesShort: this._get(inst, \"monthNamesShort\"), monthNames: this._get(inst, \"monthNames\")};\n\t},\n\n\t/* Format the given date for display. */\n\t_formatDate: function(inst, day, month, year) {\n\t\tif (!day) {\n\t\t\tinst.currentDay = inst.selectedDay;\n\t\t\tinst.currentMonth = inst.selectedMonth;\n\t\t\tinst.currentYear = inst.selectedYear;\n\t\t}\n\t\tvar date = (day ? (typeof day === \"object\" ? day :\n\t\t\tthis._daylightSavingAdjust(new Date(year, month, day))) :\n\t\t\tthis._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));\n\t\treturn this.formatDate(this._get(inst, \"dateFormat\"), date, this._getFormatConfig(inst));\n\t}\n});\n\n/*\n * Bind hover events for datepicker elements.\n * Done via delegate so the binding only occurs once in the lifetime of the parent div.\n * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.\n */\nfunction bindHover(dpDiv) {\n\tvar selector = \"button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a\";\n\treturn dpDiv.delegate(selector, \"mouseout\", function() {\n\t\t\t$(this).removeClass(\"ui-state-hover\");\n\t\t\tif (this.className.indexOf(\"ui-datepicker-prev\") !== -1) {\n\t\t\t\t$(this).removeClass(\"ui-datepicker-prev-hover\");\n\t\t\t}\n\t\t\tif (this.className.indexOf(\"ui-datepicker-next\") !== -1) {\n\t\t\t\t$(this).removeClass(\"ui-datepicker-next-hover\");\n\t\t\t}\n\t\t})\n\t\t.delegate(selector, \"mouseover\", function(){\n\t\t\tif (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {\n\t\t\t\t$(this).parents(\".ui-datepicker-calendar\").find(\"a\").removeClass(\"ui-state-hover\");\n\t\t\t\t$(this).addClass(\"ui-state-hover\");\n\t\t\t\tif (this.className.indexOf(\"ui-datepicker-prev\") !== -1) {\n\t\t\t\t\t$(this).addClass(\"ui-datepicker-prev-hover\");\n\t\t\t\t}\n\t\t\t\tif (this.className.indexOf(\"ui-datepicker-next\") !== -1) {\n\t\t\t\t\t$(this).addClass(\"ui-datepicker-next-hover\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n}\n\n/* jQuery extend now ignores nulls! */\nfunction extendRemove(target, props) {\n\t$.extend(target, props);\n\tfor (var name in props) {\n\t\tif (props[name] == null) {\n\t\t\ttarget[name] = props[name];\n\t\t}\n\t}\n\treturn target;\n}\n\n/* Invoke the datepicker functionality.\n   @param  options  string - a command, optionally followed by additional parameters or\n\t\t\t\t\tObject - settings for attaching new datepicker functionality\n   @return  jQuery object */\n$.fn.datepicker = function(options){\n\n\t/* Verify an empty collection wasn't passed - Fixes #6976 */\n\tif ( !this.length ) {\n\t\treturn this;\n\t}\n\n\t/* Initialise the date picker. */\n\tif (!$.datepicker.initialized) {\n\t\t$(document).mousedown($.datepicker._checkExternalClick);\n\t\t$.datepicker.initialized = true;\n\t}\n\n\t/* Append datepicker main container to body if not exist. */\n\tif ($(\"#\"+$.datepicker._mainDivId).length === 0) {\n\t\t$(\"body\").append($.datepicker.dpDiv);\n\t}\n\n\tvar otherArgs = Array.prototype.slice.call(arguments, 1);\n\tif (typeof options === \"string\" && (options === \"isDisabled\" || options === \"getDate\" || options === \"widget\")) {\n\t\treturn $.datepicker[\"_\" + options + \"Datepicker\"].\n\t\t\tapply($.datepicker, [this[0]].concat(otherArgs));\n\t}\n\tif (options === \"option\" && arguments.length === 2 && typeof arguments[1] === \"string\") {\n\t\treturn $.datepicker[\"_\" + options + \"Datepicker\"].\n\t\t\tapply($.datepicker, [this[0]].concat(otherArgs));\n\t}\n\treturn this.each(function() {\n\t\ttypeof options === \"string\" ?\n\t\t\t$.datepicker[\"_\" + options + \"Datepicker\"].\n\t\t\t\tapply($.datepicker, [this].concat(otherArgs)) :\n\t\t\t$.datepicker._attachDatepicker(this, options);\n\t});\n};\n\n$.datepicker = new Datepicker(); // singleton instance\n$.datepicker.initialized = false;\n$.datepicker.uuid = new Date().getTime();\n$.datepicker.version = \"1.10.4\";\n\n})(jQuery);\n","var jQuery = require('jquery');\nrequire('./core');\nrequire('./widget');\nrequire('./position');\n\n/*!\n * jQuery UI Menu 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/menu/\n *\n * Depends:\n *\tjquery.ui.core.js\n *\tjquery.ui.widget.js\n *\tjquery.ui.position.js\n */\n(function( $, undefined ) {\n\n$.widget( \"ui.menu\", {\n\tversion: \"1.10.4\",\n\tdefaultElement: \"<ul>\",\n\tdelay: 300,\n\toptions: {\n\t\ticons: {\n\t\t\tsubmenu: \"ui-icon-carat-1-e\"\n\t\t},\n\t\tmenus: \"ul\",\n\t\tposition: {\n\t\t\tmy: \"left top\",\n\t\t\tat: \"right top\"\n\t\t},\n\t\trole: \"menu\",\n\n\t\t// callbacks\n\t\tblur: null,\n\t\tfocus: null,\n\t\tselect: null\n\t},\n\n\t_create: function() {\n\t\tthis.activeMenu = this.element;\n\t\t// flag used to prevent firing of the click handler\n\t\t// as the event bubbles up through nested menus\n\t\tthis.mouseHandled = false;\n\t\tthis.element\n\t\t\t.uniqueId()\n\t\t\t.addClass( \"ui-menu ui-widget ui-widget-content ui-corner-all\" )\n\t\t\t.toggleClass( \"ui-menu-icons\", !!this.element.find( \".ui-icon\" ).length )\n\t\t\t.attr({\n\t\t\t\trole: this.options.role,\n\t\t\t\ttabIndex: 0\n\t\t\t})\n\t\t\t// need to catch all clicks on disabled menu\n\t\t\t// not possible through _on\n\t\t\t.bind( \"click\" + this.eventNamespace, $.proxy(function( event ) {\n\t\t\t\tif ( this.options.disabled ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}, this ));\n\n\t\tif ( this.options.disabled ) {\n\t\t\tthis.element\n\t\t\t\t.addClass( \"ui-state-disabled\" )\n\t\t\t\t.attr( \"aria-disabled\", \"true\" );\n\t\t}\n\n\t\tthis._on({\n\t\t\t// Prevent focus from sticking to links inside menu after clicking\n\t\t\t// them (focus should always stay on UL during navigation).\n\t\t\t\"mousedown .ui-menu-item > a\": function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t},\n\t\t\t\"click .ui-state-disabled > a\": function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t},\n\t\t\t\"click .ui-menu-item:has(a)\": function( event ) {\n\t\t\t\tvar target = $( event.target ).closest( \".ui-menu-item\" );\n\t\t\t\tif ( !this.mouseHandled && target.not( \".ui-state-disabled\" ).length ) {\n\t\t\t\t\tthis.select( event );\n\n\t\t\t\t\t// Only set the mouseHandled flag if the event will bubble, see #9469.\n\t\t\t\t\tif ( !event.isPropagationStopped() ) {\n\t\t\t\t\t\tthis.mouseHandled = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Open submenu on click\n\t\t\t\t\tif ( target.has( \".ui-menu\" ).length ) {\n\t\t\t\t\t\tthis.expand( event );\n\t\t\t\t\t} else if ( !this.element.is( \":focus\" ) && $( this.document[ 0 ].activeElement ).closest( \".ui-menu\" ).length ) {\n\n\t\t\t\t\t\t// Redirect focus to the menu\n\t\t\t\t\t\tthis.element.trigger( \"focus\", [ true ] );\n\n\t\t\t\t\t\t// If the active item is on the top level, let it stay active.\n\t\t\t\t\t\t// Otherwise, blur the active item since it is no longer visible.\n\t\t\t\t\t\tif ( this.active && this.active.parents( \".ui-menu\" ).length === 1 ) {\n\t\t\t\t\t\t\tclearTimeout( this.timer );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"mouseenter .ui-menu-item\": function( event ) {\n\t\t\t\tvar target = $( event.currentTarget );\n\t\t\t\t// Remove ui-state-active class from siblings of the newly focused menu item\n\t\t\t\t// to avoid a jump caused by adjacent elements both having a class with a border\n\t\t\t\ttarget.siblings().children( \".ui-state-active\" ).removeClass( \"ui-state-active\" );\n\t\t\t\tthis.focus( event, target );\n\t\t\t},\n\t\t\tmouseleave: \"collapseAll\",\n\t\t\t\"mouseleave .ui-menu\": \"collapseAll\",\n\t\t\tfocus: function( event, keepActiveItem ) {\n\t\t\t\t// If there's already an active item, keep it active\n\t\t\t\t// If not, activate the first item\n\t\t\t\tvar item = this.active || this.element.children( \".ui-menu-item\" ).eq( 0 );\n\n\t\t\t\tif ( !keepActiveItem ) {\n\t\t\t\t\tthis.focus( event, item );\n\t\t\t\t}\n\t\t\t},\n\t\t\tblur: function( event ) {\n\t\t\t\tthis._delay(function() {\n\t\t\t\t\tif ( !$.contains( this.element[0], this.document[0].activeElement ) ) {\n\t\t\t\t\t\tthis.collapseAll( event );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tkeydown: \"_keydown\"\n\t\t});\n\n\t\tthis.refresh();\n\n\t\t// Clicks outside of a menu collapse any open menus\n\t\tthis._on( this.document, {\n\t\t\tclick: function( event ) {\n\t\t\t\tif ( !$( event.target ).closest( \".ui-menu\" ).length ) {\n\t\t\t\t\tthis.collapseAll( event );\n\t\t\t\t}\n\n\t\t\t\t// Reset the mouseHandled flag\n\t\t\t\tthis.mouseHandled = false;\n\t\t\t}\n\t\t});\n\t},\n\n\t_destroy: function() {\n\t\t// Destroy (sub)menus\n\t\tthis.element\n\t\t\t.removeAttr( \"aria-activedescendant\" )\n\t\t\t.find( \".ui-menu\" ).addBack()\n\t\t\t\t.removeClass( \"ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons\" )\n\t\t\t\t.removeAttr( \"role\" )\n\t\t\t\t.removeAttr( \"tabIndex\" )\n\t\t\t\t.removeAttr( \"aria-labelledby\" )\n\t\t\t\t.removeAttr( \"aria-expanded\" )\n\t\t\t\t.removeAttr( \"aria-hidden\" )\n\t\t\t\t.removeAttr( \"aria-disabled\" )\n\t\t\t\t.removeUniqueId()\n\t\t\t\t.show();\n\n\t\t// Destroy menu items\n\t\tthis.element.find( \".ui-menu-item\" )\n\t\t\t.removeClass( \"ui-menu-item\" )\n\t\t\t.removeAttr( \"role\" )\n\t\t\t.removeAttr( \"aria-disabled\" )\n\t\t\t.children( \"a\" )\n\t\t\t\t.removeUniqueId()\n\t\t\t\t.removeClass( \"ui-corner-all ui-state-hover\" )\n\t\t\t\t.removeAttr( \"tabIndex\" )\n\t\t\t\t.removeAttr( \"role\" )\n\t\t\t\t.removeAttr( \"aria-haspopup\" )\n\t\t\t\t.children().each( function() {\n\t\t\t\t\tvar elem = $( this );\n\t\t\t\t\tif ( elem.data( \"ui-menu-submenu-carat\" ) ) {\n\t\t\t\t\t\telem.remove();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t// Destroy menu dividers\n\t\tthis.element.find( \".ui-menu-divider\" ).removeClass( \"ui-menu-divider ui-widget-content\" );\n\t},\n\n\t_keydown: function( event ) {\n\t\tvar match, prev, character, skip, regex,\n\t\t\tpreventDefault = true;\n\n\t\tfunction escape( value ) {\n\t\t\treturn value.replace( /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\" );\n\t\t}\n\n\t\tswitch ( event.keyCode ) {\n\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\tthis.previousPage( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\tthis.nextPage( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.HOME:\n\t\t\tthis._move( \"first\", \"first\", event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.END:\n\t\t\tthis._move( \"last\", \"last\", event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.UP:\n\t\t\tthis.previous( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.DOWN:\n\t\t\tthis.next( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.LEFT:\n\t\t\tthis.collapse( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.RIGHT:\n\t\t\tif ( this.active && !this.active.is( \".ui-state-disabled\" ) ) {\n\t\t\t\tthis.expand( event );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.ENTER:\n\t\tcase $.ui.keyCode.SPACE:\n\t\t\tthis._activate( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.ESCAPE:\n\t\t\tthis.collapse( event );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpreventDefault = false;\n\t\t\tprev = this.previousFilter || \"\";\n\t\t\tcharacter = String.fromCharCode( event.keyCode );\n\t\t\tskip = false;\n\n\t\t\tclearTimeout( this.filterTimer );\n\n\t\t\tif ( character === prev ) {\n\t\t\t\tskip = true;\n\t\t\t} else {\n\t\t\t\tcharacter = prev + character;\n\t\t\t}\n\n\t\t\tregex = new RegExp( \"^\" + escape( character ), \"i\" );\n\t\t\tmatch = this.activeMenu.children( \".ui-menu-item\" ).filter(function() {\n\t\t\t\treturn regex.test( $( this ).children( \"a\" ).text() );\n\t\t\t});\n\t\t\tmatch = skip && match.index( this.active.next() ) !== -1 ?\n\t\t\t\tthis.active.nextAll( \".ui-menu-item\" ) :\n\t\t\t\tmatch;\n\n\t\t\t// If no matches on the current filter, reset to the last character pressed\n\t\t\t// to move down the menu to the first item that starts with that character\n\t\t\tif ( !match.length ) {\n\t\t\t\tcharacter = String.fromCharCode( event.keyCode );\n\t\t\t\tregex = new RegExp( \"^\" + escape( character ), \"i\" );\n\t\t\t\tmatch = this.activeMenu.children( \".ui-menu-item\" ).filter(function() {\n\t\t\t\t\treturn regex.test( $( this ).children( \"a\" ).text() );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( match.length ) {\n\t\t\t\tthis.focus( event, match );\n\t\t\t\tif ( match.length > 1 ) {\n\t\t\t\t\tthis.previousFilter = character;\n\t\t\t\t\tthis.filterTimer = this._delay(function() {\n\t\t\t\t\t\tdelete this.previousFilter;\n\t\t\t\t\t}, 1000 );\n\t\t\t\t} else {\n\t\t\t\t\tdelete this.previousFilter;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete this.previousFilter;\n\t\t\t}\n\t\t}\n\n\t\tif ( preventDefault ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t},\n\n\t_activate: function( event ) {\n\t\tif ( !this.active.is( \".ui-state-disabled\" ) ) {\n\t\t\tif ( this.active.children( \"a[aria-haspopup='true']\" ).length ) {\n\t\t\t\tthis.expand( event );\n\t\t\t} else {\n\t\t\t\tthis.select( event );\n\t\t\t}\n\t\t}\n\t},\n\n\trefresh: function() {\n\t\tvar menus,\n\t\t\ticon = this.options.icons.submenu,\n\t\t\tsubmenus = this.element.find( this.options.menus );\n\n\t\tthis.element.toggleClass( \"ui-menu-icons\", !!this.element.find( \".ui-icon\" ).length );\n\n\t\t// Initialize nested menus\n\t\tsubmenus.filter( \":not(.ui-menu)\" )\n\t\t\t.addClass( \"ui-menu ui-widget ui-widget-content ui-corner-all\" )\n\t\t\t.hide()\n\t\t\t.attr({\n\t\t\t\trole: this.options.role,\n\t\t\t\t\"aria-hidden\": \"true\",\n\t\t\t\t\"aria-expanded\": \"false\"\n\t\t\t})\n\t\t\t.each(function() {\n\t\t\t\tvar menu = $( this ),\n\t\t\t\t\titem = menu.prev( \"a\" ),\n\t\t\t\t\tsubmenuCarat = $( \"<span>\" )\n\t\t\t\t\t\t.addClass( \"ui-menu-icon ui-icon \" + icon )\n\t\t\t\t\t\t.data( \"ui-menu-submenu-carat\", true );\n\n\t\t\t\titem\n\t\t\t\t\t.attr( \"aria-haspopup\", \"true\" )\n\t\t\t\t\t.prepend( submenuCarat );\n\t\t\t\tmenu.attr( \"aria-labelledby\", item.attr( \"id\" ) );\n\t\t\t});\n\n\t\tmenus = submenus.add( this.element );\n\n\t\t// Don't refresh list items that are already adapted\n\t\tmenus.children( \":not(.ui-menu-item):has(a)\" )\n\t\t\t.addClass( \"ui-menu-item\" )\n\t\t\t.attr( \"role\", \"presentation\" )\n\t\t\t.children( \"a\" )\n\t\t\t\t.uniqueId()\n\t\t\t\t.addClass( \"ui-corner-all\" )\n\t\t\t\t.attr({\n\t\t\t\t\ttabIndex: -1,\n\t\t\t\t\trole: this._itemRole()\n\t\t\t\t});\n\n\t\t// Initialize unlinked menu-items containing spaces and/or dashes only as dividers\n\t\tmenus.children( \":not(.ui-menu-item)\" ).each(function() {\n\t\t\tvar item = $( this );\n\t\t\t// hyphen, em dash, en dash\n\t\t\tif ( !/[^\\-\\u2014\\u2013\\s]/.test( item.text() ) ) {\n\t\t\t\titem.addClass( \"ui-widget-content ui-menu-divider\" );\n\t\t\t}\n\t\t});\n\n\t\t// Add aria-disabled attribute to any disabled menu item\n\t\tmenus.children( \".ui-state-disabled\" ).attr( \"aria-disabled\", \"true\" );\n\n\t\t// If the active item has been removed, blur the menu\n\t\tif ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {\n\t\t\tthis.blur();\n\t\t}\n\t},\n\n\t_itemRole: function() {\n\t\treturn {\n\t\t\tmenu: \"menuitem\",\n\t\t\tlistbox: \"option\"\n\t\t}[ this.options.role ];\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === \"icons\" ) {\n\t\t\tthis.element.find( \".ui-menu-icon\" )\n\t\t\t\t.removeClass( this.options.icons.submenu )\n\t\t\t\t.addClass( value.submenu );\n\t\t}\n\t\tthis._super( key, value );\n\t},\n\n\tfocus: function( event, item ) {\n\t\tvar nested, focused;\n\t\tthis.blur( event, event && event.type === \"focus\" );\n\n\t\tthis._scrollIntoView( item );\n\n\t\tthis.active = item.first();\n\t\tfocused = this.active.children( \"a\" ).addClass( \"ui-state-focus\" );\n\t\t// Only update aria-activedescendant if there's a role\n\t\t// otherwise we assume focus is managed elsewhere\n\t\tif ( this.options.role ) {\n\t\t\tthis.element.attr( \"aria-activedescendant\", focused.attr( \"id\" ) );\n\t\t}\n\n\t\t// Highlight active parent menu item, if any\n\t\tthis.active\n\t\t\t.parent()\n\t\t\t.closest( \".ui-menu-item\" )\n\t\t\t.children( \"a:first\" )\n\t\t\t.addClass( \"ui-state-active\" );\n\n\t\tif ( event && event.type === \"keydown\" ) {\n\t\t\tthis._close();\n\t\t} else {\n\t\t\tthis.timer = this._delay(function() {\n\t\t\t\tthis._close();\n\t\t\t}, this.delay );\n\t\t}\n\n\t\tnested = item.children( \".ui-menu\" );\n\t\tif ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {\n\t\t\tthis._startOpening(nested);\n\t\t}\n\t\tthis.activeMenu = item.parent();\n\n\t\tthis._trigger( \"focus\", event, { item: item } );\n\t},\n\n\t_scrollIntoView: function( item ) {\n\t\tvar borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;\n\t\tif ( this._hasScroll() ) {\n\t\t\tborderTop = parseFloat( $.css( this.activeMenu[0], \"borderTopWidth\" ) ) || 0;\n\t\t\tpaddingTop = parseFloat( $.css( this.activeMenu[0], \"paddingTop\" ) ) || 0;\n\t\t\toffset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;\n\t\t\tscroll = this.activeMenu.scrollTop();\n\t\t\telementHeight = this.activeMenu.height();\n\t\t\titemHeight = item.height();\n\n\t\t\tif ( offset < 0 ) {\n\t\t\t\tthis.activeMenu.scrollTop( scroll + offset );\n\t\t\t} else if ( offset + itemHeight > elementHeight ) {\n\t\t\t\tthis.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );\n\t\t\t}\n\t\t}\n\t},\n\n\tblur: function( event, fromFocus ) {\n\t\tif ( !fromFocus ) {\n\t\t\tclearTimeout( this.timer );\n\t\t}\n\n\t\tif ( !this.active ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.active.children( \"a\" ).removeClass( \"ui-state-focus\" );\n\t\tthis.active = null;\n\n\t\tthis._trigger( \"blur\", event, { item: this.active } );\n\t},\n\n\t_startOpening: function( submenu ) {\n\t\tclearTimeout( this.timer );\n\n\t\t// Don't open if already open fixes a Firefox bug that caused a .5 pixel\n\t\t// shift in the submenu position when mousing over the carat icon\n\t\tif ( submenu.attr( \"aria-hidden\" ) !== \"true\" ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.timer = this._delay(function() {\n\t\t\tthis._close();\n\t\t\tthis._open( submenu );\n\t\t}, this.delay );\n\t},\n\n\t_open: function( submenu ) {\n\t\tvar position = $.extend({\n\t\t\tof: this.active\n\t\t}, this.options.position );\n\n\t\tclearTimeout( this.timer );\n\t\tthis.element.find( \".ui-menu\" ).not( submenu.parents( \".ui-menu\" ) )\n\t\t\t.hide()\n\t\t\t.attr( \"aria-hidden\", \"true\" );\n\n\t\tsubmenu\n\t\t\t.show()\n\t\t\t.removeAttr( \"aria-hidden\" )\n\t\t\t.attr( \"aria-expanded\", \"true\" )\n\t\t\t.position( position );\n\t},\n\n\tcollapseAll: function( event, all ) {\n\t\tclearTimeout( this.timer );\n\t\tthis.timer = this._delay(function() {\n\t\t\t// If we were passed an event, look for the submenu that contains the event\n\t\t\tvar currentMenu = all ? this.element :\n\t\t\t\t$( event && event.target ).closest( this.element.find( \".ui-menu\" ) );\n\n\t\t\t// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway\n\t\t\tif ( !currentMenu.length ) {\n\t\t\t\tcurrentMenu = this.element;\n\t\t\t}\n\n\t\t\tthis._close( currentMenu );\n\n\t\t\tthis.blur( event );\n\t\t\tthis.activeMenu = currentMenu;\n\t\t}, this.delay );\n\t},\n\n\t// With no arguments, closes the currently active menu - if nothing is active\n\t// it closes all menus.  If passed an argument, it will search for menus BELOW\n\t_close: function( startMenu ) {\n\t\tif ( !startMenu ) {\n\t\t\tstartMenu = this.active ? this.active.parent() : this.element;\n\t\t}\n\n\t\tstartMenu\n\t\t\t.find( \".ui-menu\" )\n\t\t\t\t.hide()\n\t\t\t\t.attr( \"aria-hidden\", \"true\" )\n\t\t\t\t.attr( \"aria-expanded\", \"false\" )\n\t\t\t.end()\n\t\t\t.find( \"a.ui-state-active\" )\n\t\t\t\t.removeClass( \"ui-state-active\" );\n\t},\n\n\tcollapse: function( event ) {\n\t\tvar newItem = this.active &&\n\t\t\tthis.active.parent().closest( \".ui-menu-item\", this.element );\n\t\tif ( newItem && newItem.length ) {\n\t\t\tthis._close();\n\t\t\tthis.focus( event, newItem );\n\t\t}\n\t},\n\n\texpand: function( event ) {\n\t\tvar newItem = this.active &&\n\t\t\tthis.active\n\t\t\t\t.children( \".ui-menu \" )\n\t\t\t\t.children( \".ui-menu-item\" )\n\t\t\t\t.first();\n\n\t\tif ( newItem && newItem.length ) {\n\t\t\tthis._open( newItem.parent() );\n\n\t\t\t// Delay so Firefox will not hide activedescendant change in expanding submenu from AT\n\t\t\tthis._delay(function() {\n\t\t\t\tthis.focus( event, newItem );\n\t\t\t});\n\t\t}\n\t},\n\n\tnext: function( event ) {\n\t\tthis._move( \"next\", \"first\", event );\n\t},\n\n\tprevious: function( event ) {\n\t\tthis._move( \"prev\", \"last\", event );\n\t},\n\n\tisFirstItem: function() {\n\t\treturn this.active && !this.active.prevAll( \".ui-menu-item\" ).length;\n\t},\n\n\tisLastItem: function() {\n\t\treturn this.active && !this.active.nextAll( \".ui-menu-item\" ).length;\n\t},\n\n\t_move: function( direction, filter, event ) {\n\t\tvar next;\n\t\tif ( this.active ) {\n\t\t\tif ( direction === \"first\" || direction === \"last\" ) {\n\t\t\t\tnext = this.active\n\t\t\t\t\t[ direction === \"first\" ? \"prevAll\" : \"nextAll\" ]( \".ui-menu-item\" )\n\t\t\t\t\t.eq( -1 );\n\t\t\t} else {\n\t\t\t\tnext = this.active\n\t\t\t\t\t[ direction + \"All\" ]( \".ui-menu-item\" )\n\t\t\t\t\t.eq( 0 );\n\t\t\t}\n\t\t}\n\t\tif ( !next || !next.length || !this.active ) {\n\t\t\tnext = this.activeMenu.children( \".ui-menu-item\" )[ filter ]();\n\t\t}\n\n\t\tthis.focus( event, next );\n\t},\n\n\tnextPage: function( event ) {\n\t\tvar item, base, height;\n\n\t\tif ( !this.active ) {\n\t\t\tthis.next( event );\n\t\t\treturn;\n\t\t}\n\t\tif ( this.isLastItem() ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( this._hasScroll() ) {\n\t\t\tbase = this.active.offset().top;\n\t\t\theight = this.element.height();\n\t\t\tthis.active.nextAll( \".ui-menu-item\" ).each(function() {\n\t\t\t\titem = $( this );\n\t\t\t\treturn item.offset().top - base - height < 0;\n\t\t\t});\n\n\t\t\tthis.focus( event, item );\n\t\t} else {\n\t\t\tthis.focus( event, this.activeMenu.children( \".ui-menu-item\" )\n\t\t\t\t[ !this.active ? \"first\" : \"last\" ]() );\n\t\t}\n\t},\n\n\tpreviousPage: function( event ) {\n\t\tvar item, base, height;\n\t\tif ( !this.active ) {\n\t\t\tthis.next( event );\n\t\t\treturn;\n\t\t}\n\t\tif ( this.isFirstItem() ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( this._hasScroll() ) {\n\t\t\tbase = this.active.offset().top;\n\t\t\theight = this.element.height();\n\t\t\tthis.active.prevAll( \".ui-menu-item\" ).each(function() {\n\t\t\t\titem = $( this );\n\t\t\t\treturn item.offset().top - base + height > 0;\n\t\t\t});\n\n\t\t\tthis.focus( event, item );\n\t\t} else {\n\t\t\tthis.focus( event, this.activeMenu.children( \".ui-menu-item\" ).first() );\n\t\t}\n\t},\n\n\t_hasScroll: function() {\n\t\treturn this.element.outerHeight() < this.element.prop( \"scrollHeight\" );\n\t},\n\n\tselect: function( event ) {\n\t\t// TODO: It should never be possible to not have an active item at this\n\t\t// point, but the tests don't trigger mouseenter before click.\n\t\tthis.active = this.active || $( event.target ).closest( \".ui-menu-item\" );\n\t\tvar ui = { item: this.active };\n\t\tif ( !this.active.has( \".ui-menu\" ).length ) {\n\t\t\tthis.collapseAll( event, true );\n\t\t}\n\t\tthis._trigger( \"select\", event, ui );\n\t}\n});\n\n}( jQuery ));\n","var jQuery = require('jquery');\nrequire('./widget');\n\n/*!\n * jQuery UI Mouse 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/mouse/\n *\n * Depends:\n *\tjquery.ui.widget.js\n */\n(function( $, undefined ) {\n\nvar mouseHandled = false;\n$( document ).mouseup( function() {\n\tmouseHandled = false;\n});\n\n$.widget(\"ui.mouse\", {\n\tversion: \"1.10.4\",\n\toptions: {\n\t\tcancel: \"input,textarea,button,select,option\",\n\t\tdistance: 1,\n\t\tdelay: 0\n\t},\n\t_mouseInit: function() {\n\t\tvar that = this;\n\n\t\tthis.element\n\t\t\t.bind(\"mousedown.\"+this.widgetName, function(event) {\n\t\t\t\treturn that._mouseDown(event);\n\t\t\t})\n\t\t\t.bind(\"click.\"+this.widgetName, function(event) {\n\t\t\t\tif (true === $.data(event.target, that.widgetName + \".preventClickEvent\")) {\n\t\t\t\t\t$.removeData(event.target, that.widgetName + \".preventClickEvent\");\n\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.started = false;\n\t},\n\n\t// TODO: make sure destroying one instance of mouse doesn't mess with\n\t// other instances of mouse\n\t_mouseDestroy: function() {\n\t\tthis.element.unbind(\".\"+this.widgetName);\n\t\tif ( this._mouseMoveDelegate ) {\n\t\t\t$(document)\n\t\t\t\t.unbind(\"mousemove.\"+this.widgetName, this._mouseMoveDelegate)\n\t\t\t\t.unbind(\"mouseup.\"+this.widgetName, this._mouseUpDelegate);\n\t\t}\n\t},\n\n\t_mouseDown: function(event) {\n\t\t// don't let more than one widget handle mouseStart\n\t\tif( mouseHandled ) { return; }\n\n\t\t// we may have missed mouseup (out of window)\n\t\t(this._mouseStarted && this._mouseUp(event));\n\n\t\tthis._mouseDownEvent = event;\n\n\t\tvar that = this,\n\t\t\tbtnIsLeft = (event.which === 1),\n\t\t\t// event.target.nodeName works around a bug in IE 8 with\n\t\t\t// disabled inputs (#7620)\n\t\t\telIsCancel = (typeof this.options.cancel === \"string\" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\n\t\tif (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tthis.mouseDelayMet = !this.options.delay;\n\t\tif (!this.mouseDelayMet) {\n\t\t\tthis._mouseDelayTimer = setTimeout(function() {\n\t\t\t\tthat.mouseDelayMet = true;\n\t\t\t}, this.options.delay);\n\t\t}\n\n\t\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n\t\t\tthis._mouseStarted = (this._mouseStart(event) !== false);\n\t\t\tif (!this._mouseStarted) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Click event may never have fired (Gecko & Opera)\n\t\tif (true === $.data(event.target, this.widgetName + \".preventClickEvent\")) {\n\t\t\t$.removeData(event.target, this.widgetName + \".preventClickEvent\");\n\t\t}\n\n\t\t// these delegates are required to keep context\n\t\tthis._mouseMoveDelegate = function(event) {\n\t\t\treturn that._mouseMove(event);\n\t\t};\n\t\tthis._mouseUpDelegate = function(event) {\n\t\t\treturn that._mouseUp(event);\n\t\t};\n\t\t$(document)\n\t\t\t.bind(\"mousemove.\"+this.widgetName, this._mouseMoveDelegate)\n\t\t\t.bind(\"mouseup.\"+this.widgetName, this._mouseUpDelegate);\n\n\t\tevent.preventDefault();\n\n\t\tmouseHandled = true;\n\t\treturn true;\n\t},\n\n\t_mouseMove: function(event) {\n\t\t// IE mouseup check - mouseup happened when mouse was out of window\n\t\tif ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {\n\t\t\treturn this._mouseUp(event);\n\t\t}\n\n\t\tif (this._mouseStarted) {\n\t\t\tthis._mouseDrag(event);\n\t\t\treturn event.preventDefault();\n\t\t}\n\n\t\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n\t\t\tthis._mouseStarted =\n\t\t\t\t(this._mouseStart(this._mouseDownEvent, event) !== false);\n\t\t\t(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\n\t\t}\n\n\t\treturn !this._mouseStarted;\n\t},\n\n\t_mouseUp: function(event) {\n\t\t$(document)\n\t\t\t.unbind(\"mousemove.\"+this.widgetName, this._mouseMoveDelegate)\n\t\t\t.unbind(\"mouseup.\"+this.widgetName, this._mouseUpDelegate);\n\n\t\tif (this._mouseStarted) {\n\t\t\tthis._mouseStarted = false;\n\n\t\t\tif (event.target === this._mouseDownEvent.target) {\n\t\t\t\t$.data(event.target, this.widgetName + \".preventClickEvent\", true);\n\t\t\t}\n\n\t\t\tthis._mouseStop(event);\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_mouseDistanceMet: function(event) {\n\t\treturn (Math.max(\n\t\t\t\tMath.abs(this._mouseDownEvent.pageX - event.pageX),\n\t\t\t\tMath.abs(this._mouseDownEvent.pageY - event.pageY)\n\t\t\t) >= this.options.distance\n\t\t);\n\t},\n\n\t_mouseDelayMet: function(/* event */) {\n\t\treturn this.mouseDelayMet;\n\t},\n\n\t// These are placeholder methods, to be overriden by extending plugin\n\t_mouseStart: function(/* event */) {},\n\t_mouseDrag: function(/* event */) {},\n\t_mouseStop: function(/* event */) {},\n\t_mouseCapture: function(/* event */) { return true; }\n});\n\n})(jQuery);\n","var jQuery = require('jquery');\n\n/*!\n * jQuery UI Position 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/position/\n */\n(function( $, undefined ) {\n\n$.ui = $.ui || {};\n\nvar cachedScrollbarWidth,\n\tmax = Math.max,\n\tabs = Math.abs,\n\tround = Math.round,\n\trhorizontal = /left|center|right/,\n\trvertical = /top|center|bottom/,\n\troffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n\trposition = /^\\w+/,\n\trpercent = /%$/,\n\t_position = $.fn.position;\n\nfunction getOffsets( offsets, width, height ) {\n\treturn [\n\t\tparseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\n\t\tparseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\n\t];\n}\n\nfunction parseCss( element, property ) {\n\treturn parseInt( $.css( element, property ), 10 ) || 0;\n}\n\nfunction getDimensions( elem ) {\n\tvar raw = elem[0];\n\tif ( raw.nodeType === 9 ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: 0, left: 0 }\n\t\t};\n\t}\n\tif ( $.isWindow( raw ) ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n\t\t};\n\t}\n\tif ( raw.preventDefault ) {\n\t\treturn {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\toffset: { top: raw.pageY, left: raw.pageX }\n\t\t};\n\t}\n\treturn {\n\t\twidth: elem.outerWidth(),\n\t\theight: elem.outerHeight(),\n\t\toffset: elem.offset()\n\t};\n}\n\n$.position = {\n\tscrollbarWidth: function() {\n\t\tif ( cachedScrollbarWidth !== undefined ) {\n\t\t\treturn cachedScrollbarWidth;\n\t\t}\n\t\tvar w1, w2,\n\t\t\tdiv = $( \"<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>\" ),\n\t\t\tinnerDiv = div.children()[0];\n\n\t\t$( \"body\" ).append( div );\n\t\tw1 = innerDiv.offsetWidth;\n\t\tdiv.css( \"overflow\", \"scroll\" );\n\n\t\tw2 = innerDiv.offsetWidth;\n\n\t\tif ( w1 === w2 ) {\n\t\t\tw2 = div[0].clientWidth;\n\t\t}\n\n\t\tdiv.remove();\n\n\t\treturn (cachedScrollbarWidth = w1 - w2);\n\t},\n\tgetScrollInfo: function( within ) {\n\t\tvar overflowX = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-x\" ),\n\t\t\toverflowY = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-y\" ),\n\t\t\thasOverflowX = overflowX === \"scroll\" ||\n\t\t\t\t( overflowX === \"auto\" && within.width < within.element[0].scrollWidth ),\n\t\t\thasOverflowY = overflowY === \"scroll\" ||\n\t\t\t\t( overflowY === \"auto\" && within.height < within.element[0].scrollHeight );\n\t\treturn {\n\t\t\twidth: hasOverflowY ? $.position.scrollbarWidth() : 0,\n\t\t\theight: hasOverflowX ? $.position.scrollbarWidth() : 0\n\t\t};\n\t},\n\tgetWithinInfo: function( element ) {\n\t\tvar withinElement = $( element || window ),\n\t\t\tisWindow = $.isWindow( withinElement[0] ),\n\t\t\tisDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;\n\t\treturn {\n\t\t\telement: withinElement,\n\t\t\tisWindow: isWindow,\n\t\t\tisDocument: isDocument,\n\t\t\toffset: withinElement.offset() || { left: 0, top: 0 },\n\t\t\tscrollLeft: withinElement.scrollLeft(),\n\t\t\tscrollTop: withinElement.scrollTop(),\n\t\t\twidth: isWindow ? withinElement.width() : withinElement.outerWidth(),\n\t\t\theight: isWindow ? withinElement.height() : withinElement.outerHeight()\n\t\t};\n\t}\n};\n\n$.fn.position = function( options ) {\n\tif ( !options || !options.of ) {\n\t\treturn _position.apply( this, arguments );\n\t}\n\n\t// make a copy, we don't want to modify arguments\n\toptions = $.extend( {}, options );\n\n\tvar atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n\t\ttarget = $( options.of ),\n\t\twithin = $.position.getWithinInfo( options.within ),\n\t\tscrollInfo = $.position.getScrollInfo( within ),\n\t\tcollision = ( options.collision || \"flip\" ).split( \" \" ),\n\t\toffsets = {};\n\n\tdimensions = getDimensions( target );\n\tif ( target[0].preventDefault ) {\n\t\t// force left top to allow flipping\n\t\toptions.at = \"left top\";\n\t}\n\ttargetWidth = dimensions.width;\n\ttargetHeight = dimensions.height;\n\ttargetOffset = dimensions.offset;\n\t// clone to reuse original targetOffset later\n\tbasePosition = $.extend( {}, targetOffset );\n\n\t// force my and at to have valid horizontal and vertical positions\n\t// if a value is missing or invalid, it will be converted to center\n\t$.each( [ \"my\", \"at\" ], function() {\n\t\tvar pos = ( options[ this ] || \"\" ).split( \" \" ),\n\t\t\thorizontalOffset,\n\t\t\tverticalOffset;\n\n\t\tif ( pos.length === 1) {\n\t\t\tpos = rhorizontal.test( pos[ 0 ] ) ?\n\t\t\t\tpos.concat( [ \"center\" ] ) :\n\t\t\t\trvertical.test( pos[ 0 ] ) ?\n\t\t\t\t\t[ \"center\" ].concat( pos ) :\n\t\t\t\t\t[ \"center\", \"center\" ];\n\t\t}\n\t\tpos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\n\t\tpos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\n\n\t\t// calculate offsets\n\t\thorizontalOffset = roffset.exec( pos[ 0 ] );\n\t\tverticalOffset = roffset.exec( pos[ 1 ] );\n\t\toffsets[ this ] = [\n\t\t\thorizontalOffset ? horizontalOffset[ 0 ] : 0,\n\t\t\tverticalOffset ? verticalOffset[ 0 ] : 0\n\t\t];\n\n\t\t// reduce to just the positions without the offsets\n\t\toptions[ this ] = [\n\t\t\trposition.exec( pos[ 0 ] )[ 0 ],\n\t\t\trposition.exec( pos[ 1 ] )[ 0 ]\n\t\t];\n\t});\n\n\t// normalize collision option\n\tif ( collision.length === 1 ) {\n\t\tcollision[ 1 ] = collision[ 0 ];\n\t}\n\n\tif ( options.at[ 0 ] === \"right\" ) {\n\t\tbasePosition.left += targetWidth;\n\t} else if ( options.at[ 0 ] === \"center\" ) {\n\t\tbasePosition.left += targetWidth / 2;\n\t}\n\n\tif ( options.at[ 1 ] === \"bottom\" ) {\n\t\tbasePosition.top += targetHeight;\n\t} else if ( options.at[ 1 ] === \"center\" ) {\n\t\tbasePosition.top += targetHeight / 2;\n\t}\n\n\tatOffset = getOffsets( offsets.at, targetWidth, targetHeight );\n\tbasePosition.left += atOffset[ 0 ];\n\tbasePosition.top += atOffset[ 1 ];\n\n\treturn this.each(function() {\n\t\tvar collisionPosition, using,\n\t\t\telem = $( this ),\n\t\t\telemWidth = elem.outerWidth(),\n\t\t\telemHeight = elem.outerHeight(),\n\t\t\tmarginLeft = parseCss( this, \"marginLeft\" ),\n\t\t\tmarginTop = parseCss( this, \"marginTop\" ),\n\t\t\tcollisionWidth = elemWidth + marginLeft + parseCss( this, \"marginRight\" ) + scrollInfo.width,\n\t\t\tcollisionHeight = elemHeight + marginTop + parseCss( this, \"marginBottom\" ) + scrollInfo.height,\n\t\t\tposition = $.extend( {}, basePosition ),\n\t\t\tmyOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\n\n\t\tif ( options.my[ 0 ] === \"right\" ) {\n\t\t\tposition.left -= elemWidth;\n\t\t} else if ( options.my[ 0 ] === \"center\" ) {\n\t\t\tposition.left -= elemWidth / 2;\n\t\t}\n\n\t\tif ( options.my[ 1 ] === \"bottom\" ) {\n\t\t\tposition.top -= elemHeight;\n\t\t} else if ( options.my[ 1 ] === \"center\" ) {\n\t\t\tposition.top -= elemHeight / 2;\n\t\t}\n\n\t\tposition.left += myOffset[ 0 ];\n\t\tposition.top += myOffset[ 1 ];\n\n\t\t// if the browser doesn't support fractions, then round for consistent results\n\t\tif ( !$.support.offsetFractions ) {\n\t\t\tposition.left = round( position.left );\n\t\t\tposition.top = round( position.top );\n\t\t}\n\n\t\tcollisionPosition = {\n\t\t\tmarginLeft: marginLeft,\n\t\t\tmarginTop: marginTop\n\t\t};\n\n\t\t$.each( [ \"left\", \"top\" ], function( i, dir ) {\n\t\t\tif ( $.ui.position[ collision[ i ] ] ) {\n\t\t\t\t$.ui.position[ collision[ i ] ][ dir ]( position, {\n\t\t\t\t\ttargetWidth: targetWidth,\n\t\t\t\t\ttargetHeight: targetHeight,\n\t\t\t\t\telemWidth: elemWidth,\n\t\t\t\t\telemHeight: elemHeight,\n\t\t\t\t\tcollisionPosition: collisionPosition,\n\t\t\t\t\tcollisionWidth: collisionWidth,\n\t\t\t\t\tcollisionHeight: collisionHeight,\n\t\t\t\t\toffset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\n\t\t\t\t\tmy: options.my,\n\t\t\t\t\tat: options.at,\n\t\t\t\t\twithin: within,\n\t\t\t\t\telem : elem\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tif ( options.using ) {\n\t\t\t// adds feedback as second argument to using callback, if present\n\t\t\tusing = function( props ) {\n\t\t\t\tvar left = targetOffset.left - position.left,\n\t\t\t\t\tright = left + targetWidth - elemWidth,\n\t\t\t\t\ttop = targetOffset.top - position.top,\n\t\t\t\t\tbottom = top + targetHeight - elemHeight,\n\t\t\t\t\tfeedback = {\n\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\telement: target,\n\t\t\t\t\t\t\tleft: targetOffset.left,\n\t\t\t\t\t\t\ttop: targetOffset.top,\n\t\t\t\t\t\t\twidth: targetWidth,\n\t\t\t\t\t\t\theight: targetHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\telement: {\n\t\t\t\t\t\t\telement: elem,\n\t\t\t\t\t\t\tleft: position.left,\n\t\t\t\t\t\t\ttop: position.top,\n\t\t\t\t\t\t\twidth: elemWidth,\n\t\t\t\t\t\t\theight: elemHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\thorizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n\t\t\t\t\t\tvertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n\t\t\t\t\t};\n\t\t\t\tif ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\n\t\t\t\t\tfeedback.horizontal = \"center\";\n\t\t\t\t}\n\t\t\t\tif ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\n\t\t\t\t\tfeedback.vertical = \"middle\";\n\t\t\t\t}\n\t\t\t\tif ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\n\t\t\t\t\tfeedback.important = \"horizontal\";\n\t\t\t\t} else {\n\t\t\t\t\tfeedback.important = \"vertical\";\n\t\t\t\t}\n\t\t\t\toptions.using.call( this, props, feedback );\n\t\t\t};\n\t\t}\n\n\t\telem.offset( $.extend( position, { using: using } ) );\n\t});\n};\n\n$.ui.position = {\n\tfit: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\touterWidth = within.width,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = withinOffset - collisionPosLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n\t\t\t\tnewOverRight;\n\n\t\t\t// element is wider than within\n\t\t\tif ( data.collisionWidth > outerWidth ) {\n\t\t\t\t// element is initially over the left side of within\n\t\t\t\tif ( overLeft > 0 && overRight <= 0 ) {\n\t\t\t\t\tnewOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;\n\t\t\t\t\tposition.left += overLeft - newOverRight;\n\t\t\t\t// element is initially over right side of within\n\t\t\t\t} else if ( overRight > 0 && overLeft <= 0 ) {\n\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t// element is initially over both left and right sides of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overLeft > overRight ) {\n\t\t\t\t\t\tposition.left = withinOffset + outerWidth - data.collisionWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// too far left -> align with left edge\n\t\t\t} else if ( overLeft > 0 ) {\n\t\t\t\tposition.left += overLeft;\n\t\t\t// too far right -> align with right edge\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tposition.left -= overRight;\n\t\t\t// adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.left = max( position.left - collisionPosLeft, position.left );\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\touterHeight = data.within.height,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = withinOffset - collisionPosTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n\t\t\t\tnewOverBottom;\n\n\t\t\t// element is taller than within\n\t\t\tif ( data.collisionHeight > outerHeight ) {\n\t\t\t\t// element is initially over the top of within\n\t\t\t\tif ( overTop > 0 && overBottom <= 0 ) {\n\t\t\t\t\tnewOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;\n\t\t\t\t\tposition.top += overTop - newOverBottom;\n\t\t\t\t// element is initially over bottom of within\n\t\t\t\t} else if ( overBottom > 0 && overTop <= 0 ) {\n\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t// element is initially over both top and bottom of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overTop > overBottom ) {\n\t\t\t\t\t\tposition.top = withinOffset + outerHeight - data.collisionHeight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// too far up -> align with top\n\t\t\t} else if ( overTop > 0 ) {\n\t\t\t\tposition.top += overTop;\n\t\t\t// too far down -> align with bottom edge\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tposition.top -= overBottom;\n\t\t\t// adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.top = max( position.top - collisionPosTop, position.top );\n\t\t\t}\n\t\t}\n\t},\n\tflip: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.left + within.scrollLeft,\n\t\t\t\touterWidth = within.width,\n\t\t\t\toffsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = collisionPosLeft - offsetLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n\t\t\t\tmyOffset = data.my[ 0 ] === \"left\" ?\n\t\t\t\t\t-data.elemWidth :\n\t\t\t\t\tdata.my[ 0 ] === \"right\" ?\n\t\t\t\t\t\tdata.elemWidth :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 0 ] === \"left\" ?\n\t\t\t\t\tdata.targetWidth :\n\t\t\t\t\tdata.at[ 0 ] === \"right\" ?\n\t\t\t\t\t\t-data.targetWidth :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 0 ],\n\t\t\t\tnewOverRight,\n\t\t\t\tnewOverLeft;\n\n\t\t\tif ( overLeft < 0 ) {\n\t\t\t\tnewOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;\n\t\t\t\tif ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( overRight > 0 ) {\n\t\t\t\tnewOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;\n\t\t\t\tif ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.top + within.scrollTop,\n\t\t\t\touterHeight = within.height,\n\t\t\t\toffsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = collisionPosTop - offsetTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n\t\t\t\ttop = data.my[ 1 ] === \"top\",\n\t\t\t\tmyOffset = top ?\n\t\t\t\t\t-data.elemHeight :\n\t\t\t\t\tdata.my[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\tdata.elemHeight :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 1 ] === \"top\" ?\n\t\t\t\t\tdata.targetHeight :\n\t\t\t\t\tdata.at[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\t-data.targetHeight :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 1 ],\n\t\t\t\tnewOverTop,\n\t\t\t\tnewOverBottom;\n\t\t\tif ( overTop < 0 ) {\n\t\t\t\tnewOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;\n\t\t\t\tif ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( overBottom > 0 ) {\n\t\t\t\tnewOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;\n\t\t\t\tif ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tflipfit: {\n\t\tleft: function() {\n\t\t\t$.ui.position.flip.left.apply( this, arguments );\n\t\t\t$.ui.position.fit.left.apply( this, arguments );\n\t\t},\n\t\ttop: function() {\n\t\t\t$.ui.position.flip.top.apply( this, arguments );\n\t\t\t$.ui.position.fit.top.apply( this, arguments );\n\t\t}\n\t}\n};\n\n// fraction support test\n(function () {\n\tvar testElement, testElementParent, testElementStyle, offsetLeft, i,\n\t\tbody = document.getElementsByTagName( \"body\" )[ 0 ],\n\t\tdiv = document.createElement( \"div\" );\n\n\t//Create a \"fake body\" for testing based on method used in jQuery.support\n\ttestElement = document.createElement( body ? \"div\" : \"body\" );\n\ttestElementStyle = {\n\t\tvisibility: \"hidden\",\n\t\twidth: 0,\n\t\theight: 0,\n\t\tborder: 0,\n\t\tmargin: 0,\n\t\tbackground: \"none\"\n\t};\n\tif ( body ) {\n\t\t$.extend( testElementStyle, {\n\t\t\tposition: \"absolute\",\n\t\t\tleft: \"-1000px\",\n\t\t\ttop: \"-1000px\"\n\t\t});\n\t}\n\tfor ( i in testElementStyle ) {\n\t\ttestElement.style[ i ] = testElementStyle[ i ];\n\t}\n\ttestElement.appendChild( div );\n\ttestElementParent = body || document.documentElement;\n\ttestElementParent.insertBefore( testElement, testElementParent.firstChild );\n\n\tdiv.style.cssText = \"position: absolute; left: 10.7432222px;\";\n\n\toffsetLeft = $( div ).offset().left;\n\t$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;\n\n\ttestElement.innerHTML = \"\";\n\ttestElementParent.removeChild( testElement );\n})();\n\n}( jQuery ) );\n","var jQuery = require('jquery');\nrequire('./core');\nrequire('./mouse');\nrequire('./widget');\n\n/*!\n * jQuery UI Slider 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/slider/\n *\n * Depends:\n *\tjquery.ui.core.js\n *\tjquery.ui.mouse.js\n *\tjquery.ui.widget.js\n */\n(function( $, undefined ) {\n\n// number of pages in a slider\n// (how many times can you page up/down to go through the whole range)\nvar numPages = 5;\n\n$.widget( \"ui.slider\", $.ui.mouse, {\n\tversion: \"1.10.4\",\n\twidgetEventPrefix: \"slide\",\n\n\toptions: {\n\t\tanimate: false,\n\t\tdistance: 0,\n\t\tmax: 100,\n\t\tmin: 0,\n\t\torientation: \"horizontal\",\n\t\trange: false,\n\t\tstep: 1,\n\t\tvalue: 0,\n\t\tvalues: null,\n\n\t\t// callbacks\n\t\tchange: null,\n\t\tslide: null,\n\t\tstart: null,\n\t\tstop: null\n\t},\n\n\t_create: function() {\n\t\tthis._keySliding = false;\n\t\tthis._mouseSliding = false;\n\t\tthis._animateOff = true;\n\t\tthis._handleIndex = null;\n\t\tthis._detectOrientation();\n\t\tthis._mouseInit();\n\n\t\tthis.element\n\t\t\t.addClass( \"ui-slider\" +\n\t\t\t\t\" ui-slider-\" + this.orientation +\n\t\t\t\t\" ui-widget\" +\n\t\t\t\t\" ui-widget-content\" +\n\t\t\t\t\" ui-corner-all\");\n\n\t\tthis._refresh();\n\t\tthis._setOption( \"disabled\", this.options.disabled );\n\n\t\tthis._animateOff = false;\n\t},\n\n\t_refresh: function() {\n\t\tthis._createRange();\n\t\tthis._createHandles();\n\t\tthis._setupEvents();\n\t\tthis._refreshValue();\n\t},\n\n\t_createHandles: function() {\n\t\tvar i, handleCount,\n\t\t\toptions = this.options,\n\t\t\texistingHandles = this.element.find( \".ui-slider-handle\" ).addClass( \"ui-state-default ui-corner-all\" ),\n\t\t\thandle = \"<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>\",\n\t\t\thandles = [];\n\n\t\thandleCount = ( options.values && options.values.length ) || 1;\n\n\t\tif ( existingHandles.length > handleCount ) {\n\t\t\texistingHandles.slice( handleCount ).remove();\n\t\t\texistingHandles = existingHandles.slice( 0, handleCount );\n\t\t}\n\n\t\tfor ( i = existingHandles.length; i < handleCount; i++ ) {\n\t\t\thandles.push( handle );\n\t\t}\n\n\t\tthis.handles = existingHandles.add( $( handles.join( \"\" ) ).appendTo( this.element ) );\n\n\t\tthis.handle = this.handles.eq( 0 );\n\n\t\tthis.handles.each(function( i ) {\n\t\t\t$( this ).data( \"ui-slider-handle-index\", i );\n\t\t});\n\t},\n\n\t_createRange: function() {\n\t\tvar options = this.options,\n\t\t\tclasses = \"\";\n\n\t\tif ( options.range ) {\n\t\t\tif ( options.range === true ) {\n\t\t\t\tif ( !options.values ) {\n\t\t\t\t\toptions.values = [ this._valueMin(), this._valueMin() ];\n\t\t\t\t} else if ( options.values.length && options.values.length !== 2 ) {\n\t\t\t\t\toptions.values = [ options.values[0], options.values[0] ];\n\t\t\t\t} else if ( $.isArray( options.values ) ) {\n\t\t\t\t\toptions.values = options.values.slice(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !this.range || !this.range.length ) {\n\t\t\t\tthis.range = $( \"<div></div>\" )\n\t\t\t\t\t.appendTo( this.element );\n\n\t\t\t\tclasses = \"ui-slider-range\" +\n\t\t\t\t// note: this isn't the most fittingly semantic framework class for this element,\n\t\t\t\t// but worked best visually with a variety of themes\n\t\t\t\t\" ui-widget-header ui-corner-all\";\n\t\t\t} else {\n\t\t\t\tthis.range.removeClass( \"ui-slider-range-min ui-slider-range-max\" )\n\t\t\t\t\t// Handle range switching from true to min/max\n\t\t\t\t\t.css({\n\t\t\t\t\t\t\"left\": \"\",\n\t\t\t\t\t\t\"bottom\": \"\"\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.range.addClass( classes +\n\t\t\t\t( ( options.range === \"min\" || options.range === \"max\" ) ? \" ui-slider-range-\" + options.range : \"\" ) );\n\t\t} else {\n\t\t\tif ( this.range ) {\n\t\t\t\tthis.range.remove();\n\t\t\t}\n\t\t\tthis.range = null;\n\t\t}\n\t},\n\n\t_setupEvents: function() {\n\t\tvar elements = this.handles.add( this.range ).filter( \"a\" );\n\t\tthis._off( elements );\n\t\tthis._on( elements, this._handleEvents );\n\t\tthis._hoverable( elements );\n\t\tthis._focusable( elements );\n\t},\n\n\t_destroy: function() {\n\t\tthis.handles.remove();\n\t\tif ( this.range ) {\n\t\t\tthis.range.remove();\n\t\t}\n\n\t\tthis.element\n\t\t\t.removeClass( \"ui-slider\" +\n\t\t\t\t\" ui-slider-horizontal\" +\n\t\t\t\t\" ui-slider-vertical\" +\n\t\t\t\t\" ui-widget\" +\n\t\t\t\t\" ui-widget-content\" +\n\t\t\t\t\" ui-corner-all\" );\n\n\t\tthis._mouseDestroy();\n\t},\n\n\t_mouseCapture: function( event ) {\n\t\tvar position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,\n\t\t\tthat = this,\n\t\t\to = this.options;\n\n\t\tif ( o.disabled ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.elementSize = {\n\t\t\twidth: this.element.outerWidth(),\n\t\t\theight: this.element.outerHeight()\n\t\t};\n\t\tthis.elementOffset = this.element.offset();\n\n\t\tposition = { x: event.pageX, y: event.pageY };\n\t\tnormValue = this._normValueFromMouse( position );\n\t\tdistance = this._valueMax() - this._valueMin() + 1;\n\t\tthis.handles.each(function( i ) {\n\t\t\tvar thisDistance = Math.abs( normValue - that.values(i) );\n\t\t\tif (( distance > thisDistance ) ||\n\t\t\t\t( distance === thisDistance &&\n\t\t\t\t\t(i === that._lastChangedValue || that.values(i) === o.min ))) {\n\t\t\t\tdistance = thisDistance;\n\t\t\t\tclosestHandle = $( this );\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t});\n\n\t\tallowed = this._start( event, index );\n\t\tif ( allowed === false ) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._mouseSliding = true;\n\n\t\tthis._handleIndex = index;\n\n\t\tclosestHandle\n\t\t\t.addClass( \"ui-state-active\" )\n\t\t\t.focus();\n\n\t\toffset = closestHandle.offset();\n\t\tmouseOverHandle = !$( event.target ).parents().addBack().is( \".ui-slider-handle\" );\n\t\tthis._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {\n\t\t\tleft: event.pageX - offset.left - ( closestHandle.width() / 2 ),\n\t\t\ttop: event.pageY - offset.top -\n\t\t\t\t( closestHandle.height() / 2 ) -\n\t\t\t\t( parseInt( closestHandle.css(\"borderTopWidth\"), 10 ) || 0 ) -\n\t\t\t\t( parseInt( closestHandle.css(\"borderBottomWidth\"), 10 ) || 0) +\n\t\t\t\t( parseInt( closestHandle.css(\"marginTop\"), 10 ) || 0)\n\t\t};\n\n\t\tif ( !this.handles.hasClass( \"ui-state-hover\" ) ) {\n\t\t\tthis._slide( event, index, normValue );\n\t\t}\n\t\tthis._animateOff = true;\n\t\treturn true;\n\t},\n\n\t_mouseStart: function() {\n\t\treturn true;\n\t},\n\n\t_mouseDrag: function( event ) {\n\t\tvar position = { x: event.pageX, y: event.pageY },\n\t\t\tnormValue = this._normValueFromMouse( position );\n\n\t\tthis._slide( event, this._handleIndex, normValue );\n\n\t\treturn false;\n\t},\n\n\t_mouseStop: function( event ) {\n\t\tthis.handles.removeClass( \"ui-state-active\" );\n\t\tthis._mouseSliding = false;\n\n\t\tthis._stop( event, this._handleIndex );\n\t\tthis._change( event, this._handleIndex );\n\n\t\tthis._handleIndex = null;\n\t\tthis._clickOffset = null;\n\t\tthis._animateOff = false;\n\n\t\treturn false;\n\t},\n\n\t_detectOrientation: function() {\n\t\tthis.orientation = ( this.options.orientation === \"vertical\" ) ? \"vertical\" : \"horizontal\";\n\t},\n\n\t_normValueFromMouse: function( position ) {\n\t\tvar pixelTotal,\n\t\t\tpixelMouse,\n\t\t\tpercentMouse,\n\t\t\tvalueTotal,\n\t\t\tvalueMouse;\n\n\t\tif ( this.orientation === \"horizontal\" ) {\n\t\t\tpixelTotal = this.elementSize.width;\n\t\t\tpixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );\n\t\t} else {\n\t\t\tpixelTotal = this.elementSize.height;\n\t\t\tpixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );\n\t\t}\n\n\t\tpercentMouse = ( pixelMouse / pixelTotal );\n\t\tif ( percentMouse > 1 ) {\n\t\t\tpercentMouse = 1;\n\t\t}\n\t\tif ( percentMouse < 0 ) {\n\t\t\tpercentMouse = 0;\n\t\t}\n\t\tif ( this.orientation === \"vertical\" ) {\n\t\t\tpercentMouse = 1 - percentMouse;\n\t\t}\n\n\t\tvalueTotal = this._valueMax() - this._valueMin();\n\t\tvalueMouse = this._valueMin() + percentMouse * valueTotal;\n\n\t\treturn this._trimAlignValue( valueMouse );\n\t},\n\n\t_start: function( event, index ) {\n\t\tvar uiHash = {\n\t\t\thandle: this.handles[ index ],\n\t\t\tvalue: this.value()\n\t\t};\n\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\tuiHash.value = this.values( index );\n\t\t\tuiHash.values = this.values();\n\t\t}\n\t\treturn this._trigger( \"start\", event, uiHash );\n\t},\n\n\t_slide: function( event, index, newVal ) {\n\t\tvar otherVal,\n\t\t\tnewValues,\n\t\t\tallowed;\n\n\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\totherVal = this.values( index ? 0 : 1 );\n\n\t\t\tif ( ( this.options.values.length === 2 && this.options.range === true ) &&\n\t\t\t\t\t( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )\n\t\t\t\t) {\n\t\t\t\tnewVal = otherVal;\n\t\t\t}\n\n\t\t\tif ( newVal !== this.values( index ) ) {\n\t\t\t\tnewValues = this.values();\n\t\t\t\tnewValues[ index ] = newVal;\n\t\t\t\t// A slide can be canceled by returning false from the slide callback\n\t\t\t\tallowed = this._trigger( \"slide\", event, {\n\t\t\t\t\thandle: this.handles[ index ],\n\t\t\t\t\tvalue: newVal,\n\t\t\t\t\tvalues: newValues\n\t\t\t\t} );\n\t\t\t\totherVal = this.values( index ? 0 : 1 );\n\t\t\t\tif ( allowed !== false ) {\n\t\t\t\t\tthis.values( index, newVal );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ( newVal !== this.value() ) {\n\t\t\t\t// A slide can be canceled by returning false from the slide callback\n\t\t\t\tallowed = this._trigger( \"slide\", event, {\n\t\t\t\t\thandle: this.handles[ index ],\n\t\t\t\t\tvalue: newVal\n\t\t\t\t} );\n\t\t\t\tif ( allowed !== false ) {\n\t\t\t\t\tthis.value( newVal );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_stop: function( event, index ) {\n\t\tvar uiHash = {\n\t\t\thandle: this.handles[ index ],\n\t\t\tvalue: this.value()\n\t\t};\n\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\tuiHash.value = this.values( index );\n\t\t\tuiHash.values = this.values();\n\t\t}\n\n\t\tthis._trigger( \"stop\", event, uiHash );\n\t},\n\n\t_change: function( event, index ) {\n\t\tif ( !this._keySliding && !this._mouseSliding ) {\n\t\t\tvar uiHash = {\n\t\t\t\thandle: this.handles[ index ],\n\t\t\t\tvalue: this.value()\n\t\t\t};\n\t\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\t\tuiHash.value = this.values( index );\n\t\t\t\tuiHash.values = this.values();\n\t\t\t}\n\n\t\t\t//store the last changed value index for reference when handles overlap\n\t\t\tthis._lastChangedValue = index;\n\n\t\t\tthis._trigger( \"change\", event, uiHash );\n\t\t}\n\t},\n\n\tvalue: function( newValue ) {\n\t\tif ( arguments.length ) {\n\t\t\tthis.options.value = this._trimAlignValue( newValue );\n\t\t\tthis._refreshValue();\n\t\t\tthis._change( null, 0 );\n\t\t\treturn;\n\t\t}\n\n\t\treturn this._value();\n\t},\n\n\tvalues: function( index, newValue ) {\n\t\tvar vals,\n\t\t\tnewValues,\n\t\t\ti;\n\n\t\tif ( arguments.length > 1 ) {\n\t\t\tthis.options.values[ index ] = this._trimAlignValue( newValue );\n\t\t\tthis._refreshValue();\n\t\t\tthis._change( null, index );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( arguments.length ) {\n\t\t\tif ( $.isArray( arguments[ 0 ] ) ) {\n\t\t\t\tvals = this.options.values;\n\t\t\t\tnewValues = arguments[ 0 ];\n\t\t\t\tfor ( i = 0; i < vals.length; i += 1 ) {\n\t\t\t\t\tvals[ i ] = this._trimAlignValue( newValues[ i ] );\n\t\t\t\t\tthis._change( null, i );\n\t\t\t\t}\n\t\t\t\tthis._refreshValue();\n\t\t\t} else {\n\t\t\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\t\t\treturn this._values( index );\n\t\t\t\t} else {\n\t\t\t\t\treturn this.value();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._values();\n\t\t}\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tvar i,\n\t\t\tvalsLength = 0;\n\n\t\tif ( key === \"range\" && this.options.range === true ) {\n\t\t\tif ( value === \"min\" ) {\n\t\t\t\tthis.options.value = this._values( 0 );\n\t\t\t\tthis.options.values = null;\n\t\t\t} else if ( value === \"max\" ) {\n\t\t\t\tthis.options.value = this._values( this.options.values.length-1 );\n\t\t\t\tthis.options.values = null;\n\t\t\t}\n\t\t}\n\n\t\tif ( $.isArray( this.options.values ) ) {\n\t\t\tvalsLength = this.options.values.length;\n\t\t}\n\n\t\t$.Widget.prototype._setOption.apply( this, arguments );\n\n\t\tswitch ( key ) {\n\t\t\tcase \"orientation\":\n\t\t\t\tthis._detectOrientation();\n\t\t\t\tthis.element\n\t\t\t\t\t.removeClass( \"ui-slider-horizontal ui-slider-vertical\" )\n\t\t\t\t\t.addClass( \"ui-slider-\" + this.orientation );\n\t\t\t\tthis._refreshValue();\n\t\t\t\tbreak;\n\t\t\tcase \"value\":\n\t\t\t\tthis._animateOff = true;\n\t\t\t\tthis._refreshValue();\n\t\t\t\tthis._change( null, 0 );\n\t\t\t\tthis._animateOff = false;\n\t\t\t\tbreak;\n\t\t\tcase \"values\":\n\t\t\t\tthis._animateOff = true;\n\t\t\t\tthis._refreshValue();\n\t\t\t\tfor ( i = 0; i < valsLength; i += 1 ) {\n\t\t\t\t\tthis._change( null, i );\n\t\t\t\t}\n\t\t\t\tthis._animateOff = false;\n\t\t\t\tbreak;\n\t\t\tcase \"min\":\n\t\t\tcase \"max\":\n\t\t\t\tthis._animateOff = true;\n\t\t\t\tthis._refreshValue();\n\t\t\t\tthis._animateOff = false;\n\t\t\t\tbreak;\n\t\t\tcase \"range\":\n\t\t\t\tthis._animateOff = true;\n\t\t\t\tthis._refresh();\n\t\t\t\tthis._animateOff = false;\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\t//internal value getter\n\t// _value() returns value trimmed by min and max, aligned by step\n\t_value: function() {\n\t\tvar val = this.options.value;\n\t\tval = this._trimAlignValue( val );\n\n\t\treturn val;\n\t},\n\n\t//internal values getter\n\t// _values() returns array of values trimmed by min and max, aligned by step\n\t// _values( index ) returns single value trimmed by min and max, aligned by step\n\t_values: function( index ) {\n\t\tvar val,\n\t\t\tvals,\n\t\t\ti;\n\n\t\tif ( arguments.length ) {\n\t\t\tval = this.options.values[ index ];\n\t\t\tval = this._trimAlignValue( val );\n\n\t\t\treturn val;\n\t\t} else if ( this.options.values && this.options.values.length ) {\n\t\t\t// .slice() creates a copy of the array\n\t\t\t// this copy gets trimmed by min and max and then returned\n\t\t\tvals = this.options.values.slice();\n\t\t\tfor ( i = 0; i < vals.length; i+= 1) {\n\t\t\t\tvals[ i ] = this._trimAlignValue( vals[ i ] );\n\t\t\t}\n\n\t\t\treturn vals;\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t},\n\n\t// returns the step-aligned value that val is closest to, between (inclusive) min and max\n\t_trimAlignValue: function( val ) {\n\t\tif ( val <= this._valueMin() ) {\n\t\t\treturn this._valueMin();\n\t\t}\n\t\tif ( val >= this._valueMax() ) {\n\t\t\treturn this._valueMax();\n\t\t}\n\t\tvar step = ( this.options.step > 0 ) ? this.options.step : 1,\n\t\t\tvalModStep = (val - this._valueMin()) % step,\n\t\t\talignValue = val - valModStep;\n\n\t\tif ( Math.abs(valModStep) * 2 >= step ) {\n\t\t\talignValue += ( valModStep > 0 ) ? step : ( -step );\n\t\t}\n\n\t\t// Since JavaScript has problems with large floats, round\n\t\t// the final value to 5 digits after the decimal point (see #4124)\n\t\treturn parseFloat( alignValue.toFixed(5) );\n\t},\n\n\t_valueMin: function() {\n\t\treturn this.options.min;\n\t},\n\n\t_valueMax: function() {\n\t\treturn this.options.max;\n\t},\n\n\t_refreshValue: function() {\n\t\tvar lastValPercent, valPercent, value, valueMin, valueMax,\n\t\t\toRange = this.options.range,\n\t\t\to = this.options,\n\t\t\tthat = this,\n\t\t\tanimate = ( !this._animateOff ) ? o.animate : false,\n\t\t\t_set = {};\n\n\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\tthis.handles.each(function( i ) {\n\t\t\t\tvalPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;\n\t\t\t\t_set[ that.orientation === \"horizontal\" ? \"left\" : \"bottom\" ] = valPercent + \"%\";\n\t\t\t\t$( this ).stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( _set, o.animate );\n\t\t\t\tif ( that.options.range === true ) {\n\t\t\t\t\tif ( that.orientation === \"horizontal\" ) {\n\t\t\t\t\t\tif ( i === 0 ) {\n\t\t\t\t\t\t\tthat.range.stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( { left: valPercent + \"%\" }, o.animate );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( i === 1 ) {\n\t\t\t\t\t\t\tthat.range[ animate ? \"animate\" : \"css\" ]( { width: ( valPercent - lastValPercent ) + \"%\" }, { queue: false, duration: o.animate } );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( i === 0 ) {\n\t\t\t\t\t\t\tthat.range.stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( { bottom: ( valPercent ) + \"%\" }, o.animate );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( i === 1 ) {\n\t\t\t\t\t\t\tthat.range[ animate ? \"animate\" : \"css\" ]( { height: ( valPercent - lastValPercent ) + \"%\" }, { queue: false, duration: o.animate } );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastValPercent = valPercent;\n\t\t\t});\n\t\t} else {\n\t\t\tvalue = this.value();\n\t\t\tvalueMin = this._valueMin();\n\t\t\tvalueMax = this._valueMax();\n\t\t\tvalPercent = ( valueMax !== valueMin ) ?\n\t\t\t\t\t( value - valueMin ) / ( valueMax - valueMin ) * 100 :\n\t\t\t\t\t0;\n\t\t\t_set[ this.orientation === \"horizontal\" ? \"left\" : \"bottom\" ] = valPercent + \"%\";\n\t\t\tthis.handle.stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( _set, o.animate );\n\n\t\t\tif ( oRange === \"min\" && this.orientation === \"horizontal\" ) {\n\t\t\t\tthis.range.stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( { width: valPercent + \"%\" }, o.animate );\n\t\t\t}\n\t\t\tif ( oRange === \"max\" && this.orientation === \"horizontal\" ) {\n\t\t\t\tthis.range[ animate ? \"animate\" : \"css\" ]( { width: ( 100 - valPercent ) + \"%\" }, { queue: false, duration: o.animate } );\n\t\t\t}\n\t\t\tif ( oRange === \"min\" && this.orientation === \"vertical\" ) {\n\t\t\t\tthis.range.stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( { height: valPercent + \"%\" }, o.animate );\n\t\t\t}\n\t\t\tif ( oRange === \"max\" && this.orientation === \"vertical\" ) {\n\t\t\t\tthis.range[ animate ? \"animate\" : \"css\" ]( { height: ( 100 - valPercent ) + \"%\" }, { queue: false, duration: o.animate } );\n\t\t\t}\n\t\t}\n\t},\n\n\t_handleEvents: {\n\t\tkeydown: function( event ) {\n\t\t\tvar allowed, curVal, newVal, step,\n\t\t\t\tindex = $( event.target ).data( \"ui-slider-handle-index\" );\n\n\t\t\tswitch ( event.keyCode ) {\n\t\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\tcase $.ui.keyCode.END:\n\t\t\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\t\tcase $.ui.keyCode.UP:\n\t\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tif ( !this._keySliding ) {\n\t\t\t\t\t\tthis._keySliding = true;\n\t\t\t\t\t\t$( event.target ).addClass( \"ui-state-active\" );\n\t\t\t\t\t\tallowed = this._start( event, index );\n\t\t\t\t\t\tif ( allowed === false ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstep = this.options.step;\n\t\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\t\tcurVal = newVal = this.values( index );\n\t\t\t} else {\n\t\t\t\tcurVal = newVal = this.value();\n\t\t\t}\n\n\t\t\tswitch ( event.keyCode ) {\n\t\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\t\tnewVal = this._valueMin();\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.END:\n\t\t\t\t\tnewVal = this._valueMax();\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\t\t\tnewVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\t\t\tnewVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.UP:\n\t\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\t\t\tif ( curVal === this._valueMax() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tnewVal = this._trimAlignValue( curVal + step );\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\t\tif ( curVal === this._valueMin() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tnewVal = this._trimAlignValue( curVal - step );\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis._slide( event, index, newVal );\n\t\t},\n\t\tclick: function( event ) {\n\t\t\tevent.preventDefault();\n\t\t},\n\t\tkeyup: function( event ) {\n\t\t\tvar index = $( event.target ).data( \"ui-slider-handle-index\" );\n\n\t\t\tif ( this._keySliding ) {\n\t\t\t\tthis._keySliding = false;\n\t\t\t\tthis._stop( event, index );\n\t\t\t\tthis._change( event, index );\n\t\t\t\t$( event.target ).removeClass( \"ui-state-active\" );\n\t\t\t}\n\t\t}\n\t}\n\n});\n\n}(jQuery));\n","var jQuery = require('jquery');\nrequire('./core');\nrequire('./mouse');\nrequire('./widget');\n\n/*!\n * jQuery UI Sortable 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/sortable/\n *\n * Depends:\n *\tjquery.ui.core.js\n *\tjquery.ui.mouse.js\n *\tjquery.ui.widget.js\n */\n(function( $, undefined ) {\n\nfunction isOverAxis( x, reference, size ) {\n\treturn ( x > reference ) && ( x < ( reference + size ) );\n}\n\nfunction isFloating(item) {\n\treturn (/left|right/).test(item.css(\"float\")) || (/inline|table-cell/).test(item.css(\"display\"));\n}\n\n$.widget(\"ui.sortable\", $.ui.mouse, {\n\tversion: \"1.10.4\",\n\twidgetEventPrefix: \"sort\",\n\tready: false,\n\toptions: {\n\t\tappendTo: \"parent\",\n\t\taxis: false,\n\t\tconnectWith: false,\n\t\tcontainment: false,\n\t\tcursor: \"auto\",\n\t\tcursorAt: false,\n\t\tdropOnEmpty: true,\n\t\tforcePlaceholderSize: false,\n\t\tforceHelperSize: false,\n\t\tgrid: false,\n\t\thandle: false,\n\t\thelper: \"original\",\n\t\titems: \"> *\",\n\t\topacity: false,\n\t\tplaceholder: false,\n\t\trevert: false,\n\t\tscroll: true,\n\t\tscrollSensitivity: 20,\n\t\tscrollSpeed: 20,\n\t\tscope: \"default\",\n\t\ttolerance: \"intersect\",\n\t\tzIndex: 1000,\n\n\t\t// callbacks\n\t\tactivate: null,\n\t\tbeforeStop: null,\n\t\tchange: null,\n\t\tdeactivate: null,\n\t\tout: null,\n\t\tover: null,\n\t\treceive: null,\n\t\tremove: null,\n\t\tsort: null,\n\t\tstart: null,\n\t\tstop: null,\n\t\tupdate: null\n\t},\n\t_create: function() {\n\n\t\tvar o = this.options;\n\t\tthis.containerCache = {};\n\t\tthis.element.addClass(\"ui-sortable\");\n\n\t\t//Get the items\n\t\tthis.refresh();\n\n\t\t//Let's determine if the items are being displayed horizontally\n\t\tthis.floating = this.items.length ? o.axis === \"x\" || isFloating(this.items[0].item) : false;\n\n\t\t//Let's determine the parent's offset\n\t\tthis.offset = this.element.offset();\n\n\t\t//Initialize mouse events for interaction\n\t\tthis._mouseInit();\n\n\t\t//We're ready to go\n\t\tthis.ready = true;\n\n\t},\n\n\t_destroy: function() {\n\t\tthis.element\n\t\t\t.removeClass(\"ui-sortable ui-sortable-disabled\");\n\t\tthis._mouseDestroy();\n\n\t\tfor ( var i = this.items.length - 1; i >= 0; i-- ) {\n\t\t\tthis.items[i].item.removeData(this.widgetName + \"-item\");\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_setOption: function(key, value){\n\t\tif ( key === \"disabled\" ) {\n\t\t\tthis.options[ key ] = value;\n\n\t\t\tthis.widget().toggleClass( \"ui-sortable-disabled\", !!value );\n\t\t} else {\n\t\t\t// Don't call widget base _setOption for disable as it adds ui-state-disabled class\n\t\t\t$.Widget.prototype._setOption.apply(this, arguments);\n\t\t}\n\t},\n\n\t_mouseCapture: function(event, overrideHandle) {\n\t\tvar currentItem = null,\n\t\t\tvalidHandle = false,\n\t\t\tthat = this;\n\n\t\tif (this.reverting) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif(this.options.disabled || this.options.type === \"static\") {\n\t\t\treturn false;\n\t\t}\n\n\t\t//We have to refresh the items data once first\n\t\tthis._refreshItems(event);\n\n\t\t//Find out if the clicked node (or one of its parents) is a actual item in this.items\n\t\t$(event.target).parents().each(function() {\n\t\t\tif($.data(this, that.widgetName + \"-item\") === that) {\n\t\t\t\tcurrentItem = $(this);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\tif($.data(event.target, that.widgetName + \"-item\") === that) {\n\t\t\tcurrentItem = $(event.target);\n\t\t}\n\n\t\tif(!currentItem) {\n\t\t\treturn false;\n\t\t}\n\t\tif(this.options.handle && !overrideHandle) {\n\t\t\t$(this.options.handle, currentItem).find(\"*\").addBack().each(function() {\n\t\t\t\tif(this === event.target) {\n\t\t\t\t\tvalidHandle = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(!validHandle) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.currentItem = currentItem;\n\t\tthis._removeCurrentsFromItems();\n\t\treturn true;\n\n\t},\n\n\t_mouseStart: function(event, overrideHandle, noActivation) {\n\n\t\tvar i, body,\n\t\t\to = this.options;\n\n\t\tthis.currentContainer = this;\n\n\t\t//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture\n\t\tthis.refreshPositions();\n\n\t\t//Create and append the visible helper\n\t\tthis.helper = this._createHelper(event);\n\n\t\t//Cache the helper size\n\t\tthis._cacheHelperProportions();\n\n\t\t/*\n\t\t * - Position generation -\n\t\t * This block generates everything position related - it's the core of draggables.\n\t\t */\n\n\t\t//Cache the margins of the original element\n\t\tthis._cacheMargins();\n\n\t\t//Get the next scrolling parent\n\t\tthis.scrollParent = this.helper.scrollParent();\n\n\t\t//The element's absolute position on the page minus margins\n\t\tthis.offset = this.currentItem.offset();\n\t\tthis.offset = {\n\t\t\ttop: this.offset.top - this.margins.top,\n\t\t\tleft: this.offset.left - this.margins.left\n\t\t};\n\n\t\t$.extend(this.offset, {\n\t\t\tclick: { //Where the click happened, relative to the element\n\t\t\t\tleft: event.pageX - this.offset.left,\n\t\t\t\ttop: event.pageY - this.offset.top\n\t\t\t},\n\t\t\tparent: this._getParentOffset(),\n\t\t\trelative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\n\t\t});\n\n\t\t// Only after we got the offset, we can change the helper's position to absolute\n\t\t// TODO: Still need to figure out a way to make relative sorting possible\n\t\tthis.helper.css(\"position\", \"absolute\");\n\t\tthis.cssPosition = this.helper.css(\"position\");\n\n\t\t//Generate the original position\n\t\tthis.originalPosition = this._generatePosition(event);\n\t\tthis.originalPageX = event.pageX;\n\t\tthis.originalPageY = event.pageY;\n\n\t\t//Adjust the mouse offset relative to the helper if \"cursorAt\" is supplied\n\t\t(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\n\n\t\t//Cache the former DOM position\n\t\tthis.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };\n\n\t\t//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way\n\t\tif(this.helper[0] !== this.currentItem[0]) {\n\t\t\tthis.currentItem.hide();\n\t\t}\n\n\t\t//Create the placeholder\n\t\tthis._createPlaceholder();\n\n\t\t//Set a containment if given in the options\n\t\tif(o.containment) {\n\t\t\tthis._setContainment();\n\t\t}\n\n\t\tif( o.cursor && o.cursor !== \"auto\" ) { // cursor option\n\t\t\tbody = this.document.find( \"body\" );\n\n\t\t\t// support: IE\n\t\t\tthis.storedCursor = body.css( \"cursor\" );\n\t\t\tbody.css( \"cursor\", o.cursor );\n\n\t\t\tthis.storedStylesheet = $( \"<style>*{ cursor: \"+o.cursor+\" !important; }</style>\" ).appendTo( body );\n\t\t}\n\n\t\tif(o.opacity) { // opacity option\n\t\t\tif (this.helper.css(\"opacity\")) {\n\t\t\t\tthis._storedOpacity = this.helper.css(\"opacity\");\n\t\t\t}\n\t\t\tthis.helper.css(\"opacity\", o.opacity);\n\t\t}\n\n\t\tif(o.zIndex) { // zIndex option\n\t\t\tif (this.helper.css(\"zIndex\")) {\n\t\t\t\tthis._storedZIndex = this.helper.css(\"zIndex\");\n\t\t\t}\n\t\t\tthis.helper.css(\"zIndex\", o.zIndex);\n\t\t}\n\n\t\t//Prepare scrolling\n\t\tif(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== \"HTML\") {\n\t\t\tthis.overflowOffset = this.scrollParent.offset();\n\t\t}\n\n\t\t//Call callbacks\n\t\tthis._trigger(\"start\", event, this._uiHash());\n\n\t\t//Recache the helper size\n\t\tif(!this._preserveHelperProportions) {\n\t\t\tthis._cacheHelperProportions();\n\t\t}\n\n\n\t\t//Post \"activate\" events to possible containers\n\t\tif( !noActivation ) {\n\t\t\tfor ( i = this.containers.length - 1; i >= 0; i-- ) {\n\t\t\t\tthis.containers[ i ]._trigger( \"activate\", event, this._uiHash( this ) );\n\t\t\t}\n\t\t}\n\n\t\t//Prepare possible droppables\n\t\tif($.ui.ddmanager) {\n\t\t\t$.ui.ddmanager.current = this;\n\t\t}\n\n\t\tif ($.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t$.ui.ddmanager.prepareOffsets(this, event);\n\t\t}\n\n\t\tthis.dragging = true;\n\n\t\tthis.helper.addClass(\"ui-sortable-helper\");\n\t\tthis._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n\t\treturn true;\n\n\t},\n\n\t_mouseDrag: function(event) {\n\t\tvar i, item, itemElement, intersection,\n\t\t\to = this.options,\n\t\t\tscrolled = false;\n\n\t\t//Compute the helpers position\n\t\tthis.position = this._generatePosition(event);\n\t\tthis.positionAbs = this._convertPositionTo(\"absolute\");\n\n\t\tif (!this.lastPositionAbs) {\n\t\t\tthis.lastPositionAbs = this.positionAbs;\n\t\t}\n\n\t\t//Do scrolling\n\t\tif(this.options.scroll) {\n\t\t\tif(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== \"HTML\") {\n\n\t\t\t\tif((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {\n\t\t\t\t\tthis.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\n\t\t\t\t} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {\n\t\t\t\t\tthis.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\n\t\t\t\t}\n\n\t\t\t\tif((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {\n\t\t\t\t\tthis.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\n\t\t\t\t} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {\n\t\t\t\t\tthis.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n\t\t\t\t} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n\t\t\t\t}\n\n\t\t\t\tif(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n\t\t\t\t} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t\t$.ui.ddmanager.prepareOffsets(this, event);\n\t\t\t}\n\t\t}\n\n\t\t//Regenerate the absolute position used for position checks\n\t\tthis.positionAbs = this._convertPositionTo(\"absolute\");\n\n\t\t//Set the helper position\n\t\tif(!this.options.axis || this.options.axis !== \"y\") {\n\t\t\tthis.helper[0].style.left = this.position.left+\"px\";\n\t\t}\n\t\tif(!this.options.axis || this.options.axis !== \"x\") {\n\t\t\tthis.helper[0].style.top = this.position.top+\"px\";\n\t\t}\n\n\t\t//Rearrange\n\t\tfor (i = this.items.length - 1; i >= 0; i--) {\n\n\t\t\t//Cache variables and intersection, continue if no intersection\n\t\t\titem = this.items[i];\n\t\t\titemElement = item.item[0];\n\t\t\tintersection = this._intersectsWithPointer(item);\n\t\t\tif (!intersection) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Only put the placeholder inside the current Container, skip all\n\t\t\t// items from other containers. This works because when moving\n\t\t\t// an item from one container to another the\n\t\t\t// currentContainer is switched before the placeholder is moved.\n\t\t\t//\n\t\t\t// Without this, moving items in \"sub-sortables\" can cause\n\t\t\t// the placeholder to jitter beetween the outer and inner container.\n\t\t\tif (item.instance !== this.currentContainer) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// cannot intersect with itself\n\t\t\t// no useless actions that have been done before\n\t\t\t// no action if the item moved is the parent of the item checked\n\t\t\tif (itemElement !== this.currentItem[0] &&\n\t\t\t\tthis.placeholder[intersection === 1 ? \"next\" : \"prev\"]()[0] !== itemElement &&\n\t\t\t\t!$.contains(this.placeholder[0], itemElement) &&\n\t\t\t\t(this.options.type === \"semi-dynamic\" ? !$.contains(this.element[0], itemElement) : true)\n\t\t\t) {\n\n\t\t\t\tthis.direction = intersection === 1 ? \"down\" : \"up\";\n\n\t\t\t\tif (this.options.tolerance === \"pointer\" || this._intersectsWithSides(item)) {\n\t\t\t\t\tthis._rearrange(event, item);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tthis._trigger(\"change\", event, this._uiHash());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//Post events to containers\n\t\tthis._contactContainers(event);\n\n\t\t//Interconnect with droppables\n\t\tif($.ui.ddmanager) {\n\t\t\t$.ui.ddmanager.drag(this, event);\n\t\t}\n\n\t\t//Call callbacks\n\t\tthis._trigger(\"sort\", event, this._uiHash());\n\n\t\tthis.lastPositionAbs = this.positionAbs;\n\t\treturn false;\n\n\t},\n\n\t_mouseStop: function(event, noPropagation) {\n\n\t\tif(!event) {\n\t\t\treturn;\n\t\t}\n\n\t\t//If we are using droppables, inform the manager about the drop\n\t\tif ($.ui.ddmanager && !this.options.dropBehaviour) {\n\t\t\t$.ui.ddmanager.drop(this, event);\n\t\t}\n\n\t\tif(this.options.revert) {\n\t\t\tvar that = this,\n\t\t\t\tcur = this.placeholder.offset(),\n\t\t\t\taxis = this.options.axis,\n\t\t\t\tanimation = {};\n\n\t\t\tif ( !axis || axis === \"x\" ) {\n\t\t\t\tanimation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);\n\t\t\t}\n\t\t\tif ( !axis || axis === \"y\" ) {\n\t\t\t\tanimation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);\n\t\t\t}\n\t\t\tthis.reverting = true;\n\t\t\t$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {\n\t\t\t\tthat._clear(event);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._clear(event, noPropagation);\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tcancel: function() {\n\n\t\tif(this.dragging) {\n\n\t\t\tthis._mouseUp({ target: null });\n\n\t\t\tif(this.options.helper === \"original\") {\n\t\t\t\tthis.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n\t\t\t} else {\n\t\t\t\tthis.currentItem.show();\n\t\t\t}\n\n\t\t\t//Post deactivating events to containers\n\t\t\tfor (var i = this.containers.length - 1; i >= 0; i--){\n\t\t\t\tthis.containers[i]._trigger(\"deactivate\", null, this._uiHash(this));\n\t\t\t\tif(this.containers[i].containerCache.over) {\n\t\t\t\t\tthis.containers[i]._trigger(\"out\", null, this._uiHash(this));\n\t\t\t\t\tthis.containers[i].containerCache.over = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (this.placeholder) {\n\t\t\t//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n\t\t\tif(this.placeholder[0].parentNode) {\n\t\t\t\tthis.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n\t\t\t}\n\t\t\tif(this.options.helper !== \"original\" && this.helper && this.helper[0].parentNode) {\n\t\t\t\tthis.helper.remove();\n\t\t\t}\n\n\t\t\t$.extend(this, {\n\t\t\t\thelper: null,\n\t\t\t\tdragging: false,\n\t\t\t\treverting: false,\n\t\t\t\t_noFinalSort: null\n\t\t\t});\n\n\t\t\tif(this.domPosition.prev) {\n\t\t\t\t$(this.domPosition.prev).after(this.currentItem);\n\t\t\t} else {\n\t\t\t\t$(this.domPosition.parent).prepend(this.currentItem);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tserialize: function(o) {\n\n\t\tvar items = this._getItemsAsjQuery(o && o.connected),\n\t\t\tstr = [];\n\t\to = o || {};\n\n\t\t$(items).each(function() {\n\t\t\tvar res = ($(o.item || this).attr(o.attribute || \"id\") || \"\").match(o.expression || (/(.+)[\\-=_](.+)/));\n\t\t\tif (res) {\n\t\t\t\tstr.push((o.key || res[1]+\"[]\")+\"=\"+(o.key && o.expression ? res[1] : res[2]));\n\t\t\t}\n\t\t});\n\n\t\tif(!str.length && o.key) {\n\t\t\tstr.push(o.key + \"=\");\n\t\t}\n\n\t\treturn str.join(\"&\");\n\n\t},\n\n\ttoArray: function(o) {\n\n\t\tvar items = this._getItemsAsjQuery(o && o.connected),\n\t\t\tret = [];\n\n\t\to = o || {};\n\n\t\titems.each(function() { ret.push($(o.item || this).attr(o.attribute || \"id\") || \"\"); });\n\t\treturn ret;\n\n\t},\n\n\t/* Be careful with the following core functions */\n\t_intersectsWith: function(item) {\n\n\t\tvar x1 = this.positionAbs.left,\n\t\t\tx2 = x1 + this.helperProportions.width,\n\t\t\ty1 = this.positionAbs.top,\n\t\t\ty2 = y1 + this.helperProportions.height,\n\t\t\tl = item.left,\n\t\t\tr = l + item.width,\n\t\t\tt = item.top,\n\t\t\tb = t + item.height,\n\t\t\tdyClick = this.offset.click.top,\n\t\t\tdxClick = this.offset.click.left,\n\t\t\tisOverElementHeight = ( this.options.axis === \"x\" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),\n\t\t\tisOverElementWidth = ( this.options.axis === \"y\" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),\n\t\t\tisOverElement = isOverElementHeight && isOverElementWidth;\n\n\t\tif ( this.options.tolerance === \"pointer\" ||\n\t\t\tthis.options.forcePointerForContainers ||\n\t\t\t(this.options.tolerance !== \"pointer\" && this.helperProportions[this.floating ? \"width\" : \"height\"] > item[this.floating ? \"width\" : \"height\"])\n\t\t) {\n\t\t\treturn isOverElement;\n\t\t} else {\n\n\t\t\treturn (l < x1 + (this.helperProportions.width / 2) && // Right Half\n\t\t\t\tx2 - (this.helperProportions.width / 2) < r && // Left Half\n\t\t\t\tt < y1 + (this.helperProportions.height / 2) && // Bottom Half\n\t\t\t\ty2 - (this.helperProportions.height / 2) < b ); // Top Half\n\n\t\t}\n\t},\n\n\t_intersectsWithPointer: function(item) {\n\n\t\tvar isOverElementHeight = (this.options.axis === \"x\") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),\n\t\t\tisOverElementWidth = (this.options.axis === \"y\") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),\n\t\t\tisOverElement = isOverElementHeight && isOverElementWidth,\n\t\t\tverticalDirection = this._getDragVerticalDirection(),\n\t\t\thorizontalDirection = this._getDragHorizontalDirection();\n\n\t\tif (!isOverElement) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.floating ?\n\t\t\t( ((horizontalDirection && horizontalDirection === \"right\") || verticalDirection === \"down\") ? 2 : 1 )\n\t\t\t: ( verticalDirection && (verticalDirection === \"down\" ? 2 : 1) );\n\n\t},\n\n\t_intersectsWithSides: function(item) {\n\n\t\tvar isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),\n\t\t\tisOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),\n\t\t\tverticalDirection = this._getDragVerticalDirection(),\n\t\t\thorizontalDirection = this._getDragHorizontalDirection();\n\n\t\tif (this.floating && horizontalDirection) {\n\t\t\treturn ((horizontalDirection === \"right\" && isOverRightHalf) || (horizontalDirection === \"left\" && !isOverRightHalf));\n\t\t} else {\n\t\t\treturn verticalDirection && ((verticalDirection === \"down\" && isOverBottomHalf) || (verticalDirection === \"up\" && !isOverBottomHalf));\n\t\t}\n\n\t},\n\n\t_getDragVerticalDirection: function() {\n\t\tvar delta = this.positionAbs.top - this.lastPositionAbs.top;\n\t\treturn delta !== 0 && (delta > 0 ? \"down\" : \"up\");\n\t},\n\n\t_getDragHorizontalDirection: function() {\n\t\tvar delta = this.positionAbs.left - this.lastPositionAbs.left;\n\t\treturn delta !== 0 && (delta > 0 ? \"right\" : \"left\");\n\t},\n\n\trefresh: function(event) {\n\t\tthis._refreshItems(event);\n\t\tthis.refreshPositions();\n\t\treturn this;\n\t},\n\n\t_connectWith: function() {\n\t\tvar options = this.options;\n\t\treturn options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;\n\t},\n\n\t_getItemsAsjQuery: function(connected) {\n\n\t\tvar i, j, cur, inst,\n\t\t\titems = [],\n\t\t\tqueries = [],\n\t\t\tconnectWith = this._connectWith();\n\n\t\tif(connectWith && connected) {\n\t\t\tfor (i = connectWith.length - 1; i >= 0; i--){\n\t\t\t\tcur = $(connectWith[i]);\n\t\t\t\tfor ( j = cur.length - 1; j >= 0; j--){\n\t\t\t\t\tinst = $.data(cur[j], this.widgetFullName);\n\t\t\t\t\tif(inst && inst !== this && !inst.options.disabled) {\n\t\t\t\t\t\tqueries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(\".ui-sortable-helper\").not(\".ui-sortable-placeholder\"), inst]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(\".ui-sortable-helper\").not(\".ui-sortable-placeholder\"), this]);\n\n\t\tfunction addItems() {\n\t\t\titems.push( this );\n\t\t}\n\t\tfor (i = queries.length - 1; i >= 0; i--){\n\t\t\tqueries[i][0].each( addItems );\n\t\t}\n\n\t\treturn $(items);\n\n\t},\n\n\t_removeCurrentsFromItems: function() {\n\n\t\tvar list = this.currentItem.find(\":data(\" + this.widgetName + \"-item)\");\n\n\t\tthis.items = $.grep(this.items, function (item) {\n\t\t\tfor (var j=0; j < list.length; j++) {\n\t\t\t\tif(list[j] === item.item[0]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t},\n\n\t_refreshItems: function(event) {\n\n\t\tthis.items = [];\n\t\tthis.containers = [this];\n\n\t\tvar i, j, cur, inst, targetData, _queries, item, queriesLength,\n\t\t\titems = this.items,\n\t\t\tqueries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],\n\t\t\tconnectWith = this._connectWith();\n\n\t\tif(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down\n\t\t\tfor (i = connectWith.length - 1; i >= 0; i--){\n\t\t\t\tcur = $(connectWith[i]);\n\t\t\t\tfor (j = cur.length - 1; j >= 0; j--){\n\t\t\t\t\tinst = $.data(cur[j], this.widgetFullName);\n\t\t\t\t\tif(inst && inst !== this && !inst.options.disabled) {\n\t\t\t\t\t\tqueries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);\n\t\t\t\t\t\tthis.containers.push(inst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = queries.length - 1; i >= 0; i--) {\n\t\t\ttargetData = queries[i][1];\n\t\t\t_queries = queries[i][0];\n\n\t\t\tfor (j=0, queriesLength = _queries.length; j < queriesLength; j++) {\n\t\t\t\titem = $(_queries[j]);\n\n\t\t\t\titem.data(this.widgetName + \"-item\", targetData); // Data for target checking (mouse manager)\n\n\t\t\t\titems.push({\n\t\t\t\t\titem: item,\n\t\t\t\t\tinstance: targetData,\n\t\t\t\t\twidth: 0, height: 0,\n\t\t\t\t\tleft: 0, top: 0\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t},\n\n\trefreshPositions: function(fast) {\n\n\t\t//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change\n\t\tif(this.offsetParent && this.helper) {\n\t\t\tthis.offset.parent = this._getParentOffset();\n\t\t}\n\n\t\tvar i, item, t, p;\n\n\t\tfor (i = this.items.length - 1; i >= 0; i--){\n\t\t\titem = this.items[i];\n\n\t\t\t//We ignore calculating positions of all connected containers when we're not over them\n\t\t\tif(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tt = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;\n\n\t\t\tif (!fast) {\n\t\t\t\titem.width = t.outerWidth();\n\t\t\t\titem.height = t.outerHeight();\n\t\t\t}\n\n\t\t\tp = t.offset();\n\t\t\titem.left = p.left;\n\t\t\titem.top = p.top;\n\t\t}\n\n\t\tif(this.options.custom && this.options.custom.refreshContainers) {\n\t\t\tthis.options.custom.refreshContainers.call(this);\n\t\t} else {\n\t\t\tfor (i = this.containers.length - 1; i >= 0; i--){\n\t\t\t\tp = this.containers[i].element.offset();\n\t\t\t\tthis.containers[i].containerCache.left = p.left;\n\t\t\t\tthis.containers[i].containerCache.top = p.top;\n\t\t\t\tthis.containers[i].containerCache.width\t= this.containers[i].element.outerWidth();\n\t\t\t\tthis.containers[i].containerCache.height = this.containers[i].element.outerHeight();\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_createPlaceholder: function(that) {\n\t\tthat = that || this;\n\t\tvar className,\n\t\t\to = that.options;\n\n\t\tif(!o.placeholder || o.placeholder.constructor === String) {\n\t\t\tclassName = o.placeholder;\n\t\t\to.placeholder = {\n\t\t\t\telement: function() {\n\n\t\t\t\t\tvar nodeName = that.currentItem[0].nodeName.toLowerCase(),\n\t\t\t\t\t\telement = $( \"<\" + nodeName + \">\", that.document[0] )\n\t\t\t\t\t\t\t.addClass(className || that.currentItem[0].className+\" ui-sortable-placeholder\")\n\t\t\t\t\t\t\t.removeClass(\"ui-sortable-helper\");\n\n\t\t\t\t\tif ( nodeName === \"tr\" ) {\n\t\t\t\t\t\tthat.currentItem.children().each(function() {\n\t\t\t\t\t\t\t$( \"<td>&#160;</td>\", that.document[0] )\n\t\t\t\t\t\t\t\t.attr( \"colspan\", $( this ).attr( \"colspan\" ) || 1 )\n\t\t\t\t\t\t\t\t.appendTo( element );\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if ( nodeName === \"img\" ) {\n\t\t\t\t\t\telement.attr( \"src\", that.currentItem.attr( \"src\" ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !className ) {\n\t\t\t\t\t\telement.css( \"visibility\", \"hidden\" );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn element;\n\t\t\t\t},\n\t\t\t\tupdate: function(container, p) {\n\n\t\t\t\t\t// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that\n\t\t\t\t\t// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified\n\t\t\t\t\tif(className && !o.forcePlaceholderSize) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item\n\t\t\t\t\tif(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css(\"paddingTop\")||0, 10) - parseInt(that.currentItem.css(\"paddingBottom\")||0, 10)); }\n\t\t\t\t\tif(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css(\"paddingLeft\")||0, 10) - parseInt(that.currentItem.css(\"paddingRight\")||0, 10)); }\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t//Create the placeholder\n\t\tthat.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));\n\n\t\t//Append it after the actual current item\n\t\tthat.currentItem.after(that.placeholder);\n\n\t\t//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)\n\t\to.placeholder.update(that, that.placeholder);\n\n\t},\n\n\t_contactContainers: function(event) {\n\t\tvar i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,\n\t\t\tinnermostContainer = null,\n\t\t\tinnermostIndex = null;\n\n\t\t// get innermost container that intersects with item\n\t\tfor (i = this.containers.length - 1; i >= 0; i--) {\n\n\t\t\t// never consider a container that's located within the item itself\n\t\t\tif($.contains(this.currentItem[0], this.containers[i].element[0])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(this._intersectsWith(this.containers[i].containerCache)) {\n\n\t\t\t\t// if we've already found a container and it's more \"inner\" than this, then continue\n\t\t\t\tif(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tinnermostContainer = this.containers[i];\n\t\t\t\tinnermostIndex = i;\n\n\t\t\t} else {\n\t\t\t\t// container doesn't intersect. trigger \"out\" event if necessary\n\t\t\t\tif(this.containers[i].containerCache.over) {\n\t\t\t\t\tthis.containers[i]._trigger(\"out\", event, this._uiHash(this));\n\t\t\t\t\tthis.containers[i].containerCache.over = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// if no intersecting containers found, return\n\t\tif(!innermostContainer) {\n\t\t\treturn;\n\t\t}\n\n\t\t// move the item into the container if it's not there already\n\t\tif(this.containers.length === 1) {\n\t\t\tif (!this.containers[innermostIndex].containerCache.over) {\n\t\t\t\tthis.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n\t\t\t\tthis.containers[innermostIndex].containerCache.over = 1;\n\t\t\t}\n\t\t} else {\n\n\t\t\t//When entering a new container, we will find the item with the least distance and append our item near it\n\t\t\tdist = 10000;\n\t\t\titemWithLeastDistance = null;\n\t\t\tfloating = innermostContainer.floating || isFloating(this.currentItem);\n\t\t\tposProperty = floating ? \"left\" : \"top\";\n\t\t\tsizeProperty = floating ? \"width\" : \"height\";\n\t\t\tbase = this.positionAbs[posProperty] + this.offset.click[posProperty];\n\t\t\tfor (j = this.items.length - 1; j >= 0; j--) {\n\t\t\t\tif(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(this.items[j].item[0] === this.currentItem[0]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcur = this.items[j].item.offset()[posProperty];\n\t\t\t\tnearBottom = false;\n\t\t\t\tif(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){\n\t\t\t\t\tnearBottom = true;\n\t\t\t\t\tcur += this.items[j][sizeProperty];\n\t\t\t\t}\n\n\t\t\t\tif(Math.abs(cur - base) < dist) {\n\t\t\t\t\tdist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];\n\t\t\t\t\tthis.direction = nearBottom ? \"up\": \"down\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Check if dropOnEmpty is enabled\n\t\t\tif(!itemWithLeastDistance && !this.options.dropOnEmpty) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(this.currentContainer === this.containers[innermostIndex]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);\n\t\t\tthis._trigger(\"change\", event, this._uiHash());\n\t\t\tthis.containers[innermostIndex]._trigger(\"change\", event, this._uiHash(this));\n\t\t\tthis.currentContainer = this.containers[innermostIndex];\n\n\t\t\t//Update the placeholder\n\t\t\tthis.options.placeholder.update(this.currentContainer, this.placeholder);\n\n\t\t\tthis.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n\t\t\tthis.containers[innermostIndex].containerCache.over = 1;\n\t\t}\n\n\n\t},\n\n\t_createHelper: function(event) {\n\n\t\tvar o = this.options,\n\t\t\thelper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === \"clone\" ? this.currentItem.clone() : this.currentItem);\n\n\t\t//Add the helper to the DOM if that didn't happen already\n\t\tif(!helper.parents(\"body\").length) {\n\t\t\t$(o.appendTo !== \"parent\" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);\n\t\t}\n\n\t\tif(helper[0] === this.currentItem[0]) {\n\t\t\tthis._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css(\"position\"), top: this.currentItem.css(\"top\"), left: this.currentItem.css(\"left\") };\n\t\t}\n\n\t\tif(!helper[0].style.width || o.forceHelperSize) {\n\t\t\thelper.width(this.currentItem.width());\n\t\t}\n\t\tif(!helper[0].style.height || o.forceHelperSize) {\n\t\t\thelper.height(this.currentItem.height());\n\t\t}\n\n\t\treturn helper;\n\n\t},\n\n\t_adjustOffsetFromHelper: function(obj) {\n\t\tif (typeof obj === \"string\") {\n\t\t\tobj = obj.split(\" \");\n\t\t}\n\t\tif ($.isArray(obj)) {\n\t\t\tobj = {left: +obj[0], top: +obj[1] || 0};\n\t\t}\n\t\tif (\"left\" in obj) {\n\t\t\tthis.offset.click.left = obj.left + this.margins.left;\n\t\t}\n\t\tif (\"right\" in obj) {\n\t\t\tthis.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n\t\t}\n\t\tif (\"top\" in obj) {\n\t\t\tthis.offset.click.top = obj.top + this.margins.top;\n\t\t}\n\t\tif (\"bottom\" in obj) {\n\t\t\tthis.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n\t\t}\n\t},\n\n\t_getParentOffset: function() {\n\n\n\t\t//Get the offsetParent and cache its position\n\t\tthis.offsetParent = this.helper.offsetParent();\n\t\tvar po = this.offsetParent.offset();\n\n\t\t// This is a special case where we need to modify a offset calculated on start, since the following happened:\n\t\t// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n\t\t// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n\t\t//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n\t\tif(this.cssPosition === \"absolute\" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n\t\t\tpo.left += this.scrollParent.scrollLeft();\n\t\t\tpo.top += this.scrollParent.scrollTop();\n\t\t}\n\n\t\t// This needs to be actually done for all browsers, since pageX/pageY includes this information\n\t\t// with an ugly IE fix\n\t\tif( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === \"html\" && $.ui.ie)) {\n\t\t\tpo = { top: 0, left: 0 };\n\t\t}\n\n\t\treturn {\n\t\t\ttop: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"),10) || 0),\n\t\t\tleft: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"),10) || 0)\n\t\t};\n\n\t},\n\n\t_getRelativeOffset: function() {\n\n\t\tif(this.cssPosition === \"relative\") {\n\t\t\tvar p = this.currentItem.position();\n\t\t\treturn {\n\t\t\t\ttop: p.top - (parseInt(this.helper.css(\"top\"),10) || 0) + this.scrollParent.scrollTop(),\n\t\t\t\tleft: p.left - (parseInt(this.helper.css(\"left\"),10) || 0) + this.scrollParent.scrollLeft()\n\t\t\t};\n\t\t} else {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t},\n\n\t_cacheMargins: function() {\n\t\tthis.margins = {\n\t\t\tleft: (parseInt(this.currentItem.css(\"marginLeft\"),10) || 0),\n\t\t\ttop: (parseInt(this.currentItem.css(\"marginTop\"),10) || 0)\n\t\t};\n\t},\n\n\t_cacheHelperProportions: function() {\n\t\tthis.helperProportions = {\n\t\t\twidth: this.helper.outerWidth(),\n\t\t\theight: this.helper.outerHeight()\n\t\t};\n\t},\n\n\t_setContainment: function() {\n\n\t\tvar ce, co, over,\n\t\t\to = this.options;\n\t\tif(o.containment === \"parent\") {\n\t\t\to.containment = this.helper[0].parentNode;\n\t\t}\n\t\tif(o.containment === \"document\" || o.containment === \"window\") {\n\t\t\tthis.containment = [\n\t\t\t\t0 - this.offset.relative.left - this.offset.parent.left,\n\t\t\t\t0 - this.offset.relative.top - this.offset.parent.top,\n\t\t\t\t$(o.containment === \"document\" ? document : window).width() - this.helperProportions.width - this.margins.left,\n\t\t\t\t($(o.containment === \"document\" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top\n\t\t\t];\n\t\t}\n\n\t\tif(!(/^(document|window|parent)$/).test(o.containment)) {\n\t\t\tce = $(o.containment)[0];\n\t\t\tco = $(o.containment).offset();\n\t\t\tover = ($(ce).css(\"overflow\") !== \"hidden\");\n\n\t\t\tthis.containment = [\n\t\t\t\tco.left + (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingLeft\"),10) || 0) - this.margins.left,\n\t\t\t\tco.top + (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingTop\"),10) || 0) - this.margins.top,\n\t\t\t\tco.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingRight\"),10) || 0) - this.helperProportions.width - this.margins.left,\n\t\t\t\tco.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingBottom\"),10) || 0) - this.helperProportions.height - this.margins.top\n\t\t\t];\n\t\t}\n\n\t},\n\n\t_convertPositionTo: function(d, pos) {\n\n\t\tif(!pos) {\n\t\t\tpos = this.position;\n\t\t}\n\t\tvar mod = d === \"absolute\" ? 1 : -1,\n\t\t\tscroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\n\t\t\tscrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n\t\treturn {\n\t\t\ttop: (\n\t\t\t\tpos.top\t+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.relative.top * mod +\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top * mod -\t\t\t\t\t\t\t\t\t\t\t// The offsetParent's offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)\n\t\t\t),\n\t\t\tleft: (\n\t\t\t\tpos.left +\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.relative.left * mod +\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left * mod\t-\t\t\t\t\t\t\t\t\t\t// The offsetParent's offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)\n\t\t\t)\n\t\t};\n\n\t},\n\n\t_generatePosition: function(event) {\n\n\t\tvar top, left,\n\t\t\to = this.options,\n\t\t\tpageX = event.pageX,\n\t\t\tpageY = event.pageY,\n\t\t\tscroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n\t\t// This is another very weird special case that only happens for relative elements:\n\t\t// 1. If the css position is relative\n\t\t// 2. and the scroll parent is the document or similar to the offset parent\n\t\t// we have to refresh the relative offset during the scroll so there are no jumps\n\t\tif(this.cssPosition === \"relative\" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {\n\t\t\tthis.offset.relative = this._getRelativeOffset();\n\t\t}\n\n\t\t/*\n\t\t * - Position constraining -\n\t\t * Constrain the position to a mix of grid, containment.\n\t\t */\n\n\t\tif(this.originalPosition) { //If we are not dragging yet, we won't check for options\n\n\t\t\tif(this.containment) {\n\t\t\t\tif(event.pageX - this.offset.click.left < this.containment[0]) {\n\t\t\t\t\tpageX = this.containment[0] + this.offset.click.left;\n\t\t\t\t}\n\t\t\t\tif(event.pageY - this.offset.click.top < this.containment[1]) {\n\t\t\t\t\tpageY = this.containment[1] + this.offset.click.top;\n\t\t\t\t}\n\t\t\t\tif(event.pageX - this.offset.click.left > this.containment[2]) {\n\t\t\t\t\tpageX = this.containment[2] + this.offset.click.left;\n\t\t\t\t}\n\t\t\t\tif(event.pageY - this.offset.click.top > this.containment[3]) {\n\t\t\t\t\tpageY = this.containment[3] + this.offset.click.top;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(o.grid) {\n\t\t\t\ttop = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];\n\t\t\t\tpageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\n\n\t\t\t\tleft = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];\n\t\t\t\tpageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttop: (\n\t\t\t\tpageY -\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.click.top -\t\t\t\t\t\t\t\t\t\t\t\t\t// Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.top\t-\t\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top +\t\t\t\t\t\t\t\t\t\t\t\t// The offsetParent's offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))\n\t\t\t),\n\t\t\tleft: (\n\t\t\t\tpageX -\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.click.left -\t\t\t\t\t\t\t\t\t\t\t\t// Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.left\t-\t\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left +\t\t\t\t\t\t\t\t\t\t\t\t// The offsetParent's offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))\n\t\t\t)\n\t\t};\n\n\t},\n\n\t_rearrange: function(event, i, a, hardRefresh) {\n\n\t\ta ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === \"down\" ? i.item[0] : i.item[0].nextSibling));\n\n\t\t//Various things done here to improve the performance:\n\t\t// 1. we create a setTimeout, that calls refreshPositions\n\t\t// 2. on the instance, we have a counter variable, that get's higher after every append\n\t\t// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same\n\t\t// 4. this lets only the last addition to the timeout stack through\n\t\tthis.counter = this.counter ? ++this.counter : 1;\n\t\tvar counter = this.counter;\n\n\t\tthis._delay(function() {\n\t\t\tif(counter === this.counter) {\n\t\t\t\tthis.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove\n\t\t\t}\n\t\t});\n\n\t},\n\n\t_clear: function(event, noPropagation) {\n\n\t\tthis.reverting = false;\n\t\t// We delay all events that have to be triggered to after the point where the placeholder has been removed and\n\t\t// everything else normalized again\n\t\tvar i,\n\t\t\tdelayedTriggers = [];\n\n\t\t// We first have to update the dom position of the actual currentItem\n\t\t// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)\n\t\tif(!this._noFinalSort && this.currentItem.parent().length) {\n\t\t\tthis.placeholder.before(this.currentItem);\n\t\t}\n\t\tthis._noFinalSort = null;\n\n\t\tif(this.helper[0] === this.currentItem[0]) {\n\t\t\tfor(i in this._storedCSS) {\n\t\t\t\tif(this._storedCSS[i] === \"auto\" || this._storedCSS[i] === \"static\") {\n\t\t\t\t\tthis._storedCSS[i] = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n\t\t} else {\n\t\t\tthis.currentItem.show();\n\t\t}\n\n\t\tif(this.fromOutside && !noPropagation) {\n\t\t\tdelayedTriggers.push(function(event) { this._trigger(\"receive\", event, this._uiHash(this.fromOutside)); });\n\t\t}\n\t\tif((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(\".ui-sortable-helper\")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {\n\t\t\tdelayedTriggers.push(function(event) { this._trigger(\"update\", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed\n\t\t}\n\n\t\t// Check if the items Container has Changed and trigger appropriate\n\t\t// events.\n\t\tif (this !== this.currentContainer) {\n\t\t\tif(!noPropagation) {\n\t\t\t\tdelayedTriggers.push(function(event) { this._trigger(\"remove\", event, this._uiHash()); });\n\t\t\t\tdelayedTriggers.push((function(c) { return function(event) { c._trigger(\"receive\", event, this._uiHash(this)); };  }).call(this, this.currentContainer));\n\t\t\t\tdelayedTriggers.push((function(c) { return function(event) { c._trigger(\"update\", event, this._uiHash(this));  }; }).call(this, this.currentContainer));\n\t\t\t}\n\t\t}\n\n\n\t\t//Post events to containers\n\t\tfunction delayEvent( type, instance, container ) {\n\t\t\treturn function( event ) {\n\t\t\t\tcontainer._trigger( type, event, instance._uiHash( instance ) );\n\t\t\t};\n\t\t}\n\t\tfor (i = this.containers.length - 1; i >= 0; i--){\n\t\t\tif (!noPropagation) {\n\t\t\t\tdelayedTriggers.push( delayEvent( \"deactivate\", this, this.containers[ i ] ) );\n\t\t\t}\n\t\t\tif(this.containers[i].containerCache.over) {\n\t\t\t\tdelayedTriggers.push( delayEvent( \"out\", this, this.containers[ i ] ) );\n\t\t\t\tthis.containers[i].containerCache.over = 0;\n\t\t\t}\n\t\t}\n\n\t\t//Do what was originally in plugins\n\t\tif ( this.storedCursor ) {\n\t\t\tthis.document.find( \"body\" ).css( \"cursor\", this.storedCursor );\n\t\t\tthis.storedStylesheet.remove();\n\t\t}\n\t\tif(this._storedOpacity) {\n\t\t\tthis.helper.css(\"opacity\", this._storedOpacity);\n\t\t}\n\t\tif(this._storedZIndex) {\n\t\t\tthis.helper.css(\"zIndex\", this._storedZIndex === \"auto\" ? \"\" : this._storedZIndex);\n\t\t}\n\n\t\tthis.dragging = false;\n\t\tif(this.cancelHelperRemoval) {\n\t\t\tif(!noPropagation) {\n\t\t\t\tthis._trigger(\"beforeStop\", event, this._uiHash());\n\t\t\t\tfor (i=0; i < delayedTriggers.length; i++) {\n\t\t\t\t\tdelayedTriggers[i].call(this, event);\n\t\t\t\t} //Trigger all delayed events\n\t\t\t\tthis._trigger(\"stop\", event, this._uiHash());\n\t\t\t}\n\n\t\t\tthis.fromOutside = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tif(!noPropagation) {\n\t\t\tthis._trigger(\"beforeStop\", event, this._uiHash());\n\t\t}\n\n\t\t//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n\t\tthis.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n\n\t\tif(this.helper[0] !== this.currentItem[0]) {\n\t\t\tthis.helper.remove();\n\t\t}\n\t\tthis.helper = null;\n\n\t\tif(!noPropagation) {\n\t\t\tfor (i=0; i < delayedTriggers.length; i++) {\n\t\t\t\tdelayedTriggers[i].call(this, event);\n\t\t\t} //Trigger all delayed events\n\t\t\tthis._trigger(\"stop\", event, this._uiHash());\n\t\t}\n\n\t\tthis.fromOutside = false;\n\t\treturn true;\n\n\t},\n\n\t_trigger: function() {\n\t\tif ($.Widget.prototype._trigger.apply(this, arguments) === false) {\n\t\t\tthis.cancel();\n\t\t}\n\t},\n\n\t_uiHash: function(_inst) {\n\t\tvar inst = _inst || this;\n\t\treturn {\n\t\t\thelper: inst.helper,\n\t\t\tplaceholder: inst.placeholder || $([]),\n\t\t\tposition: inst.position,\n\t\t\toriginalPosition: inst.originalPosition,\n\t\t\toffset: inst.positionAbs,\n\t\t\titem: inst.currentItem,\n\t\t\tsender: _inst ? _inst.element : null\n\t\t};\n\t}\n\n});\n\n})(jQuery);\n","var jQuery = require('jquery');\nrequire('./core');\nrequire('./widget');\nrequire('./button');\n\n/*!\n * jQuery UI Spinner 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/spinner/\n *\n * Depends:\n *  jquery.ui.core.js\n *  jquery.ui.widget.js\n *  jquery.ui.button.js\n */\n(function( $ ) {\n\nfunction modifier( fn ) {\n\treturn function() {\n\t\tvar previous = this.element.val();\n\t\tfn.apply( this, arguments );\n\t\tthis._refresh();\n\t\tif ( previous !== this.element.val() ) {\n\t\t\tthis._trigger( \"change\" );\n\t\t}\n\t};\n}\n\n$.widget( \"ui.spinner\", {\n\tversion: \"1.10.4\",\n\tdefaultElement: \"<input>\",\n\twidgetEventPrefix: \"spin\",\n\toptions: {\n\t\tculture: null,\n\t\ticons: {\n\t\t\tdown: \"ui-icon-triangle-1-s\",\n\t\t\tup: \"ui-icon-triangle-1-n\"\n\t\t},\n\t\tincremental: true,\n\t\tmax: null,\n\t\tmin: null,\n\t\tnumberFormat: null,\n\t\tpage: 10,\n\t\tstep: 1,\n\n\t\tchange: null,\n\t\tspin: null,\n\t\tstart: null,\n\t\tstop: null\n\t},\n\n\t_create: function() {\n\t\t// handle string values that need to be parsed\n\t\tthis._setOption( \"max\", this.options.max );\n\t\tthis._setOption( \"min\", this.options.min );\n\t\tthis._setOption( \"step\", this.options.step );\n\n\t\t// Only format if there is a value, prevents the field from being marked\n\t\t// as invalid in Firefox, see #9573.\n\t\tif ( this.value() !== \"\" ) {\n\t\t\t// Format the value, but don't constrain.\n\t\t\tthis._value( this.element.val(), true );\n\t\t}\n\n\t\tthis._draw();\n\t\tthis._on( this._events );\n\t\tthis._refresh();\n\n\t\t// turning off autocomplete prevents the browser from remembering the\n\t\t// value when navigating through history, so we re-enable autocomplete\n\t\t// if the page is unloaded before the widget is destroyed. #7790\n\t\tthis._on( this.window, {\n\t\t\tbeforeunload: function() {\n\t\t\t\tthis.element.removeAttr( \"autocomplete\" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_getCreateOptions: function() {\n\t\tvar options = {},\n\t\t\telement = this.element;\n\n\t\t$.each( [ \"min\", \"max\", \"step\" ], function( i, option ) {\n\t\t\tvar value = element.attr( option );\n\t\t\tif ( value !== undefined && value.length ) {\n\t\t\t\toptions[ option ] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn options;\n\t},\n\n\t_events: {\n\t\tkeydown: function( event ) {\n\t\t\tif ( this._start( event ) && this._keydown( event ) ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t},\n\t\tkeyup: \"_stop\",\n\t\tfocus: function() {\n\t\t\tthis.previous = this.element.val();\n\t\t},\n\t\tblur: function( event ) {\n\t\t\tif ( this.cancelBlur ) {\n\t\t\t\tdelete this.cancelBlur;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._stop();\n\t\t\tthis._refresh();\n\t\t\tif ( this.previous !== this.element.val() ) {\n\t\t\t\tthis._trigger( \"change\", event );\n\t\t\t}\n\t\t},\n\t\tmousewheel: function( event, delta ) {\n\t\t\tif ( !delta ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( !this.spinning && !this._start( event ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis._spin( (delta > 0 ? 1 : -1) * this.options.step, event );\n\t\t\tclearTimeout( this.mousewheelTimer );\n\t\t\tthis.mousewheelTimer = this._delay(function() {\n\t\t\t\tif ( this.spinning ) {\n\t\t\t\t\tthis._stop( event );\n\t\t\t\t}\n\t\t\t}, 100 );\n\t\t\tevent.preventDefault();\n\t\t},\n\t\t\"mousedown .ui-spinner-button\": function( event ) {\n\t\t\tvar previous;\n\n\t\t\t// We never want the buttons to have focus; whenever the user is\n\t\t\t// interacting with the spinner, the focus should be on the input.\n\t\t\t// If the input is focused then this.previous is properly set from\n\t\t\t// when the input first received focus. If the input is not focused\n\t\t\t// then we need to set this.previous based on the value before spinning.\n\t\t\tprevious = this.element[0] === this.document[0].activeElement ?\n\t\t\t\tthis.previous : this.element.val();\n\t\t\tfunction checkFocus() {\n\t\t\t\tvar isActive = this.element[0] === this.document[0].activeElement;\n\t\t\t\tif ( !isActive ) {\n\t\t\t\t\tthis.element.focus();\n\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t// support: IE\n\t\t\t\t\t// IE sets focus asynchronously, so we need to check if focus\n\t\t\t\t\t// moved off of the input because the user clicked on the button.\n\t\t\t\t\tthis._delay(function() {\n\t\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ensure focus is on (or stays on) the text field\n\t\t\tevent.preventDefault();\n\t\t\tcheckFocus.call( this );\n\n\t\t\t// support: IE\n\t\t\t// IE doesn't prevent moving focus even with event.preventDefault()\n\t\t\t// so we set a flag to know when we should ignore the blur event\n\t\t\t// and check (again) if focus moved off of the input.\n\t\t\tthis.cancelBlur = true;\n\t\t\tthis._delay(function() {\n\t\t\t\tdelete this.cancelBlur;\n\t\t\t\tcheckFocus.call( this );\n\t\t\t});\n\n\t\t\tif ( this._start( event ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._repeat( null, $( event.currentTarget ).hasClass( \"ui-spinner-up\" ) ? 1 : -1, event );\n\t\t},\n\t\t\"mouseup .ui-spinner-button\": \"_stop\",\n\t\t\"mouseenter .ui-spinner-button\": function( event ) {\n\t\t\t// button will add ui-state-active if mouse was down while mouseleave and kept down\n\t\t\tif ( !$( event.currentTarget ).hasClass( \"ui-state-active\" ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( this._start( event ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._repeat( null, $( event.currentTarget ).hasClass( \"ui-spinner-up\" ) ? 1 : -1, event );\n\t\t},\n\t\t// TODO: do we really want to consider this a stop?\n\t\t// shouldn't we just stop the repeater and wait until mouseup before\n\t\t// we trigger the stop event?\n\t\t\"mouseleave .ui-spinner-button\": \"_stop\"\n\t},\n\n\t_draw: function() {\n\t\tvar uiSpinner = this.uiSpinner = this.element\n\t\t\t.addClass( \"ui-spinner-input\" )\n\t\t\t.attr( \"autocomplete\", \"off\" )\n\t\t\t.wrap( this._uiSpinnerHtml() )\n\t\t\t.parent()\n\t\t\t\t// add buttons\n\t\t\t\t.append( this._buttonHtml() );\n\n\t\tthis.element.attr( \"role\", \"spinbutton\" );\n\n\t\t// button bindings\n\t\tthis.buttons = uiSpinner.find( \".ui-spinner-button\" )\n\t\t\t.attr( \"tabIndex\", -1 )\n\t\t\t.button()\n\t\t\t.removeClass( \"ui-corner-all\" );\n\n\t\t// IE 6 doesn't understand height: 50% for the buttons\n\t\t// unless the wrapper has an explicit height\n\t\tif ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&\n\t\t\t\tuiSpinner.height() > 0 ) {\n\t\t\tuiSpinner.height( uiSpinner.height() );\n\t\t}\n\n\t\t// disable spinner if element was already disabled\n\t\tif ( this.options.disabled ) {\n\t\t\tthis.disable();\n\t\t}\n\t},\n\n\t_keydown: function( event ) {\n\t\tvar options = this.options,\n\t\t\tkeyCode = $.ui.keyCode;\n\n\t\tswitch ( event.keyCode ) {\n\t\tcase keyCode.UP:\n\t\t\tthis._repeat( null, 1, event );\n\t\t\treturn true;\n\t\tcase keyCode.DOWN:\n\t\t\tthis._repeat( null, -1, event );\n\t\t\treturn true;\n\t\tcase keyCode.PAGE_UP:\n\t\t\tthis._repeat( null, options.page, event );\n\t\t\treturn true;\n\t\tcase keyCode.PAGE_DOWN:\n\t\t\tthis._repeat( null, -options.page, event );\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_uiSpinnerHtml: function() {\n\t\treturn \"<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>\";\n\t},\n\n\t_buttonHtml: function() {\n\t\treturn \"\" +\n\t\t\t\"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>\" +\n\t\t\t\t\"<span class='ui-icon \" + this.options.icons.up + \"'>&#9650;</span>\" +\n\t\t\t\"</a>\" +\n\t\t\t\"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>\" +\n\t\t\t\t\"<span class='ui-icon \" + this.options.icons.down + \"'>&#9660;</span>\" +\n\t\t\t\"</a>\";\n\t},\n\n\t_start: function( event ) {\n\t\tif ( !this.spinning && this._trigger( \"start\", event ) === false ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !this.counter ) {\n\t\t\tthis.counter = 1;\n\t\t}\n\t\tthis.spinning = true;\n\t\treturn true;\n\t},\n\n\t_repeat: function( i, steps, event ) {\n\t\ti = i || 500;\n\n\t\tclearTimeout( this.timer );\n\t\tthis.timer = this._delay(function() {\n\t\t\tthis._repeat( 40, steps, event );\n\t\t}, i );\n\n\t\tthis._spin( steps * this.options.step, event );\n\t},\n\n\t_spin: function( step, event ) {\n\t\tvar value = this.value() || 0;\n\n\t\tif ( !this.counter ) {\n\t\t\tthis.counter = 1;\n\t\t}\n\n\t\tvalue = this._adjustValue( value + step * this._increment( this.counter ) );\n\n\t\tif ( !this.spinning || this._trigger( \"spin\", event, { value: value } ) !== false) {\n\t\t\tthis._value( value );\n\t\t\tthis.counter++;\n\t\t}\n\t},\n\n\t_increment: function( i ) {\n\t\tvar incremental = this.options.incremental;\n\n\t\tif ( incremental ) {\n\t\t\treturn $.isFunction( incremental ) ?\n\t\t\t\tincremental( i ) :\n\t\t\t\tMath.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );\n\t\t}\n\n\t\treturn 1;\n\t},\n\n\t_precision: function() {\n\t\tvar precision = this._precisionOf( this.options.step );\n\t\tif ( this.options.min !== null ) {\n\t\t\tprecision = Math.max( precision, this._precisionOf( this.options.min ) );\n\t\t}\n\t\treturn precision;\n\t},\n\n\t_precisionOf: function( num ) {\n\t\tvar str = num.toString(),\n\t\t\tdecimal = str.indexOf( \".\" );\n\t\treturn decimal === -1 ? 0 : str.length - decimal - 1;\n\t},\n\n\t_adjustValue: function( value ) {\n\t\tvar base, aboveMin,\n\t\t\toptions = this.options;\n\n\t\t// make sure we're at a valid step\n\t\t// - find out where we are relative to the base (min or 0)\n\t\tbase = options.min !== null ? options.min : 0;\n\t\taboveMin = value - base;\n\t\t// - round to the nearest step\n\t\taboveMin = Math.round(aboveMin / options.step) * options.step;\n\t\t// - rounding is based on 0, so adjust back to our base\n\t\tvalue = base + aboveMin;\n\n\t\t// fix precision from bad JS floating point math\n\t\tvalue = parseFloat( value.toFixed( this._precision() ) );\n\n\t\t// clamp the value\n\t\tif ( options.max !== null && value > options.max) {\n\t\t\treturn options.max;\n\t\t}\n\t\tif ( options.min !== null && value < options.min ) {\n\t\t\treturn options.min;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t_stop: function( event ) {\n\t\tif ( !this.spinning ) {\n\t\t\treturn;\n\t\t}\n\n\t\tclearTimeout( this.timer );\n\t\tclearTimeout( this.mousewheelTimer );\n\t\tthis.counter = 0;\n\t\tthis.spinning = false;\n\t\tthis._trigger( \"stop\", event );\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === \"culture\" || key === \"numberFormat\" ) {\n\t\t\tvar prevValue = this._parse( this.element.val() );\n\t\t\tthis.options[ key ] = value;\n\t\t\tthis.element.val( this._format( prevValue ) );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key === \"max\" || key === \"min\" || key === \"step\" ) {\n\t\t\tif ( typeof value === \"string\" ) {\n\t\t\t\tvalue = this._parse( value );\n\t\t\t}\n\t\t}\n\t\tif ( key === \"icons\" ) {\n\t\t\tthis.buttons.first().find( \".ui-icon\" )\n\t\t\t\t.removeClass( this.options.icons.up )\n\t\t\t\t.addClass( value.up );\n\t\t\tthis.buttons.last().find( \".ui-icon\" )\n\t\t\t\t.removeClass( this.options.icons.down )\n\t\t\t\t.addClass( value.down );\n\t\t}\n\n\t\tthis._super( key, value );\n\n\t\tif ( key === \"disabled\" ) {\n\t\t\tif ( value ) {\n\t\t\t\tthis.element.prop( \"disabled\", true );\n\t\t\t\tthis.buttons.button( \"disable\" );\n\t\t\t} else {\n\t\t\t\tthis.element.prop( \"disabled\", false );\n\t\t\t\tthis.buttons.button( \"enable\" );\n\t\t\t}\n\t\t}\n\t},\n\n\t_setOptions: modifier(function( options ) {\n\t\tthis._super( options );\n\t\tthis._value( this.element.val() );\n\t}),\n\n\t_parse: function( val ) {\n\t\tif ( typeof val === \"string\" && val !== \"\" ) {\n\t\t\tval = window.Globalize && this.options.numberFormat ?\n\t\t\t\tGlobalize.parseFloat( val, 10, this.options.culture ) : +val;\n\t\t}\n\t\treturn val === \"\" || isNaN( val ) ? null : val;\n\t},\n\n\t_format: function( value ) {\n\t\tif ( value === \"\" ) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn window.Globalize && this.options.numberFormat ?\n\t\t\tGlobalize.format( value, this.options.numberFormat, this.options.culture ) :\n\t\t\tvalue;\n\t},\n\n\t_refresh: function() {\n\t\tthis.element.attr({\n\t\t\t\"aria-valuemin\": this.options.min,\n\t\t\t\"aria-valuemax\": this.options.max,\n\t\t\t// TODO: what should we do with values that can't be parsed?\n\t\t\t\"aria-valuenow\": this._parse( this.element.val() )\n\t\t});\n\t},\n\n\t// update the value without triggering change\n\t_value: function( value, allowAny ) {\n\t\tvar parsed;\n\t\tif ( value !== \"\" ) {\n\t\t\tparsed = this._parse( value );\n\t\t\tif ( parsed !== null ) {\n\t\t\t\tif ( !allowAny ) {\n\t\t\t\t\tparsed = this._adjustValue( parsed );\n\t\t\t\t}\n\t\t\t\tvalue = this._format( parsed );\n\t\t\t}\n\t\t}\n\t\tthis.element.val( value );\n\t\tthis._refresh();\n\t},\n\n\t_destroy: function() {\n\t\tthis.element\n\t\t\t.removeClass( \"ui-spinner-input\" )\n\t\t\t.prop( \"disabled\", false )\n\t\t\t.removeAttr( \"autocomplete\" )\n\t\t\t.removeAttr( \"role\" )\n\t\t\t.removeAttr( \"aria-valuemin\" )\n\t\t\t.removeAttr( \"aria-valuemax\" )\n\t\t\t.removeAttr( \"aria-valuenow\" );\n\t\tthis.uiSpinner.replaceWith( this.element );\n\t},\n\n\tstepUp: modifier(function( steps ) {\n\t\tthis._stepUp( steps );\n\t}),\n\t_stepUp: function( steps ) {\n\t\tif ( this._start() ) {\n\t\t\tthis._spin( (steps || 1) * this.options.step );\n\t\t\tthis._stop();\n\t\t}\n\t},\n\n\tstepDown: modifier(function( steps ) {\n\t\tthis._stepDown( steps );\n\t}),\n\t_stepDown: function( steps ) {\n\t\tif ( this._start() ) {\n\t\t\tthis._spin( (steps || 1) * -this.options.step );\n\t\t\tthis._stop();\n\t\t}\n\t},\n\n\tpageUp: modifier(function( pages ) {\n\t\tthis._stepUp( (pages || 1) * this.options.page );\n\t}),\n\n\tpageDown: modifier(function( pages ) {\n\t\tthis._stepDown( (pages || 1) * this.options.page );\n\t}),\n\n\tvalue: function( newVal ) {\n\t\tif ( !arguments.length ) {\n\t\t\treturn this._parse( this.element.val() );\n\t\t}\n\t\tmodifier( this._value ).call( this, newVal );\n\t},\n\n\twidget: function() {\n\t\treturn this.uiSpinner;\n\t}\n});\n\n}( jQuery ) );\n","var jQuery = require('jquery');\n\n/*!\n * jQuery UI Widget 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/jQuery.widget/\n */\n(function( $, undefined ) {\n\nvar uuid = 0,\n\tslice = Array.prototype.slice,\n\t_cleanData = $.cleanData;\n$.cleanData = function( elems ) {\n\tfor ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\n\t\ttry {\n\t\t\t$( elem ).triggerHandler( \"remove\" );\n\t\t// http://bugs.jquery.com/ticket/8235\n\t\t} catch( e ) {}\n\t}\n\t_cleanData( elems );\n};\n\n$.widget = function( name, base, prototype ) {\n\tvar fullName, existingConstructor, constructor, basePrototype,\n\t\t// proxiedPrototype allows the provided prototype to remain unmodified\n\t\t// so that it can be used as a mixin for multiple widgets (#8876)\n\t\tproxiedPrototype = {},\n\t\tnamespace = name.split( \".\" )[ 0 ];\n\n\tname = name.split( \".\" )[ 1 ];\n\tfullName = namespace + \"-\" + name;\n\n\tif ( !prototype ) {\n\t\tprototype = base;\n\t\tbase = $.Widget;\n\t}\n\n\t// create selector for plugin\n\t$.expr[ \":\" ][ fullName.toLowerCase() ] = function( elem ) {\n\t\treturn !!$.data( elem, fullName );\n\t};\n\n\t$[ namespace ] = $[ namespace ] || {};\n\texistingConstructor = $[ namespace ][ name ];\n\tconstructor = $[ namespace ][ name ] = function( options, element ) {\n\t\t// allow instantiation without \"new\" keyword\n\t\tif ( !this._createWidget ) {\n\t\t\treturn new constructor( options, element );\n\t\t}\n\n\t\t// allow instantiation without initializing for simple inheritance\n\t\t// must use \"new\" keyword (the code above always passes args)\n\t\tif ( arguments.length ) {\n\t\t\tthis._createWidget( options, element );\n\t\t}\n\t};\n\t// extend with the existing constructor to carry over any static properties\n\t$.extend( constructor, existingConstructor, {\n\t\tversion: prototype.version,\n\t\t// copy the object used to create the prototype in case we need to\n\t\t// redefine the widget later\n\t\t_proto: $.extend( {}, prototype ),\n\t\t// track widgets that inherit from this widget in case this widget is\n\t\t// redefined after a widget inherits from it\n\t\t_childConstructors: []\n\t});\n\n\tbasePrototype = new base();\n\t// we need to make the options hash a property directly on the new instance\n\t// otherwise we'll modify the options hash on the prototype that we're\n\t// inheriting from\n\tbasePrototype.options = $.widget.extend( {}, basePrototype.options );\n\t$.each( prototype, function( prop, value ) {\n\t\tif ( !$.isFunction( value ) ) {\n\t\t\tproxiedPrototype[ prop ] = value;\n\t\t\treturn;\n\t\t}\n\t\tproxiedPrototype[ prop ] = (function() {\n\t\t\tvar _super = function() {\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, arguments );\n\t\t\t\t},\n\t\t\t\t_superApply = function( args ) {\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, args );\n\t\t\t\t};\n\t\t\treturn function() {\n\t\t\t\tvar __super = this._super,\n\t\t\t\t\t__superApply = this._superApply,\n\t\t\t\t\treturnValue;\n\n\t\t\t\tthis._super = _super;\n\t\t\t\tthis._superApply = _superApply;\n\n\t\t\t\treturnValue = value.apply( this, arguments );\n\n\t\t\t\tthis._super = __super;\n\t\t\t\tthis._superApply = __superApply;\n\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t})();\n\t});\n\tconstructor.prototype = $.widget.extend( basePrototype, {\n\t\t// TODO: remove support for widgetEventPrefix\n\t\t// always use the name + a colon as the prefix, e.g., draggable:start\n\t\t// don't prefix for widgets that aren't DOM-based\n\t\twidgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name\n\t}, proxiedPrototype, {\n\t\tconstructor: constructor,\n\t\tnamespace: namespace,\n\t\twidgetName: name,\n\t\twidgetFullName: fullName\n\t});\n\n\t// If this widget is being redefined then we need to find all widgets that\n\t// are inheriting from it and redefine all of them so that they inherit from\n\t// the new version of this widget. We're essentially trying to replace one\n\t// level in the prototype chain.\n\tif ( existingConstructor ) {\n\t\t$.each( existingConstructor._childConstructors, function( i, child ) {\n\t\t\tvar childPrototype = child.prototype;\n\n\t\t\t// redefine the child widget using the same prototype that was\n\t\t\t// originally used, but inherit from the new version of the base\n\t\t\t$.widget( childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto );\n\t\t});\n\t\t// remove the list of existing child constructors from the old constructor\n\t\t// so the old child constructors can be garbage collected\n\t\tdelete existingConstructor._childConstructors;\n\t} else {\n\t\tbase._childConstructors.push( constructor );\n\t}\n\n\t$.widget.bridge( name, constructor );\n};\n\n$.widget.extend = function( target ) {\n\tvar input = slice.call( arguments, 1 ),\n\t\tinputIndex = 0,\n\t\tinputLength = input.length,\n\t\tkey,\n\t\tvalue;\n\tfor ( ; inputIndex < inputLength; inputIndex++ ) {\n\t\tfor ( key in input[ inputIndex ] ) {\n\t\t\tvalue = input[ inputIndex ][ key ];\n\t\t\tif ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\n\t\t\t\t// Clone objects\n\t\t\t\tif ( $.isPlainObject( value ) ) {\n\t\t\t\t\ttarget[ key ] = $.isPlainObject( target[ key ] ) ?\n\t\t\t\t\t\t$.widget.extend( {}, target[ key ], value ) :\n\t\t\t\t\t\t// Don't extend strings, arrays, etc. with objects\n\t\t\t\t\t\t$.widget.extend( {}, value );\n\t\t\t\t// Copy everything else by reference\n\t\t\t\t} else {\n\t\t\t\t\ttarget[ key ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n};\n\n$.widget.bridge = function( name, object ) {\n\tvar fullName = object.prototype.widgetFullName || name;\n\t$.fn[ name ] = function( options ) {\n\t\tvar isMethodCall = typeof options === \"string\",\n\t\t\targs = slice.call( arguments, 1 ),\n\t\t\treturnValue = this;\n\n\t\t// allow multiple hashes to be passed on init\n\t\toptions = !isMethodCall && args.length ?\n\t\t\t$.widget.extend.apply( null, [ options ].concat(args) ) :\n\t\t\toptions;\n\n\t\tif ( isMethodCall ) {\n\t\t\tthis.each(function() {\n\t\t\t\tvar methodValue,\n\t\t\t\t\tinstance = $.data( this, fullName );\n\t\t\t\tif ( !instance ) {\n\t\t\t\t\treturn $.error( \"cannot call methods on \" + name + \" prior to initialization; \" +\n\t\t\t\t\t\t\"attempted to call method '\" + options + \"'\" );\n\t\t\t\t}\n\t\t\t\tif ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === \"_\" ) {\n\t\t\t\t\treturn $.error( \"no such method '\" + options + \"' for \" + name + \" widget instance\" );\n\t\t\t\t}\n\t\t\t\tmethodValue = instance[ options ].apply( instance, args );\n\t\t\t\tif ( methodValue !== instance && methodValue !== undefined ) {\n\t\t\t\t\treturnValue = methodValue && methodValue.jquery ?\n\t\t\t\t\t\treturnValue.pushStack( methodValue.get() ) :\n\t\t\t\t\t\tmethodValue;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tthis.each(function() {\n\t\t\t\tvar instance = $.data( this, fullName );\n\t\t\t\tif ( instance ) {\n\t\t\t\t\tinstance.option( options || {} )._init();\n\t\t\t\t} else {\n\t\t\t\t\t$.data( this, fullName, new object( options, this ) );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn returnValue;\n\t};\n};\n\n$.Widget = function( /* options, element */ ) {};\n$.Widget._childConstructors = [];\n\n$.Widget.prototype = {\n\twidgetName: \"widget\",\n\twidgetEventPrefix: \"\",\n\tdefaultElement: \"<div>\",\n\toptions: {\n\t\tdisabled: false,\n\n\t\t// callbacks\n\t\tcreate: null\n\t},\n\t_createWidget: function( options, element ) {\n\t\telement = $( element || this.defaultElement || this )[ 0 ];\n\t\tthis.element = $( element );\n\t\tthis.uuid = uuid++;\n\t\tthis.eventNamespace = \".\" + this.widgetName + this.uuid;\n\t\tthis.options = $.widget.extend( {},\n\t\t\tthis.options,\n\t\t\tthis._getCreateOptions(),\n\t\t\toptions );\n\n\t\tthis.bindings = $();\n\t\tthis.hoverable = $();\n\t\tthis.focusable = $();\n\n\t\tif ( element !== this ) {\n\t\t\t$.data( element, this.widgetFullName, this );\n\t\t\tthis._on( true, this.element, {\n\t\t\t\tremove: function( event ) {\n\t\t\t\t\tif ( event.target === element ) {\n\t\t\t\t\t\tthis.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.document = $( element.style ?\n\t\t\t\t// element within the document\n\t\t\t\telement.ownerDocument :\n\t\t\t\t// element is window or document\n\t\t\t\telement.document || element );\n\t\t\tthis.window = $( this.document[0].defaultView || this.document[0].parentWindow );\n\t\t}\n\n\t\tthis._create();\n\t\tthis._trigger( \"create\", null, this._getCreateEventData() );\n\t\tthis._init();\n\t},\n\t_getCreateOptions: $.noop,\n\t_getCreateEventData: $.noop,\n\t_create: $.noop,\n\t_init: $.noop,\n\n\tdestroy: function() {\n\t\tthis._destroy();\n\t\t// we can probably remove the unbind calls in 2.0\n\t\t// all event bindings should go through this._on()\n\t\tthis.element\n\t\t\t.unbind( this.eventNamespace )\n\t\t\t// 1.9 BC for #7810\n\t\t\t// TODO remove dual storage\n\t\t\t.removeData( this.widgetName )\n\t\t\t.removeData( this.widgetFullName )\n\t\t\t// support: jquery <1.6.3\n\t\t\t// http://bugs.jquery.com/ticket/9413\n\t\t\t.removeData( $.camelCase( this.widgetFullName ) );\n\t\tthis.widget()\n\t\t\t.unbind( this.eventNamespace )\n\t\t\t.removeAttr( \"aria-disabled\" )\n\t\t\t.removeClass(\n\t\t\t\tthis.widgetFullName + \"-disabled \" +\n\t\t\t\t\"ui-state-disabled\" );\n\n\t\t// clean up events and states\n\t\tthis.bindings.unbind( this.eventNamespace );\n\t\tthis.hoverable.removeClass( \"ui-state-hover\" );\n\t\tthis.focusable.removeClass( \"ui-state-focus\" );\n\t},\n\t_destroy: $.noop,\n\n\twidget: function() {\n\t\treturn this.element;\n\t},\n\n\toption: function( key, value ) {\n\t\tvar options = key,\n\t\t\tparts,\n\t\t\tcurOption,\n\t\t\ti;\n\n\t\tif ( arguments.length === 0 ) {\n\t\t\t// don't return a reference to the internal hash\n\t\t\treturn $.widget.extend( {}, this.options );\n\t\t}\n\n\t\tif ( typeof key === \"string\" ) {\n\t\t\t// handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n\t\t\toptions = {};\n\t\t\tparts = key.split( \".\" );\n\t\t\tkey = parts.shift();\n\t\t\tif ( parts.length ) {\n\t\t\t\tcurOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\n\t\t\t\tfor ( i = 0; i < parts.length - 1; i++ ) {\n\t\t\t\t\tcurOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\n\t\t\t\t\tcurOption = curOption[ parts[ i ] ];\n\t\t\t\t}\n\t\t\t\tkey = parts.pop();\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn curOption[ key ] === undefined ? null : curOption[ key ];\n\t\t\t\t}\n\t\t\t\tcurOption[ key ] = value;\n\t\t\t} else {\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn this.options[ key ] === undefined ? null : this.options[ key ];\n\t\t\t\t}\n\t\t\t\toptions[ key ] = value;\n\t\t\t}\n\t\t}\n\n\t\tthis._setOptions( options );\n\n\t\treturn this;\n\t},\n\t_setOptions: function( options ) {\n\t\tvar key;\n\n\t\tfor ( key in options ) {\n\t\t\tthis._setOption( key, options[ key ] );\n\t\t}\n\n\t\treturn this;\n\t},\n\t_setOption: function( key, value ) {\n\t\tthis.options[ key ] = value;\n\n\t\tif ( key === \"disabled\" ) {\n\t\t\tthis.widget()\n\t\t\t\t.toggleClass( this.widgetFullName + \"-disabled ui-state-disabled\", !!value )\n\t\t\t\t.attr( \"aria-disabled\", value );\n\t\t\tthis.hoverable.removeClass( \"ui-state-hover\" );\n\t\t\tthis.focusable.removeClass( \"ui-state-focus\" );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tenable: function() {\n\t\treturn this._setOption( \"disabled\", false );\n\t},\n\tdisable: function() {\n\t\treturn this._setOption( \"disabled\", true );\n\t},\n\n\t_on: function( suppressDisabledCheck, element, handlers ) {\n\t\tvar delegateElement,\n\t\t\tinstance = this;\n\n\t\t// no suppressDisabledCheck flag, shuffle arguments\n\t\tif ( typeof suppressDisabledCheck !== \"boolean\" ) {\n\t\t\thandlers = element;\n\t\t\telement = suppressDisabledCheck;\n\t\t\tsuppressDisabledCheck = false;\n\t\t}\n\n\t\t// no element argument, shuffle and use this.element\n\t\tif ( !handlers ) {\n\t\t\thandlers = element;\n\t\t\telement = this.element;\n\t\t\tdelegateElement = this.widget();\n\t\t} else {\n\t\t\t// accept selectors, DOM elements\n\t\t\telement = delegateElement = $( element );\n\t\t\tthis.bindings = this.bindings.add( element );\n\t\t}\n\n\t\t$.each( handlers, function( event, handler ) {\n\t\t\tfunction handlerProxy() {\n\t\t\t\t// allow widgets to customize the disabled handling\n\t\t\t\t// - disabled as an array instead of boolean\n\t\t\t\t// - disabled class as method for disabling individual parts\n\t\t\t\tif ( !suppressDisabledCheck &&\n\t\t\t\t\t\t( instance.options.disabled === true ||\n\t\t\t\t\t\t\t$( this ).hasClass( \"ui-state-disabled\" ) ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\n\t\t\t\t\t.apply( instance, arguments );\n\t\t\t}\n\n\t\t\t// copy the guid so direct unbinding works\n\t\t\tif ( typeof handler !== \"string\" ) {\n\t\t\t\thandlerProxy.guid = handler.guid =\n\t\t\t\t\thandler.guid || handlerProxy.guid || $.guid++;\n\t\t\t}\n\n\t\t\tvar match = event.match( /^(\\w+)\\s*(.*)$/ ),\n\t\t\t\teventName = match[1] + instance.eventNamespace,\n\t\t\t\tselector = match[2];\n\t\t\tif ( selector ) {\n\t\t\t\tdelegateElement.delegate( selector, eventName, handlerProxy );\n\t\t\t} else {\n\t\t\t\telement.bind( eventName, handlerProxy );\n\t\t\t}\n\t\t});\n\t},\n\n\t_off: function( element, eventName ) {\n\t\teventName = (eventName || \"\").split( \" \" ).join( this.eventNamespace + \" \" ) + this.eventNamespace;\n\t\telement.unbind( eventName ).undelegate( eventName );\n\t},\n\n\t_delay: function( handler, delay ) {\n\t\tfunction handlerProxy() {\n\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\n\t\t\t\t.apply( instance, arguments );\n\t\t}\n\t\tvar instance = this;\n\t\treturn setTimeout( handlerProxy, delay || 0 );\n\t},\n\n\t_hoverable: function( element ) {\n\t\tthis.hoverable = this.hoverable.add( element );\n\t\tthis._on( element, {\n\t\t\tmouseenter: function( event ) {\n\t\t\t\t$( event.currentTarget ).addClass( \"ui-state-hover\" );\n\t\t\t},\n\t\t\tmouseleave: function( event ) {\n\t\t\t\t$( event.currentTarget ).removeClass( \"ui-state-hover\" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_focusable: function( element ) {\n\t\tthis.focusable = this.focusable.add( element );\n\t\tthis._on( element, {\n\t\t\tfocusin: function( event ) {\n\t\t\t\t$( event.currentTarget ).addClass( \"ui-state-focus\" );\n\t\t\t},\n\t\t\tfocusout: function( event ) {\n\t\t\t\t$( event.currentTarget ).removeClass( \"ui-state-focus\" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_trigger: function( type, event, data ) {\n\t\tvar prop, orig,\n\t\t\tcallback = this.options[ type ];\n\n\t\tdata = data || {};\n\t\tevent = $.Event( event );\n\t\tevent.type = ( type === this.widgetEventPrefix ?\n\t\t\ttype :\n\t\t\tthis.widgetEventPrefix + type ).toLowerCase();\n\t\t// the original event may come from any element\n\t\t// so we need to reset the target on the new event\n\t\tevent.target = this.element[ 0 ];\n\n\t\t// copy original event properties over to the new event\n\t\torig = event.originalEvent;\n\t\tif ( orig ) {\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tif ( !( prop in event ) ) {\n\t\t\t\t\tevent[ prop ] = orig[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element.trigger( event, data );\n\t\treturn !( $.isFunction( callback ) &&\n\t\t\tcallback.apply( this.element[0], [ event ].concat( data ) ) === false ||\n\t\t\tevent.isDefaultPrevented() );\n\t}\n};\n\n$.each( { show: \"fadeIn\", hide: \"fadeOut\" }, function( method, defaultEffect ) {\n\t$.Widget.prototype[ \"_\" + method ] = function( element, options, callback ) {\n\t\tif ( typeof options === \"string\" ) {\n\t\t\toptions = { effect: options };\n\t\t}\n\t\tvar hasOptions,\n\t\t\teffectName = !options ?\n\t\t\t\tmethod :\n\t\t\t\toptions === true || typeof options === \"number\" ?\n\t\t\t\t\tdefaultEffect :\n\t\t\t\t\toptions.effect || defaultEffect;\n\t\toptions = options || {};\n\t\tif ( typeof options === \"number\" ) {\n\t\t\toptions = { duration: options };\n\t\t}\n\t\thasOptions = !$.isEmptyObject( options );\n\t\toptions.complete = callback;\n\t\tif ( options.delay ) {\n\t\t\telement.delay( options.delay );\n\t\t}\n\t\tif ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\n\t\t\telement[ method ]( options );\n\t\t} else if ( effectName !== method && element[ effectName ] ) {\n\t\t\telement[ effectName ]( options.duration, options.easing, callback );\n\t\t} else {\n\t\t\telement.queue(function( next ) {\n\t\t\t\t$( this )[ method ]();\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback.call( element[ 0 ] );\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t}\n\t};\n});\n\n})( jQuery );\n","var $ = require(\"jquery\");\n/* ========================================================================\n* Bootstrap: button.js v3.1.1\n* http://getbootstrap.com/javascript/#buttons\n* ========================================================================\n* Copyright 2011-2014 Twitter, Inc.\n* Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n* ======================================================================== */\n\n'use strict';\n\n// BUTTON PUBLIC CLASS DEFINITION\n// ==============================\n\nvar Button = function (element, options) {\n  this.$element  = $(element)\n  this.options   = $.extend({}, Button.DEFAULTS, options)\n  this.isLoading = false\n}\n\nButton.DEFAULTS = {\n  loadingText: 'loading...'\n}\n\nButton.prototype.setState = function (state) {\n  var d    = 'bk-bs-disabled'\n  var $el  = this.$element\n  var val  = $el.is('input') ? 'val' : 'html'\n  var data = $el.data()\n\n  state = state + 'Text'\n\n  if (!data.resetText) $el.data('resetText', $el[val]())\n\n  $el[val](data[state] || this.options[state])\n\n  // push to event loop to allow forms to submit\n  setTimeout($.proxy(function () {\n    if (state == 'loadingText') {\n      this.isLoading = true\n      $el.addClass(d).attr(d, d)\n    } else if (this.isLoading) {\n      this.isLoading = false\n      $el.removeClass(d).removeAttr(d)\n    }\n  }, this), 0)\n}\n\nButton.prototype.toggle = function () {\n  var changed = true\n  var $parent = this.$element.closest('[data-bk-bs-toggle=\"buttons\"]')\n\n  if ($parent.length) {\n    var $input = this.$element.find('input')\n    if ($input.prop('type') == 'radio') {\n      if ($input.prop('checked') && this.$element.hasClass('bk-bs-active')) changed = false\n      else $parent.find('.bk-bs-active').removeClass('bk-bs-active')\n    }\n    if (changed) $input.prop('checked', !this.$element.hasClass('bk-bs-active')).trigger('change')\n  }\n\n  if (changed) this.$element.toggleClass('bk-bs-active')\n}\n\n\n// BUTTON PLUGIN DEFINITION\n// ========================\n\nvar old = $.fn.button\n\n$.fn.button = function (option) {\n  return this.each(function () {\n    var $this   = $(this)\n    var data    = $this.data('bk-bs.button')\n    var options = typeof option == 'object' && option\n\n    if (!data) $this.data('bk-bs.button', (data = new Button(this, options)))\n\n    if (option == 'toggle') data.toggle()\n    else if (option) data.setState(option)\n  })\n}\n\n$.fn.button.Constructor = Button\n\n\n// BUTTON NO CONFLICT\n// ==================\n\n$.fn.button.noConflict = function () {\n  $.fn.button = old\n  return this\n}\n\n\n// BUTTON DATA-API\n// ===============\n\n$(document).on('click.bk-bs.button.data-api', '[data-bk-bs-toggle^=button]', function (e) {\n  var $btn = $(e.target)\n  if (!$btn.hasClass('bk-bs-btn')) $btn = $btn.closest('.bk-bs-btn')\n  $btn.button('toggle')\n  e.preventDefault()\n})\n","var $ = require(\"jquery\");\n\n/* ========================================================================\n * Bootstrap: dropdown.js v3.1.1\n * http://getbootstrap.com/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n'use strict';\n\n// DROPDOWN CLASS DEFINITION\n// =========================\n\nvar backdrop = '.bk-bs-dropdown-backdrop'\nvar toggle   = '[data-bk-bs-toggle=dropdown]'\nvar Dropdown = function (element) {\n  $(element).on('click.bk-bs.dropdown', this.toggle)\n}\n\nDropdown.prototype.toggle = function (e) {\n  var $this = $(this)\n\n  if ($this.is('.bk-bs-disabled, :disabled')) return\n\n  var $parent  = getParent($this)\n  var isActive = $parent.hasClass('bk-bs-open')\n\n  clearMenus()\n\n  if (!isActive) {\n    if ('ontouchstart' in document.documentElement && !$parent.closest('.bk-bs-navbar-nav').length) {\n      // if mobile we use a backdrop because click events don't delegate\n      $('<div class=\"bk-bs-dropdown-backdrop\"/>').insertAfter($(this)).on('click', clearMenus)\n    }\n\n    var relatedTarget = { relatedTarget: this }\n    $parent.trigger(e = $.Event('show.bk-bs.dropdown', relatedTarget))\n\n    if (e.isDefaultPrevented()) return\n\n    $parent\n      .toggleClass('bk-bs-open')\n      .trigger('shown.bk-bs.dropdown', relatedTarget)\n\n    $this.focus()\n  }\n\n  return false\n}\n\nDropdown.prototype.keydown = function (e) {\n  if (!/(38|40|27)/.test(e.keyCode)) return\n\n  var $this = $(this)\n\n  e.preventDefault()\n  e.stopPropagation()\n\n  if ($this.is('.bk-bs-disabled, :disabled')) return\n\n  var $parent  = getParent($this)\n  var isActive = $parent.hasClass('bk-bs-open')\n\n  if (!isActive || (isActive && e.keyCode == 27)) {\n    if (e.which == 27) $parent.find(toggle).focus()\n    return $this.click()\n  }\n\n  var desc = ' li:not(.bk-bs-divider):visible a'\n  var $items = $parent.find('[role=menu]' + desc + ', [role=listbox]' + desc)\n\n  if (!$items.length) return\n\n  var index = $items.index($items.filter(':focus'))\n\n  if (e.keyCode == 38 && index > 0)                 index--                        // up\n  if (e.keyCode == 40 && index < $items.length - 1) index++                        // down\n  if (!~index)                                      index = 0\n\n  $items.eq(index).focus()\n}\n\nfunction clearMenus(e) {\n  $(backdrop).remove()\n  $(toggle).each(function () {\n    var $parent = getParent($(this))\n    var relatedTarget = { relatedTarget: this }\n    if (!$parent.hasClass('bk-bs-open')) return\n    $parent.trigger(e = $.Event('hide.bk-bs.dropdown', relatedTarget))\n    if (e.isDefaultPrevented()) return\n    $parent.removeClass('bk-bs-open').trigger('hidden.bk-bs.dropdown', relatedTarget)\n  })\n}\n\nfunction getParent($this) {\n  var selector = $this.attr('data-bk-bs-target')\n\n  if (!selector) {\n    selector = $this.attr('href')\n    selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') //strip for ie7\n  }\n\n  var $parent = selector && $(selector)\n\n  return $parent && $parent.length ? $parent : $this.parent()\n}\n\n\n// DROPDOWN PLUGIN DEFINITION\n// ==========================\n\nvar old = $.fn.dropdown\n\n$.fn.dropdown = function (option) {\n  return this.each(function () {\n    var $this = $(this)\n    var data  = $this.data('bk-bs.dropdown')\n\n    if (!data) $this.data('bk-bs.dropdown', (data = new Dropdown(this)))\n    if (typeof option == 'string') data[option].call($this)\n  })\n}\n\n$.fn.dropdown.Constructor = Dropdown\n\n\n// DROPDOWN NO CONFLICT\n// ====================\n\n$.fn.dropdown.noConflict = function () {\n  $.fn.dropdown = old\n  return this\n}\n\n\n// APPLY TO STANDARD DROPDOWN ELEMENTS\n// ===================================\n\n$(document)\n  .on('click.bk-bs.dropdown.data-api', clearMenus)\n  .on('click.bk-bs.dropdown.data-api', '.bk-bs-dropdown form', function (e) { e.stopPropagation() })\n  .on('click.bk-bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)\n  .on('keydown.bk-bs.dropdown.data-api', toggle + ', [role=menu], [role=listbox]', Dropdown.prototype.keydown)\n","var $ = require(\"jquery\");\n/* ========================================================================\n * Bootstrap: tab.js v3.1.1\n * http://getbootstrap.com/javascript/#tabs\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n'use strict';\n\n// TAB CLASS DEFINITION\n// ====================\n\nvar Tab = function (element) {\n  this.element = $(element)\n}\n\nTab.prototype.show = function () {\n  var $this    = this.element\n  var $ul      = $this.closest('ul:not(.bk-bs-dropdown-menu)')\n  var selector = $this.data('bk-bs-target')\n\n  if (!selector) {\n    selector = $this.attr('href')\n    selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') //strip for ie7\n  }\n\n  if ($this.parent('li').hasClass('bk-bs-active')) return\n\n  var previous = $ul.find('.bk-bs-active:last a')[0]\n  var e        = $.Event('show.bk-bs.tab', {\n    relatedTarget: previous\n  })\n\n  $this.trigger(e)\n\n  if (e.isDefaultPrevented()) return\n\n  var $target = $(selector)\n\n  this.activate($this.parent('li'), $ul)\n  this.activate($target, $target.parent(), function () {\n    $this.trigger({\n      type: 'shown.bk-bs.tab',\n      relatedTarget: previous\n    })\n  })\n}\n\nTab.prototype.activate = function (element, container, callback) {\n  var $active    = container.find('> .bk-bs-active')\n  var transition = callback\n    && $.support.transition\n    && $active.hasClass('bk-bs-fade')\n\n  function next() {\n    $active\n      .removeClass('bk-bs-active')\n      .find('> .bk-bs-dropdown-menu > .bk-bs-active')\n      .removeClass('bk-bs-active')\n\n    element.addClass('bk-bs-active')\n\n    if (transition) {\n      element[0].offsetWidth // reflow for transition\n      element.addClass('bk-bs-in')\n    } else {\n      element.removeClass('bk-bs-fade')\n    }\n\n    if (element.parent('.bk-bs-dropdown-menu')) {\n      element.closest('li.bk-bs-dropdown').addClass('bk-bs-active')\n    }\n\n    callback && callback()\n  }\n\n  transition ?\n    $active\n      .one($.support.transition.end, next)\n      .emulateTransitionEnd(150) :\n    next()\n\n  $active.removeClass('bk-bs-in')\n}\n\n\n// TAB PLUGIN DEFINITION\n// =====================\n\nvar old = $.fn.tab\n\n$.fn.tab = function ( option ) {\n  return this.each(function () {\n    var $this = $(this)\n    var data  = $this.data('bk-bs.tab')\n\n    if (!data) $this.data('bk-bs.tab', (data = new Tab(this)))\n    if (typeof option == 'string') data[option]()\n  })\n}\n\n$.fn.tab.Constructor = Tab\n\n\n// TAB NO CONFLICT\n// ===============\n\n$.fn.tab.noConflict = function () {\n  $.fn.tab = old\n  return this\n}\n\n\n// TAB DATA-API\n// ============\n\n$(document).on('click.bk-bs.tab.data-api', '[data-bk-bs-toggle=\"tab\"], [data-bk-bs-toggle=\"pill\"]', function (e) {\n  e.preventDefault()\n  $(this).tab('show')\n})\n","/**\n * jQRangeSlider\n * A javascript slider selector that supports dates\n *\n * Copyright (C) Guillaume Gautreau 2012\n * Dual licensed under the MIT or GPL Version 2 licenses.\n *\n */\n\nvar $ = require(\"jquery\");\nrequire(\"./jQRangeSlider\");\n\"use strict\";\n\nmodule.exports = $.widget(\"ui.dateRangeSlider\", $.ui.rangeSlider, {\n\toptions: {\n\t\tbounds: {min: new Date(2010,0,1).valueOf(), max: new Date(2012,0,1).valueOf()},\n\t\tdefaultValues: {min: new Date(2010,1,11).valueOf(), max: new Date(2011,1,11).valueOf()}\n\t},\n\n\t_create: function(){\n\t\t$.ui.rangeSlider.prototype._create.apply(this);\n\n\t\tthis.element.addClass(\"bk-ui-dateRangeSlider\");\n\t},\n\n\tdestroy: function(){\n\t\tthis.element.removeClass(\"bk-ui-dateRangeSlider\");\n\t\t$.ui.rangeSlider.prototype.destroy.apply(this);\n\t},\n\n\t_setDefaultValues: function(){\n\t\tthis._values = {\n\t\t\tmin: this.options.defaultValues.min.valueOf(),\n\t\t\tmax: this.options.defaultValues.max.valueOf()\n\t\t};\n\t},\n\n\t_setRulerParameters: function(){\n\t\tthis.ruler.ruler({\n\t\t\tmin: new Date(this.options.bounds.min),\n\t\t\tmax: new Date(this.options.bounds.max),\n\t\t\tscales: this.options.scales\n\t\t});\n\t},\n\n\t_setOption: function(key, value){\n\t\tif ((key === \"defaultValues\" || key === \"bounds\") && typeof value !== \"undefined\" && value !== null && this._isValidDate(value.min) && this._isValidDate(value.max)){\n\t\t\t$.ui.rangeSlider.prototype._setOption.apply(this, [key, {min:value.min.valueOf(), max:value.max.valueOf()}]);\n\t\t}else{\n\t\t\t$.ui.rangeSlider.prototype._setOption.apply(this, this._toArray(arguments));\n\t\t}\n\t},\n\n\t_handleType: function(){\n\t\treturn \"dateRangeSliderHandle\";\n\t},\n\n\toption: function(key){\n\t\tif (key === \"bounds\" || key === \"defaultValues\"){\n\t\t\tvar result = $.ui.rangeSlider.prototype.option.apply(this, arguments);\n\n\t\t\treturn {min:new Date(result.min), max:new Date(result.max)};\n\t\t}\n\n\t\treturn $.ui.rangeSlider.prototype.option.apply(this, this._toArray(arguments));\n\t},\n\n\t_defaultFormatter: function(value){\n\t\tvar month = value.getMonth() + 1,\n\t\t\tday = value.getDate();\n\n\t\treturn \"\" + value.getFullYear() + \"-\" + (month < 10 ? \"0\" + month : month) + \"-\" + (day < 10 ? \"0\" + day : day);\n\t},\n\n\t_getFormatter: function(){\n\t\tvar formatter = this.options.formatter;\n\n\t\tif (this.options.formatter === false || this.options.formatter === null){\n\t\t\tformatter = this._defaultFormatter;\n\t\t}\n\n\t\treturn (function(formatter){\n\t\t\treturn function(value){\n\t\t\t\treturn formatter(new Date(value));\n\t\t\t}\n\t\t}(formatter));\n\t},\n\n\tvalues: function(min, max){\n\t\tvar values = null;\n\n\t\tif (this._isValidDate(min) && this._isValidDate(max))\n\t\t{\n\t\t\tvalues = $.ui.rangeSlider.prototype.values.apply(this, [min.valueOf(), max.valueOf()]);\n\t\t}else{\n\t\t\tvalues = $.ui.rangeSlider.prototype.values.apply(this, this._toArray(arguments));\n\t\t}\n\n\t\treturn {min: new Date(values.min), max: new Date(values.max)};\n\t},\n\n\tmin: function(min){\n\t\tif (this._isValidDate(min)){\n\t\t\treturn new Date($.ui.rangeSlider.prototype.min.apply(this, [min.valueOf()]));\n\t\t}\n\n\t\treturn new Date($.ui.rangeSlider.prototype.min.apply(this));\n\t},\n\n\tmax: function(max){\n\t\tif (this._isValidDate(max)){\n\t\t\treturn new Date($.ui.rangeSlider.prototype.max.apply(this, [max.valueOf()]));\n\t\t}\n\n\t\treturn new Date($.ui.rangeSlider.prototype.max.apply(this));\n\t},\n\n\tbounds: function(min, max){\n\t\tvar result;\n\n\t\tif (this._isValidDate(min) && this._isValidDate(max)) {\n\t\t\tresult = $.ui.rangeSlider.prototype.bounds.apply(this, [min.valueOf(), max.valueOf()]);\n\t\t} else {\n\t\t\tresult = $.ui.rangeSlider.prototype.bounds.apply(this, this._toArray(arguments));\n\t\t}\n\n\t\treturn {min: new Date(result.min), max: new Date(result.max)};\n\t},\n\n\t_isValidDate: function(value){\n\t\treturn typeof value !== \"undefined\" && value instanceof Date;\n\t},\n\n\t_toArray: function(argsObject){\n\t\treturn Array.prototype.slice.call(argsObject);\n\t}\n});\n","/**\n * jQRangeSlider\n * A javascript slider selector that supports dates\n *\n * Copyright (C) Guillaume Gautreau 2012\n * Dual licensed under the MIT or GPL Version 2 licenses.\n *\n */\n\nvar $ = require(\"jquery\");\nrequire(\"jquery-ui/core\");\nrequire(\"jquery-ui/widget\");\nrequire(\"jquery-ui/mouse\");\nrequire(\"jquery-mousewheel\");\n\"use strict\";\n\nmodule.exports = $.widget(\"ui.rangeSlider\", {\n\toptions: {\n\t\tbounds: {min:0, max:100},\n\t\tdefaultValues: {min:20, max:50},\n\t\twheelMode: null,\n\t\twheelSpeed: 4,\n\t\tarrows: true,\n\t\tvalueLabels: \"show\",\n\t\tformatter: null,\n\t\tdurationIn: 0,\n\t\tdurationOut: 400,\n\t\tdelayOut: 200,\n\t\trange: {min: false, max: false},\n\t\tstep: false,\n\t\tscales: false,\n\t\tenabled: true,\n\t\tsymmetricPositionning: false\n\t},\n\n\t_values: null,\n\t_valuesChanged: false,\n\t_initialized: false,\n\n\t// Created elements\n\tbar: null,\n\tleftHandle: null,\n\trightHandle: null,\n\tinnerBar: null,\n\tcontainer: null,\n\tarrows: null,\n\tlabels: null,\n\tchanging: {min:false, max:false},\n\tchanged: {min:false, max:false},\n\truler: null,\n\n\t_create: function(){\n\t\tthis._setDefaultValues();\n\n\t\tthis.labels = {left: null, right:null, leftDisplayed:true, rightDisplayed:true};\n\t\tthis.arrows = {left:null, right:null};\n\t\tthis.changing = {min:false, max:false};\n\t\tthis.changed = {min:false, max:false};\n\n\t\tthis._createElements();\n\n\t\tthis._bindResize();\n\n\t\tsetTimeout($.proxy(this.resize, this), 1);\n\t\tsetTimeout($.proxy(this._initValues, this), 1);\n\t},\n\n\t_setDefaultValues: function(){\n\t\tthis._values = {\n\t\t\tmin: this.options.defaultValues.min,\n\t\t\tmax: this.options.defaultValues.max\n\t\t};\n\t},\n\n\t_bindResize: function(){\n\t\tvar that = this;\n\n\t\tthis._resizeProxy = function(e){\n\t\t\tthat.resize(e);\n\t\t};\n\n\t\t$(window).resize(this._resizeProxy);\n\t},\n\n\t_initWidth: function(){\n\t\tthis.container.css(\"width\", this.element.width() - this.container.outerWidth(true) + this.container.width());\n\t\tthis.innerBar.css(\"width\", this.container.width() - this.innerBar.outerWidth(true) + this.innerBar.width());\n\t},\n\n\t_initValues: function(){\n\t\tthis._initialized = true;\n\t\tthis.values(this._values.min, this._values.max);\n\t},\n\n\t_setOption: function(key, value) {\n\t\tthis._setWheelOption(key, value);\n\t\tthis._setArrowsOption(key, value);\n\t\tthis._setLabelsOption(key, value);\n\t\tthis._setLabelsDurations(key, value);\n\t\tthis._setFormatterOption(key, value);\n\t\tthis._setBoundsOption(key, value);\n\t\tthis._setRangeOption(key, value);\n\t\tthis._setStepOption(key, value);\n\t\tthis._setScalesOption(key, value);\n\t\tthis._setEnabledOption(key, value);\n\t\tthis._setPositionningOption(key, value);\n\t},\n\n\t_validProperty: function(object, name, defaultValue){\n\t\tif (object === null || typeof object[name] === \"undefined\"){\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\treturn object[name];\n\t},\n\n\t_setStepOption: function(key, value){\n\t\tif (key === \"step\"){\n\t\t\tthis.options.step = value;\n\t\t\tthis._leftHandle(\"option\", \"step\", value);\n\t\t\tthis._rightHandle(\"option\", \"step\", value);\n\t\t\tthis._changed(true);\n\t\t}\n\t},\n\n\t_setScalesOption: function(key, value){\n\t\tif (key === \"scales\"){\n\t\t\tif (value === false || value === null){\n\t\t\t\tthis.options.scales = false;\n\t\t\t\tthis._destroyRuler();\n\t\t\t}else if (value instanceof Array){\n\t\t\t\tthis.options.scales = value;\n\t\t\t\tthis._updateRuler();\n\t\t\t}\n\t\t}\n\t},\n\n\t_setRangeOption: function(key, value){\n\t\tif (key === \"range\"){\n\t\t\tthis._bar(\"option\", \"range\", value);\n\t\t\tthis.options.range = this._bar(\"option\", \"range\");\n\t\t\tthis._changed(true);\n\t\t}\n\t},\n\n\t_setBoundsOption: function(key, value){\n\t\tif (key === \"bounds\" && typeof value.min !== \"undefined\" && typeof value.max !== \"undefined\"){\n\t\t\tthis.bounds(value.min, value.max);\n\t\t}\n\t},\n\n\t_setWheelOption: function(key, value){\n\t\tif (key === \"wheelMode\" || key === \"wheelSpeed\"){\n\t\t\tthis._bar(\"option\", key, value);\n\t\t\tthis.options[key] = this._bar(\"option\", key);\n\t\t}\n\t},\n\n\t_setLabelsOption: function(key, value){\n\t\tif (key === \"valueLabels\"){\n\t\t\tif (value !== \"hide\" && value !== \"show\" && value !== \"change\"){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.options.valueLabels = value;\n\n\t\t\tif (value !== \"hide\"){\n\t\t\t\tthis._createLabels();\n\t\t\t\tthis._leftLabel(\"update\");\n\t\t\t\tthis._rightLabel(\"update\");\n\t\t\t}else{\n\t\t\t\tthis._destroyLabels();\n\t\t\t}\n\t\t}\n\t},\n\n\t_setFormatterOption: function(key, value){\n\t\tif (key === \"formatter\" && value !== null && typeof value === \"function\"){\n\t\t\tif (this.options.valueLabels !== \"hide\"){\n\t\t\t\tthis._leftLabel(\"option\", \"formatter\", value);\n\t\t\t\tthis.options.formatter = this._rightLabel(\"option\", \"formatter\", value);\n\t\t\t}\n\t\t}\n\t},\n\n\t_setArrowsOption: function(key, value){\n\t\tif (key === \"arrows\" && (value === true || value === false) && value !== this.options.arrows){\n\t\t\tif (value === true){\n\t\t\t\tthis.element\n\t\t\t\t\t.removeClass(\"bk-ui-rangeSlider-noArrow\")\n\t\t\t\t\t.addClass(\"bk-ui-rangeSlider-withArrows\");\n\t\t\t\tthis.arrows.left.css(\"display\", \"block\");\n\t\t\t\tthis.arrows.right.css(\"display\", \"block\");\n\t\t\t\tthis.options.arrows = true;\n\t\t\t}else if (value === false){\n\t\t\t\tthis.element\n\t\t\t\t\t.addClass(\"bk-ui-rangeSlider-noArrow\")\n\t\t\t\t\t.removeClass(\"bk-ui-rangeSlider-withArrows\");\n\t\t\t\tthis.arrows.left.css(\"display\", \"none\");\n\t\t\t\tthis.arrows.right.css(\"display\", \"none\");\n\t\t\t\tthis.options.arrows = false;\n\t\t\t}\n\n\t\t\tthis._initWidth();\n\t\t}\n\t},\n\n\t_setLabelsDurations: function(key, value){\n\t\tif (key === \"durationIn\" || key === \"durationOut\" || key === \"delayOut\"){\n\t\t\tif (parseInt(value, 10) !== value) return;\n\n\t\t\tif (this.labels.left !== null){\n\t\t\t\tthis._leftLabel(\"option\", key, value);\n\t\t\t}\n\n\t\t\tif (this.labels.right !== null){\n\t\t\t\tthis._rightLabel(\"option\", key, value);\n\t\t\t}\n\n\t\t\tthis.options[key] = value;\n\t\t}\n\t},\n\n\t_setEnabledOption: function(key, value){\n\t\tif (key === \"enabled\"){\n\t\t\tthis.toggle(value);\n\t\t}\n\t},\n\n\t_setPositionningOption: function(key, value){\n\t\tif (key === \"symmetricPositionning\"){\n\t\t\tthis._rightHandle(\"option\", key, value);\n\t\t\tthis.options[key] = this._leftHandle(\"option\", key, value);\n\t\t}\n\t},\n\n\t_createElements: function(){\n\t\tif (this.element.css(\"position\") !== \"absolute\"){\n\t\t\tthis.element.css(\"position\", \"relative\");\n\t\t}\n\n\t\tthis.element.addClass(\"bk-ui-rangeSlider\");\n\n\t\tthis.container = $(\"<div class='bk-ui-rangeSlider-container' />\")\n\t\t\t.css(\"position\", \"absolute\")\n\t\t\t.appendTo(this.element);\n\n\t\tthis.innerBar = $(\"<div class='bk-ui-rangeSlider-innerBar' />\")\n\t\t\t.css(\"position\", \"absolute\")\n\t\t\t.css(\"top\", 0)\n\t\t\t.css(\"left\", 0);\n\n\t\tthis._createHandles();\n\t\tthis._createBar();\n\t\tthis.container.prepend(this.innerBar);\n\t\tthis._createArrows();\n\n\t\tif (this.options.valueLabels !== \"hide\"){\n\t\t\tthis._createLabels();\n\t\t}else{\n\t\t\tthis._destroyLabels();\n\t\t}\n\n\t\tthis._updateRuler();\n\n\t\tif (!this.options.enabled) this._toggle(this.options.enabled);\n\t},\n\n\t_createHandle: function(options){\n\t\treturn $(\"<div />\")\n\t\t\t[this._handleType()](options)\n\t\t\t.bind(\"sliderDrag\", $.proxy(this._changing, this))\n\t\t\t.bind(\"stop\", $.proxy(this._changed, this));\n\t},\n\n\t_createHandles: function(){\n\t\tthis.leftHandle = this._createHandle({\n\t\t\t\tisLeft: true,\n\t\t\t\tbounds: this.options.bounds,\n\t\t\t\tvalue: this._values.min,\n\t\t\t\tstep: this.options.step,\n\t\t\t\tsymmetricPositionning: this.options.symmetricPositionning\n\t\t}).appendTo(this.container);\n\n\t\tthis.rightHandle = this._createHandle({\n\t\t\tisLeft: false,\n\t\t\tbounds: this.options.bounds,\n\t\t\tvalue: this._values.max,\n\t\t\tstep: this.options.step,\n\t\t\tsymmetricPositionning: this.options.symmetricPositionning\n\t\t}).appendTo(this.container);\n\t},\n\n\t_createBar: function(){\n\t\tthis.bar = $(\"<div />\")\n\t\t\t.prependTo(this.container)\n\t\t\t.bind(\"sliderDrag scroll zoom\", $.proxy(this._changing, this))\n\t\t\t.bind(\"stop\", $.proxy(this._changed, this));\n\n\t\tthis._bar({\n\t\t\t\tleftHandle: this.leftHandle,\n\t\t\t\trightHandle: this.rightHandle,\n\t\t\t\tvalues: {min: this._values.min, max: this._values.max},\n\t\t\t\ttype: this._handleType(),\n\t\t\t\trange: this.options.range,\n\t\t\t\twheelMode: this.options.wheelMode,\n\t\t\t\twheelSpeed: this.options.wheelSpeed\n\t\t\t});\n\n\t\tthis.options.range = this._bar(\"option\", \"range\");\n\t\tthis.options.wheelMode = this._bar(\"option\", \"wheelMode\");\n\t\tthis.options.wheelSpeed = this._bar(\"option\", \"wheelSpeed\");\n\t},\n\n\t_createArrows: function(){\n\t\tthis.arrows.left = this._createArrow(\"left\");\n\t\tthis.arrows.right = this._createArrow(\"right\");\n\n\t\tif (!this.options.arrows){\n\t\t\tthis.arrows.left.css(\"display\", \"none\");\n\t\t\tthis.arrows.right.css(\"display\", \"none\");\n\t\t\tthis.element.addClass(\"bk-ui-rangeSlider-noArrow\");\n\t\t}else{\n\t\t\tthis.element.addClass(\"bk-ui-rangeSlider-withArrows\");\n\t\t}\n\t},\n\n\t_createArrow: function(whichOne){\n\t\tvar arrow = $(\"<div class='bk-ui-rangeSlider-arrow' />\")\n\t\t\t.append(\"<div class='bk-ui-rangeSlider-arrow-inner' />\")\n\t\t\t.addClass(\"bk-ui-rangeSlider-\" + whichOne + \"Arrow\")\n\t\t\t.css(\"position\", \"absolute\")\n\t\t\t.css(whichOne, 0)\n\t\t\t.appendTo(this.element),\n\t\t\ttarget;\n\n\t\tif (whichOne === \"right\"){\n\t\t\ttarget = $.proxy(this._scrollRightClick, this);\n\t\t}else{\n\t\t\ttarget = $.proxy(this._scrollLeftClick, this);\n\t\t}\n\n\t\tarrow.bind(\"mousedown touchstart\", target);\n\n\t\treturn arrow;\n\t},\n\n\t_proxy: function(element, type, args){\n\t\tvar array = Array.prototype.slice.call(args);\n\n\t\tif (element && element[type]){\n\t\t\treturn element[type].apply(element, array);\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t_handleType: function(){\n\t\treturn \"rangeSliderHandle\";\n\t},\n\n\t_barType: function(){\n\t\treturn \"rangeSliderBar\";\n\t},\n\n\t_bar: function(){\n\t\treturn this._proxy(this.bar, this._barType(), arguments);\n\t},\n\n\t_labelType: function(){\n\t\treturn \"rangeSliderLabel\";\n\t},\n\n\t_leftLabel: function(){\n\t\treturn this._proxy(this.labels.left, this._labelType(), arguments);\n\t},\n\n\t_rightLabel: function(){\n\t\treturn this._proxy(this.labels.right, this._labelType(), arguments);\n\t},\n\n\t_leftHandle: function(){\n\t\treturn this._proxy(this.leftHandle, this._handleType(), arguments);\n\t},\n\n\t_rightHandle: function(){\n\t\treturn this._proxy(this.rightHandle, this._handleType(), arguments);\n\t},\n\n\t_getValue: function(position, handle){\n\t\tif (handle === this.rightHandle){\n\t\t\tposition = position - handle.outerWidth();\n\t\t}\n\n\t\treturn position * (this.options.bounds.max - this.options.bounds.min) / (this.container.innerWidth() - handle.outerWidth(true)) + this.options.bounds.min;\n\t},\n\n\t_trigger: function(eventName){\n\t\tvar that = this;\n\n\t\tsetTimeout(function(){\n\t\t\tthat.element.trigger(eventName, {\n\t\t\t\t\tlabel: that.element,\n\t\t\t\t\tvalues: that.values()\n\t\t\t\t});\n\t\t}, 1);\n\t},\n\n\t_changing: function(){\n\t\tif(this._updateValues()){\n\t\t\tthis._trigger(\"valuesChanging\");\n\t\t\tthis._valuesChanged = true;\n\t\t}\n\t},\n\n\t_deactivateLabels: function(){\n\t\tif (this.options.valueLabels === \"change\"){\n\t\t\tthis._leftLabel(\"option\", \"show\", \"hide\");\n\t\t\tthis._rightLabel(\"option\", \"show\", \"hide\");\n\t\t}\n\t},\n\n\t_reactivateLabels: function(){\n\t\tif (this.options.valueLabels === \"change\"){\n\t\t\tthis._leftLabel(\"option\", \"show\", \"change\");\n\t\t\tthis._rightLabel(\"option\", \"show\", \"change\");\n\t\t}\n\t},\n\n\t_changed: function(isAutomatic){\n\t\tif (isAutomatic === true){\n\t\t\tthis._deactivateLabels();\n\t\t}\n\n\t\tif (this._updateValues() || this._valuesChanged){\n\t\t\tthis._trigger(\"valuesChanged\");\n\n\t\t\tif (isAutomatic !== true){\n\t\t\t\tthis._trigger(\"userValuesChanged\");\n\t\t\t}\n\n\t\t\tthis._valuesChanged = false;\n\t\t}\n\n\t\tif (isAutomatic === true){\n\t\t\tthis._reactivateLabels();\n\t\t}\n\t},\n\n\t_updateValues: function(){\n\t\tvar left = this._leftHandle(\"value\"),\n\t\t\tright = this._rightHandle(\"value\"),\n\t\t\tmin = this._min(left, right),\n\t\t\tmax = this._max(left, right),\n\t\t\tchanging = (min !== this._values.min || max !== this._values.max);\n\n\t\tthis._values.min = this._min(left, right);\n\t\tthis._values.max = this._max(left, right);\n\n\t\treturn changing;\n\t},\n\n\t_min: function(value1, value2){\n\t\treturn Math.min(value1, value2);\n\t},\n\n\t_max: function(value1, value2){\n\t\treturn Math.max(value1, value2);\n\t},\n\n\t/*\n\t * Value labels\n\t */\n\t_createLabel: function(label, handle){\n\t\tvar params;\n\n\t\tif (label === null){\n\t\t\tparams = this._getLabelConstructorParameters(label, handle);\n\t\t\tlabel = $(\"<div />\")\n\t\t\t\t.appendTo(this.element)\n\t\t\t\t[this._labelType()](params);\n\t\t}else{\n\t\t\tparams = this._getLabelRefreshParameters(label, handle);\n\n\t\t\tlabel[this._labelType()](params);\n\t\t}\n\n\t\treturn label;\n\t},\n\n\t_getLabelConstructorParameters: function(label, handle){\n\t\treturn {\n\t\t\thandle: handle,\n\t\t\thandleType: this._handleType(),\n\t\t\tformatter: this._getFormatter(),\n\t\t\tshow: this.options.valueLabels,\n\t\t\tdurationIn: this.options.durationIn,\n\t\t\tdurationOut: this.options.durationOut,\n\t\t\tdelayOut: this.options.delayOut\n\t\t};\n\t},\n\n\t_getLabelRefreshParameters: function(){\n\t\treturn {\n\t\t\tformatter: this._getFormatter(),\n\t\t\tshow: this.options.valueLabels,\n\t\t\tdurationIn: this.options.durationIn,\n\t\t\tdurationOut: this.options.durationOut,\n\t\t\tdelayOut: this.options.delayOut\n\t\t};\n\t},\n\n\t_getFormatter: function(){\n\t\tif (this.options.formatter === false || this.options.formatter === null){\n\t\t\treturn this._defaultFormatter;\n\t\t}\n\n\t\treturn this.options.formatter;\n\t},\n\n\t_defaultFormatter: function(value){\n\t\treturn Math.round(value);\n\t},\n\n\t_destroyLabel: function(label){\n\t\tif (label !== null){\n\t\t\tlabel[this._labelType()](\"destroy\");\n\t\t\tlabel.remove();\n\t\t\tlabel = null;\n\t\t}\n\n\t\treturn label;\n\t},\n\n\t_createLabels: function(){\n\t\tthis.labels.left = this._createLabel(this.labels.left, this.leftHandle);\n\t\tthis.labels.right = this._createLabel(this.labels.right, this.rightHandle);\n\n\t\tthis._leftLabel(\"pair\", this.labels.right);\n\t},\n\n\t_destroyLabels: function(){\n\t\tthis.labels.left = this._destroyLabel(this.labels.left);\n\t\tthis.labels.right = this._destroyLabel(this.labels.right);\n\t},\n\n\t/*\n\t * Scrolling\n\t */\n\t_stepRatio: function(){\n\t\treturn this._leftHandle(\"stepRatio\");\n\t},\n\n\t_scrollRightClick: function(e){\n\t\tif (!this.options.enabled) return false;\n\n\t\te.preventDefault();\n\t\tthis._bar(\"startScroll\");\n\t\tthis._bindStopScroll();\n\n\t\tthis._continueScrolling(\"scrollRight\", 4 * this._stepRatio(), 1);\n\t},\n\n\t_continueScrolling: function(action, timeout, quantity, timesBeforeSpeedingUp){\n\t\tif (!this.options.enabled) return false;\n\n\t\tthis._bar(action, quantity);\n\t\ttimesBeforeSpeedingUp = timesBeforeSpeedingUp || 5;\n\t\ttimesBeforeSpeedingUp--;\n\n\t\tvar that = this,\n\t\t\tminTimeout = 16,\n\t\t\tmaxQuantity = Math.max(1, 4 / this._stepRatio());\n\n\t\tthis._scrollTimeout = setTimeout(function(){\n\t\t\tif (timesBeforeSpeedingUp === 0){\n\t\t\t\tif (timeout > minTimeout){\n\t\t\t\t\ttimeout = Math.max(minTimeout, timeout / 1.5);\n\t\t\t\t} else {\n\t\t\t\t\tquantity = Math.min(maxQuantity, quantity * 2);\n\t\t\t\t}\n\n\t\t\t\ttimesBeforeSpeedingUp = 5;\n\t\t\t}\n\n\t\t\tthat._continueScrolling(action, timeout, quantity, timesBeforeSpeedingUp);\n\t\t}, timeout);\n\t},\n\n\t_scrollLeftClick: function(e){\n\t\tif (!this.options.enabled) return false;\n\n\t\te.preventDefault();\n\n\t\tthis._bar(\"startScroll\");\n\t\tthis._bindStopScroll();\n\n\t\tthis._continueScrolling(\"scrollLeft\", 4 * this._stepRatio(), 1);\n\t},\n\n\t_bindStopScroll: function(){\n\t\tvar that = this;\n\t\tthis._stopScrollHandle = function(e){\n\t\t\te.preventDefault();\n\t\t\tthat._stopScroll();\n\t\t};\n\n\t\t$(document).bind(\"mouseup touchend\", this._stopScrollHandle);\n\t},\n\n\t_stopScroll: function(){\n\t\t$(document).unbind(\"mouseup touchend\", this._stopScrollHandle);\n\t\tthis._stopScrollHandle = null;\n\t\tthis._bar(\"stopScroll\");\n\t\tclearTimeout(this._scrollTimeout);\n\t},\n\n\t/*\n\t * Ruler\n\t */\n\t_createRuler: function(){\n\t\tthis.ruler = $(\"<div class='bk-ui-rangeSlider-ruler' />\").appendTo(this.innerBar);\n\t},\n\n\t_setRulerParameters: function(){\n\t\tthis.ruler.ruler({\n\t\t\tmin: this.options.bounds.min,\n\t\t\tmax: this.options.bounds.max,\n\t\t\tscales: this.options.scales\n\t\t});\n\t},\n\n\t_destroyRuler: function(){\n\t\tif (this.ruler !== null && $.fn.ruler){\n\t\t\tthis.ruler.ruler(\"destroy\");\n\t\t\tthis.ruler.remove();\n\t\t\tthis.ruler = null;\n\t\t}\n\t},\n\n\t_updateRuler: function(){\n\t\tthis._destroyRuler();\n\n\t\tif (this.options.scales === false || !$.fn.ruler){\n\t\t\treturn;\n\t\t}\n\n\t\tthis._createRuler();\n\t\tthis._setRulerParameters();\n\t},\n\n\t/*\n\t * Public methods\n\t */\n\tvalues: function(min, max){\n\t\tvar val;\n\n\t\tif (typeof min !== \"undefined\" && typeof max !== \"undefined\"){\n\t\t\tif (!this._initialized){\n\t\t\t\tthis._values.min = min;\n\t\t\t\tthis._values.max = max;\n\t\t\t\treturn this._values;\n\t\t\t}\n\n\t\t\tthis._deactivateLabels();\n\t\t\tval = this._bar(\"values\", min, max);\n\t\t\tthis._changed(true);\n\t\t\tthis._reactivateLabels();\n\t\t}else{\n\t\t\tval = this._bar(\"values\", min, max);\n\t\t}\n\n\t\treturn val;\n\t},\n\n\tmin: function(min){\n\t\tthis._values.min = this.values(min, this._values.max).min;\n\n\t\treturn this._values.min;\n\t},\n\n\tmax: function(max){\n\t\tthis._values.max = this.values(this._values.min, max).max;\n\n\t\treturn this._values.max;\n\t},\n\n\tbounds: function(min, max){\n\t\tif (this._isValidValue(min) && this._isValidValue(max) && min < max){\n\n\t\t\tthis._setBounds(min, max);\n\t\t\tthis._updateRuler();\n\t\t\tthis._changed(true);\n\t\t}\n\n\t\treturn this.options.bounds;\n\t},\n\n\t_isValidValue: function(value){\n\t\treturn typeof value !== \"undefined\" && parseFloat(value) === value;\n\t},\n\n\t_setBounds: function(min, max){\n\t\tthis.options.bounds = {min: min, max: max};\n\t\tthis._leftHandle(\"option\", \"bounds\", this.options.bounds);\n\t\tthis._rightHandle(\"option\", \"bounds\", this.options.bounds);\n\t\tthis._bar(\"option\", \"bounds\", this.options.bounds);\n\t},\n\n\tzoomIn: function(quantity){\n\t\tthis._bar(\"zoomIn\", quantity)\n\t},\n\n\tzoomOut: function(quantity){\n\t\tthis._bar(\"zoomOut\", quantity);\n\t},\n\n\tscrollLeft: function(quantity){\n\t\tthis._bar(\"startScroll\");\n\t\tthis._bar(\"scrollLeft\", quantity);\n\t\tthis._bar(\"stopScroll\");\n\t},\n\n\tscrollRight: function(quantity){\n\t\tthis._bar(\"startScroll\");\n\t\tthis._bar(\"scrollRight\", quantity);\n\t\tthis._bar(\"stopScroll\");\n\t},\n\n\t/**\n\t * Resize\n\t */\n\tresize: function(){\n\t\tthis._initWidth();\n\t\tthis._leftHandle(\"update\");\n\t\tthis._rightHandle(\"update\");\n\t\tthis._bar(\"update\");\n\t},\n\n\t/*\n\t * Enable / disable\n\t */\n\tenable: function(){\n\t\tthis.toggle(true);\n\t},\n\n\tdisable: function(){\n\t\tthis.toggle(false);\n\t},\n\n\ttoggle: function(enabled){\n\t\tif (enabled === undefined) enabled = !this.options.enabled;\n\n\t\tif (this.options.enabled !== enabled){\n\t\t\tthis._toggle(enabled);\n\t\t}\n\t},\n\n\t_toggle: function(enabled){\n\t\tthis.options.enabled = enabled;\n\t\tthis.element.toggleClass(\"bk-ui-rangeSlider-disabled\", !enabled);\n\n\t\tvar action = enabled ? \"enable\" : \"disable\";\n\n\t\tthis._bar(action);\n\t\tthis._leftHandle(action);\n\t\tthis._rightHandle(action);\n\t\tthis._leftLabel(action);\n\t\tthis._rightLabel(action);\n\t},\n\n\t/*\n\t * Destroy\n\t */\n\tdestroy: function(){\n\t\tthis.element.removeClass(\"bk-ui-rangeSlider-withArrows bk-ui-rangeSlider-noArrow bk-ui-rangeSlider-disabled\");\n\n\t\tthis._destroyWidgets();\n\t\tthis._destroyElements();\n\n\t\tthis.element.removeClass(\"bk-ui-rangeSlider\");\n\t\tthis.options = null;\n\n\t\t$(window).unbind(\"resize\", this._resizeProxy);\n\t\tthis._resizeProxy = null;\n\t\tthis._bindResize = null;\n\n\t\t$.Widget.prototype.destroy.apply(this, arguments);\n\t},\n\n\t_destroyWidget: function(name){\n\t\tthis[\"_\" + name](\"destroy\");\n\t\tthis[name].remove();\n\t\tthis[name] = null;\n\t},\n\n\t_destroyWidgets: function(){\n\t\tthis._destroyWidget(\"bar\");\n\t\tthis._destroyWidget(\"leftHandle\");\n\t\tthis._destroyWidget(\"rightHandle\");\n\n\t\tthis._destroyRuler();\n\t\tthis._destroyLabels();\n\t},\n\n\t_destroyElements: function(){\n\t\tthis.container.remove();\n\t\tthis.container = null;\n\n\t\tthis.innerBar.remove();\n\t\tthis.innerBar = null;\n\n\t\tthis.arrows.left.remove();\n\t\tthis.arrows.right.remove();\n\t\tthis.arrows = null;\n\t}\n});\n","/*!\n * jquery.event.drag - v 2.2\n * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com\n * Open Source MIT License - http://threedubmedia.com/code/license\n */\n// Created: 2008-06-04\n// Updated: 2012-05-21\n// REQUIRES: jquery 1.7.x\n\nvar $ = require(\"jquery\");\n\n// add the jquery instance method\n$.fn.drag = function( str, arg, opts ){\n\t// figure out the event type\n\tvar type = typeof str == \"string\" ? str : \"\",\n\t// figure out the event handler...\n\tfn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;\n\t// fix the event type\n\tif ( type.indexOf(\"drag\") !== 0 )\n\t\ttype = \"drag\"+ type;\n\t// were options passed\n\topts = ( str == fn ? arg : opts ) || {};\n\t// trigger or bind event handler\n\treturn fn ? this.bind( type, opts, fn ) : this.trigger( type );\n};\n\n// local refs (increase compression)\nvar $event = $.event,\n$special = $event.special,\n// configure the drag special event\ndrag = $special.drag = {\n\n\t// these are the default settings\n\tdefaults: {\n\t\twhich: 1, // mouse button pressed to start drag sequence\n\t\tdistance: 0, // distance dragged before dragstart\n\t\tnot: ':input', // selector to suppress dragging on target elements\n\t\thandle: null, // selector to match handle target elements\n\t\trelative: false, // true to use \"position\", false to use \"offset\"\n\t\tdrop: true, // false to suppress drop events, true or selector to allow\n\t\tclick: false // false to suppress click events after dragend (no proxy)\n\t},\n\n\t// the key name for stored drag data\n\tdatakey: \"dragdata\",\n\n\t// prevent bubbling for better performance\n\tnoBubble: true,\n\n\t// count bound related events\n\tadd: function( obj ){\n\t\t// read the interaction data\n\t\tvar data = $.data( this, drag.datakey ),\n\t\t// read any passed options\n\t\topts = obj.data || {};\n\t\t// count another realted event\n\t\tdata.related += 1;\n\t\t// extend data options bound with this event\n\t\t// don't iterate \"opts\" in case it is a node\n\t\t$.each( drag.defaults, function( key, def ){\n\t\t\tif ( opts[ key ] !== undefined )\n\t\t\t\tdata[ key ] = opts[ key ];\n\t\t});\n\t},\n\n\t// forget unbound related events\n\tremove: function(){\n\t\t$.data( this, drag.datakey ).related -= 1;\n\t},\n\n\t// configure interaction, capture settings\n\tsetup: function(){\n\t\t// check for related events\n\t\tif ( $.data( this, drag.datakey ) )\n\t\t\treturn;\n\t\t// initialize the drag data with copied defaults\n\t\tvar data = $.extend({ related:0 }, drag.defaults );\n\t\t// store the interaction data\n\t\t$.data( this, drag.datakey, data );\n\t\t// bind the mousedown event, which starts drag interactions\n\t\t$event.add( this, \"touchstart mousedown\", drag.init, data );\n\t\t// prevent image dragging in IE...\n\t\tif ( this.attachEvent )\n\t\t\tthis.attachEvent(\"ondragstart\", drag.dontstart );\n\t},\n\n\t// destroy configured interaction\n\tteardown: function(){\n\t\tvar data = $.data( this, drag.datakey ) || {};\n\t\t// check for related events\n\t\tif ( data.related )\n\t\t\treturn;\n\t\t// remove the stored data\n\t\t$.removeData( this, drag.datakey );\n\t\t// remove the mousedown event\n\t\t$event.remove( this, \"touchstart mousedown\", drag.init );\n\t\t// enable text selection\n\t\tdrag.textselect( true );\n\t\t// un-prevent image dragging in IE...\n\t\tif ( this.detachEvent )\n\t\t\tthis.detachEvent(\"ondragstart\", drag.dontstart );\n\t},\n\n\t// initialize the interaction\n\tinit: function( event ){\n\t\t// sorry, only one touch at a time\n\t\tif ( drag.touched )\n\t\t\treturn;\n\t\t// the drag/drop interaction data\n\t\tvar dd = event.data, results;\n\t\t// check the which directive\n\t\tif ( event.which != 0 && dd.which > 0 && event.which != dd.which )\n\t\t\treturn;\n\t\t// check for suppressed selector\n\t\tif ( $( event.target ).is( dd.not ) )\n\t\t\treturn;\n\t\t// check for handle selector\n\t\tif ( dd.handle && !$( event.target ).closest( dd.handle, event.currentTarget ).length )\n\t\t\treturn;\n\n\t\tdrag.touched = event.type == 'touchstart' ? this : null;\n\t\tdd.propagates = 1;\n\t\tdd.mousedown = this;\n\t\tdd.interactions = [ drag.interaction( this, dd ) ];\n\t\tdd.target = event.target;\n\t\tdd.pageX = event.pageX;\n\t\tdd.pageY = event.pageY;\n\t\tdd.dragging = null;\n\t\t// handle draginit event...\n\t\tresults = drag.hijack( event, \"draginit\", dd );\n\t\t// early cancel\n\t\tif ( !dd.propagates )\n\t\t\treturn;\n\t\t// flatten the result set\n\t\tresults = drag.flatten( results );\n\t\t// insert new interaction elements\n\t\tif ( results && results.length ){\n\t\t\tdd.interactions = [];\n\t\t\t$.each( results, function(){\n\t\t\t\tdd.interactions.push( drag.interaction( this, dd ) );\n\t\t\t});\n\t\t}\n\t\t// remember how many interactions are propagating\n\t\tdd.propagates = dd.interactions.length;\n\t\t// locate and init the drop targets\n\t\tif ( dd.drop !== false && $special.drop )\n\t\t\t$special.drop.handler( event, dd );\n\t\t// disable text selection\n\t\tdrag.textselect( false );\n\t\t// bind additional events...\n\t\tif ( drag.touched )\n\t\t\t$event.add( drag.touched, \"touchmove touchend\", drag.handler, dd );\n\t\telse\n\t\t\t$event.add( document, \"mousemove mouseup\", drag.handler, dd );\n\t\t// helps prevent text selection or scrolling\n\t\tif ( !drag.touched || dd.live )\n\t\t\treturn false;\n\t},\n\n\t// returns an interaction object\n\tinteraction: function( elem, dd ){\n\t\tvar offset = $( elem )[ dd.relative ? \"position\" : \"offset\" ]() || { top:0, left:0 };\n\t\treturn {\n\t\t\tdrag: elem,\n\t\t\tcallback: new drag.callback(),\n\t\t\tdroppable: [],\n\t\t\toffset: offset\n\t\t};\n\t},\n\n\t// handle drag-releatd DOM events\n\thandler: function( event ){\n\t\t// read the data before hijacking anything\n\t\tvar dd = event.data;\n\t\t// handle various events\n\t\tswitch ( event.type ){\n\t\t\t// mousemove, check distance, start dragging\n\t\t\tcase !dd.dragging && 'touchmove':\n\t\t\t\tevent.preventDefault();\n\t\t\tcase !dd.dragging && 'mousemove':\n\t\t\t\t//  drag tolerance, x + y = distance\n\t\t\t\tif ( Math.pow(  event.pageX-dd.pageX, 2 ) + Math.pow(  event.pageY-dd.pageY, 2 ) < Math.pow( dd.distance, 2 ) )\n\t\t\t\t\tbreak; // distance tolerance not reached\n\t\t\t\tevent.target = dd.target; // force target from \"mousedown\" event (fix distance issue)\n\t\t\t\tdrag.hijack( event, \"dragstart\", dd ); // trigger \"dragstart\"\n\t\t\t\tif ( dd.propagates ) // \"dragstart\" not rejected\n\t\t\t\t\tdd.dragging = true; // activate interaction\n\t\t\t// mousemove, dragging\n\t\t\tcase 'touchmove':\n\t\t\t\tevent.preventDefault();\n\t\t\tcase 'mousemove':\n\t\t\t\tif ( dd.dragging ){\n\t\t\t\t\t// trigger \"drag\"\n\t\t\t\t\tdrag.hijack( event, \"drag\", dd );\n\t\t\t\t\tif ( dd.propagates ){\n\t\t\t\t\t\t// manage drop events\n\t\t\t\t\t\tif ( dd.drop !== false && $special.drop )\n\t\t\t\t\t\t\t$special.drop.handler( event, dd ); // \"dropstart\", \"dropend\"\n\t\t\t\t\t\tbreak; // \"drag\" not rejected, stop\n\t\t\t\t\t}\n\t\t\t\t\tevent.type = \"mouseup\"; // helps \"drop\" handler behave\n\t\t\t\t}\n\t\t\t// mouseup, stop dragging\n\t\t\tcase 'touchend':\n\t\t\tcase 'mouseup':\n\t\t\tdefault:\n\t\t\t\tif ( drag.touched )\n\t\t\t\t\t$event.remove( drag.touched, \"touchmove touchend\", drag.handler ); // remove touch events\n\t\t\t\telse\n\t\t\t\t\t$event.remove( document, \"mousemove mouseup\", drag.handler ); // remove page events\n\t\t\t\tif ( dd.dragging ){\n\t\t\t\t\tif ( dd.drop !== false && $special.drop )\n\t\t\t\t\t\t$special.drop.handler( event, dd ); // \"drop\"\n\t\t\t\t\tdrag.hijack( event, \"dragend\", dd ); // trigger \"dragend\"\n\t\t\t\t}\n\t\t\t\tdrag.textselect( true ); // enable text selection\n\t\t\t\t// if suppressing click events...\n\t\t\t\tif ( dd.click === false && dd.dragging )\n\t\t\t\t\t$.data( dd.mousedown, \"suppress.click\", new Date().getTime() + 5 );\n\t\t\t\tdd.dragging = drag.touched = false; // deactivate element\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\t// re-use event object for custom events\n\thijack: function( event, type, dd, x, elem ){\n\t\t// not configured\n\t\tif ( !dd )\n\t\t\treturn;\n\t\t// remember the original event and type\n\t\tvar orig = { event:event.originalEvent, type:event.type },\n\t\t// is the event drag related or drog related?\n\t\tmode = type.indexOf(\"drop\") ? \"drag\" : \"drop\",\n\t\t// iteration vars\n\t\tresult, i = x || 0, ia, $elems, callback,\n\t\tlen = !isNaN( x ) ? x : dd.interactions.length;\n\t\t// modify the event type\n\t\tevent.type = type;\n\t\t// remove the original event\n\t\tevent.originalEvent = null;\n\t\t// initialize the results\n\t\tdd.results = [];\n\t\t// handle each interacted element\n\t\tdo if ( ia = dd.interactions[ i ] ){\n\t\t\t// validate the interaction\n\t\t\tif ( type !== \"dragend\" && ia.cancelled )\n\t\t\t\tcontinue;\n\t\t\t// set the dragdrop properties on the event object\n\t\t\tcallback = drag.properties( event, dd, ia );\n\t\t\t// prepare for more results\n\t\t\tia.results = [];\n\t\t\t// handle each element\n\t\t\t$( elem || ia[ mode ] || dd.droppable ).each(function( p, subject ){\n\t\t\t\t// identify drag or drop targets individually\n\t\t\t\tcallback.target = subject;\n\t\t\t\t// force propagtion of the custom event\n\t\t\t\tevent.isPropagationStopped = function(){ return false; };\n\t\t\t\t// handle the event\n\t\t\t\tresult = subject ? $event.dispatch.call( subject, event, callback ) : null;\n\t\t\t\t// stop the drag interaction for this element\n\t\t\t\tif ( result === false ){\n\t\t\t\t\tif ( mode == \"drag\" ){\n\t\t\t\t\t\tia.cancelled = true;\n\t\t\t\t\t\tdd.propagates -= 1;\n\t\t\t\t\t}\n\t\t\t\t\tif ( type == \"drop\" ){\n\t\t\t\t\t\tia[ mode ][p] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// assign any dropinit elements\n\t\t\t\telse if ( type == \"dropinit\" )\n\t\t\t\t\tia.droppable.push( drag.element( result ) || subject );\n\t\t\t\t// accept a returned proxy element\n\t\t\t\tif ( type == \"dragstart\" )\n\t\t\t\t\tia.proxy = $( drag.element( result ) || ia.drag )[0];\n\t\t\t\t// remember this result\n\t\t\t\tia.results.push( result );\n\t\t\t\t// forget the event result, for recycling\n\t\t\t\tdelete event.result;\n\t\t\t\t// break on cancelled handler\n\t\t\t\tif ( type !== \"dropinit\" )\n\t\t\t\t\treturn result;\n\t\t\t});\n\t\t\t// flatten the results\n\t\t\tdd.results[ i ] = drag.flatten( ia.results );\n\t\t\t// accept a set of valid drop targets\n\t\t\tif ( type == \"dropinit\" )\n\t\t\t\tia.droppable = drag.flatten( ia.droppable );\n\t\t\t// locate drop targets\n\t\t\tif ( type == \"dragstart\" && !ia.cancelled )\n\t\t\t\tcallback.update();\n\t\t}\n\t\twhile ( ++i < len )\n\t\t// restore the original event & type\n\t\tevent.type = orig.type;\n\t\tevent.originalEvent = orig.event;\n\t\t// return all handler results\n\t\treturn drag.flatten( dd.results );\n\t},\n\n\t// extend the callback object with drag/drop properties...\n\tproperties: function( event, dd, ia ){\n\t\tvar obj = ia.callback;\n\t\t// elements\n\t\tobj.drag = ia.drag;\n\t\tobj.proxy = ia.proxy || ia.drag;\n\t\t// starting mouse position\n\t\tobj.startX = dd.pageX;\n\t\tobj.startY = dd.pageY;\n\t\t// current distance dragged\n\t\tobj.deltaX = event.pageX - dd.pageX;\n\t\tobj.deltaY = event.pageY - dd.pageY;\n\t\t// original element position\n\t\tobj.originalX = ia.offset.left;\n\t\tobj.originalY = ia.offset.top;\n\t\t// adjusted element position\n\t\tobj.offsetX = obj.originalX + obj.deltaX;\n\t\tobj.offsetY = obj.originalY + obj.deltaY;\n\t\t// assign the drop targets information\n\t\tobj.drop = drag.flatten( ( ia.drop || [] ).slice() );\n\t\tobj.available = drag.flatten( ( ia.droppable || [] ).slice() );\n\t\treturn obj;\n\t},\n\n\t// determine is the argument is an element or jquery instance\n\telement: function( arg ){\n\t\tif ( arg && ( arg.jquery || arg.nodeType == 1 ) )\n\t\t\treturn arg;\n\t},\n\n\t// flatten nested jquery objects and arrays into a single dimension array\n\tflatten: function( arr ){\n\t\treturn $.map( arr, function( member ){\n\t\t\treturn member && member.jquery ? $.makeArray( member ) :\n\t\t\t\tmember && member.length ? drag.flatten( member ) : member;\n\t\t});\n\t},\n\n\t// toggles text selection attributes ON (true) or OFF (false)\n\ttextselect: function( bool ){\n\t\t$( document )[ bool ? \"unbind\" : \"bind\" ](\"selectstart\", drag.dontstart )\n\t\t\t.css(\"MozUserSelect\", bool ? \"\" : \"none\" );\n\t\t// .attr(\"unselectable\", bool ? \"off\" : \"on\" )\n\t\tdocument.unselectable = bool ? \"off\" : \"on\";\n\t},\n\n\t// suppress \"selectstart\" and \"ondragstart\" events\n\tdontstart: function(){\n\t\treturn false;\n\t},\n\n\t// a callback instance contructor\n\tcallback: function(){}\n\n};\n\n// callback methods\ndrag.callback.prototype = {\n\tupdate: function(){\n\t\tif ( $special.drop && this.available.length )\n\t\t\t$.each( this.available, function( i ){\n\t\t\t\t$special.drop.locate( this, i );\n\t\t\t});\n\t}\n};\n\n// patch $.event.$dispatch to allow suppressing clicks\nvar $dispatch = $event.dispatch;\n$event.dispatch = function( event ){\n\tif ( $.data( this, \"suppress.\"+ event.type ) - new Date().getTime() > 0 ){\n\t\t$.removeData( this, \"suppress.\"+ event.type );\n\t\treturn;\n\t}\n\treturn $dispatch.apply( this, arguments );\n};\n\n// event fix hooks for touch events...\nvar touchHooks =\n$event.fixHooks.touchstart =\n$event.fixHooks.touchmove =\n$event.fixHooks.touchend =\n$event.fixHooks.touchcancel = {\n\tprops: \"clientX clientY pageX pageY screenX screenY\".split( \" \" ),\n\tfilter: function( event, orig ) {\n\t\tif ( orig ){\n\t\t\tvar touched = ( orig.touches && orig.touches[0] )\n\t\t\t\t|| ( orig.changedTouches && orig.changedTouches[0] )\n\t\t\t\t|| null;\n\t\t\t// iOS webkit: touchstart, touchmove, touchend\n\t\t\tif ( touched )\n\t\t\t\t$.each( touchHooks.props, function( i, prop ){\n\t\t\t\t\tevent[ prop ] = touched[ prop ];\n\t\t\t\t});\n\t\t}\n\t\treturn event;\n\t}\n};\n\n// share the same special event configuration with related events...\n$special.draginit = $special.dragstart = $special.dragend = drag;\n","/*!\n * jquery.event.drop - v 2.2\n * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com\n * Open Source MIT License - http://threedubmedia.com/code/license\n */\n// Created: 2008-06-04\n// Updated: 2012-05-21\n// REQUIRES: jquery 1.7.x, event.drag 2.2\n\nvar $ = require(\"jquery\");\nvar $1 = require(\"jquery_event_drag\");\n\n// Events: drop, dropstart, dropend\n\n// add the jquery instance method\n$.fn.drop = function( str, arg, opts ){\n\t// figure out the event type\n\tvar type = typeof str == \"string\" ? str : \"\",\n\t// figure out the event handler...\n\tfn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;\n\t// fix the event type\n\tif ( type.indexOf(\"drop\") !== 0 )\n\t\ttype = \"drop\"+ type;\n\t// were options passed\n\topts = ( str == fn ? arg : opts ) || {};\n\t// trigger or bind event handler\n\treturn fn ? this.bind( type, opts, fn ) : this.trigger( type );\n};\n\n// DROP MANAGEMENT UTILITY\n// returns filtered drop target elements, caches their positions\n$.drop = function( opts ){\n\topts = opts || {};\n\t// safely set new options...\n\tdrop.multi = opts.multi === true ? Infinity :\n\t\topts.multi === false ? 1 : !isNaN( opts.multi ) ? opts.multi : drop.multi;\n\tdrop.delay = opts.delay || drop.delay;\n\tdrop.tolerance = $.isFunction( opts.tolerance ) ? opts.tolerance :\n\t\topts.tolerance === null ? null : drop.tolerance;\n\tdrop.mode = opts.mode || drop.mode || 'intersect';\n};\n\n// local refs (increase compression)\nvar $event = $.event,\n$special = $event.special,\n// configure the drop special event\ndrop = $.event.special.drop = {\n\n\t// these are the default settings\n\tmulti: 1, // allow multiple drop winners per dragged element\n\tdelay: 20, // async timeout delay\n\tmode: 'overlap', // drop tolerance mode\n\n\t// internal cache\n\ttargets: [],\n\n\t// the key name for stored drop data\n\tdatakey: \"dropdata\",\n\n\t// prevent bubbling for better performance\n\tnoBubble: true,\n\n\t// count bound related events\n\tadd: function( obj ){\n\t\t// read the interaction data\n\t\tvar data = $.data( this, drop.datakey );\n\t\t// count another realted event\n\t\tdata.related += 1;\n\t},\n\n\t// forget unbound related events\n\tremove: function(){\n\t\t$.data( this, drop.datakey ).related -= 1;\n\t},\n\n\t// configure the interactions\n\tsetup: function(){\n\t\t// check for related events\n\t\tif ( $.data( this, drop.datakey ) )\n\t\t\treturn;\n\t\t// initialize the drop element data\n\t\tvar data = {\n\t\t\trelated: 0,\n\t\t\tactive: [],\n\t\t\tanyactive: 0,\n\t\t\twinner: 0,\n\t\t\tlocation: {}\n\t\t};\n\t\t// store the drop data on the element\n\t\t$.data( this, drop.datakey, data );\n\t\t// store the drop target in internal cache\n\t\tdrop.targets.push( this );\n\t},\n\n\t// destroy the configure interaction\n\tteardown: function(){\n\t\tvar data = $.data( this, drop.datakey ) || {};\n\t\t// check for related events\n\t\tif ( data.related )\n\t\t\treturn;\n\t\t// remove the stored data\n\t\t$.removeData( this, drop.datakey );\n\t\t// reference the targeted element\n\t\tvar element = this;\n\t\t// remove from the internal cache\n\t\tdrop.targets = $.grep( drop.targets, function( target ){\n\t\t\treturn ( target !== element );\n\t\t});\n\t},\n\n\t// shared event handler\n\thandler: function( event, dd ){\n\t\t// local vars\n\t\tvar results, $targets;\n\t\t// make sure the right data is available\n\t\tif ( !dd )\n\t\t\treturn;\n\t\t// handle various events\n\t\tswitch ( event.type ){\n\t\t\t// draginit, from $.event.special.drag\n\t\t\tcase 'mousedown': // DROPINIT >>\n\t\t\tcase 'touchstart': // DROPINIT >>\n\t\t\t\t// collect and assign the drop targets\n\t\t\t\t$targets =  $( drop.targets );\n\t\t\t\tif ( typeof dd.drop == \"string\" )\n\t\t\t\t\t$targets = $targets.filter( dd.drop );\n\t\t\t\t// reset drop data winner properties\n\t\t\t\t$targets.each(function(){\n\t\t\t\t\tvar data = $.data( this, drop.datakey );\n\t\t\t\t\tdata.active = [];\n\t\t\t\t\tdata.anyactive = 0;\n\t\t\t\t\tdata.winner = 0;\n\t\t\t\t});\n\t\t\t\t// set available target elements\n\t\t\t\tdd.droppable = $targets;\n\t\t\t\t// activate drop targets for the initial element being dragged\n\t\t\t\t$special.drag.hijack( event, \"dropinit\", dd );\n\t\t\t\tbreak;\n\t\t\t// drag, from $.event.special.drag\n\t\t\tcase 'mousemove': // TOLERATE >>\n\t\t\tcase 'touchmove': // TOLERATE >>\n\t\t\t\tdrop.event = event; // store the mousemove event\n\t\t\t\tif ( !drop.timer )\n\t\t\t\t\t// monitor drop targets\n\t\t\t\t\tdrop.tolerate( dd );\n\t\t\t\tbreak;\n\t\t\t// dragend, from $.event.special.drag\n\t\t\tcase 'mouseup': // DROP >> DROPEND >>\n\t\t\tcase 'touchend': // DROP >> DROPEND >>\n\t\t\t\tdrop.timer = clearTimeout( drop.timer ); // delete timer\n\t\t\t\tif ( dd.propagates ){\n\t\t\t\t\t$special.drag.hijack( event, \"drop\", dd );\n\t\t\t\t\t$special.drag.hijack( event, \"dropend\", dd );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t}\n\t},\n\n\t// returns the location positions of an element\n\tlocate: function( elem, index ){\n\t\tvar data = $.data( elem, drop.datakey ),\n\t\t$elem = $( elem ),\n\t\tposi = $elem.offset() || {},\n\t\theight = $elem.outerHeight(),\n\t\twidth = $elem.outerWidth(),\n\t\tlocation = {\n\t\t\telem: elem,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\ttop: posi.top,\n\t\t\tleft: posi.left,\n\t\t\tright: posi.left + width,\n\t\t\tbottom: posi.top + height\n\t\t};\n\t\t// drag elements might not have dropdata\n\t\tif ( data ){\n\t\t\tdata.location = location;\n\t\t\tdata.index = index;\n\t\t\tdata.elem = elem;\n\t\t}\n\t\treturn location;\n\t},\n\n\t// test the location positions of an element against another OR an X,Y coord\n\tcontains: function( target, test ){ // target { location } contains test [x,y] or { location }\n\t\treturn ( ( test[0] || test.left ) >= target.left && ( test[0] || test.right ) <= target.right\n\t\t\t&& ( test[1] || test.top ) >= target.top && ( test[1] || test.bottom ) <= target.bottom );\n\t},\n\n\t// stored tolerance modes\n\tmodes: { // fn scope: \"$.event.special.drop\" object\n\t\t// target with mouse wins, else target with most overlap wins\n\t\t'intersect': function( event, proxy, target ){\n\t\t\treturn this.contains( target, [ event.pageX, event.pageY ] ) ? // check cursor\n\t\t\t\t1e9 : this.modes.overlap.apply( this, arguments ); // check overlap\n\t\t},\n\t\t// target with most overlap wins\n\t\t'overlap': function( event, proxy, target ){\n\t\t\t// calculate the area of overlap...\n\t\t\treturn Math.max( 0, Math.min( target.bottom, proxy.bottom ) - Math.max( target.top, proxy.top ) )\n\t\t\t\t* Math.max( 0, Math.min( target.right, proxy.right ) - Math.max( target.left, proxy.left ) );\n\t\t},\n\t\t// proxy is completely contained within target bounds\n\t\t'fit': function( event, proxy, target ){\n\t\t\treturn this.contains( target, proxy ) ? 1 : 0;\n\t\t},\n\t\t// center of the proxy is contained within target bounds\n\t\t'middle': function( event, proxy, target ){\n\t\t\treturn this.contains( target, [ proxy.left + proxy.width * .5, proxy.top + proxy.height * .5 ] ) ? 1 : 0;\n\t\t}\n\t},\n\n\t// sort drop target cache by by winner (dsc), then index (asc)\n\tsort: function( a, b ){\n\t\treturn ( b.winner - a.winner ) || ( a.index - b.index );\n\t},\n\n\t// async, recursive tolerance execution\n\ttolerate: function( dd ){\n\t\t// declare local refs\n\t\tvar i, drp, drg, data, arr, len, elem,\n\t\t// interaction iteration variables\n\t\tx = 0, ia, end = dd.interactions.length,\n\t\t// determine the mouse coords\n\t\txy = [ drop.event.pageX, drop.event.pageY ],\n\t\t// custom or stored tolerance fn\n\t\ttolerance = drop.tolerance || drop.modes[ drop.mode ];\n\t\t// go through each passed interaction...\n\t\tdo if ( ia = dd.interactions[x] ){\n\t\t\t// check valid interaction\n\t\t\tif ( !ia )\n\t\t\t\treturn;\n\t\t\t// initialize or clear the drop data\n\t\t\tia.drop = [];\n\t\t\t// holds the drop elements\n\t\t\tarr = [];\n\t\t\tlen = ia.droppable.length;\n\t\t\t// determine the proxy location, if needed\n\t\t\tif ( tolerance )\n\t\t\t\tdrg = drop.locate( ia.proxy );\n\t\t\t// reset the loop\n\t\t\ti = 0;\n\t\t\t// loop each stored drop target\n\t\t\tdo if ( elem = ia.droppable[i] ){\n\t\t\t\tdata = $.data( elem, drop.datakey );\n\t\t\t\tdrp = data.location;\n\t\t\t\tif ( !drp ) continue;\n\t\t\t\t// find a winner: tolerance function is defined, call it\n\t\t\t\tdata.winner = tolerance ? tolerance.call( drop, drop.event, drg, drp )\n\t\t\t\t\t// mouse position is always the fallback\n\t\t\t\t\t: drop.contains( drp, xy ) ? 1 : 0;\n\t\t\t\tarr.push( data );\n\t\t\t} while ( ++i < len ); // loop\n\t\t\t// sort the drop targets\n\t\t\tarr.sort( drop.sort );\n\t\t\t// reset the loop\n\t\t\ti = 0;\n\t\t\t// loop through all of the targets again\n\t\t\tdo if ( data = arr[ i ] ){\n\t\t\t\t// winners...\n\t\t\t\tif ( data.winner && ia.drop.length < drop.multi ){\n\t\t\t\t\t// new winner... dropstart\n\t\t\t\t\tif ( !data.active[x] && !data.anyactive ){\n\t\t\t\t\t\t// check to make sure that this is not prevented\n\t\t\t\t\t\tif ( $special.drag.hijack( drop.event, \"dropstart\", dd, x, data.elem )[0] !== false ){\n\t\t\t\t\t\t\tdata.active[x] = 1;\n\t\t\t\t\t\t\tdata.anyactive += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if false, it is not a winner\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdata.winner = 0;\n\t\t\t\t\t}\n\t\t\t\t\t// if it is still a winner\n\t\t\t\t\tif ( data.winner )\n\t\t\t\t\t\tia.drop.push( data.elem );\n\t\t\t\t}\n\t\t\t\t// losers...\n\t\t\t\telse if ( data.active[x] && data.anyactive == 1 ){\n\t\t\t\t\t// former winner... dropend\n\t\t\t\t\t$special.drag.hijack( drop.event, \"dropend\", dd, x, data.elem );\n\t\t\t\t\tdata.active[x] = 0;\n\t\t\t\t\tdata.anyactive -= 1;\n\t\t\t\t}\n\t\t\t} while ( ++i < len ); // loop\n\t\t} while ( ++x < end ) // loop\n\t\t// check if the mouse is still moving or is idle\n\t\tif ( drop.last && xy[0] == drop.last.pageX && xy[1] == drop.last.pageY )\n\t\t\tdelete drop.timer; // idle, don't recurse\n\t\telse  // recurse\n\t\t\tdrop.timer = setTimeout(function(){\n\t\t\t\tdrop.tolerate( dd );\n\t\t\t}, drop.delay );\n\t\t// remember event, to compare idleness\n\t\tdrop.last = drop.event;\n\t}\n\n};\n\n// share the same special event configuration with related events...\n$special.dropinit = $special.dropstart = $special.dropend = drop;\n","var $ = require(\"jquery\");\nvar Slick = require(\"../slick.core\");\n\nfunction CheckboxSelectColumn(options) {\n  var _grid;\n  var _self = this;\n  var _handler = new Slick.EventHandler();\n  var _selectedRowsLookup = {};\n  var _defaults = {\n    columnId: \"_checkbox_selector\",\n    cssClass: null,\n    toolTip: \"Select/Deselect All\",\n    width: 30\n  };\n\n  var _options = $.extend(true, {}, _defaults, options);\n\n  function init(grid) {\n    _grid = grid;\n    _handler\n      .subscribe(_grid.onSelectedRowsChanged, handleSelectedRowsChanged)\n      .subscribe(_grid.onClick, handleClick)\n      .subscribe(_grid.onHeaderClick, handleHeaderClick)\n      .subscribe(_grid.onKeyDown, handleKeyDown);\n  }\n\n  function destroy() {\n    _handler.unsubscribeAll();\n  }\n\n  function handleSelectedRowsChanged(e, args) {\n    var selectedRows = _grid.getSelectedRows();\n    var lookup = {}, row, i;\n    for (i = 0; i < selectedRows.length; i++) {\n      row = selectedRows[i];\n      lookup[row] = true;\n      if (lookup[row] !== _selectedRowsLookup[row]) {\n        _grid.invalidateRow(row);\n        delete _selectedRowsLookup[row];\n      }\n    }\n    for (i in _selectedRowsLookup) {\n      _grid.invalidateRow(i);\n    }\n    _selectedRowsLookup = lookup;\n    _grid.render();\n\n    if (selectedRows.length && selectedRows.length == _grid.getDataLength()) {\n      _grid.updateColumnHeader(_options.columnId, \"<input type='checkbox' checked='checked'>\", _options.toolTip);\n    } else {\n      _grid.updateColumnHeader(_options.columnId, \"<input type='checkbox'>\", _options.toolTip);\n    }\n  }\n\n  function handleKeyDown(e, args) {\n    if (e.which == 32) {\n      if (_grid.getColumns()[args.cell].id === _options.columnId) {\n        // if editing, try to commit\n        if (!_grid.getEditorLock().isActive() || _grid.getEditorLock().commitCurrentEdit()) {\n          toggleRowSelection(args.row);\n        }\n        e.preventDefault();\n        e.stopImmediatePropagation();\n      }\n    }\n  }\n\n  function handleClick(e, args) {\n    // clicking on a row select checkbox\n    if (_grid.getColumns()[args.cell].id === _options.columnId && $(e.target).is(\":checkbox\")) {\n      // if editing, try to commit\n      if (_grid.getEditorLock().isActive() && !_grid.getEditorLock().commitCurrentEdit()) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return;\n      }\n\n      toggleRowSelection(args.row);\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n\n  function toggleRowSelection(row) {\n    if (_selectedRowsLookup[row]) {\n      _grid.setSelectedRows($.grep(_grid.getSelectedRows(), function (n) {\n        return n != row\n      }));\n    } else {\n      _grid.setSelectedRows(_grid.getSelectedRows().concat(row));\n    }\n  }\n\n  function handleHeaderClick(e, args) {\n    if (args.column.id == _options.columnId && $(e.target).is(\":checkbox\")) {\n      // if editing, try to commit\n      if (_grid.getEditorLock().isActive() && !_grid.getEditorLock().commitCurrentEdit()) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return;\n      }\n\n      if ($(e.target).is(\":checked\")) {\n        var rows = [];\n        for (var i = 0; i < _grid.getDataLength(); i++) {\n          rows.push(i);\n        }\n        _grid.setSelectedRows(rows);\n      } else {\n        _grid.setSelectedRows([]);\n      }\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n\n  function getColumnDefinition() {\n    return {\n      id: _options.columnId,\n      name: \"<input type='checkbox'>\",\n      toolTip: _options.toolTip,\n      field: \"sel\",\n      width: _options.width,\n      resizable: false,\n      sortable: false,\n      cssClass: _options.cssClass,\n      formatter: checkboxSelectionFormatter\n    };\n  }\n\n  function checkboxSelectionFormatter(row, cell, value, columnDef, dataContext) {\n    if (dataContext) {\n      return _selectedRowsLookup[row]\n          ? \"<input type='checkbox' checked='checked'>\"\n          : \"<input type='checkbox'>\";\n    }\n    return null;\n  }\n\n  $.extend(this, {\n    \"init\": init,\n    \"destroy\": destroy,\n\n    \"getColumnDefinition\": getColumnDefinition\n  });\n}\n\nmodule.exports = CheckboxSelectColumn;\n","var $ = require(\"jquery\");\nvar Slick = require(\"../slick.core\");\n\nfunction RowSelectionModel(options) {\n  var _grid;\n  var _ranges = [];\n  var _self = this;\n  var _handler = new Slick.EventHandler();\n  var _inHandler;\n  var _options;\n  var _defaults = {\n    selectActiveRow: true\n  };\n\n  function init(grid) {\n    _options = $.extend(true, {}, _defaults, options);\n    _grid = grid;\n    _handler.subscribe(_grid.onActiveCellChanged,\n        wrapHandler(handleActiveCellChange));\n    _handler.subscribe(_grid.onKeyDown,\n        wrapHandler(handleKeyDown));\n    _handler.subscribe(_grid.onClick,\n        wrapHandler(handleClick));\n  }\n\n  function destroy() {\n    _handler.unsubscribeAll();\n  }\n\n  function wrapHandler(handler) {\n    return function () {\n      if (!_inHandler) {\n        _inHandler = true;\n        handler.apply(this, arguments);\n        _inHandler = false;\n      }\n    };\n  }\n\n  function rangesToRows(ranges) {\n    var rows = [];\n    for (var i = 0; i < ranges.length; i++) {\n      for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\n        rows.push(j);\n      }\n    }\n    return rows;\n  }\n\n  function rowsToRanges(rows) {\n    var ranges = [];\n    var lastCell = _grid.getColumns().length - 1;\n    for (var i = 0; i < rows.length; i++) {\n      ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));\n    }\n    return ranges;\n  }\n\n  function getRowsRange(from, to) {\n    var i, rows = [];\n    for (i = from; i <= to; i++) {\n      rows.push(i);\n    }\n    for (i = to; i < from; i++) {\n      rows.push(i);\n    }\n    return rows;\n  }\n\n  function getSelectedRows() {\n    return rangesToRows(_ranges);\n  }\n\n  function setSelectedRows(rows) {\n    setSelectedRanges(rowsToRanges(rows));\n  }\n\n  function setSelectedRanges(ranges) {\n    _ranges = ranges;\n    _self.onSelectedRangesChanged.notify(_ranges);\n  }\n\n  function getSelectedRanges() {\n    return _ranges;\n  }\n\n  function handleActiveCellChange(e, data) {\n    if (_options.selectActiveRow && data.row != null) {\n      setSelectedRanges([new Slick.Range(data.row, 0, data.row, _grid.getColumns().length - 1)]);\n    }\n  }\n\n  function handleKeyDown(e) {\n    var activeRow = _grid.getActiveCell();\n    if (activeRow && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && (e.which == 38 || e.which == 40)) {\n      var selectedRows = getSelectedRows();\n      selectedRows.sort(function (x, y) {\n        return x - y\n      });\n\n      if (!selectedRows.length) {\n        selectedRows = [activeRow.row];\n      }\n\n      var top = selectedRows[0];\n      var bottom = selectedRows[selectedRows.length - 1];\n      var active;\n\n      if (e.which == 40) {\n        active = activeRow.row < bottom || top == bottom ? ++bottom : ++top;\n      } else {\n        active = activeRow.row < bottom ? --bottom : --top;\n      }\n\n      if (active >= 0 && active < _grid.getDataLength()) {\n        _grid.scrollRowIntoView(active);\n        _ranges = rowsToRanges(getRowsRange(top, bottom));\n        setSelectedRanges(_ranges);\n      }\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n  function handleClick(e) {\n    var cell = _grid.getCellFromEvent(e);\n    if (!cell || !_grid.canCellBeActive(cell.row, cell.cell)) {\n      return false;\n    }\n\n    if (!_grid.getOptions().multiSelect || (\n        !e.ctrlKey && !e.shiftKey && !e.metaKey)) {\n      return false;\n    }\n\n    var selection = rangesToRows(_ranges);\n    var idx = $.inArray(cell.row, selection);\n\n    if (idx === -1 && (e.ctrlKey || e.metaKey)) {\n      selection.push(cell.row);\n      _grid.setActiveCell(cell.row, cell.cell);\n    } else if (idx !== -1 && (e.ctrlKey || e.metaKey)) {\n      selection = $.grep(selection, function (o, i) {\n        return (o !== cell.row);\n      });\n      _grid.setActiveCell(cell.row, cell.cell);\n    } else if (selection.length && e.shiftKey) {\n      var last = selection.pop();\n      var from = Math.min(cell.row, last);\n      var to = Math.max(cell.row, last);\n      selection = [];\n      for (var i = from; i <= to; i++) {\n        if (i !== last) {\n          selection.push(i);\n        }\n      }\n      selection.push(last);\n      _grid.setActiveCell(cell.row, cell.cell);\n    }\n\n    _ranges = rowsToRanges(selection);\n    setSelectedRanges(_ranges);\n    e.stopImmediatePropagation();\n\n    return true;\n  }\n\n  $.extend(this, {\n    \"getSelectedRows\": getSelectedRows,\n    \"setSelectedRows\": setSelectedRows,\n\n    \"getSelectedRanges\": getSelectedRanges,\n    \"setSelectedRanges\": setSelectedRanges,\n\n    \"init\": init,\n    \"destroy\": destroy,\n\n    \"onSelectedRangesChanged\": new Slick.Event()\n  });\n}\n\nmodule.exports = RowSelectionModel;\n","/***\n * Contains core SlickGrid classes.\n * @module Core\n * @namespace Slick\n */\n\nvar $ = require(\"jquery\");\n\n// register namespace\nvar Slick = {\n  Event: Event,\n  EventData: EventData,\n  EventHandler: EventHandler,\n  Range: Range,\n  NonDataRow: NonDataItem,\n  Group: Group,\n  GroupTotals: GroupTotals,\n  EditorLock: EditorLock,\n\n    /***\n     * A global singleton editor lock.\n     * @class GlobalEditorLock\n     * @static\n     * @constructor\n     */\n  GlobalEditorLock: new EditorLock()\n};\n\n/***\n * An event object for passing data to event handlers and letting them control propagation.\n * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\n * @class EventData\n * @constructor\n */\nfunction EventData() {\n  var isPropagationStopped = false;\n  var isImmediatePropagationStopped = false;\n\n  /***\n   * Stops event from propagating up the DOM tree.\n   * @method stopPropagation\n   */\n  this.stopPropagation = function () {\n    isPropagationStopped = true;\n  };\n\n  /***\n   * Returns whether stopPropagation was called on this event object.\n   * @method isPropagationStopped\n   * @return {Boolean}\n   */\n  this.isPropagationStopped = function () {\n    return isPropagationStopped;\n  };\n\n  /***\n   * Prevents the rest of the handlers from being executed.\n   * @method stopImmediatePropagation\n   */\n  this.stopImmediatePropagation = function () {\n    isImmediatePropagationStopped = true;\n  };\n\n  /***\n   * Returns whether stopImmediatePropagation was called on this event object.\\\n   * @method isImmediatePropagationStopped\n   * @return {Boolean}\n   */\n  this.isImmediatePropagationStopped = function () {\n    return isImmediatePropagationStopped;\n  }\n}\n\n/***\n * A simple publisher-subscriber implementation.\n * @class Event\n * @constructor\n */\nfunction Event() {\n  var handlers = [];\n\n  /***\n   * Adds an event handler to be called when the event is fired.\n   * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\n   * object the event was fired with.<p>\n   * @method subscribe\n   * @param fn {Function} Event handler.\n   */\n  this.subscribe = function (fn) {\n    handlers.push(fn);\n  };\n\n  /***\n   * Removes an event handler added with <code>subscribe(fn)</code>.\n   * @method unsubscribe\n   * @param fn {Function} Event handler to be removed.\n   */\n  this.unsubscribe = function (fn) {\n    for (var i = handlers.length - 1; i >= 0; i--) {\n      if (handlers[i] === fn) {\n        handlers.splice(i, 1);\n      }\n    }\n  };\n\n  /***\n   * Fires an event notifying all subscribers.\n   * @method notify\n   * @param args {Object} Additional data object to be passed to all handlers.\n   * @param e {EventData}\n   *      Optional.\n   *      An <code>EventData</code> object to be passed to all handlers.\n   *      For DOM events, an existing W3C/jQuery event object can be passed in.\n   * @param scope {Object}\n   *      Optional.\n   *      The scope (\"this\") within which the handler will be executed.\n   *      If not specified, the scope will be set to the <code>Event</code> instance.\n   */\n  this.notify = function (args, e, scope) {\n    e = e || new EventData();\n    scope = scope || this;\n\n    var returnValue;\n    for (var i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {\n      returnValue = handlers[i].call(scope, e, args);\n    }\n\n    return returnValue;\n  };\n}\n\nfunction EventHandler() {\n  var handlers = [];\n\n  this.subscribe = function (event, handler) {\n    handlers.push({\n      event: event,\n      handler: handler\n    });\n    event.subscribe(handler);\n\n    return this;  // allow chaining\n  };\n\n  this.unsubscribe = function (event, handler) {\n    var i = handlers.length;\n    while (i--) {\n      if (handlers[i].event === event &&\n          handlers[i].handler === handler) {\n        handlers.splice(i, 1);\n        event.unsubscribe(handler);\n        return;\n      }\n    }\n\n    return this;  // allow chaining\n  };\n\n  this.unsubscribeAll = function () {\n    var i = handlers.length;\n    while (i--) {\n      handlers[i].event.unsubscribe(handlers[i].handler);\n    }\n    handlers = [];\n\n    return this;  // allow chaining\n  }\n}\n\n/***\n * A structure containing a range of cells.\n * @class Range\n * @constructor\n * @param fromRow {Integer} Starting row.\n * @param fromCell {Integer} Starting cell.\n * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\n * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\n */\nfunction Range(fromRow, fromCell, toRow, toCell) {\n  if (toRow === undefined && toCell === undefined) {\n    toRow = fromRow;\n    toCell = fromCell;\n  }\n\n  /***\n   * @property fromRow\n   * @type {Integer}\n   */\n  this.fromRow = Math.min(fromRow, toRow);\n\n  /***\n   * @property fromCell\n   * @type {Integer}\n   */\n  this.fromCell = Math.min(fromCell, toCell);\n\n  /***\n   * @property toRow\n   * @type {Integer}\n   */\n  this.toRow = Math.max(fromRow, toRow);\n\n  /***\n   * @property toCell\n   * @type {Integer}\n   */\n  this.toCell = Math.max(fromCell, toCell);\n\n  /***\n   * Returns whether a range represents a single row.\n   * @method isSingleRow\n   * @return {Boolean}\n   */\n  this.isSingleRow = function () {\n    return this.fromRow == this.toRow;\n  };\n\n  /***\n   * Returns whether a range represents a single cell.\n   * @method isSingleCell\n   * @return {Boolean}\n   */\n  this.isSingleCell = function () {\n    return this.fromRow == this.toRow && this.fromCell == this.toCell;\n  };\n\n  /***\n   * Returns whether a range contains a given cell.\n   * @method contains\n   * @param row {Integer}\n   * @param cell {Integer}\n   * @return {Boolean}\n   */\n  this.contains = function (row, cell) {\n    return row >= this.fromRow && row <= this.toRow &&\n        cell >= this.fromCell && cell <= this.toCell;\n  };\n\n  /***\n   * Returns a readable representation of a range.\n   * @method toString\n   * @return {String}\n   */\n  this.toString = function () {\n    if (this.isSingleCell()) {\n      return \"(\" + this.fromRow + \":\" + this.fromCell + \")\";\n    }\n    else {\n      return \"(\" + this.fromRow + \":\" + this.fromCell + \" - \" + this.toRow + \":\" + this.toCell + \")\";\n    }\n  }\n}\n\n\n/***\n * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\n * @class NonDataItem\n * @constructor\n */\nfunction NonDataItem() {\n  this.__nonDataRow = true;\n}\n\n\n/***\n * Information about a group of rows.\n * @class Group\n * @extends Slick.NonDataItem\n * @constructor\n */\nfunction Group() {\n  this.__group = true;\n\n  /**\n   * Grouping level, starting with 0.\n   * @property level\n   * @type {Number}\n   */\n  this.level = 0;\n\n  /***\n   * Number of rows in the group.\n   * @property count\n   * @type {Integer}\n   */\n  this.count = 0;\n\n  /***\n   * Grouping value.\n   * @property value\n   * @type {Object}\n   */\n  this.value = null;\n\n  /***\n   * Formatted display value of the group.\n   * @property title\n   * @type {String}\n   */\n  this.title = null;\n\n  /***\n   * Whether a group is collapsed.\n   * @property collapsed\n   * @type {Boolean}\n   */\n  this.collapsed = false;\n\n  /***\n   * GroupTotals, if any.\n   * @property totals\n   * @type {GroupTotals}\n   */\n  this.totals = null;\n\n  /**\n   * Rows that are part of the group.\n   * @property rows\n   * @type {Array}\n   */\n  this.rows = [];\n\n  /**\n   * Sub-groups that are part of the group.\n   * @property groups\n   * @type {Array}\n   */\n  this.groups = null;\n\n  /**\n   * A unique key used to identify the group.  This key can be used in calls to DataView\n   * collapseGroup() or expandGroup().\n   * @property groupingKey\n   * @type {Object}\n   */\n  this.groupingKey = null;\n}\n\nGroup.prototype = new NonDataItem();\n\n/***\n * Compares two Group instances.\n * @method equals\n * @return {Boolean}\n * @param group {Group} Group instance to compare to.\n */\nGroup.prototype.equals = function (group) {\n  return this.value === group.value &&\n      this.count === group.count &&\n      this.collapsed === group.collapsed &&\n      this.title === group.title;\n};\n\n/***\n * Information about group totals.\n * An instance of GroupTotals will be created for each totals row and passed to the aggregators\n * so that they can store arbitrary data in it.  That data can later be accessed by group totals\n * formatters during the display.\n * @class GroupTotals\n * @extends Slick.NonDataItem\n * @constructor\n */\nfunction GroupTotals() {\n  this.__groupTotals = true;\n\n  /***\n   * Parent Group.\n   * @param group\n   * @type {Group}\n   */\n  this.group = null;\n\n  /***\n   * Whether the totals have been fully initialized / calculated.\n   * Will be set to false for lazy-calculated group totals.\n   * @param initialized\n   * @type {Boolean}\n   */\n  this.initialized = false;\n}\n\nGroupTotals.prototype = new NonDataItem();\n\n/***\n * A locking helper to track the active edit controller and ensure that only a single controller\n * can be active at a time.  This prevents a whole class of state and validation synchronization\n * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress\n * and attempt a commit or cancel before proceeding.\n * @class EditorLock\n * @constructor\n */\nfunction EditorLock() {\n  var activeEditController = null;\n\n  /***\n   * Returns true if a specified edit controller is active (has the edit lock).\n   * If the parameter is not specified, returns true if any edit controller is active.\n   * @method isActive\n   * @param editController {EditController}\n   * @return {Boolean}\n   */\n  this.isActive = function (editController) {\n    return (editController ? activeEditController === editController : activeEditController !== null);\n  };\n\n  /***\n   * Sets the specified edit controller as the active edit controller (acquire edit lock).\n   * If another edit controller is already active, and exception will be thrown.\n   * @method activate\n   * @param editController {EditController} edit controller acquiring the lock\n   */\n  this.activate = function (editController) {\n    if (editController === activeEditController) { // already activated?\n      return;\n    }\n    if (activeEditController !== null) {\n      throw \"SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController\";\n    }\n    if (!editController.commitCurrentEdit) {\n      throw \"SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()\";\n    }\n    if (!editController.cancelCurrentEdit) {\n      throw \"SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()\";\n    }\n    activeEditController = editController;\n  };\n\n  /***\n   * Unsets the specified edit controller as the active edit controller (release edit lock).\n   * If the specified edit controller is not the active one, an exception will be thrown.\n   * @method deactivate\n   * @param editController {EditController} edit controller releasing the lock\n   */\n  this.deactivate = function (editController) {\n    if (activeEditController !== editController) {\n      throw \"SlickGrid.EditorLock.deactivate: specified editController is not the currently active one\";\n    }\n    activeEditController = null;\n  };\n\n  /***\n   * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\n   * controller and returns whether the commit attempt was successful (commit may fail due to validation\n   * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\n   * and false otherwise.  If no edit controller is active, returns true.\n   * @method commitCurrentEdit\n   * @return {Boolean}\n   */\n  this.commitCurrentEdit = function () {\n    return (activeEditController ? activeEditController.commitCurrentEdit() : true);\n  };\n\n  /***\n   * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\n   * controller and returns whether the edit was successfully cancelled.  If no edit controller is\n   * active, returns true.\n   * @method cancelCurrentEdit\n   * @return {Boolean}\n   */\n  this.cancelCurrentEdit = function cancelCurrentEdit() {\n    return (activeEditController ? activeEditController.cancelCurrentEdit() : true);\n  };\n}\n\nmodule.exports = Slick;\n","/**\n * @license\n * (c) 2009-2013 Michael Leibman\n * michael{dot}leibman{at}gmail{dot}com\n * http://github.com/mleibman/slickgrid\n *\n * Distributed under MIT license.\n * All rights reserved.\n *\n * SlickGrid v2.2\n *\n * NOTES:\n *     Cell/row DOM manipulations are done directly bypassing jQuery's DOM manipulation methods.\n *     This increases the speed dramatically, but can only be done safely because there are no event handlers\n *     or data associated with any cell/row DOM nodes.  Cell editors must make sure they implement .destroy()\n *     and do proper cleanup.\n */\n\nvar $ = require(\"jquery\");\nvar $1 = require(\"jquery_event_drag\");\nvar $2 = require(\"jquery_event_drop\");\nvar Slick = require(\"./slick.core\");\n\n\n// shared across all grids on the page\nvar scrollbarDimensions;\nvar maxSupportedCssHeight;  // browser's breaking point\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n// SlickGrid class implementation (available as Slick.Grid)\n\n/**\n * Creates a new instance of the grid.\n * @class SlickGrid\n * @constructor\n * @param {Node}              container   Container node to create the grid in.\n * @param {Array,Object}      data        An array of objects for databinding.\n * @param {Array}             columns     An array of column definitions.\n * @param {Object}            options     Grid options.\n **/\nfunction SlickGrid(container, data, columns, options) {\n  // settings\n  var defaults = {\n    explicitInitialization: false,\n    rowHeight: 25,\n    defaultColumnWidth: 80,\n    enableAddRow: false,\n    leaveSpaceForNewRows: false,\n    editable: false,\n    autoEdit: true,\n    enableCellNavigation: true,\n    enableColumnReorder: true,\n    asyncEditorLoading: false,\n    asyncEditorLoadDelay: 100,\n    forceFitColumns: false,\n    enableAsyncPostRender: false,\n    asyncPostRenderDelay: 50,\n    autoHeight: false,\n    editorLock: Slick.GlobalEditorLock,\n    showHeaderRow: false,\n    headerRowHeight: 25,\n    showTopPanel: false,\n    topPanelHeight: 25,\n    formatterFactory: null,\n    editorFactory: null,\n    cellFlashingCssClass: \"flashing\",\n    selectedCellCssClass: \"selected\",\n    multiSelect: true,\n    enableTextSelectionOnCells: false,\n    dataItemColumnValueExtractor: null,\n    fullWidthRows: false,\n    multiColumnSort: false,\n    defaultFormatter: defaultFormatter,\n    forceSyncScrolling: false,\n    addNewRowCssClass: \"new-row\"\n  };\n\n  var columnDefaults = {\n    name: \"\",\n    resizable: true,\n    sortable: false,\n    minWidth: 30,\n    rerenderOnResize: false,\n    headerCssClass: null,\n    defaultSortAsc: true,\n    focusable: true,\n    selectable: true\n  };\n\n  // scroller\n  var th;   // virtual height\n  var h;    // real scrollable height\n  var ph;   // page height\n  var n;    // number of pages\n  var cj;   // \"jumpiness\" coefficient\n\n  var page = 0;       // current page\n  var offset = 0;     // current page offset\n  var vScrollDir = 1;\n\n  // private\n  var initialized = false;\n  var $container;\n  var uid = \"slickgrid_\" + Math.round(1000000 * Math.random());\n  var self = this;\n  var $focusSink, $focusSink2;\n  var $headerScroller;\n  var $headers;\n  var $headerRow, $headerRowScroller, $headerRowSpacer;\n  var $topPanelScroller;\n  var $topPanel;\n  var $viewport;\n  var $canvas;\n  var $style;\n  var $boundAncestors;\n  var stylesheet, columnCssRulesL, columnCssRulesR;\n  var viewportH, viewportW;\n  var canvasWidth;\n  var viewportHasHScroll, viewportHasVScroll;\n  var headerColumnWidthDiff = 0, headerColumnHeightDiff = 0, // border+padding\n      cellWidthDiff = 0, cellHeightDiff = 0;\n  var absoluteColumnMinWidth;\n\n  var tabbingDirection = 1;\n  var activePosX;\n  var activeRow, activeCell;\n  var activeCellNode = null;\n  var currentEditor = null;\n  var serializedEditorValue;\n  var editController;\n\n  var rowsCache = {};\n  var renderedRows = 0;\n  var numVisibleRows;\n  var prevScrollTop = 0;\n  var scrollTop = 0;\n  var lastRenderedScrollTop = 0;\n  var lastRenderedScrollLeft = 0;\n  var prevScrollLeft = 0;\n  var scrollLeft = 0;\n\n  var selectionModel;\n  var selectedRows = [];\n\n  var plugins = [];\n  var cellCssClasses = {};\n\n  var columnsById = {};\n  var sortColumns = [];\n  var columnPosLeft = [];\n  var columnPosRight = [];\n\n\n  // async call handles\n  var h_editorLoader = null;\n  var h_render = null;\n  var h_postrender = null;\n  var postProcessedRows = {};\n  var postProcessToRow = null;\n  var postProcessFromRow = null;\n\n  // perf counters\n  var counter_rows_rendered = 0;\n  var counter_rows_removed = 0;\n\n  // These two variables work around a bug with inertial scrolling in Webkit/Blink on Mac.\n  // See http://crbug.com/312427.\n  var rowNodeFromLastMouseWheelEvent;  // this node must not be deleted while inertial scrolling\n  var zombieRowNodeFromLastMouseWheelEvent;  // node that was hidden instead of getting deleted\n\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Initialization\n\n  function init() {\n    $container = $(container);\n    if ($container.length < 1) {\n      throw new Error(\"SlickGrid requires a valid container, \" + container + \" does not exist in the DOM.\");\n    }\n\n    // calculate these only once and share between grid instances\n    maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight();\n    scrollbarDimensions = scrollbarDimensions || measureScrollbar();\n\n    options = $.extend({}, defaults, options);\n    validateAndEnforceOptions();\n    columnDefaults.width = options.defaultColumnWidth;\n\n    columnsById = {};\n    for (var i = 0; i < columns.length; i++) {\n      var m = columns[i] = $.extend({}, columnDefaults, columns[i]);\n      columnsById[m.id] = i;\n      if (m.minWidth && m.width < m.minWidth) {\n        m.width = m.minWidth;\n      }\n      if (m.maxWidth && m.width > m.maxWidth) {\n        m.width = m.maxWidth;\n      }\n    }\n\n    // validate loaded JavaScript modules against requested options\n    if (options.enableColumnReorder && !$.fn.sortable) {\n      throw new Error(\"SlickGrid's 'enableColumnReorder = true' option requires jquery-ui.sortable module to be loaded\");\n    }\n\n    editController = {\n      \"commitCurrentEdit\": commitCurrentEdit,\n      \"cancelCurrentEdit\": cancelCurrentEdit\n    };\n\n    $container\n        .empty()\n        .css(\"overflow\", \"hidden\")\n        .css(\"outline\", 0)\n        .addClass(uid)\n        .addClass(\"bk-ui-widget\");\n\n    // set up a positioning container if needed\n    if (!/relative|absolute|fixed/.test($container.css(\"position\"))) {\n      $container.css(\"position\", \"relative\");\n    }\n\n    $focusSink = $(\"<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>\").appendTo($container);\n\n    $headerScroller = $(\"<div class='bk-slick-header bk-ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container);\n    $headers = $(\"<div class='bk-slick-header-columns' style='left:-1000px' />\").appendTo($headerScroller);\n    $headers.width(getHeadersWidth());\n\n    $headerRowScroller = $(\"<div class='bk-slick-headerrow bk-ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container);\n    $headerRow = $(\"<div class='bk-slick-headerrow-columns' />\").appendTo($headerRowScroller);\n    $headerRowSpacer = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\")\n        .css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\")\n        .appendTo($headerRowScroller);\n\n    $topPanelScroller = $(\"<div class='bk-slick-top-panel-scroller bk-ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container);\n    $topPanel = $(\"<div class='bk-slick-top-panel' style='width:10000px' />\").appendTo($topPanelScroller);\n\n    if (!options.showTopPanel) {\n      $topPanelScroller.hide();\n    }\n\n    if (!options.showHeaderRow) {\n      $headerRowScroller.hide();\n    }\n\n    $viewport = $(\"<div class='bk-slick-viewport' style='width:100%;overflow:auto;outline:0;position:relative;;'>\").appendTo($container);\n    $viewport.css(\"overflow-y\", options.autoHeight ? \"hidden\" : \"auto\");\n\n    $canvas = $(\"<div class='grid-canvas' />\").appendTo($viewport);\n\n    $focusSink2 = $focusSink.clone().appendTo($container);\n\n    if (!options.explicitInitialization) {\n      finishInitialization();\n    }\n  }\n\n  function finishInitialization() {\n    if (!initialized) {\n      initialized = true;\n\n      viewportW = parseFloat($.css($container[0], \"width\", true));\n\n      // header columns and cells may have different padding/border skewing width calculations (box-sizing, hello?)\n      // calculate the diff so we can set consistent sizes\n      measureCellPaddingAndBorder();\n\n      // for usability reasons, all text selection in SlickGrid is disabled\n      // with the exception of input and textarea elements (selection must\n      // be enabled there so that editors work as expected); note that\n      // selection in grid cells (grid body) is already unavailable in\n      // all browsers except IE\n      disableSelection($headers); // disable all text selection in header (including input and textarea)\n\n      if (!options.enableTextSelectionOnCells) {\n        // disable text selection in grid cells except in input and textarea elements\n        // (this is IE-specific, because selectstart event will only fire in IE)\n        $viewport.bind(\"selectstart.ui\", function (event) {\n          return $(event.target).is(\"input,textarea\");\n        });\n      }\n\n      updateColumnCaches();\n      createColumnHeaders();\n      setupColumnSort();\n      createCssRules();\n      resizeCanvas();\n      bindAncestorScrollEvents();\n\n      $container\n          .bind(\"resize.bk-slickgrid\", resizeCanvas);\n      $viewport\n          //.bind(\"click\", handleClick)\n          .bind(\"scroll\", handleScroll);\n      $headerScroller\n          .bind(\"contextmenu\", handleHeaderContextMenu)\n          .bind(\"click\", handleHeaderClick)\n          .delegate(\".bk-slick-header-column\", \"mouseenter\", handleHeaderMouseEnter)\n          .delegate(\".bk-slick-header-column\", \"mouseleave\", handleHeaderMouseLeave);\n      $headerRowScroller\n          .bind(\"scroll\", handleHeaderRowScroll);\n      $focusSink.add($focusSink2)\n          .bind(\"keydown\", handleKeyDown);\n      $canvas\n          .bind(\"keydown\", handleKeyDown)\n          .bind(\"click\", handleClick)\n          .bind(\"dblclick\", handleDblClick)\n          .bind(\"contextmenu\", handleContextMenu)\n          .bind(\"draginit\", handleDragInit)\n          .bind(\"dragstart\", {distance: 3}, handleDragStart)\n          .bind(\"drag\", handleDrag)\n          .bind(\"dragend\", handleDragEnd)\n          .delegate(\".bk-slick-cell\", \"mouseenter\", handleMouseEnter)\n          .delegate(\".bk-slick-cell\", \"mouseleave\", handleMouseLeave);\n\n      // Work around http://crbug.com/312427.\n      if (navigator.userAgent.toLowerCase().match(/webkit/) &&\n          navigator.userAgent.toLowerCase().match(/macintosh/)) {\n        $canvas.bind(\"mousewheel\", handleMouseWheel);\n      }\n    }\n  }\n\n  function registerPlugin(plugin) {\n    plugins.unshift(plugin);\n    plugin.init(self);\n  }\n\n  function unregisterPlugin(plugin) {\n    for (var i = plugins.length; i >= 0; i--) {\n      if (plugins[i] === plugin) {\n        if (plugins[i].destroy) {\n          plugins[i].destroy();\n        }\n        plugins.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  function setSelectionModel(model) {\n    if (selectionModel) {\n      selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged);\n      if (selectionModel.destroy) {\n        selectionModel.destroy();\n      }\n    }\n\n    selectionModel = model;\n    if (selectionModel) {\n      selectionModel.init(self);\n      selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged);\n    }\n  }\n\n  function getSelectionModel() {\n    return selectionModel;\n  }\n\n  function getCanvasNode() {\n    return $canvas[0];\n  }\n\n  function measureScrollbar() {\n    var $c = $(\"<div style='position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;'></div>\").appendTo(\"body\");\n    var dim = {\n      width: $c.width() - $c[0].clientWidth,\n      height: $c.height() - $c[0].clientHeight\n    };\n    $c.remove();\n    return dim;\n  }\n\n  function getHeadersWidth() {\n    var headersWidth = 0;\n    for (var i = 0, ii = columns.length; i < ii; i++) {\n      var width = columns[i].width;\n      headersWidth += width;\n    }\n    headersWidth += scrollbarDimensions.width;\n    return Math.max(headersWidth, viewportW) + 1000;\n  }\n\n  function getCanvasWidth() {\n    var availableWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;\n    var rowWidth = 0;\n    var i = columns.length;\n    while (i--) {\n      rowWidth += columns[i].width;\n    }\n    return options.fullWidthRows ? Math.max(rowWidth, availableWidth) : rowWidth;\n  }\n\n  function updateCanvasWidth(forceColumnWidthsUpdate) {\n    var oldCanvasWidth = canvasWidth;\n    canvasWidth = getCanvasWidth();\n\n    if (canvasWidth != oldCanvasWidth) {\n      $canvas.width(canvasWidth);\n      $headerRow.width(canvasWidth);\n      $headers.width(getHeadersWidth());\n      viewportHasHScroll = (canvasWidth > viewportW - scrollbarDimensions.width);\n    }\n\n    $headerRowSpacer.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));\n\n    if (canvasWidth != oldCanvasWidth || forceColumnWidthsUpdate) {\n      applyColumnWidths();\n    }\n  }\n\n  function disableSelection($target) {\n    if ($target && $target.jquery) {\n      $target\n          .attr(\"unselectable\", \"on\")\n          .css(\"MozUserSelect\", \"none\")\n          .bind(\"selectstart.ui\", function () {\n            return false;\n          }); // from jquery:ui.core.js 1.7.2\n    }\n  }\n\n  function getMaxSupportedCssHeight() {\n    var supportedHeight = 1000000;\n    // FF reports the height back but still renders blank after ~6M px\n    var testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6000000 : 1000000000;\n    var div = $(\"<div style='display:none' />\").appendTo(document.body);\n\n    while (true) {\n      var test = supportedHeight * 2;\n      div.css(\"height\", test);\n      if (test > testUpTo || div.height() !== test) {\n        break;\n      } else {\n        supportedHeight = test;\n      }\n    }\n\n    div.remove();\n    return supportedHeight;\n  }\n\n  // TODO:  this is static.  need to handle page mutation.\n  function bindAncestorScrollEvents() {\n    var elem = $canvas[0];\n    while ((elem = elem.parentNode) != document.body && elem != null) {\n      // bind to scroll containers only\n      if (elem == $viewport[0] || elem.scrollWidth != elem.clientWidth || elem.scrollHeight != elem.clientHeight) {\n        var $elem = $(elem);\n        if (!$boundAncestors) {\n          $boundAncestors = $elem;\n        } else {\n          $boundAncestors = $boundAncestors.add($elem);\n        }\n        $elem.bind(\"scroll.\" + uid, handleActiveCellPositionChange);\n      }\n    }\n  }\n\n  function unbindAncestorScrollEvents() {\n    if (!$boundAncestors) {\n      return;\n    }\n    $boundAncestors.unbind(\"scroll.\" + uid);\n    $boundAncestors = null;\n  }\n\n  function updateColumnHeader(columnId, title, toolTip) {\n    if (!initialized) { return; }\n    var idx = getColumnIndex(columnId);\n    if (idx == null) {\n      return;\n    }\n\n    var columnDef = columns[idx];\n    var $header = $headers.children().eq(idx);\n    if ($header) {\n      if (title !== undefined) {\n        columns[idx].name = title;\n      }\n      if (toolTip !== undefined) {\n        columns[idx].toolTip = toolTip;\n      }\n\n      trigger(self.onBeforeHeaderCellDestroy, {\n        \"node\": $header[0],\n        \"column\": columnDef\n      });\n\n      $header\n          .attr(\"title\", toolTip || \"\")\n          .children().eq(0).html(title);\n\n      trigger(self.onHeaderCellRendered, {\n        \"node\": $header[0],\n        \"column\": columnDef\n      });\n    }\n  }\n\n  function getHeaderRow() {\n    return $headerRow[0];\n  }\n\n  function getHeaderRowColumn(columnId) {\n    var idx = getColumnIndex(columnId);\n    var $header = $headerRow.children().eq(idx);\n    return $header && $header[0];\n  }\n\n  function createColumnHeaders() {\n    function onMouseEnter() {\n      $(this).addClass(\"bk-ui-state-hover\");\n    }\n\n    function onMouseLeave() {\n      $(this).removeClass(\"bk-ui-state-hover\");\n    }\n\n    $headers.find(\".bk-slick-header-column\")\n      .each(function() {\n        var columnDef = $(this).data(\"column\");\n        if (columnDef) {\n          trigger(self.onBeforeHeaderCellDestroy, {\n            \"node\": this,\n            \"column\": columnDef\n          });\n        }\n      });\n    $headers.empty();\n    $headers.width(getHeadersWidth());\n\n    $headerRow.find(\".bk-slick-headerrow-column\")\n      .each(function() {\n        var columnDef = $(this).data(\"column\");\n        if (columnDef) {\n          trigger(self.onBeforeHeaderRowCellDestroy, {\n            \"node\": this,\n            \"column\": columnDef\n          });\n        }\n      });\n    $headerRow.empty();\n\n    for (var i = 0; i < columns.length; i++) {\n      var m = columns[i];\n\n      var header = $(\"<div class='bk-ui-state-default bk-slick-header-column' />\")\n          .html(\"<span class='bk-slick-column-name'>\" + m.name + \"</span>\")\n          .width(m.width - headerColumnWidthDiff)\n          .attr(\"id\", \"\" + uid + m.id)\n          .attr(\"title\", m.toolTip || \"\")\n          .data(\"column\", m)\n          .addClass(m.headerCssClass || \"\")\n          .appendTo($headers);\n\n      if (options.enableColumnReorder || m.sortable) {\n        header\n          .on('mouseenter', onMouseEnter)\n          .on('mouseleave', onMouseLeave);\n      }\n\n      if (m.sortable) {\n        header.addClass(\"bk-slick-header-sortable\");\n        header.append(\"<span class='bk-slick-sort-indicator' />\");\n      }\n\n      trigger(self.onHeaderCellRendered, {\n        \"node\": header[0],\n        \"column\": m\n      });\n\n      if (options.showHeaderRow) {\n        var headerRowCell = $(\"<div class='bk-ui-state-default bk-slick-headerrow-column l\" + i + \" r\" + i + \"'></div>\")\n            .data(\"column\", m)\n            .appendTo($headerRow);\n\n        trigger(self.onHeaderRowCellRendered, {\n          \"node\": headerRowCell[0],\n          \"column\": m\n        });\n      }\n    }\n\n    setSortColumns(sortColumns);\n    setupColumnResize();\n    if (options.enableColumnReorder) {\n      setupColumnReorder();\n    }\n  }\n\n  function setupColumnSort() {\n    $headers.click(function (e) {\n      // temporary workaround for a bug in jQuery 1.7.1 (http://bugs.jquery.com/ticket/11328)\n      e.metaKey = e.metaKey || e.ctrlKey;\n\n      if ($(e.target).hasClass(\"bk-slick-resizable-handle\")) {\n        return;\n      }\n\n      var $col = $(e.target).closest(\".bk-slick-header-column\");\n      if (!$col.length) {\n        return;\n      }\n\n      var column = $col.data(\"column\");\n      if (column.sortable) {\n        if (!getEditorLock().commitCurrentEdit()) {\n          return;\n        }\n\n        var sortOpts = null;\n        var i = 0;\n        for (; i < sortColumns.length; i++) {\n          if (sortColumns[i].columnId == column.id) {\n            sortOpts = sortColumns[i];\n            sortOpts.sortAsc = !sortOpts.sortAsc;\n            break;\n          }\n        }\n\n        if (e.metaKey && options.multiColumnSort) {\n          if (sortOpts) {\n            sortColumns.splice(i, 1);\n          }\n        }\n        else {\n          if ((!e.shiftKey && !e.metaKey) || !options.multiColumnSort) {\n            sortColumns = [];\n          }\n\n          if (!sortOpts) {\n            sortOpts = { columnId: column.id, sortAsc: column.defaultSortAsc };\n            sortColumns.push(sortOpts);\n          } else if (sortColumns.length == 0) {\n            sortColumns.push(sortOpts);\n          }\n        }\n\n        setSortColumns(sortColumns);\n\n        if (!options.multiColumnSort) {\n          trigger(self.onSort, {\n            multiColumnSort: false,\n            sortCol: column,\n            sortAsc: sortOpts.sortAsc}, e);\n        } else {\n          trigger(self.onSort, {\n            multiColumnSort: true,\n            sortCols: $.map(sortColumns, function(col) {\n              return {sortCol: columns[getColumnIndex(col.columnId)], sortAsc: col.sortAsc };\n            })}, e);\n        }\n      }\n    });\n  }\n\n  function setupColumnReorder() {\n    $headers.filter(\":ui-sortable\").sortable(\"destroy\");\n    $headers.sortable({\n      containment: \"parent\",\n      distance: 3,\n      axis: \"x\",\n      cursor: \"default\",\n      tolerance: \"intersection\",\n      helper: \"clone\",\n      placeholder: \"bk-slick-sortable-placeholder bk-ui-state-default bk-slick-header-column\",\n      start: function (e, ui) {\n        ui.placeholder.width(ui.helper.outerWidth() - headerColumnWidthDiff);\n        $(ui.helper).addClass(\"bk-slick-header-column-active\");\n      },\n      beforeStop: function (e, ui) {\n        $(ui.helper).removeClass(\"bk-slick-header-column-active\");\n      },\n      stop: function (e) {\n        if (!getEditorLock().commitCurrentEdit()) {\n          $(this).sortable(\"cancel\");\n          return;\n        }\n\n        var reorderedIds = $headers.sortable(\"toArray\");\n        var reorderedColumns = [];\n        for (var i = 0; i < reorderedIds.length; i++) {\n          reorderedColumns.push(columns[getColumnIndex(reorderedIds[i].replace(uid, \"\"))]);\n        }\n        setColumns(reorderedColumns);\n\n        trigger(self.onColumnsReordered, {});\n        e.stopPropagation();\n        setupColumnResize();\n      }\n    });\n  }\n\n  function setupColumnResize() {\n    var $col, j, c, pageX, columnElements, minPageX, maxPageX, firstResizable, lastResizable;\n    columnElements = $headers.children();\n    columnElements.find(\".bk-slick-resizable-handle\").remove();\n    columnElements.each(function (i, e) {\n      if (columns[i].resizable) {\n        if (firstResizable === undefined) {\n          firstResizable = i;\n        }\n        lastResizable = i;\n      }\n    });\n    if (firstResizable === undefined) {\n      return;\n    }\n    columnElements.each(function (i, e) {\n      if (i < firstResizable || (options.forceFitColumns && i >= lastResizable)) {\n        return;\n      }\n      $col = $(e);\n      $(\"<div class='bk-slick-resizable-handle' />\")\n          .appendTo(e)\n          .bind(\"dragstart\", function (e, dd) {\n            if (!getEditorLock().commitCurrentEdit()) {\n              return false;\n            }\n            pageX = e.pageX;\n            $(this).parent().addClass(\"bk-slick-header-column-active\");\n            var shrinkLeewayOnRight = null, stretchLeewayOnRight = null;\n            // lock each column's width option to current width\n            columnElements.each(function (i, e) {\n              columns[i].previousWidth = $(e).outerWidth();\n            });\n            if (options.forceFitColumns) {\n              shrinkLeewayOnRight = 0;\n              stretchLeewayOnRight = 0;\n              // colums on right affect maxPageX/minPageX\n              for (j = i + 1; j < columnElements.length; j++) {\n                c = columns[j];\n                if (c.resizable) {\n                  if (stretchLeewayOnRight !== null) {\n                    if (c.maxWidth) {\n                      stretchLeewayOnRight += c.maxWidth - c.previousWidth;\n                    } else {\n                      stretchLeewayOnRight = null;\n                    }\n                  }\n                  shrinkLeewayOnRight += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n                }\n              }\n            }\n            var shrinkLeewayOnLeft = 0, stretchLeewayOnLeft = 0;\n            for (j = 0; j <= i; j++) {\n              // columns on left only affect minPageX\n              c = columns[j];\n              if (c.resizable) {\n                if (stretchLeewayOnLeft !== null) {\n                  if (c.maxWidth) {\n                    stretchLeewayOnLeft += c.maxWidth - c.previousWidth;\n                  } else {\n                    stretchLeewayOnLeft = null;\n                  }\n                }\n                shrinkLeewayOnLeft += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n              }\n            }\n            if (shrinkLeewayOnRight === null) {\n              shrinkLeewayOnRight = 100000;\n            }\n            if (shrinkLeewayOnLeft === null) {\n              shrinkLeewayOnLeft = 100000;\n            }\n            if (stretchLeewayOnRight === null) {\n              stretchLeewayOnRight = 100000;\n            }\n            if (stretchLeewayOnLeft === null) {\n              stretchLeewayOnLeft = 100000;\n            }\n            maxPageX = pageX + Math.min(shrinkLeewayOnRight, stretchLeewayOnLeft);\n            minPageX = pageX - Math.min(shrinkLeewayOnLeft, stretchLeewayOnRight);\n          })\n          .bind(\"drag\", function (e, dd) {\n            var actualMinWidth, d = Math.min(maxPageX, Math.max(minPageX, e.pageX)) - pageX, x;\n            if (d < 0) { // shrink column\n              x = d;\n              for (j = i; j >= 0; j--) {\n                c = columns[j];\n                if (c.resizable) {\n                  actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n                  if (x && c.previousWidth + x < actualMinWidth) {\n                    x += c.previousWidth - actualMinWidth;\n                    c.width = actualMinWidth;\n                  } else {\n                    c.width = c.previousWidth + x;\n                    x = 0;\n                  }\n                }\n              }\n\n              if (options.forceFitColumns) {\n                x = -d;\n                for (j = i + 1; j < columnElements.length; j++) {\n                  c = columns[j];\n                  if (c.resizable) {\n                    if (x && c.maxWidth && (c.maxWidth - c.previousWidth < x)) {\n                      x -= c.maxWidth - c.previousWidth;\n                      c.width = c.maxWidth;\n                    } else {\n                      c.width = c.previousWidth + x;\n                      x = 0;\n                    }\n                  }\n                }\n              }\n            } else { // stretch column\n              x = d;\n              for (j = i; j >= 0; j--) {\n                c = columns[j];\n                if (c.resizable) {\n                  if (x && c.maxWidth && (c.maxWidth - c.previousWidth < x)) {\n                    x -= c.maxWidth - c.previousWidth;\n                    c.width = c.maxWidth;\n                  } else {\n                    c.width = c.previousWidth + x;\n                    x = 0;\n                  }\n                }\n              }\n\n              if (options.forceFitColumns) {\n                x = -d;\n                for (j = i + 1; j < columnElements.length; j++) {\n                  c = columns[j];\n                  if (c.resizable) {\n                    actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n                    if (x && c.previousWidth + x < actualMinWidth) {\n                      x += c.previousWidth - actualMinWidth;\n                      c.width = actualMinWidth;\n                    } else {\n                      c.width = c.previousWidth + x;\n                      x = 0;\n                    }\n                  }\n                }\n              }\n            }\n            applyColumnHeaderWidths();\n            if (options.syncColumnCellResize) {\n              applyColumnWidths();\n            }\n          })\n          .bind(\"dragend\", function (e, dd) {\n            var newWidth;\n            $(this).parent().removeClass(\"bk-slick-header-column-active\");\n            for (j = 0; j < columnElements.length; j++) {\n              c = columns[j];\n              newWidth = $(columnElements[j]).outerWidth();\n\n              if (c.previousWidth !== newWidth && c.rerenderOnResize) {\n                invalidateAllRows();\n              }\n            }\n            updateCanvasWidth(true);\n            render();\n            trigger(self.onColumnsResized, {});\n          });\n    });\n  }\n\n  function getVBoxDelta($el) {\n    var p = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"];\n    var delta = 0;\n    $.each(p, function (n, val) {\n      delta += parseFloat($el.css(val)) || 0;\n    });\n    return delta;\n  }\n\n  function measureCellPaddingAndBorder() {\n    var el;\n    var h = [\"borderLeftWidth\", \"borderRightWidth\", \"paddingLeft\", \"paddingRight\"];\n    var v = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"];\n\n    el = $(\"<div class='bk-ui-state-default bk-slick-header-column' style='visibility:hidden'>-</div>\").appendTo($headers);\n    headerColumnWidthDiff = headerColumnHeightDiff = 0;\n    if (el.css(\"box-sizing\") != \"border-box\" && el.css(\"-moz-box-sizing\") != \"border-box\" && el.css(\"-webkit-box-sizing\") != \"border-box\") {\n      $.each(h, function (n, val) {\n        headerColumnWidthDiff += parseFloat(el.css(val)) || 0;\n      });\n      $.each(v, function (n, val) {\n        headerColumnHeightDiff += parseFloat(el.css(val)) || 0;\n      });\n    }\n    el.remove();\n\n    var r = $(\"<div class='bk-slick-row' />\").appendTo($canvas);\n    el = $(\"<div class='bk-slick-cell' id='' style='visibility:hidden'>-</div>\").appendTo(r);\n    cellWidthDiff = cellHeightDiff = 0;\n    if (el.css(\"box-sizing\") != \"border-box\" && el.css(\"-moz-box-sizing\") != \"border-box\" && el.css(\"-webkit-box-sizing\") != \"border-box\") {\n      $.each(h, function (n, val) {\n        cellWidthDiff += parseFloat(el.css(val)) || 0;\n      });\n      $.each(v, function (n, val) {\n        cellHeightDiff += parseFloat(el.css(val)) || 0;\n      });\n    }\n    r.remove();\n\n    absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff);\n  }\n\n  function createCssRules() {\n    $style = $(\"<style type='text/css' rel='stylesheet' />\").appendTo($(\"head\"));\n    var rowHeight = (options.rowHeight - cellHeightDiff);\n    var rules = [\n      \".\" + uid + \" .bk-slick-header-column { left: 1000px; }\",\n      \".\" + uid + \" .bk-slick-top-panel { height:\" + options.topPanelHeight + \"px; }\",\n      \".\" + uid + \" .bk-slick-headerrow-columns { height:\" + options.headerRowHeight + \"px; }\",\n      \".\" + uid + \" .bk-slick-cell { height:\" + rowHeight + \"px; }\",\n      \".\" + uid + \" .bk-slick-row { height:\" + options.rowHeight + \"px; }\"\n    ];\n\n    for (var i = 0; i < columns.length; i++) {\n      rules.push(\".\" + uid + \" .l\" + i + \" { }\");\n      rules.push(\".\" + uid + \" .r\" + i + \" { }\");\n    }\n\n    if ($style[0].styleSheet) { // IE\n      $style[0].styleSheet.cssText = rules.join(\" \");\n    } else {\n      $style[0].appendChild(document.createTextNode(rules.join(\" \")));\n    }\n  }\n\n  function getColumnCssRules(idx) {\n    if (!stylesheet) {\n      var sheets = document.styleSheets;\n      for (var i = 0; i < sheets.length; i++) {\n        if ((sheets[i].ownerNode || sheets[i].owningElement) == $style[0]) {\n          stylesheet = sheets[i];\n          break;\n        }\n      }\n\n      if (!stylesheet) {\n        throw new Error(\"Cannot find stylesheet.\");\n      }\n\n      // find and cache column CSS rules\n      columnCssRulesL = [];\n      columnCssRulesR = [];\n      var cssRules = (stylesheet.cssRules || stylesheet.rules);\n      var matches, columnIdx;\n      for (var i = 0; i < cssRules.length; i++) {\n        var selector = cssRules[i].selectorText;\n        if (matches = /\\.l\\d+/.exec(selector)) {\n          columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);\n          columnCssRulesL[columnIdx] = cssRules[i];\n        } else if (matches = /\\.r\\d+/.exec(selector)) {\n          columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);\n          columnCssRulesR[columnIdx] = cssRules[i];\n        }\n      }\n    }\n\n    return {\n      \"left\": columnCssRulesL[idx],\n      \"right\": columnCssRulesR[idx]\n    };\n  }\n\n  function removeCssRules() {\n    $style.remove();\n    stylesheet = null;\n  }\n\n  function destroy() {\n    getEditorLock().cancelCurrentEdit();\n\n    trigger(self.onBeforeDestroy, {});\n\n    var i = plugins.length;\n    while(i--) {\n      unregisterPlugin(plugins[i]);\n    }\n\n    if (options.enableColumnReorder) {\n        $headers.filter(\":ui-sortable\").sortable(\"destroy\");\n    }\n\n    unbindAncestorScrollEvents();\n    $container.unbind(\".bk-slickgrid\");\n    removeCssRules();\n\n    $canvas.unbind(\"draginit dragstart dragend drag\");\n    $container.empty().removeClass(uid);\n  }\n\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // General\n\n  function trigger(evt, args, e) {\n    e = e || new Slick.EventData();\n    args = args || {};\n    args.grid = self;\n    return evt.notify(args, e, self);\n  }\n\n  function getEditorLock() {\n    return options.editorLock;\n  }\n\n  function getEditController() {\n    return editController;\n  }\n\n  function getColumnIndex(id) {\n    return columnsById[id];\n  }\n\n  function autosizeColumns() {\n    var i, c,\n        widths = [],\n        shrinkLeeway = 0,\n        total = 0,\n        prevTotal,\n        availWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;\n\n    for (i = 0; i < columns.length; i++) {\n      c = columns[i];\n      widths.push(c.width);\n      total += c.width;\n      if (c.resizable) {\n        shrinkLeeway += c.width - Math.max(c.minWidth, absoluteColumnMinWidth);\n      }\n    }\n\n    // shrink\n    prevTotal = total;\n    while (total > availWidth && shrinkLeeway) {\n      var shrinkProportion = (total - availWidth) / shrinkLeeway;\n      for (i = 0; i < columns.length && total > availWidth; i++) {\n        c = columns[i];\n        var width = widths[i];\n        if (!c.resizable || width <= c.minWidth || width <= absoluteColumnMinWidth) {\n          continue;\n        }\n        var absMinWidth = Math.max(c.minWidth, absoluteColumnMinWidth);\n        var shrinkSize = Math.floor(shrinkProportion * (width - absMinWidth)) || 1;\n        shrinkSize = Math.min(shrinkSize, width - absMinWidth);\n        total -= shrinkSize;\n        shrinkLeeway -= shrinkSize;\n        widths[i] -= shrinkSize;\n      }\n      if (prevTotal <= total) {  // avoid infinite loop\n        break;\n      }\n      prevTotal = total;\n    }\n\n    // grow\n    prevTotal = total;\n    while (total < availWidth) {\n      var growProportion = availWidth / total;\n      for (i = 0; i < columns.length && total < availWidth; i++) {\n        c = columns[i];\n        var currentWidth = widths[i];\n        var growSize;\n\n        if (!c.resizable || c.maxWidth <= currentWidth) {\n          growSize = 0;\n        } else {\n          growSize = Math.min(Math.floor(growProportion * currentWidth) - currentWidth, (c.maxWidth - currentWidth) || 1000000) || 1;\n        }\n        total += growSize;\n        widths[i] += growSize;\n      }\n      if (prevTotal >= total) {  // avoid infinite loop\n        break;\n      }\n      prevTotal = total;\n    }\n\n    var reRender = false;\n    for (i = 0; i < columns.length; i++) {\n      if (columns[i].rerenderOnResize && columns[i].width != widths[i]) {\n        reRender = true;\n      }\n      columns[i].width = widths[i];\n    }\n\n    applyColumnHeaderWidths();\n    updateCanvasWidth(true);\n    if (reRender) {\n      invalidateAllRows();\n      render();\n    }\n  }\n\n  function applyColumnHeaderWidths() {\n    if (!initialized) { return; }\n    var h;\n    for (var i = 0, headers = $headers.children(), ii = headers.length; i < ii; i++) {\n      h = $(headers[i]);\n      if (h.width() !== columns[i].width - headerColumnWidthDiff) {\n        h.width(columns[i].width - headerColumnWidthDiff);\n      }\n    }\n\n    updateColumnCaches();\n  }\n\n  function applyColumnWidths() {\n    var x = 0, w, rule;\n    for (var i = 0; i < columns.length; i++) {\n      w = columns[i].width;\n\n      rule = getColumnCssRules(i);\n      rule.left.style.left = x + \"px\";\n      rule.right.style.right = (canvasWidth - x - w) + \"px\";\n\n      x += columns[i].width;\n    }\n  }\n\n  function setSortColumn(columnId, ascending) {\n    setSortColumns([{ columnId: columnId, sortAsc: ascending}]);\n  }\n\n  function setSortColumns(cols) {\n    sortColumns = cols;\n\n    var headerColumnEls = $headers.children();\n    headerColumnEls\n        .removeClass(\"bk-slick-header-column-sorted\")\n        .find(\".bk-slick-sort-indicator\")\n            .removeClass(\"bk-slick-sort-indicator-asc bk-slick-sort-indicator-desc\");\n\n    $.each(sortColumns, function(i, col) {\n      if (col.sortAsc == null) {\n        col.sortAsc = true;\n      }\n      var columnIndex = getColumnIndex(col.columnId);\n      if (columnIndex != null) {\n        headerColumnEls.eq(columnIndex)\n            .addClass(\"bk-slick-header-column-sorted\")\n            .find(\".bk-slick-sort-indicator\")\n                .addClass(col.sortAsc ? \"bk-slick-sort-indicator-asc\" : \"bk-slick-sort-indicator-desc\");\n      }\n    });\n  }\n\n  function getSortColumns() {\n    return sortColumns;\n  }\n\n  function handleSelectedRangesChanged(e, ranges) {\n    selectedRows = [];\n    var hash = {};\n    for (var i = 0; i < ranges.length; i++) {\n      for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\n        if (!hash[j]) {  // prevent duplicates\n          selectedRows.push(j);\n          hash[j] = {};\n        }\n        for (var k = ranges[i].fromCell; k <= ranges[i].toCell; k++) {\n          if (canCellBeSelected(j, k)) {\n            hash[j][columns[k].id] = options.selectedCellCssClass;\n          }\n        }\n      }\n    }\n\n    setCellCssStyles(options.selectedCellCssClass, hash);\n\n    trigger(self.onSelectedRowsChanged, {rows: getSelectedRows()}, e);\n  }\n\n  function getColumns() {\n    return columns;\n  }\n\n  function updateColumnCaches() {\n    // Pre-calculate cell boundaries.\n    columnPosLeft = [];\n    columnPosRight = [];\n    var x = 0;\n    for (var i = 0, ii = columns.length; i < ii; i++) {\n      columnPosLeft[i] = x;\n      columnPosRight[i] = x + columns[i].width;\n      x += columns[i].width;\n    }\n  }\n\n  function setColumns(columnDefinitions) {\n    columns = columnDefinitions;\n\n    columnsById = {};\n    for (var i = 0; i < columns.length; i++) {\n      var m = columns[i] = $.extend({}, columnDefaults, columns[i]);\n      columnsById[m.id] = i;\n      if (m.minWidth && m.width < m.minWidth) {\n        m.width = m.minWidth;\n      }\n      if (m.maxWidth && m.width > m.maxWidth) {\n        m.width = m.maxWidth;\n      }\n    }\n\n    updateColumnCaches();\n\n    if (initialized) {\n      invalidateAllRows();\n      createColumnHeaders();\n      removeCssRules();\n      createCssRules();\n      resizeCanvas();\n      applyColumnWidths();\n      handleScroll();\n    }\n  }\n\n  function getOptions() {\n    return options;\n  }\n\n  function setOptions(args) {\n    if (!getEditorLock().commitCurrentEdit()) {\n      return;\n    }\n\n    makeActiveCellNormal();\n\n    if (options.enableAddRow !== args.enableAddRow) {\n      invalidateRow(getDataLength());\n    }\n\n    options = $.extend(options, args);\n    validateAndEnforceOptions();\n\n    $viewport.css(\"overflow-y\", options.autoHeight ? \"hidden\" : \"auto\");\n    render();\n  }\n\n  function validateAndEnforceOptions() {\n    if (options.autoHeight) {\n      options.leaveSpaceForNewRows = false;\n    }\n  }\n\n  function setData(newData, scrollToTop) {\n    data = newData;\n    invalidateAllRows();\n    updateRowCount();\n    if (scrollToTop) {\n      scrollTo(0);\n    }\n  }\n\n  function getData() {\n    return data;\n  }\n\n  function getDataLength() {\n    if (data.getLength) {\n      return data.getLength();\n    } else {\n      return data.length;\n    }\n  }\n\n  function getDataLengthIncludingAddNew() {\n    return getDataLength() + (options.enableAddRow ? 1 : 0);\n  }\n\n  function getDataItem(i) {\n    if (data.getItem) {\n      return data.getItem(i);\n    } else {\n      return data[i];\n    }\n  }\n\n  function getTopPanel() {\n    return $topPanel[0];\n  }\n\n  function setTopPanelVisibility(visible) {\n    if (options.showTopPanel != visible) {\n      options.showTopPanel = visible;\n      if (visible) {\n        $topPanelScroller.slideDown(\"fast\", resizeCanvas);\n      } else {\n        $topPanelScroller.slideUp(\"fast\", resizeCanvas);\n      }\n    }\n  }\n\n  function setHeaderRowVisibility(visible) {\n    if (options.showHeaderRow != visible) {\n      options.showHeaderRow = visible;\n      if (visible) {\n        $headerRowScroller.slideDown(\"fast\", resizeCanvas);\n      } else {\n        $headerRowScroller.slideUp(\"fast\", resizeCanvas);\n      }\n    }\n  }\n\n  function getContainerNode() {\n    return $container.get(0);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Rendering / Scrolling\n\n  function getRowTop(row) {\n    return options.rowHeight * row - offset;\n  }\n\n  function getRowFromPosition(y) {\n    return Math.floor((y + offset) / options.rowHeight);\n  }\n\n  function scrollTo(y) {\n    y = Math.max(y, 0);\n    y = Math.min(y, th - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0));\n\n    var oldOffset = offset;\n\n    page = Math.min(n - 1, Math.floor(y / ph));\n    offset = Math.round(page * cj);\n    var newScrollTop = y - offset;\n\n    if (offset != oldOffset) {\n      var range = getVisibleRange(newScrollTop);\n      cleanupRows(range);\n      updateRowPositions();\n    }\n\n    if (prevScrollTop != newScrollTop) {\n      vScrollDir = (prevScrollTop + oldOffset < newScrollTop + offset) ? 1 : -1;\n      $viewport[0].scrollTop = (lastRenderedScrollTop = scrollTop = prevScrollTop = newScrollTop);\n\n      trigger(self.onViewportChanged, {});\n    }\n  }\n\n  function defaultFormatter(row, cell, value, columnDef, dataContext) {\n    if (value == null) {\n      return \"\";\n    } else {\n      return (value + \"\").replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\");\n    }\n  }\n\n  function getFormatter(row, column) {\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n\n    // look up by id, then index\n    var columnOverrides = rowMetadata &&\n        rowMetadata.columns &&\n        (rowMetadata.columns[column.id] || rowMetadata.columns[getColumnIndex(column.id)]);\n\n    var formatter =\n        (columnOverrides && columnOverrides.formatter) ||\n        (rowMetadata && rowMetadata.formatter) ||\n        column.formatter ||\n        (options.formatterFactory && options.formatterFactory.getFormatter(column)) ||\n        options.defaultFormatter;\n\n    if (formatter.format !== undefined) {\n      var model = formatter;\n      var format = function foo(row, cell, value, columnDef, dataContext) {\n        return model.format(row, cell, value, columnDef, dataContext);\n      }\n      formatter = format\n    }\n\n    return formatter;\n  }\n\n  function getEditor(row, cell) {\n    var editor;\n    var column = columns[cell];\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n    var columnMetadata = rowMetadata && rowMetadata.columns;\n\n    if (columnMetadata && columnMetadata[column.id] && columnMetadata[column.id].editor !== undefined) {\n      editor = columnMetadata[column.id].editor;\n    } else if (columnMetadata && columnMetadata[cell] && columnMetadata[cell].editor !== undefined) {\n      editor = columnMetadata[cell].editor;\n    } else {\n      editor = column.editor || (options.editorFactory && options.editorFactory.getEditor(column));\n    }\n\n    if (editor.default_view !== undefined) {\n      editor = editor.default_view;\n    }\n\n    return editor;\n  }\n\n  function getDataItemValueForColumn(item, columnDef) {\n    if (options.dataItemColumnValueExtractor) {\n      return options.dataItemColumnValueExtractor(item, columnDef);\n    }\n    return item[columnDef.field];\n  }\n\n  function appendRowHtml(stringArray, row, range, dataLength) {\n    var d = getDataItem(row);\n    var dataLoading = row < dataLength && !d;\n    var rowCss = \"bk-slick-row\" +\n        (dataLoading ? \" loading\" : \"\") +\n        (row === activeRow ? \" active\" : \"\") +\n        (row % 2 == 1 ? \" odd\" : \" even\");\n\n    if (!d) {\n      rowCss += \" \" + options.addNewRowCssClass;\n    }\n\n    var metadata = data.getItemMetadata && data.getItemMetadata(row);\n\n    if (metadata && metadata.cssClasses) {\n      rowCss += \" \" + metadata.cssClasses;\n    }\n\n    stringArray.push(\"<div class='bk-ui-widget-content \" + rowCss + \"' style='top:\" + getRowTop(row) + \"px'>\");\n\n    var colspan, m;\n    for (var i = 0, ii = columns.length; i < ii; i++) {\n      m = columns[i];\n      colspan = 1;\n      if (metadata && metadata.columns) {\n        var columnData = metadata.columns[m.id] || metadata.columns[i];\n        colspan = (columnData && columnData.colspan) || 1;\n        if (colspan === \"*\") {\n          colspan = ii - i;\n        }\n      }\n\n      // Do not render cells outside of the viewport.\n      if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {\n        if (columnPosLeft[i] > range.rightPx) {\n          // All columns to the right are outside the range.\n          break;\n        }\n\n        appendCellHtml(stringArray, row, i, colspan, d);\n      }\n\n      if (colspan > 1) {\n        i += (colspan - 1);\n      }\n    }\n\n    stringArray.push(\"</div>\");\n  }\n\n  function appendCellHtml(stringArray, row, cell, colspan, item) {\n    var m = columns[cell];\n    var cellCss = \"bk-slick-cell l\" + cell + \" r\" + Math.min(columns.length - 1, cell + colspan - 1) +\n        (m.cssClass ? \" \" + m.cssClass : \"\");\n    if (row === activeRow && cell === activeCell) {\n      cellCss += (\" active\");\n    }\n\n    // TODO:  merge them together in the setter\n    for (var key in cellCssClasses) {\n      if (cellCssClasses[key][row] && cellCssClasses[key][row][m.id]) {\n        cellCss += (\" \" + cellCssClasses[key][row][m.id]);\n      }\n    }\n\n    stringArray.push(\"<div class='\" + cellCss + \"'>\");\n\n    // if there is a corresponding row (if not, this is the Add New row or this data hasn't been loaded yet)\n    if (item) {\n      var value = getDataItemValueForColumn(item, m);\n      stringArray.push(getFormatter(row, m)(row, cell, value, m, item));\n    }\n\n    stringArray.push(\"</div>\");\n\n    rowsCache[row].cellRenderQueue.push(cell);\n    rowsCache[row].cellColSpans[cell] = colspan;\n  }\n\n\n  function cleanupRows(rangeToKeep) {\n    for (var i in rowsCache) {\n      if (((i = parseInt(i, 10)) !== activeRow) && (i < rangeToKeep.top || i > rangeToKeep.bottom)) {\n        removeRowFromCache(i);\n      }\n    }\n  }\n\n  function invalidate() {\n    updateRowCount();\n    invalidateAllRows();\n    render();\n  }\n\n  function invalidateAllRows() {\n    if (currentEditor) {\n      makeActiveCellNormal();\n    }\n    for (var row in rowsCache) {\n      removeRowFromCache(row);\n    }\n  }\n\n  function removeRowFromCache(row) {\n    var cacheEntry = rowsCache[row];\n    if (!cacheEntry) {\n      return;\n    }\n\n    if (rowNodeFromLastMouseWheelEvent == cacheEntry.rowNode) {\n      cacheEntry.rowNode.style.display = 'none';\n      zombieRowNodeFromLastMouseWheelEvent = rowNodeFromLastMouseWheelEvent;\n    } else {\n      $canvas[0].removeChild(cacheEntry.rowNode);\n    }\n\n    delete rowsCache[row];\n    delete postProcessedRows[row];\n    renderedRows--;\n    counter_rows_removed++;\n  }\n\n  function invalidateRows(rows) {\n    var i, rl;\n    if (!rows || !rows.length) {\n      return;\n    }\n    vScrollDir = 0;\n    for (i = 0, rl = rows.length; i < rl; i++) {\n      if (currentEditor && activeRow === rows[i]) {\n        makeActiveCellNormal();\n      }\n      if (rowsCache[rows[i]]) {\n        removeRowFromCache(rows[i]);\n      }\n    }\n  }\n\n  function invalidateRow(row) {\n    invalidateRows([row]);\n  }\n\n  function updateCell(row, cell) {\n    var cellNode = getCellNode(row, cell);\n    if (!cellNode) {\n      return;\n    }\n\n    var m = columns[cell], d = getDataItem(row);\n    if (currentEditor && activeRow === row && activeCell === cell) {\n      currentEditor.loadValue(d);\n    } else {\n      cellNode.innerHTML = d ? getFormatter(row, m)(row, cell, getDataItemValueForColumn(d, m), m, d) : \"\";\n      invalidatePostProcessingResults(row);\n    }\n  }\n\n  function updateRow(row) {\n    var cacheEntry = rowsCache[row];\n    if (!cacheEntry) {\n      return;\n    }\n\n    ensureCellNodesInRowsCache(row);\n\n    var d = getDataItem(row);\n\n    for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {\n      if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {\n        continue;\n      }\n\n      columnIdx = columnIdx | 0;\n      var m = columns[columnIdx],\n          node = cacheEntry.cellNodesByColumnIdx[columnIdx];\n\n      if (row === activeRow && columnIdx === activeCell && currentEditor) {\n        currentEditor.loadValue(d);\n      } else if (d) {\n        node.innerHTML = getFormatter(row, m)(row, columnIdx, getDataItemValueForColumn(d, m), m, d);\n      } else {\n        node.innerHTML = \"\";\n      }\n    }\n\n    invalidatePostProcessingResults(row);\n  }\n\n  function getViewportHeight() {\n    return parseFloat($.css($container[0], \"height\", true)) -\n        parseFloat($.css($container[0], \"paddingTop\", true)) -\n        parseFloat($.css($container[0], \"paddingBottom\", true)) -\n        parseFloat($.css($headerScroller[0], \"height\")) - getVBoxDelta($headerScroller) -\n        (options.showTopPanel ? options.topPanelHeight + getVBoxDelta($topPanelScroller) : 0) -\n        (options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0);\n  }\n\n  function resizeCanvas() {\n    if (!initialized) { return; }\n    if (options.autoHeight) {\n      viewportH = options.rowHeight * getDataLengthIncludingAddNew();\n    } else {\n      viewportH = getViewportHeight();\n    }\n\n    numVisibleRows = Math.ceil(viewportH / options.rowHeight);\n    viewportW = parseFloat($.css($container[0], \"width\", true));\n    if (!options.autoHeight) {\n      $viewport.height(viewportH);\n    }\n\n    if (options.forceFitColumns) {\n      autosizeColumns();\n    }\n\n    updateRowCount();\n    handleScroll();\n    // Since the width has changed, force the render() to reevaluate virtually rendered cells.\n    lastRenderedScrollLeft = -1;\n    render();\n  }\n\n  function updateRowCount() {\n    if (!initialized) { return; }\n\n    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n    var numberOfRows = dataLengthIncludingAddNew +\n        (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0);\n\n    var oldViewportHasVScroll = viewportHasVScroll;\n    // with autoHeight, we do not need to accommodate the vertical scroll bar\n    viewportHasVScroll = !options.autoHeight && (numberOfRows * options.rowHeight > viewportH);\n\n    makeActiveCellNormal();\n\n    // remove the rows that are now outside of the data range\n    // this helps avoid redundant calls to .removeRow() when the size of the data decreased by thousands of rows\n    var l = dataLengthIncludingAddNew - 1;\n    for (var i in rowsCache) {\n      if (i >= l) {\n        removeRowFromCache(i);\n      }\n    }\n\n    if (activeCellNode && activeRow > l) {\n      resetActiveCell();\n    }\n\n    var oldH = h;\n    th = Math.max(options.rowHeight * numberOfRows, viewportH - scrollbarDimensions.height);\n    if (th < maxSupportedCssHeight) {\n      // just one page\n      h = ph = th;\n      n = 1;\n      cj = 0;\n    } else {\n      // break into pages\n      h = maxSupportedCssHeight;\n      ph = h / 100;\n      n = Math.floor(th / ph);\n      cj = (th - h) / (n - 1);\n    }\n\n    if (h !== oldH) {\n      $canvas.css(\"height\", h);\n      scrollTop = $viewport[0].scrollTop;\n    }\n\n    var oldScrollTopInRange = (scrollTop + offset <= th - viewportH);\n\n    if (th == 0 || scrollTop == 0) {\n      page = offset = 0;\n    } else if (oldScrollTopInRange) {\n      // maintain virtual position\n      scrollTo(scrollTop + offset);\n    } else {\n      // scroll to bottom\n      scrollTo(th - viewportH);\n    }\n\n    if (h != oldH && options.autoHeight) {\n      resizeCanvas();\n    }\n\n    if (options.forceFitColumns && oldViewportHasVScroll != viewportHasVScroll) {\n      autosizeColumns();\n    }\n    updateCanvasWidth(false);\n  }\n\n  function getVisibleRange(viewportTop, viewportLeft) {\n    if (viewportTop == null) {\n      viewportTop = scrollTop;\n    }\n    if (viewportLeft == null) {\n      viewportLeft = scrollLeft;\n    }\n\n    return {\n      top: getRowFromPosition(viewportTop),\n      bottom: getRowFromPosition(viewportTop + viewportH) + 1,\n      leftPx: viewportLeft,\n      rightPx: viewportLeft + viewportW\n    };\n  }\n\n  function getRenderedRange(viewportTop, viewportLeft) {\n    var range = getVisibleRange(viewportTop, viewportLeft);\n    var buffer = Math.round(viewportH / options.rowHeight);\n    var minBuffer = 3;\n\n    if (vScrollDir == -1) {\n      range.top -= buffer;\n      range.bottom += minBuffer;\n    } else if (vScrollDir == 1) {\n      range.top -= minBuffer;\n      range.bottom += buffer;\n    } else {\n      range.top -= minBuffer;\n      range.bottom += minBuffer;\n    }\n\n    range.top = Math.max(0, range.top);\n    range.bottom = Math.min(getDataLengthIncludingAddNew() - 1, range.bottom);\n\n    range.leftPx -= viewportW;\n    range.rightPx += viewportW;\n\n    range.leftPx = Math.max(0, range.leftPx);\n    range.rightPx = Math.min(canvasWidth, range.rightPx);\n\n    return range;\n  }\n\n  function ensureCellNodesInRowsCache(row) {\n    var cacheEntry = rowsCache[row];\n    if (cacheEntry) {\n      if (cacheEntry.cellRenderQueue.length) {\n        var lastChild = cacheEntry.rowNode.lastChild;\n        while (cacheEntry.cellRenderQueue.length) {\n          var columnIdx = cacheEntry.cellRenderQueue.pop();\n          cacheEntry.cellNodesByColumnIdx[columnIdx] = lastChild;\n          lastChild = lastChild.previousSibling;\n        }\n      }\n    }\n  }\n\n  function cleanUpCells(range, row) {\n    var totalCellsRemoved = 0;\n    var cacheEntry = rowsCache[row];\n\n    // Remove cells outside the range.\n    var cellsToRemove = [];\n    for (var i in cacheEntry.cellNodesByColumnIdx) {\n      // I really hate it when people mess with Array.prototype.\n      if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(i)) {\n        continue;\n      }\n\n      // This is a string, so it needs to be cast back to a number.\n      i = i | 0;\n\n      var colspan = cacheEntry.cellColSpans[i];\n      if (columnPosLeft[i] > range.rightPx ||\n        columnPosRight[Math.min(columns.length - 1, i + colspan - 1)] < range.leftPx) {\n        if (!(row == activeRow && i == activeCell)) {\n          cellsToRemove.push(i);\n        }\n      }\n    }\n\n    var cellToRemove;\n    while ((cellToRemove = cellsToRemove.pop()) != null) {\n      cacheEntry.rowNode.removeChild(cacheEntry.cellNodesByColumnIdx[cellToRemove]);\n      delete cacheEntry.cellColSpans[cellToRemove];\n      delete cacheEntry.cellNodesByColumnIdx[cellToRemove];\n      if (postProcessedRows[row]) {\n        delete postProcessedRows[row][cellToRemove];\n      }\n      totalCellsRemoved++;\n    }\n  }\n\n  function cleanUpAndRenderCells(range) {\n    var cacheEntry;\n    var stringArray = [];\n    var processedRows = [];\n    var cellsAdded;\n    var totalCellsAdded = 0;\n    var colspan;\n\n    for (var row = range.top, btm = range.bottom; row <= btm; row++) {\n      cacheEntry = rowsCache[row];\n      if (!cacheEntry) {\n        continue;\n      }\n\n      // cellRenderQueue populated in renderRows() needs to be cleared first\n      ensureCellNodesInRowsCache(row);\n\n      cleanUpCells(range, row);\n\n      // Render missing cells.\n      cellsAdded = 0;\n\n      var metadata = data.getItemMetadata && data.getItemMetadata(row);\n      metadata = metadata && metadata.columns;\n\n      var d = getDataItem(row);\n\n      // TODO:  shorten this loop (index? heuristics? binary search?)\n      for (var i = 0, ii = columns.length; i < ii; i++) {\n        // Cells to the right are outside the range.\n        if (columnPosLeft[i] > range.rightPx) {\n          break;\n        }\n\n        // Already rendered.\n        if ((colspan = cacheEntry.cellColSpans[i]) != null) {\n          i += (colspan > 1 ? colspan - 1 : 0);\n          continue;\n        }\n\n        colspan = 1;\n        if (metadata) {\n          var columnData = metadata[columns[i].id] || metadata[i];\n          colspan = (columnData && columnData.colspan) || 1;\n          if (colspan === \"*\") {\n            colspan = ii - i;\n          }\n        }\n\n        if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {\n          appendCellHtml(stringArray, row, i, colspan, d);\n          cellsAdded++;\n        }\n\n        i += (colspan > 1 ? colspan - 1 : 0);\n      }\n\n      if (cellsAdded) {\n        totalCellsAdded += cellsAdded;\n        processedRows.push(row);\n      }\n    }\n\n    if (!stringArray.length) {\n      return;\n    }\n\n    var x = document.createElement(\"div\");\n    x.innerHTML = stringArray.join(\"\");\n\n    var processedRow;\n    var node;\n    while ((processedRow = processedRows.pop()) != null) {\n      cacheEntry = rowsCache[processedRow];\n      var columnIdx;\n      while ((columnIdx = cacheEntry.cellRenderQueue.pop()) != null) {\n        node = x.lastChild;\n        cacheEntry.rowNode.appendChild(node);\n        cacheEntry.cellNodesByColumnIdx[columnIdx] = node;\n      }\n    }\n  }\n\n  function renderRows(range) {\n    var parentNode = $canvas[0],\n        stringArray = [],\n        rows = [],\n        needToReselectCell = false,\n        dataLength = getDataLength();\n\n    for (var i = range.top, ii = range.bottom; i <= ii; i++) {\n      if (rowsCache[i]) {\n        continue;\n      }\n      renderedRows++;\n      rows.push(i);\n\n      // Create an entry right away so that appendRowHtml() can\n      // start populatating it.\n      rowsCache[i] = {\n        \"rowNode\": null,\n\n        // ColSpans of rendered cells (by column idx).\n        // Can also be used for checking whether a cell has been rendered.\n        \"cellColSpans\": [],\n\n        // Cell nodes (by column idx).  Lazy-populated by ensureCellNodesInRowsCache().\n        \"cellNodesByColumnIdx\": [],\n\n        // Column indices of cell nodes that have been rendered, but not yet indexed in\n        // cellNodesByColumnIdx.  These are in the same order as cell nodes added at the\n        // end of the row.\n        \"cellRenderQueue\": []\n      };\n\n      appendRowHtml(stringArray, i, range, dataLength);\n      if (activeCellNode && activeRow === i) {\n        needToReselectCell = true;\n      }\n      counter_rows_rendered++;\n    }\n\n    if (!rows.length) { return; }\n\n    var x = document.createElement(\"div\");\n    x.innerHTML = stringArray.join(\"\");\n\n    for (var i = 0, ii = rows.length; i < ii; i++) {\n      rowsCache[rows[i]].rowNode = parentNode.appendChild(x.firstChild);\n    }\n\n    if (needToReselectCell) {\n      activeCellNode = getCellNode(activeRow, activeCell);\n    }\n  }\n\n  function startPostProcessing() {\n    if (!options.enableAsyncPostRender) {\n      return;\n    }\n    clearTimeout(h_postrender);\n    h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n  }\n\n  function invalidatePostProcessingResults(row) {\n    delete postProcessedRows[row];\n    postProcessFromRow = Math.min(postProcessFromRow, row);\n    postProcessToRow = Math.max(postProcessToRow, row);\n    startPostProcessing();\n  }\n\n  function updateRowPositions() {\n    for (var row in rowsCache) {\n      rowsCache[row].rowNode.style.top = getRowTop(row) + \"px\";\n    }\n  }\n\n  function render() {\n    if (!initialized) { return; }\n    var visible = getVisibleRange();\n    var rendered = getRenderedRange();\n\n    // remove rows no longer in the viewport\n    cleanupRows(rendered);\n\n    // add new rows & missing cells in existing rows\n    if (lastRenderedScrollLeft != scrollLeft) {\n      cleanUpAndRenderCells(rendered);\n    }\n\n    // render missing rows\n    renderRows(rendered);\n\n    postProcessFromRow = visible.top;\n    postProcessToRow = Math.min(getDataLengthIncludingAddNew() - 1, visible.bottom);\n    startPostProcessing();\n\n    lastRenderedScrollTop = scrollTop;\n    lastRenderedScrollLeft = scrollLeft;\n    h_render = null;\n  }\n\n  function handleHeaderRowScroll() {\n    var scrollLeft = $headerRowScroller[0].scrollLeft;\n    if (scrollLeft != $viewport[0].scrollLeft) {\n      $viewport[0].scrollLeft = scrollLeft;\n    }\n  }\n\n  function handleScroll() {\n    scrollTop = $viewport[0].scrollTop;\n    scrollLeft = $viewport[0].scrollLeft;\n    var vScrollDist = Math.abs(scrollTop - prevScrollTop);\n    var hScrollDist = Math.abs(scrollLeft - prevScrollLeft);\n\n    if (hScrollDist) {\n      prevScrollLeft = scrollLeft;\n      $headerScroller[0].scrollLeft = scrollLeft;\n      $topPanelScroller[0].scrollLeft = scrollLeft;\n      $headerRowScroller[0].scrollLeft = scrollLeft;\n    }\n\n    if (vScrollDist) {\n      vScrollDir = prevScrollTop < scrollTop ? 1 : -1;\n      prevScrollTop = scrollTop;\n\n      // switch virtual pages if needed\n      if (vScrollDist < viewportH) {\n        scrollTo(scrollTop + offset);\n      } else {\n        var oldOffset = offset;\n        if (h == viewportH) {\n          page = 0;\n        } else {\n          page = Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH) / (h - viewportH)) * (1 / ph)));\n        }\n        offset = Math.round(page * cj);\n        if (oldOffset != offset) {\n          invalidateAllRows();\n        }\n      }\n    }\n\n    if (hScrollDist || vScrollDist) {\n      if (h_render) {\n        clearTimeout(h_render);\n      }\n\n      if (Math.abs(lastRenderedScrollTop - scrollTop) > 20 ||\n          Math.abs(lastRenderedScrollLeft - scrollLeft) > 20) {\n        if (options.forceSyncScrolling || (\n            Math.abs(lastRenderedScrollTop - scrollTop) < viewportH &&\n            Math.abs(lastRenderedScrollLeft - scrollLeft) < viewportW)) {\n          render();\n        } else {\n          h_render = setTimeout(render, 50);\n        }\n\n        trigger(self.onViewportChanged, {});\n      }\n    }\n\n    trigger(self.onScroll, {scrollLeft: scrollLeft, scrollTop: scrollTop});\n  }\n\n  function asyncPostProcessRows() {\n    var dataLength = getDataLength();\n    while (postProcessFromRow <= postProcessToRow) {\n      var row = (vScrollDir >= 0) ? postProcessFromRow++ : postProcessToRow--;\n      var cacheEntry = rowsCache[row];\n      if (!cacheEntry || row >= dataLength) {\n        continue;\n      }\n\n      if (!postProcessedRows[row]) {\n        postProcessedRows[row] = {};\n      }\n\n      ensureCellNodesInRowsCache(row);\n      for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {\n        if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {\n          continue;\n        }\n\n        columnIdx = columnIdx | 0;\n\n        var m = columns[columnIdx];\n        if (m.asyncPostRender && !postProcessedRows[row][columnIdx]) {\n          var node = cacheEntry.cellNodesByColumnIdx[columnIdx];\n          if (node) {\n            m.asyncPostRender(node, row, getDataItem(row), m);\n          }\n          postProcessedRows[row][columnIdx] = true;\n        }\n      }\n\n      h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n      return;\n    }\n  }\n\n  function updateCellCssStylesOnRenderedRows(addedHash, removedHash) {\n    var node, columnId, addedRowHash, removedRowHash;\n    for (var row in rowsCache) {\n      removedRowHash = removedHash && removedHash[row];\n      addedRowHash = addedHash && addedHash[row];\n\n      if (removedRowHash) {\n        for (columnId in removedRowHash) {\n          if (!addedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {\n            node = getCellNode(row, getColumnIndex(columnId));\n            if (node) {\n              $(node).removeClass(removedRowHash[columnId]);\n            }\n          }\n        }\n      }\n\n      if (addedRowHash) {\n        for (columnId in addedRowHash) {\n          if (!removedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {\n            node = getCellNode(row, getColumnIndex(columnId));\n            if (node) {\n              $(node).addClass(addedRowHash[columnId]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function addCellCssStyles(key, hash) {\n    if (cellCssClasses[key]) {\n      throw \"addCellCssStyles: cell CSS hash with key '\" + key + \"' already exists.\";\n    }\n\n    cellCssClasses[key] = hash;\n    updateCellCssStylesOnRenderedRows(hash, null);\n\n    trigger(self.onCellCssStylesChanged, { \"key\": key, \"hash\": hash });\n  }\n\n  function removeCellCssStyles(key) {\n    if (!cellCssClasses[key]) {\n      return;\n    }\n\n    updateCellCssStylesOnRenderedRows(null, cellCssClasses[key]);\n    delete cellCssClasses[key];\n\n    trigger(self.onCellCssStylesChanged, { \"key\": key, \"hash\": null });\n  }\n\n  function setCellCssStyles(key, hash) {\n    var prevHash = cellCssClasses[key];\n\n    cellCssClasses[key] = hash;\n    updateCellCssStylesOnRenderedRows(hash, prevHash);\n\n    trigger(self.onCellCssStylesChanged, { \"key\": key, \"hash\": hash });\n  }\n\n  function getCellCssStyles(key) {\n    return cellCssClasses[key];\n  }\n\n  function flashCell(row, cell, speed) {\n    speed = speed || 100;\n    if (rowsCache[row]) {\n      var $cell = $(getCellNode(row, cell));\n\n      var toggleCellClass = function foo(times) {\n        if (!times) {\n          return;\n        }\n        setTimeout(function () {\n              $cell.queue(function () {\n                $cell.toggleClass(options.cellFlashingCssClass).dequeue();\n                toggleCellClass(times - 1);\n              });\n            },\n            speed);\n      }\n\n      toggleCellClass(4);\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Interactivity\n\n  function handleMouseWheel(e) {\n    var rowNode = $(e.target).closest(\".bk-slick-row\")[0];\n    if (rowNode != rowNodeFromLastMouseWheelEvent) {\n      if (zombieRowNodeFromLastMouseWheelEvent && zombieRowNodeFromLastMouseWheelEvent != rowNode) {\n        $canvas[0].removeChild(zombieRowNodeFromLastMouseWheelEvent);\n        zombieRowNodeFromLastMouseWheelEvent = null;\n      }\n      rowNodeFromLastMouseWheelEvent = rowNode;\n    }\n  }\n\n  function handleDragInit(e, dd) {\n    var cell = getCellFromEvent(e);\n    if (!cell || !cellExists(cell.row, cell.cell)) {\n      return false;\n    }\n\n    var retval = trigger(self.onDragInit, dd, e);\n    if (e.isImmediatePropagationStopped()) {\n      return retval;\n    }\n\n    // if nobody claims to be handling drag'n'drop by stopping immediate propagation,\n    // cancel out of it\n    return false;\n  }\n\n  function handleDragStart(e, dd) {\n    var cell = getCellFromEvent(e);\n    if (!cell || !cellExists(cell.row, cell.cell)) {\n      return false;\n    }\n\n    var retval = trigger(self.onDragStart, dd, e);\n    if (e.isImmediatePropagationStopped()) {\n      return retval;\n    }\n\n    return false;\n  }\n\n  function handleDrag(e, dd) {\n    return trigger(self.onDrag, dd, e);\n  }\n\n  function handleDragEnd(e, dd) {\n    trigger(self.onDragEnd, dd, e);\n  }\n\n  function handleKeyDown(e) {\n    trigger(self.onKeyDown, {row: activeRow, cell: activeCell}, e);\n    var handled = e.isImmediatePropagationStopped();\n\n    if (!handled) {\n      if (!e.shiftKey && !e.altKey && !e.ctrlKey) {\n        if (e.which == 27) {\n          if (!getEditorLock().isActive()) {\n            return; // no editing mode to cancel, allow bubbling and default processing (exit without cancelling the event)\n          }\n          cancelEditAndSetFocus();\n        } else if (e.which == 34) {\n          navigatePageDown();\n          handled = true;\n        } else if (e.which == 33) {\n          navigatePageUp();\n          handled = true;\n        } else if (e.which == 37) {\n          handled = navigateLeft();\n        } else if (e.which == 39) {\n          handled = navigateRight();\n        } else if (e.which == 38) {\n          handled = navigateUp();\n        } else if (e.which == 40) {\n          handled = navigateDown();\n        } else if (e.which == 9) {\n          handled = navigateNext();\n        } else if (e.which == 13) {\n          if (options.editable) {\n            if (currentEditor) {\n              // adding new row\n              if (activeRow === getDataLength()) {\n                navigateDown();\n              } else {\n                commitEditAndSetFocus();\n              }\n            } else {\n              if (getEditorLock().commitCurrentEdit()) {\n                makeActiveCellEditable();\n              }\n            }\n          }\n          handled = true;\n        }\n      } else if (e.which == 9 && e.shiftKey && !e.ctrlKey && !e.altKey) {\n        handled = navigatePrev();\n      }\n    }\n\n    if (handled) {\n      // the event has been handled so don't let parent element (bubbling/propagation) or browser (default) handle it\n      e.stopPropagation();\n      e.preventDefault();\n      try {\n        e.originalEvent.keyCode = 0; // prevent default behaviour for special keys in IE browsers (F3, F5, etc.)\n      }\n      // ignore exceptions - setting the original event's keycode throws access denied exception for \"Ctrl\"\n      // (hitting control key only, nothing else), \"Shift\" (maybe others)\n      catch (error) {\n      }\n    }\n  }\n\n  function handleClick(e) {\n    if (!currentEditor) {\n      // if this click resulted in some cell child node getting focus,\n      // don't steal it back - keyboard events will still bubble up\n      // IE9+ seems to default DIVs to tabIndex=0 instead of -1, so check for cell clicks directly.\n      if (e.target != document.activeElement || $(e.target).hasClass(\"bk-slick-cell\")) {\n        setFocus();\n      }\n    }\n\n    var cell = getCellFromEvent(e);\n    if (!cell || (currentEditor !== null && activeRow == cell.row && activeCell == cell.cell)) {\n      return;\n    }\n\n    trigger(self.onClick, {row: cell.row, cell: cell.cell}, e);\n    if (e.isImmediatePropagationStopped()) {\n      return;\n    }\n\n    if ((activeCell != cell.cell || activeRow != cell.row) && canCellBeActive(cell.row, cell.cell)) {\n      if (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()) {\n        scrollRowIntoView(cell.row, false);\n        setActiveCellInternal(getCellNode(cell.row, cell.cell));\n      }\n    }\n  }\n\n  function handleContextMenu(e) {\n    var $cell = $(e.target).closest(\".bk-slick-cell\", $canvas);\n    if ($cell.length === 0) {\n      return;\n    }\n\n    // are we editing this cell?\n    if (activeCellNode === $cell[0] && currentEditor !== null) {\n      return;\n    }\n\n    trigger(self.onContextMenu, {}, e);\n  }\n\n  function handleDblClick(e) {\n    var cell = getCellFromEvent(e);\n    if (!cell || (currentEditor !== null && activeRow == cell.row && activeCell == cell.cell)) {\n      return;\n    }\n\n    trigger(self.onDblClick, {row: cell.row, cell: cell.cell}, e);\n    if (e.isImmediatePropagationStopped()) {\n      return;\n    }\n\n    if (options.editable) {\n      gotoCell(cell.row, cell.cell, true);\n    }\n  }\n\n  function handleHeaderMouseEnter(e) {\n    trigger(self.onHeaderMouseEnter, {\n      \"column\": $(this).data(\"column\")\n    }, e);\n  }\n\n  function handleHeaderMouseLeave(e) {\n    trigger(self.onHeaderMouseLeave, {\n      \"column\": $(this).data(\"column\")\n    }, e);\n  }\n\n  function handleHeaderContextMenu(e) {\n    var $header = $(e.target).closest(\".bk-slick-header-column\", \".bk-slick-header-columns\");\n    var column = $header && $header.data(\"column\");\n    trigger(self.onHeaderContextMenu, {column: column}, e);\n  }\n\n  function handleHeaderClick(e) {\n    var $header = $(e.target).closest(\".bk-slick-header-column\", \".bk-slick-header-columns\");\n    var column = $header && $header.data(\"column\");\n    if (column) {\n      trigger(self.onHeaderClick, {column: column}, e);\n    }\n  }\n\n  function handleMouseEnter(e) {\n    trigger(self.onMouseEnter, {}, e);\n  }\n\n  function handleMouseLeave(e) {\n    trigger(self.onMouseLeave, {}, e);\n  }\n\n  function cellExists(row, cell) {\n    return !(row < 0 || row >= getDataLength() || cell < 0 || cell >= columns.length);\n  }\n\n  function getCellFromPoint(x, y) {\n    var row = getRowFromPosition(y);\n    var cell = 0;\n\n    var w = 0;\n    for (var i = 0; i < columns.length && w < x; i++) {\n      w += columns[i].width;\n      cell++;\n    }\n\n    if (cell < 0) {\n      cell = 0;\n    }\n\n    return {row: row, cell: cell - 1};\n  }\n\n  function getCellFromNode(cellNode) {\n    // read column number from .l<columnNumber> CSS class\n    var cls = /l\\d+/.exec(cellNode.className);\n    if (!cls) {\n      throw \"getCellFromNode: cannot get cell - \" + cellNode.className;\n    }\n    return parseInt(cls[0].substr(1, cls[0].length - 1), 10);\n  }\n\n  function getRowFromNode(rowNode) {\n    for (var row in rowsCache) {\n      if (rowsCache[row].rowNode === rowNode) {\n        return row | 0;\n      }\n    }\n\n    return null;\n  }\n\n  function getCellFromEvent(e) {\n    var $cell = $(e.target).closest(\".bk-slick-cell\", $canvas);\n    if (!$cell.length) {\n      return null;\n    }\n\n    var row = getRowFromNode($cell[0].parentNode);\n    var cell = getCellFromNode($cell[0]);\n\n    if (row == null || cell == null) {\n      return null;\n    } else {\n      return {\n        \"row\": row,\n        \"cell\": cell\n      };\n    }\n  }\n\n  function getCellNodeBox(row, cell) {\n    if (!cellExists(row, cell)) {\n      return null;\n    }\n\n    var y1 = getRowTop(row);\n    var y2 = y1 + options.rowHeight - 1;\n    var x1 = 0;\n    for (var i = 0; i < cell; i++) {\n      x1 += columns[i].width;\n    }\n    var x2 = x1 + columns[cell].width;\n\n    return {\n      top: y1,\n      left: x1,\n      bottom: y2,\n      right: x2\n    };\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Cell switching\n\n  function resetActiveCell() {\n    setActiveCellInternal(null, false);\n  }\n\n  function setFocus() {\n    if (tabbingDirection == -1) {\n      $focusSink[0].focus();\n    } else {\n      $focusSink2[0].focus();\n    }\n  }\n\n  function scrollCellIntoView(row, cell, doPaging) {\n    scrollRowIntoView(row, doPaging);\n\n    var colspan = getColspan(row, cell);\n    var left = columnPosLeft[cell],\n      right = columnPosRight[cell + (colspan > 1 ? colspan - 1 : 0)],\n      scrollRight = scrollLeft + viewportW;\n\n    if (left < scrollLeft) {\n      $viewport.scrollLeft(left);\n      handleScroll();\n      render();\n    } else if (right > scrollRight) {\n      $viewport.scrollLeft(Math.min(left, right - $viewport[0].clientWidth));\n      handleScroll();\n      render();\n    }\n  }\n\n  function setActiveCellInternal(newCell, opt_editMode) {\n    if (activeCellNode !== null) {\n      makeActiveCellNormal();\n      $(activeCellNode).removeClass(\"active\");\n      if (rowsCache[activeRow]) {\n        $(rowsCache[activeRow].rowNode).removeClass(\"active\");\n      }\n    }\n\n    var activeCellChanged = (activeCellNode !== newCell);\n    activeCellNode = newCell;\n\n    if (activeCellNode != null) {\n      activeRow = getRowFromNode(activeCellNode.parentNode);\n      activeCell = activePosX = getCellFromNode(activeCellNode);\n\n      if (opt_editMode == null) {\n        opt_editMode = (activeRow == getDataLength()) || options.autoEdit;\n      }\n\n      $(activeCellNode).addClass(\"active\");\n      $(rowsCache[activeRow].rowNode).addClass(\"active\");\n\n      if (options.editable && opt_editMode && isCellPotentiallyEditable(activeRow, activeCell)) {\n        clearTimeout(h_editorLoader);\n\n        if (options.asyncEditorLoading) {\n          h_editorLoader = setTimeout(function () {\n            makeActiveCellEditable();\n          }, options.asyncEditorLoadDelay);\n        } else {\n          makeActiveCellEditable();\n        }\n      }\n    } else {\n      activeRow = activeCell = null;\n    }\n\n    if (activeCellChanged) {\n      trigger(self.onActiveCellChanged, getActiveCell());\n    }\n  }\n\n  function clearTextSelection() {\n    if (document.selection && document.selection.empty) {\n      try {\n        //IE fails here if selected element is not in dom\n        document.selection.empty();\n      } catch (e) { }\n    } else if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel && sel.removeAllRanges) {\n        sel.removeAllRanges();\n      }\n    }\n  }\n\n  function isCellPotentiallyEditable(row, cell) {\n    var dataLength = getDataLength();\n    // is the data for this row loaded?\n    if (row < dataLength && !getDataItem(row)) {\n      return false;\n    }\n\n    // are we in the Add New row?  can we create new from this cell?\n    if (columns[cell].cannotTriggerInsert && row >= dataLength) {\n      return false;\n    }\n\n    // does this cell have an editor?\n    if (!getEditor(row, cell)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function makeActiveCellNormal() {\n    if (!currentEditor) {\n      return;\n    }\n    trigger(self.onBeforeCellEditorDestroy, {editor: currentEditor});\n    currentEditor.destroy();\n    currentEditor = null;\n\n    if (activeCellNode) {\n      var d = getDataItem(activeRow);\n      $(activeCellNode).removeClass(\"editable invalid\");\n      if (d) {\n        var column = columns[activeCell];\n        var formatter = getFormatter(activeRow, column);\n        activeCellNode.innerHTML = formatter(activeRow, activeCell, getDataItemValueForColumn(d, column), column, d);\n        invalidatePostProcessingResults(activeRow);\n      }\n    }\n\n    // if there previously was text selected on a page (such as selected text in the edit cell just removed),\n    // IE can't set focus to anything else correctly\n    if (navigator.userAgent.toLowerCase().match(/msie/)) {\n      clearTextSelection();\n    }\n\n    getEditorLock().deactivate(editController);\n  }\n\n  function makeActiveCellEditable(editor) {\n    if (!activeCellNode) {\n      return;\n    }\n    if (!options.editable) {\n      throw \"Grid : makeActiveCellEditable : should never get called when options.editable is false\";\n    }\n\n    // cancel pending async call if there is one\n    clearTimeout(h_editorLoader);\n\n    if (!isCellPotentiallyEditable(activeRow, activeCell)) {\n      return;\n    }\n\n    var columnDef = columns[activeCell];\n    var item = getDataItem(activeRow);\n\n    if (trigger(self.onBeforeEditCell, {row: activeRow, cell: activeCell, item: item, column: columnDef}) === false) {\n      setFocus();\n      return;\n    }\n\n    getEditorLock().activate(editController);\n    $(activeCellNode).addClass(\"editable\");\n\n    // don't clear the cell if a custom editor is passed through\n    if (!editor) {\n      activeCellNode.innerHTML = \"\";\n    }\n\n    currentEditor = new (editor || getEditor(activeRow, activeCell))({\n      grid: self,\n      gridPosition: absBox($container[0]),\n      position: absBox(activeCellNode),\n      container: activeCellNode,\n      column: columnDef,\n      item: item || {},\n      commitChanges: commitEditAndSetFocus,\n      cancelChanges: cancelEditAndSetFocus\n    });\n\n    if (item) {\n      currentEditor.loadValue(item);\n    }\n\n    serializedEditorValue = currentEditor.serializeValue();\n\n    if (currentEditor.position) {\n      handleActiveCellPositionChange();\n    }\n  }\n\n  function commitEditAndSetFocus() {\n    // if the commit fails, it would do so due to a validation error\n    // if so, do not steal the focus from the editor\n    if (getEditorLock().commitCurrentEdit()) {\n      setFocus();\n      if (options.autoEdit) {\n        navigateDown();\n      }\n    }\n  }\n\n  function cancelEditAndSetFocus() {\n    if (getEditorLock().cancelCurrentEdit()) {\n      setFocus();\n    }\n  }\n\n  function absBox(elem) {\n    var box = {\n      top: elem.offsetTop,\n      left: elem.offsetLeft,\n      bottom: 0,\n      right: 0,\n      width: $(elem).outerWidth(),\n      height: $(elem).outerHeight(),\n      visible: true};\n    box.bottom = box.top + box.height;\n    box.right = box.left + box.width;\n\n    // walk up the tree\n    var offsetParent = elem.offsetParent;\n    while ((elem = elem.parentNode) != document.body) {\n      if (box.visible && elem.scrollHeight != elem.offsetHeight && $(elem).css(\"overflowY\") != \"visible\") {\n        box.visible = box.bottom > elem.scrollTop && box.top < elem.scrollTop + elem.clientHeight;\n      }\n\n      if (box.visible && elem.scrollWidth != elem.offsetWidth && $(elem).css(\"overflowX\") != \"visible\") {\n        box.visible = box.right > elem.scrollLeft && box.left < elem.scrollLeft + elem.clientWidth;\n      }\n\n      box.left -= elem.scrollLeft;\n      box.top -= elem.scrollTop;\n\n      if (elem === offsetParent) {\n        box.left += elem.offsetLeft;\n        box.top += elem.offsetTop;\n        offsetParent = elem.offsetParent;\n      }\n\n      box.bottom = box.top + box.height;\n      box.right = box.left + box.width;\n    }\n\n    return box;\n  }\n\n  function getActiveCellPosition() {\n    return absBox(activeCellNode);\n  }\n\n  function getGridPosition() {\n    return absBox($container[0])\n  }\n\n  function handleActiveCellPositionChange() {\n    if (!activeCellNode) {\n      return;\n    }\n\n    trigger(self.onActiveCellPositionChanged, {});\n\n    if (currentEditor) {\n      var cellBox = getActiveCellPosition();\n      if (currentEditor.show && currentEditor.hide) {\n        if (!cellBox.visible) {\n          currentEditor.hide();\n        } else {\n          currentEditor.show();\n        }\n      }\n\n      if (currentEditor.position) {\n        currentEditor.position(cellBox);\n      }\n    }\n  }\n\n  function getCellEditor() {\n    return currentEditor;\n  }\n\n  function getActiveCell() {\n    if (!activeCellNode) {\n      return null;\n    } else {\n      return {row: activeRow, cell: activeCell};\n    }\n  }\n\n  function getActiveCellNode() {\n    return activeCellNode;\n  }\n\n  function scrollRowIntoView(row, doPaging) {\n    var rowAtTop = row * options.rowHeight;\n    var rowAtBottom = (row + 1) * options.rowHeight - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0);\n\n    // need to page down?\n    if ((row + 1) * options.rowHeight > scrollTop + viewportH + offset) {\n      scrollTo(doPaging ? rowAtTop : rowAtBottom);\n      render();\n    }\n    // or page up?\n    else if (row * options.rowHeight < scrollTop + offset) {\n      scrollTo(doPaging ? rowAtBottom : rowAtTop);\n      render();\n    }\n  }\n\n  function scrollRowToTop(row) {\n    scrollTo(row * options.rowHeight);\n    render();\n  }\n\n  function scrollPage(dir) {\n    var deltaRows = dir * numVisibleRows;\n    scrollTo((getRowFromPosition(scrollTop) + deltaRows) * options.rowHeight);\n    render();\n\n    if (options.enableCellNavigation && activeRow != null) {\n      var row = activeRow + deltaRows;\n      var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n      if (row >= dataLengthIncludingAddNew) {\n        row = dataLengthIncludingAddNew - 1;\n      }\n      if (row < 0) {\n        row = 0;\n      }\n\n      var cell = 0, prevCell = null;\n      var prevActivePosX = activePosX;\n      while (cell <= activePosX) {\n        if (canCellBeActive(row, cell)) {\n          prevCell = cell;\n        }\n        cell += getColspan(row, cell);\n      }\n\n      if (prevCell !== null) {\n        setActiveCellInternal(getCellNode(row, prevCell));\n        activePosX = prevActivePosX;\n      } else {\n        resetActiveCell();\n      }\n    }\n  }\n\n  function navigatePageDown() {\n    scrollPage(1);\n  }\n\n  function navigatePageUp() {\n    scrollPage(-1);\n  }\n\n  function getColspan(row, cell) {\n    var metadata = data.getItemMetadata && data.getItemMetadata(row);\n    if (!metadata || !metadata.columns) {\n      return 1;\n    }\n\n    var columnData = metadata.columns[columns[cell].id] || metadata.columns[cell];\n    var colspan = (columnData && columnData.colspan);\n    if (colspan === \"*\") {\n      colspan = columns.length - cell;\n    } else {\n      colspan = colspan || 1;\n    }\n\n    return colspan;\n  }\n\n  function findFirstFocusableCell(row) {\n    var cell = 0;\n    while (cell < columns.length) {\n      if (canCellBeActive(row, cell)) {\n        return cell;\n      }\n      cell += getColspan(row, cell);\n    }\n    return null;\n  }\n\n  function findLastFocusableCell(row) {\n    var cell = 0;\n    var lastFocusableCell = null;\n    while (cell < columns.length) {\n      if (canCellBeActive(row, cell)) {\n        lastFocusableCell = cell;\n      }\n      cell += getColspan(row, cell);\n    }\n    return lastFocusableCell;\n  }\n\n  function gotoRight(row, cell, posX) {\n    if (cell >= columns.length) {\n      return null;\n    }\n\n    do {\n      cell += getColspan(row, cell);\n    }\n    while (cell < columns.length && !canCellBeActive(row, cell));\n\n    if (cell < columns.length) {\n      return {\n        \"row\": row,\n        \"cell\": cell,\n        \"posX\": cell\n      };\n    }\n    return null;\n  }\n\n  function gotoLeft(row, cell, posX) {\n    if (cell <= 0) {\n      return null;\n    }\n\n    var firstFocusableCell = findFirstFocusableCell(row);\n    if (firstFocusableCell === null || firstFocusableCell >= cell) {\n      return null;\n    }\n\n    var prev = {\n      \"row\": row,\n      \"cell\": firstFocusableCell,\n      \"posX\": firstFocusableCell\n    };\n    var pos;\n    while (true) {\n      pos = gotoRight(prev.row, prev.cell, prev.posX);\n      if (!pos) {\n        return null;\n      }\n      if (pos.cell >= cell) {\n        return prev;\n      }\n      prev = pos;\n    }\n  }\n\n  function gotoDown(row, cell, posX) {\n    var prevCell;\n    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n    while (true) {\n      if (++row >= dataLengthIncludingAddNew) {\n        return null;\n      }\n\n      prevCell = cell = 0;\n      while (cell <= posX) {\n        prevCell = cell;\n        cell += getColspan(row, cell);\n      }\n\n      if (canCellBeActive(row, prevCell)) {\n        return {\n          \"row\": row,\n          \"cell\": prevCell,\n          \"posX\": posX\n        };\n      }\n    }\n  }\n\n  function gotoUp(row, cell, posX) {\n    var prevCell;\n    while (true) {\n      if (--row < 0) {\n        return null;\n      }\n\n      prevCell = cell = 0;\n      while (cell <= posX) {\n        prevCell = cell;\n        cell += getColspan(row, cell);\n      }\n\n      if (canCellBeActive(row, prevCell)) {\n        return {\n          \"row\": row,\n          \"cell\": prevCell,\n          \"posX\": posX\n        };\n      }\n    }\n  }\n\n  function gotoNext(row, cell, posX) {\n    if (row == null && cell == null) {\n      row = cell = posX = 0;\n      if (canCellBeActive(row, cell)) {\n        return {\n          \"row\": row,\n          \"cell\": cell,\n          \"posX\": cell\n        };\n      }\n    }\n\n    var pos = gotoRight(row, cell, posX);\n    if (pos) {\n      return pos;\n    }\n\n    var firstFocusableCell = null;\n    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n    while (++row < dataLengthIncludingAddNew) {\n      firstFocusableCell = findFirstFocusableCell(row);\n      if (firstFocusableCell !== null) {\n        return {\n          \"row\": row,\n          \"cell\": firstFocusableCell,\n          \"posX\": firstFocusableCell\n        };\n      }\n    }\n    return null;\n  }\n\n  function gotoPrev(row, cell, posX) {\n    if (row == null && cell == null) {\n      row = getDataLengthIncludingAddNew() - 1;\n      cell = posX = columns.length - 1;\n      if (canCellBeActive(row, cell)) {\n        return {\n          \"row\": row,\n          \"cell\": cell,\n          \"posX\": cell\n        };\n      }\n    }\n\n    var pos;\n    var lastSelectableCell;\n    while (!pos) {\n      pos = gotoLeft(row, cell, posX);\n      if (pos) {\n        break;\n      }\n      if (--row < 0) {\n        return null;\n      }\n\n      cell = 0;\n      lastSelectableCell = findLastFocusableCell(row);\n      if (lastSelectableCell !== null) {\n        pos = {\n          \"row\": row,\n          \"cell\": lastSelectableCell,\n          \"posX\": lastSelectableCell\n        };\n      }\n    }\n    return pos;\n  }\n\n  function navigateRight() {\n    return navigate(\"right\");\n  }\n\n  function navigateLeft() {\n    return navigate(\"left\");\n  }\n\n  function navigateDown() {\n    return navigate(\"down\");\n  }\n\n  function navigateUp() {\n    return navigate(\"up\");\n  }\n\n  function navigateNext() {\n    return navigate(\"next\");\n  }\n\n  function navigatePrev() {\n    return navigate(\"prev\");\n  }\n\n  /**\n   * @param {string} dir Navigation direction.\n   * @return {boolean} Whether navigation resulted in a change of active cell.\n   */\n  function navigate(dir) {\n    if (!options.enableCellNavigation) {\n      return false;\n    }\n\n    if (!activeCellNode && dir != \"prev\" && dir != \"next\") {\n      return false;\n    }\n\n    if (!getEditorLock().commitCurrentEdit()) {\n      return true;\n    }\n    setFocus();\n\n    var tabbingDirections = {\n      \"up\": -1,\n      \"down\": 1,\n      \"left\": -1,\n      \"right\": 1,\n      \"prev\": -1,\n      \"next\": 1\n    };\n    tabbingDirection = tabbingDirections[dir];\n\n    var stepFunctions = {\n      \"up\": gotoUp,\n      \"down\": gotoDown,\n      \"left\": gotoLeft,\n      \"right\": gotoRight,\n      \"prev\": gotoPrev,\n      \"next\": gotoNext\n    };\n    var stepFn = stepFunctions[dir];\n    var pos = stepFn(activeRow, activeCell, activePosX);\n    if (pos) {\n      var isAddNewRow = (pos.row == getDataLength());\n      scrollCellIntoView(pos.row, pos.cell, !isAddNewRow);\n      setActiveCellInternal(getCellNode(pos.row, pos.cell));\n      activePosX = pos.posX;\n      return true;\n    } else {\n      setActiveCellInternal(getCellNode(activeRow, activeCell));\n      return false;\n    }\n  }\n\n  function getCellNode(row, cell) {\n    if (rowsCache[row]) {\n      ensureCellNodesInRowsCache(row);\n      return rowsCache[row].cellNodesByColumnIdx[cell];\n    }\n    return null;\n  }\n\n  function setActiveCell(row, cell) {\n    if (!initialized) { return; }\n    if (row > getDataLength() || row < 0 || cell >= columns.length || cell < 0) {\n      return;\n    }\n\n    if (!options.enableCellNavigation) {\n      return;\n    }\n\n    scrollCellIntoView(row, cell, false);\n    setActiveCellInternal(getCellNode(row, cell), false);\n  }\n\n  function canCellBeActive(row, cell) {\n    if (!options.enableCellNavigation || row >= getDataLengthIncludingAddNew() ||\n        row < 0 || cell >= columns.length || cell < 0) {\n      return false;\n    }\n\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n    if (rowMetadata && typeof rowMetadata.focusable === \"boolean\") {\n      return rowMetadata.focusable;\n    }\n\n    var columnMetadata = rowMetadata && rowMetadata.columns;\n    if (columnMetadata && columnMetadata[columns[cell].id] && typeof columnMetadata[columns[cell].id].focusable === \"boolean\") {\n      return columnMetadata[columns[cell].id].focusable;\n    }\n    if (columnMetadata && columnMetadata[cell] && typeof columnMetadata[cell].focusable === \"boolean\") {\n      return columnMetadata[cell].focusable;\n    }\n\n    return columns[cell].focusable;\n  }\n\n  function canCellBeSelected(row, cell) {\n    if (row >= getDataLength() || row < 0 || cell >= columns.length || cell < 0) {\n      return false;\n    }\n\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n    if (rowMetadata && typeof rowMetadata.selectable === \"boolean\") {\n      return rowMetadata.selectable;\n    }\n\n    var columnMetadata = rowMetadata && rowMetadata.columns && (rowMetadata.columns[columns[cell].id] || rowMetadata.columns[cell]);\n    if (columnMetadata && typeof columnMetadata.selectable === \"boolean\") {\n      return columnMetadata.selectable;\n    }\n\n    return columns[cell].selectable;\n  }\n\n  function gotoCell(row, cell, forceEdit) {\n    if (!initialized) { return; }\n    if (!canCellBeActive(row, cell)) {\n      return;\n    }\n\n    if (!getEditorLock().commitCurrentEdit()) {\n      return;\n    }\n\n    scrollCellIntoView(row, cell, false);\n\n    var newCell = getCellNode(row, cell);\n\n    // if selecting the 'add new' row, start editing right away\n    setActiveCellInternal(newCell, forceEdit || (row === getDataLength()) || options.autoEdit);\n\n    // if no editor was created, set the focus back on the grid\n    if (!currentEditor) {\n      setFocus();\n    }\n  }\n\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // IEditor implementation for the editor lock\n\n  function commitCurrentEdit() {\n    var item = getDataItem(activeRow);\n    var column = columns[activeCell];\n\n    if (currentEditor) {\n      if (currentEditor.isValueChanged()) {\n        var validationResults = currentEditor.validate();\n\n        if (validationResults.valid) {\n          if (activeRow < getDataLength()) {\n            var editCommand = {\n              row: activeRow,\n              cell: activeCell,\n              editor: currentEditor,\n              serializedValue: currentEditor.serializeValue(),\n              prevSerializedValue: serializedEditorValue,\n              execute: function () {\n                this.editor.applyValue(item, this.serializedValue);\n                updateRow(this.row);\n                trigger(self.onCellChange, {\n                  row: activeRow,\n                  cell: activeCell,\n                  item: item\n                });\n              },\n              undo: function () {\n                this.editor.applyValue(item, this.prevSerializedValue);\n                updateRow(this.row);\n                trigger(self.onCellChange, {\n                  row: activeRow,\n                  cell: activeCell,\n                  item: item\n                });\n              }\n            };\n\n            if (options.editCommandHandler) {\n              makeActiveCellNormal();\n              options.editCommandHandler(item, column, editCommand);\n            } else {\n              editCommand.execute();\n              makeActiveCellNormal();\n            }\n\n          } else {\n            var newItem = {};\n            currentEditor.applyValue(newItem, currentEditor.serializeValue());\n            makeActiveCellNormal();\n            trigger(self.onAddNewRow, {item: newItem, column: column});\n          }\n\n          // check whether the lock has been re-acquired by event handlers\n          return !getEditorLock().isActive();\n        } else {\n          // Re-add the CSS class to trigger transitions, if any.\n          $(activeCellNode).removeClass(\"invalid\");\n          $(activeCellNode).width();  // force layout\n          $(activeCellNode).addClass(\"invalid\");\n\n          trigger(self.onValidationError, {\n            editor: currentEditor,\n            cellNode: activeCellNode,\n            validationResults: validationResults,\n            row: activeRow,\n            cell: activeCell,\n            column: column\n          });\n\n          currentEditor.focus();\n          return false;\n        }\n      }\n\n      makeActiveCellNormal();\n    }\n    return true;\n  }\n\n  function cancelCurrentEdit() {\n    makeActiveCellNormal();\n    return true;\n  }\n\n  function rowsToRanges(rows) {\n    var ranges = [];\n    var lastCell = columns.length - 1;\n    for (var i = 0; i < rows.length; i++) {\n      ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));\n    }\n    return ranges;\n  }\n\n  function getSelectedRows() {\n    if (!selectionModel) {\n      throw \"Selection model is not set\";\n    }\n    return selectedRows;\n  }\n\n  function setSelectedRows(rows) {\n    if (!selectionModel) {\n      throw \"Selection model is not set\";\n    }\n    selectionModel.setSelectedRanges(rowsToRanges(rows));\n  }\n\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Debug\n\n  this.debug = function () {\n    var s = \"\";\n\n    s += (\"\\n\" + \"counter_rows_rendered:  \" + counter_rows_rendered);\n    s += (\"\\n\" + \"counter_rows_removed:  \" + counter_rows_removed);\n    s += (\"\\n\" + \"renderedRows:  \" + renderedRows);\n    s += (\"\\n\" + \"numVisibleRows:  \" + numVisibleRows);\n    s += (\"\\n\" + \"maxSupportedCssHeight:  \" + maxSupportedCssHeight);\n    s += (\"\\n\" + \"n(umber of pages):  \" + n);\n    s += (\"\\n\" + \"(current) page:  \" + page);\n    s += (\"\\n\" + \"page height (ph):  \" + ph);\n    s += (\"\\n\" + \"vScrollDir:  \" + vScrollDir);\n\n    alert(s);\n  };\n\n  // a debug helper to be able to access private members\n  this.eval = function (expr) {\n    return eval(expr);\n  };\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Public API\n\n  $.extend(this, {\n    \"slickGridVersion\": \"2.1\",\n\n    // Events\n    \"onScroll\": new Slick.Event(),\n    \"onSort\": new Slick.Event(),\n    \"onHeaderMouseEnter\": new Slick.Event(),\n    \"onHeaderMouseLeave\": new Slick.Event(),\n    \"onHeaderContextMenu\": new Slick.Event(),\n    \"onHeaderClick\": new Slick.Event(),\n    \"onHeaderCellRendered\": new Slick.Event(),\n    \"onBeforeHeaderCellDestroy\": new Slick.Event(),\n    \"onHeaderRowCellRendered\": new Slick.Event(),\n    \"onBeforeHeaderRowCellDestroy\": new Slick.Event(),\n    \"onMouseEnter\": new Slick.Event(),\n    \"onMouseLeave\": new Slick.Event(),\n    \"onClick\": new Slick.Event(),\n    \"onDblClick\": new Slick.Event(),\n    \"onContextMenu\": new Slick.Event(),\n    \"onKeyDown\": new Slick.Event(),\n    \"onAddNewRow\": new Slick.Event(),\n    \"onValidationError\": new Slick.Event(),\n    \"onViewportChanged\": new Slick.Event(),\n    \"onColumnsReordered\": new Slick.Event(),\n    \"onColumnsResized\": new Slick.Event(),\n    \"onCellChange\": new Slick.Event(),\n    \"onBeforeEditCell\": new Slick.Event(),\n    \"onBeforeCellEditorDestroy\": new Slick.Event(),\n    \"onBeforeDestroy\": new Slick.Event(),\n    \"onActiveCellChanged\": new Slick.Event(),\n    \"onActiveCellPositionChanged\": new Slick.Event(),\n    \"onDragInit\": new Slick.Event(),\n    \"onDragStart\": new Slick.Event(),\n    \"onDrag\": new Slick.Event(),\n    \"onDragEnd\": new Slick.Event(),\n    \"onSelectedRowsChanged\": new Slick.Event(),\n    \"onCellCssStylesChanged\": new Slick.Event(),\n\n    // Methods\n    \"registerPlugin\": registerPlugin,\n    \"unregisterPlugin\": unregisterPlugin,\n    \"getColumns\": getColumns,\n    \"setColumns\": setColumns,\n    \"getColumnIndex\": getColumnIndex,\n    \"updateColumnHeader\": updateColumnHeader,\n    \"setSortColumn\": setSortColumn,\n    \"setSortColumns\": setSortColumns,\n    \"getSortColumns\": getSortColumns,\n    \"autosizeColumns\": autosizeColumns,\n    \"getOptions\": getOptions,\n    \"setOptions\": setOptions,\n    \"getData\": getData,\n    \"getDataLength\": getDataLength,\n    \"getDataItem\": getDataItem,\n    \"setData\": setData,\n    \"getSelectionModel\": getSelectionModel,\n    \"setSelectionModel\": setSelectionModel,\n    \"getSelectedRows\": getSelectedRows,\n    \"setSelectedRows\": setSelectedRows,\n    \"getContainerNode\": getContainerNode,\n\n    \"render\": render,\n    \"invalidate\": invalidate,\n    \"invalidateRow\": invalidateRow,\n    \"invalidateRows\": invalidateRows,\n    \"invalidateAllRows\": invalidateAllRows,\n    \"updateCell\": updateCell,\n    \"updateRow\": updateRow,\n    \"getViewport\": getVisibleRange,\n    \"getRenderedRange\": getRenderedRange,\n    \"resizeCanvas\": resizeCanvas,\n    \"updateRowCount\": updateRowCount,\n    \"scrollRowIntoView\": scrollRowIntoView,\n    \"scrollRowToTop\": scrollRowToTop,\n    \"scrollCellIntoView\": scrollCellIntoView,\n    \"getCanvasNode\": getCanvasNode,\n    \"focus\": setFocus,\n\n    \"getCellFromPoint\": getCellFromPoint,\n    \"getCellFromEvent\": getCellFromEvent,\n    \"getActiveCell\": getActiveCell,\n    \"setActiveCell\": setActiveCell,\n    \"getActiveCellNode\": getActiveCellNode,\n    \"getActiveCellPosition\": getActiveCellPosition,\n    \"resetActiveCell\": resetActiveCell,\n    \"editActiveCell\": makeActiveCellEditable,\n    \"getCellEditor\": getCellEditor,\n    \"getCellNode\": getCellNode,\n    \"getCellNodeBox\": getCellNodeBox,\n    \"canCellBeSelected\": canCellBeSelected,\n    \"canCellBeActive\": canCellBeActive,\n    \"navigatePrev\": navigatePrev,\n    \"navigateNext\": navigateNext,\n    \"navigateUp\": navigateUp,\n    \"navigateDown\": navigateDown,\n    \"navigateLeft\": navigateLeft,\n    \"navigateRight\": navigateRight,\n    \"navigatePageUp\": navigatePageUp,\n    \"navigatePageDown\": navigatePageDown,\n    \"gotoCell\": gotoCell,\n    \"getTopPanel\": getTopPanel,\n    \"setTopPanelVisibility\": setTopPanelVisibility,\n    \"setHeaderRowVisibility\": setHeaderRowVisibility,\n    \"getHeaderRow\": getHeaderRow,\n    \"getHeaderRowColumn\": getHeaderRowColumn,\n    \"getGridPosition\": getGridPosition,\n    \"flashCell\": flashCell,\n    \"addCellCssStyles\": addCellCssStyles,\n    \"setCellCssStyles\": setCellCssStyles,\n    \"removeCellCssStyles\": removeCellCssStyles,\n    \"getCellCssStyles\": getCellCssStyles,\n\n    \"init\": finishInitialization,\n    \"destroy\": destroy,\n\n    // IEditor implementation\n    \"getEditorLock\": getEditorLock,\n    \"getEditController\": getEditController\n  });\n\n  init();\n}\n\nmodule.exports = SlickGrid;\n"],"preExisting":"//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi93b3JrL2Jva2VoL2Jva2VoanMvc3JjL2pzL3BsdWdpbi1wcmVsdWRlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy9hYnN0cmFjdF9idXR0b24uanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL2Fic3RyYWN0X2ljb24uanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL2F1dG9jb21wbGV0ZV9pbnB1dC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvYnV0dG9uLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy9idXR0b25fZ3JvdXBfdGVtcGxhdGUuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL2J1dHRvbl90ZW1wbGF0ZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvY2VsbF9lZGl0b3JzLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy9jZWxsX2Zvcm1hdHRlcnMuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL2NoZWNrYm94X2J1dHRvbl9ncm91cC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvY2hlY2tib3hfZ3JvdXAuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL2RhdGFfdGFibGUuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL2RhdGVfcGlja2VyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy9kYXRlX3JhbmdlX3NsaWRlci5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvZGl2LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy9kcm9wZG93bi5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvZHJvcGRvd25fdGVtcGxhdGUuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy9pbnB1dF93aWRnZXQuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL21haW4uanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL21hcmt1cC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvbWFya3VwX3RlbXBsYXRlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy9tdWx0aXNlbGVjdC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvbXVsdGlzZWxlY3R0ZW1wbGF0ZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvcGFuZWwuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL3BhcmFncmFwaC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvcHJldGV4dC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvcmFkaW9fYnV0dG9uX2dyb3VwLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy9yYWRpb19ncm91cC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvcmFuZ2Vfc2xpZGVyLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy9zZWxlY3Rib3guanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL3NlbGVjdHRlbXBsYXRlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy9zbGlkZXIuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL3NsaWRlcnRlbXBsYXRlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy90YWJsZV9jb2x1bW4uanMiLCJidWlsZC9qcy90cmVlL21vZGVscy93aWRnZXRzL3RhYmxlX3dpZGdldC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvdGFicy5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvdGFic190ZW1wbGF0ZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvdGV4dF9pbnB1dC5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvdGV4dF9pbnB1dF90ZW1wbGF0ZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL3dpZGdldHMvdG9nZ2xlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvd2lkZ2V0cy93aWRnZXQuanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5LXVpL2F1dG9jb21wbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnktdWkvYnV0dG9uLmpzIiwibm9kZV9tb2R1bGVzL2pxdWVyeS11aS9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2pxdWVyeS11aS9kYXRlcGlja2VyLmpzIiwibm9kZV9tb2R1bGVzL2pxdWVyeS11aS9tZW51LmpzIiwibm9kZV9tb2R1bGVzL2pxdWVyeS11aS9tb3VzZS5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnktdWkvcG9zaXRpb24uanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3NsaWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnktdWkvc29ydGFibGUuanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3NwaW5uZXIuanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3dpZGdldC5qcyIsInNyYy92ZW5kb3IvYm9vdHN0cmFwLTMuMS4xL2pzL2J1dHRvbi5qcyIsInNyYy92ZW5kb3IvYm9vdHN0cmFwLTMuMS4xL2pzL2Ryb3Bkb3duLmpzIiwic3JjL3ZlbmRvci9ib290c3RyYXAtMy4xLjEvanMvdGFiLmpzIiwic3JjL3ZlbmRvci9qcXJhbmdlc2xpZGVyLTUuNy4wL2pRRGF0ZVJhbmdlU2xpZGVyLmpzIiwic3JjL3ZlbmRvci9qcXJhbmdlc2xpZGVyLTUuNy4wL2pRUmFuZ2VTbGlkZXIuanMiLCJzcmMvdmVuZG9yL2pxdWVyeS1ldmVudC0yLjIvanF1ZXJ5LmV2ZW50LmRyYWcuanMiLCJzcmMvdmVuZG9yL2pxdWVyeS1ldmVudC0yLjIvanF1ZXJ5LmV2ZW50LmRyb3AuanMiLCJzcmMvdmVuZG9yL3NsaWNrLWdyaWQtMi4xLjAvcGx1Z2lucy9zbGljay5jaGVja2JveHNlbGVjdGNvbHVtbi5qcyIsInNyYy92ZW5kb3Ivc2xpY2stZ3JpZC0yLjEuMC9wbHVnaW5zL3NsaWNrLnJvd3NlbGVjdGlvbm1vZGVsLmpzIiwic3JjL3ZlbmRvci9zbGljay1ncmlkLTIuMS4wL3NsaWNrLmNvcmUuanMiLCJzcmMvdmVuZG9yL3NsaWNrLWdyaWQtMi4xLjAvc2xpY2suZ3JpZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6L0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzl3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gb3V0ZXIobW9kdWxlcywgY2FjaGUsIGVudHJ5KSB7XG4gIGlmIChCb2tlaCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBtb2R1bGVzKSB7XG4gICAgICBCb2tlaC5yZXF1aXJlLm1vZHVsZXNbbmFtZV0gPSBtb2R1bGVzW25hbWVdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwbHVnaW4gPSBCb2tlaC5yZXF1aXJlKGVudHJ5WzBdKTtcbiAgICAgIEJva2VoLk1vZGVscy5yZWdpc3Rlcl9tb2RlbHMocGx1Z2luLm1vZGVscyk7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSBcIm1vZGVsc1wiKSB7XG4gICAgICAgICAgQm9rZWhbbmFtZV0gPSBwbHVnaW5bbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgQm9rZWguIFlvdSBoYXZlIHRvIGxvYWQgaXQgcHJpb3IgdG8gbG9hZGluZyBwbHVnaW5zLlwiKTtcbiAgfVxufSlcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvcHJvcGVydGllc1wiKTtcbnZhciBidWlsZF92aWV3c18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvYnVpbGRfdmlld3NcIik7XG52YXIgd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi93aWRnZXRcIik7XG52YXIgYnV0dG9uX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi9idXR0b25fdGVtcGxhdGVcIik7XG5leHBvcnRzLkFic3RyYWN0QnV0dG9uVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBYnN0cmFjdEJ1dHRvblZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0QnV0dG9uVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0QnV0dG9uVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWJzdHJhY3RCdXR0b25WaWV3LnByb3RvdHlwZS5ldmVudHMgPSB7XG4gICAgICAgIFwiY2xpY2tcIjogXCJjaGFuZ2VfaW5wdXRcIlxuICAgIH07XG4gICAgQWJzdHJhY3RCdXR0b25WaWV3LnByb3RvdHlwZS50ZW1wbGF0ZSA9IGJ1dHRvbl90ZW1wbGF0ZV8xLmRlZmF1bHQ7XG4gICAgQWJzdHJhY3RCdXR0b25WaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgQWJzdHJhY3RCdXR0b25WaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaWNvbl92aWV3cyA9IHt9O1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnJlbmRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuICAgIH07XG4gICAgQWJzdHJhY3RCdXR0b25WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkYnV0dG9uLCBodG1sLCBpY29uLCBrZXksIHJlZiwgdmFsO1xuICAgICAgICBBYnN0cmFjdEJ1dHRvblZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICBpY29uID0gdGhpcy5tb2RlbC5pY29uO1xuICAgICAgICBpZiAoaWNvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBidWlsZF92aWV3c18xLmJ1aWxkX3ZpZXdzKHRoaXMuaWNvbl92aWV3cywgW2ljb25dKTtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuaWNvbl92aWV3cztcbiAgICAgICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFsID0gcmVmW2tleV07XG4gICAgICAgICAgICAgICAgdmFsLiRlbC5kZXRhY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgICAgICBodG1sID0gdGhpcy50ZW1wbGF0ZSh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoaHRtbCk7XG4gICAgICAgICRidXR0b24gPSB0aGlzLiRlbC5maW5kKCdidXR0b24nKTtcbiAgICAgICAgaWYgKGljb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgJGJ1dHRvbi5wcmVwZW5kKFwiJm5ic3A7XCIpO1xuICAgICAgICAgICAgJGJ1dHRvbi5wcmVwZW5kKHRoaXMuaWNvbl92aWV3c1tpY29uLmlkXS4kZWwpO1xuICAgICAgICB9XG4gICAgICAgICRidXR0b24ucHJvcChcImRpc2FibGVkXCIsIHRoaXMubW9kZWwuZGlzYWJsZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFic3RyYWN0QnV0dG9uVmlldy5wcm90b3R5cGUuY2hhbmdlX2lucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4gKHJlZiA9IHRoaXMubW9kZWwuY2FsbGJhY2spICE9IG51bGwgPyByZWYuZXhlY3V0ZSh0aGlzLm1vZGVsKSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdEJ1dHRvblZpZXc7XG59KSh3aWRnZXRfMS5XaWRnZXRWaWV3KTtcbmV4cG9ydHMuQWJzdHJhY3RCdXR0b24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQWJzdHJhY3RCdXR0b24sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0QnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RCdXR0b24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFic3RyYWN0QnV0dG9uLnByb3RvdHlwZS50eXBlID0gXCJBYnN0cmFjdEJ1dHRvblwiO1xuICAgIEFic3RyYWN0QnV0dG9uLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkFic3RyYWN0QnV0dG9uVmlldztcbiAgICBBYnN0cmFjdEJ1dHRvbi5kZWZpbmUoe1xuICAgICAgICBjYWxsYmFjazogW3AuSW5zdGFuY2VdLFxuICAgICAgICBsYWJlbDogW3AuU3RyaW5nLCBcIkJ1dHRvblwiXSxcbiAgICAgICAgaWNvbjogW3AuSW5zdGFuY2VdLFxuICAgICAgICBidXR0b25fdHlwZTogW3AuU3RyaW5nLCBcImRlZmF1bHRcIl1cbiAgICB9KTtcbiAgICByZXR1cm4gQWJzdHJhY3RCdXR0b247XG59KSh3aWRnZXRfMS5XaWRnZXQpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHdpZGdldF8xID0gcmVxdWlyZShcIi4vd2lkZ2V0XCIpO1xuZXhwb3J0cy5BYnN0cmFjdEljb24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQWJzdHJhY3RJY29uLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdEljb24oKSB7XG4gICAgICAgIHJldHVybiBBYnN0cmFjdEljb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFic3RyYWN0SWNvbi5wcm90b3R5cGUudHlwZSA9IFwiQWJzdHJhY3RJY29uXCI7XG4gICAgcmV0dXJuIEFic3RyYWN0SWNvbjtcbn0pKHdpZGdldF8xLldpZGdldCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5yZXF1aXJlKFwianF1ZXJ5LXVpL2F1dG9jb21wbGV0ZVwiKTtcbnZhciB0ZXh0X2lucHV0XzEgPSByZXF1aXJlKFwiLi90ZXh0X2lucHV0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5BdXRvY29tcGxldGVJbnB1dFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQXV0b2NvbXBsZXRlSW5wdXRWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBdXRvY29tcGxldGVJbnB1dFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBBdXRvY29tcGxldGVJbnB1dFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEF1dG9jb21wbGV0ZUlucHV0Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGlucHV0O1xuICAgICAgICBBdXRvY29tcGxldGVJbnB1dFZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICAkaW5wdXQgPSB0aGlzLiRlbC5maW5kKFwiaW5wdXRcIik7XG4gICAgICAgICRpbnB1dC5hdXRvY29tcGxldGUoe1xuICAgICAgICAgICAgc291cmNlOiB0aGlzLm1vZGVsLmNvbXBsZXRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICAkaW5wdXQuYXV0b2NvbXBsZXRlKFwid2lkZ2V0XCIpLmFkZENsYXNzKFwiYmstYXV0b2NvbXBsZXRlLWlucHV0XCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBBdXRvY29tcGxldGVJbnB1dFZpZXc7XG59KSh0ZXh0X2lucHV0XzEuVGV4dElucHV0Vmlldyk7XG5leHBvcnRzLkF1dG9jb21wbGV0ZUlucHV0ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEF1dG9jb21wbGV0ZUlucHV0LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBdXRvY29tcGxldGVJbnB1dCgpIHtcbiAgICAgICAgcmV0dXJuIEF1dG9jb21wbGV0ZUlucHV0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBdXRvY29tcGxldGVJbnB1dC5wcm90b3R5cGUudHlwZSA9IFwiQXV0b2NvbXBsZXRlSW5wdXRcIjtcbiAgICBBdXRvY29tcGxldGVJbnB1dC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5BdXRvY29tcGxldGVJbnB1dFZpZXc7XG4gICAgQXV0b2NvbXBsZXRlSW5wdXQuZGVmaW5lKHtcbiAgICAgICAgY29tcGxldGlvbnM6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICByZXR1cm4gQXV0b2NvbXBsZXRlSW5wdXQ7XG59KSh0ZXh0X2lucHV0XzEuVGV4dElucHV0KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhYnN0cmFjdF9idXR0b25fMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0X2J1dHRvblwiKTtcbmV4cG9ydHMuQnV0dG9uVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCdXR0b25WaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCdXR0b25WaWV3KCkge1xuICAgICAgICByZXR1cm4gQnV0dG9uVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQnV0dG9uVmlldy5wcm90b3R5cGUuY2hhbmdlX2lucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vZGVsLmNsaWNrcyA9IHRoaXMubW9kZWwuY2xpY2tzICsgMTtcbiAgICAgICAgcmV0dXJuIEJ1dHRvblZpZXcuX19zdXBlcl9fLmNoYW5nZV9pbnB1dC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1dHRvblZpZXc7XG59KShhYnN0cmFjdF9idXR0b25fMS5BYnN0cmFjdEJ1dHRvblZpZXcpO1xuZXhwb3J0cy5CdXR0b24gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQnV0dG9uLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCdXR0b24oKSB7XG4gICAgICAgIHJldHVybiBCdXR0b24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJ1dHRvbi5wcm90b3R5cGUudHlwZSA9IFwiQnV0dG9uXCI7XG4gICAgQnV0dG9uLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkJ1dHRvblZpZXc7XG4gICAgQnV0dG9uLmRlZmluZSh7XG4gICAgICAgIGNsaWNrczogW3AuTnVtYmVyLCAwXVxuICAgIH0pO1xuICAgIHJldHVybiBCdXR0b247XG59KShhYnN0cmFjdF9idXR0b25fMS5BYnN0cmFjdEJ1dHRvbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBET00gPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsL2RvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogXCJiay1icy1idG4tZ3JvdXBcIiwgXCJkYXRhLWJrLWJzLXRvZ2dsZVwiOiBcImJ1dHRvbnNcIiB9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBET00gPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsL2RvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHJldHVybiAoRE9NLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzczogXCJiay1icy1idG4gYmstYnMtYnRuLVwiICsgcHJvcHMuYnV0dG9uX3R5cGUgfSwgcHJvcHMubGFiZWwpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xudmFyICQgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xucmVxdWlyZShcImpxdWVyeS11aS9hdXRvY29tcGxldGVcIik7XG5yZXF1aXJlKFwianF1ZXJ5LXVpL3NwaW5uZXJcIik7XG52YXIgcCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgYm9rZWhfdmlld18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvYm9rZWhfdmlld1wiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xuZXhwb3J0cy5DZWxsRWRpdG9yVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDZWxsRWRpdG9yVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2VsbEVkaXRvclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBDZWxsRWRpdG9yVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLnRhZ05hbWUgPSBcImRpdlwiO1xuICAgIENlbGxFZGl0b3JWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgPSBcImJrLWNlbGwtZWRpdG9yXCI7XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLmlucHV0ID0gbnVsbDtcbiAgICBDZWxsRWRpdG9yVmlldy5wcm90b3R5cGUuZW1wdHlWYWx1ZSA9IG51bGw7XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5hcmdzLmNvbHVtbi5lZGl0b3I7XG4gICAgICAgIENlbGxFZGl0b3JWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuICAgIH07XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQ2VsbEVkaXRvclZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmRUbyh0aGlzLmFyZ3MuY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy4kaW5wdXQgPSAkKHRoaXMuaW5wdXQpO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy4kaW5wdXQpO1xuICAgICAgICB0aGlzLnJlbmRlckVkaXRvcigpO1xuICAgICAgICB0aGlzLmRpc2FibGVOYXZpZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLnJlbmRlckVkaXRvciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBDZWxsRWRpdG9yVmlldy5wcm90b3R5cGUuZGlzYWJsZU5hdmlnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpbnB1dC5rZXlkb3duKChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcDtcbiAgICAgICAgICAgICAgICBzdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuVVA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfRE9XTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH07XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZSgpO1xuICAgIH07XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQuZm9jdXMoKTtcbiAgICB9O1xuICAgIENlbGxFZGl0b3JWaWV3LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENlbGxFZGl0b3JWaWV3LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENlbGxFZGl0b3JWaWV3LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBDZWxsRWRpdG9yVmlldy5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpbnB1dC52YWwoKTtcbiAgICB9O1xuICAgIENlbGxFZGl0b3JWaWV3LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LnZhbCh2YWwpO1xuICAgIH07XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLnNlcmlhbGl6ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIH07XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLmlzVmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLmdldFZhbHVlKCkgPT09IFwiXCIgJiYgKHRoaXMuZGVmYXVsdFZhbHVlID09IG51bGwpKSAmJiAodGhpcy5nZXRWYWx1ZSgpICE9PSB0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgfTtcbiAgICBDZWxsRWRpdG9yVmlldy5wcm90b3R5cGUuYXBwbHlWYWx1ZSA9IGZ1bmN0aW9uIChpdGVtLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzLmdyaWQuZ2V0RGF0YSgpLnNldEZpZWxkKGl0ZW0uaW5kZXgsIHRoaXMuYXJncy5jb2x1bW4uZmllbGQsIHN0YXRlKTtcbiAgICB9O1xuICAgIENlbGxFZGl0b3JWaWV3LnByb3RvdHlwZS5sb2FkVmFsdWUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHZhbHVlID0gaXRlbVt0aGlzLmFyZ3MuY29sdW1uLmZpZWxkXTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLmVtcHR5VmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFZhbHVlKHRoaXMuZGVmYXVsdFZhbHVlKTtcbiAgICB9O1xuICAgIENlbGxFZGl0b3JWaWV3LnByb3RvdHlwZS52YWxpZGF0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh0aGlzLmFyZ3MuY29sdW1uLnZhbGlkYXRvcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5hcmdzLmNvbHVtbi52YWxpZGF0b3IodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICAgIG1zZzogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ2VsbEVkaXRvclZpZXcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVZhbHVlKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2VsbEVkaXRvclZpZXc7XG59KShib2tlaF92aWV3XzEuQm9rZWhWaWV3KTtcbmV4cG9ydHMuQ2VsbEVkaXRvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDZWxsRWRpdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDZWxsRWRpdG9yKCkge1xuICAgICAgICByZXR1cm4gQ2VsbEVkaXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2VsbEVkaXRvci5wcm90b3R5cGUudHlwZSA9IFwiQ2VsbEVkaXRvclwiO1xuICAgIENlbGxFZGl0b3IucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQ2VsbEVkaXRvclZpZXc7XG4gICAgcmV0dXJuIENlbGxFZGl0b3I7XG59KShtb2RlbF8xLk1vZGVsKTtcbmV4cG9ydHMuU3RyaW5nRWRpdG9yVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTdHJpbmdFZGl0b3JWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTdHJpbmdFZGl0b3JWaWV3KCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nRWRpdG9yVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3RyaW5nRWRpdG9yVmlldy5wcm90b3R5cGUuZW1wdHlWYWx1ZSA9IFwiXCI7XG4gICAgU3RyaW5nRWRpdG9yVmlldy5wcm90b3R5cGUuaW5wdXQgPSAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgLz4nO1xuICAgIFN0cmluZ0VkaXRvclZpZXcucHJvdG90eXBlLnJlbmRlckVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsZXRpb25zO1xuICAgICAgICBjb21wbGV0aW9ucyA9IHRoaXMubW9kZWwuY29tcGxldGlvbnM7XG4gICAgICAgIGlmICghXy5pc0VtcHR5KGNvbXBsZXRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuYXV0b2NvbXBsZXRlKHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGNvbXBsZXRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmF1dG9jb21wbGV0ZShcIndpZGdldFwiKS5hZGRDbGFzcyhcImJrLWNlbGwtZWRpdG9yLWNvbXBsZXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmZvY3VzKCkuc2VsZWN0KCk7XG4gICAgfTtcbiAgICBTdHJpbmdFZGl0b3JWaWV3LnByb3RvdHlwZS5sb2FkVmFsdWUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBTdHJpbmdFZGl0b3JWaWV3Ll9fc3VwZXJfXy5sb2FkVmFsdWUuY2FsbCh0aGlzLCBpdGVtKTtcbiAgICAgICAgdGhpcy4kaW5wdXRbMF0uZGVmYXVsdFZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzLiRpbnB1dC5zZWxlY3QoKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdFZGl0b3JWaWV3O1xufSkoZXhwb3J0cy5DZWxsRWRpdG9yVmlldyk7XG5leHBvcnRzLlN0cmluZ0VkaXRvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTdHJpbmdFZGl0b3IsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFN0cmluZ0VkaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZ0VkaXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3RyaW5nRWRpdG9yLnByb3RvdHlwZS50eXBlID0gJ1N0cmluZ0VkaXRvcic7XG4gICAgU3RyaW5nRWRpdG9yLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlN0cmluZ0VkaXRvclZpZXc7XG4gICAgU3RyaW5nRWRpdG9yLmRlZmluZSh7XG4gICAgICAgIGNvbXBsZXRpb25zOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgcmV0dXJuIFN0cmluZ0VkaXRvcjtcbn0pKGV4cG9ydHMuQ2VsbEVkaXRvcik7XG5leHBvcnRzLlRleHRFZGl0b3JWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRleHRFZGl0b3JWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUZXh0RWRpdG9yVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFRleHRFZGl0b3JWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gVGV4dEVkaXRvclZpZXc7XG59KShleHBvcnRzLkNlbGxFZGl0b3JWaWV3KTtcbmV4cG9ydHMuVGV4dEVkaXRvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUZXh0RWRpdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUZXh0RWRpdG9yKCkge1xuICAgICAgICByZXR1cm4gVGV4dEVkaXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGV4dEVkaXRvci5wcm90b3R5cGUudHlwZSA9ICdUZXh0RWRpdG9yJztcbiAgICBUZXh0RWRpdG9yLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlRleHRFZGl0b3JWaWV3O1xuICAgIHJldHVybiBUZXh0RWRpdG9yO1xufSkoZXhwb3J0cy5DZWxsRWRpdG9yKTtcbmV4cG9ydHMuU2VsZWN0RWRpdG9yVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTZWxlY3RFZGl0b3JWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTZWxlY3RFZGl0b3JWaWV3KCkge1xuICAgICAgICByZXR1cm4gU2VsZWN0RWRpdG9yVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VsZWN0RWRpdG9yVmlldy5wcm90b3R5cGUuaW5wdXQgPSAnPHNlbGVjdCAvPic7XG4gICAgU2VsZWN0RWRpdG9yVmlldy5wcm90b3R5cGUucmVuZGVyRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgbGVuLCBvcHRpb24sIHJlZjtcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5vcHRpb25zO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG9wdGlvbiA9IHJlZltpXTtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmFwcGVuZCgkKCc8b3B0aW9uPicpLmF0dHIoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25cbiAgICAgICAgICAgIH0pLnRleHQob3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbiAgICB9O1xuICAgIFNlbGVjdEVkaXRvclZpZXcucHJvdG90eXBlLmxvYWRWYWx1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIFNlbGVjdEVkaXRvclZpZXcuX19zdXBlcl9fLmxvYWRWYWx1ZS5jYWxsKHRoaXMsIGl0ZW0pO1xuICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQuc2VsZWN0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0RWRpdG9yVmlldztcbn0pKGV4cG9ydHMuQ2VsbEVkaXRvclZpZXcpO1xuZXhwb3J0cy5TZWxlY3RFZGl0b3IgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2VsZWN0RWRpdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTZWxlY3RFZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3RFZGl0b3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlbGVjdEVkaXRvci5wcm90b3R5cGUudHlwZSA9ICdTZWxlY3RFZGl0b3InO1xuICAgIFNlbGVjdEVkaXRvci5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5TZWxlY3RFZGl0b3JWaWV3O1xuICAgIFNlbGVjdEVkaXRvci5kZWZpbmUoe1xuICAgICAgICBvcHRpb25zOiBbcC5BcnJheSwgW11dXG4gICAgfSk7XG4gICAgcmV0dXJuIFNlbGVjdEVkaXRvcjtcbn0pKGV4cG9ydHMuQ2VsbEVkaXRvcik7XG5leHBvcnRzLlBlcmNlbnRFZGl0b3JWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBlcmNlbnRFZGl0b3JWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQZXJjZW50RWRpdG9yVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFBlcmNlbnRFZGl0b3JWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gUGVyY2VudEVkaXRvclZpZXc7XG59KShleHBvcnRzLkNlbGxFZGl0b3JWaWV3KTtcbmV4cG9ydHMuUGVyY2VudEVkaXRvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQZXJjZW50RWRpdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQZXJjZW50RWRpdG9yKCkge1xuICAgICAgICByZXR1cm4gUGVyY2VudEVkaXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGVyY2VudEVkaXRvci5wcm90b3R5cGUudHlwZSA9ICdQZXJjZW50RWRpdG9yJztcbiAgICBQZXJjZW50RWRpdG9yLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlBlcmNlbnRFZGl0b3JWaWV3O1xuICAgIHJldHVybiBQZXJjZW50RWRpdG9yO1xufSkoZXhwb3J0cy5DZWxsRWRpdG9yKTtcbmV4cG9ydHMuQ2hlY2tib3hFZGl0b3JWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENoZWNrYm94RWRpdG9yVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2hlY2tib3hFZGl0b3JWaWV3KCkge1xuICAgICAgICByZXR1cm4gQ2hlY2tib3hFZGl0b3JWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDaGVja2JveEVkaXRvclZpZXcucHJvdG90eXBlLmlucHV0ID0gJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cInRydWVcIiAvPic7XG4gICAgQ2hlY2tib3hFZGl0b3JWaWV3LnByb3RvdHlwZS5yZW5kZXJFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzKCk7XG4gICAgfTtcbiAgICBDaGVja2JveEVkaXRvclZpZXcucHJvdG90eXBlLmxvYWRWYWx1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gISFpdGVtW3RoaXMuYXJncy5jb2x1bW4uZmllbGRdO1xuICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQucHJvcCgnY2hlY2tlZCcsIHRoaXMuZGVmYXVsdFZhbHVlKTtcbiAgICB9O1xuICAgIENoZWNrYm94RWRpdG9yVmlldy5wcm90b3R5cGUuc2VyaWFsaXplVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpbnB1dC5wcm9wKCdjaGVja2VkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hlY2tib3hFZGl0b3JWaWV3O1xufSkoZXhwb3J0cy5DZWxsRWRpdG9yVmlldyk7XG5leHBvcnRzLkNoZWNrYm94RWRpdG9yID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENoZWNrYm94RWRpdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDaGVja2JveEVkaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIENoZWNrYm94RWRpdG9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDaGVja2JveEVkaXRvci5wcm90b3R5cGUudHlwZSA9ICdDaGVja2JveEVkaXRvcic7XG4gICAgQ2hlY2tib3hFZGl0b3IucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQ2hlY2tib3hFZGl0b3JWaWV3O1xuICAgIHJldHVybiBDaGVja2JveEVkaXRvcjtcbn0pKGV4cG9ydHMuQ2VsbEVkaXRvcik7XG5leHBvcnRzLkludEVkaXRvclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW50RWRpdG9yVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW50RWRpdG9yVmlldygpIHtcbiAgICAgICAgcmV0dXJuIEludEVkaXRvclZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEludEVkaXRvclZpZXcucHJvdG90eXBlLmlucHV0ID0gJzxpbnB1dCB0eXBlPVwidGV4dFwiIC8+JztcbiAgICBJbnRFZGl0b3JWaWV3LnByb3RvdHlwZS5yZW5kZXJFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJGlucHV0LnNwaW5uZXIoe1xuICAgICAgICAgICAgc3RlcDogdGhpcy5tb2RlbC5zdGVwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQuZm9jdXMoKS5zZWxlY3QoKTtcbiAgICB9O1xuICAgIEludEVkaXRvclZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kaW5wdXQuc3Bpbm5lcihcImRlc3Ryb3lcIik7XG4gICAgICAgIHJldHVybiBJbnRFZGl0b3JWaWV3Ll9fc3VwZXJfXy5yZW1vdmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEludEVkaXRvclZpZXcucHJvdG90eXBlLnNlcmlhbGl6ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRWYWx1ZSgpLCAxMCkgfHwgMDtcbiAgICB9O1xuICAgIEludEVkaXRvclZpZXcucHJvdG90eXBlLmxvYWRWYWx1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIEludEVkaXRvclZpZXcuX19zdXBlcl9fLmxvYWRWYWx1ZS5jYWxsKHRoaXMsIGl0ZW0pO1xuICAgICAgICB0aGlzLiRpbnB1dFswXS5kZWZhdWx0VmFsdWUgPSB0aGlzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LnNlbGVjdCgpO1xuICAgIH07XG4gICAgSW50RWRpdG9yVmlldy5wcm90b3R5cGUudmFsaWRhdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtc2c6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgaW50ZWdlclwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEludEVkaXRvclZpZXcuX19zdXBlcl9fLnZhbGlkYXRlVmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbnRFZGl0b3JWaWV3O1xufSkoZXhwb3J0cy5DZWxsRWRpdG9yVmlldyk7XG5leHBvcnRzLkludEVkaXRvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChJbnRFZGl0b3IsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEludEVkaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIEludEVkaXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSW50RWRpdG9yLnByb3RvdHlwZS50eXBlID0gJ0ludEVkaXRvcic7XG4gICAgSW50RWRpdG9yLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkludEVkaXRvclZpZXc7XG4gICAgSW50RWRpdG9yLmRlZmluZSh7XG4gICAgICAgIHN0ZXA6IFtwLk51bWJlciwgMV1cbiAgICB9KTtcbiAgICByZXR1cm4gSW50RWRpdG9yO1xufSkoZXhwb3J0cy5DZWxsRWRpdG9yKTtcbmV4cG9ydHMuTnVtYmVyRWRpdG9yVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChOdW1iZXJFZGl0b3JWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBOdW1iZXJFZGl0b3JWaWV3KCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyRWRpdG9yVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTnVtYmVyRWRpdG9yVmlldy5wcm90b3R5cGUuaW5wdXQgPSAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgLz4nO1xuICAgIE51bWJlckVkaXRvclZpZXcucHJvdG90eXBlLnJlbmRlckVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy4kaW5wdXQuc3Bpbm5lcih7XG4gICAgICAgICAgICBzdGVwOiB0aGlzLm1vZGVsLnN0ZXBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiRpbnB1dC5mb2N1cygpLnNlbGVjdCgpO1xuICAgIH07XG4gICAgTnVtYmVyRWRpdG9yVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRpbnB1dC5zcGlubmVyKFwiZGVzdHJveVwiKTtcbiAgICAgICAgcmV0dXJuIE51bWJlckVkaXRvclZpZXcuX19zdXBlcl9fLnJlbW92ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTnVtYmVyRWRpdG9yVmlldy5wcm90b3R5cGUuc2VyaWFsaXplVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuZ2V0VmFsdWUoKSkgfHwgMC4wO1xuICAgIH07XG4gICAgTnVtYmVyRWRpdG9yVmlldy5wcm90b3R5cGUubG9hZFZhbHVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgTnVtYmVyRWRpdG9yVmlldy5fX3N1cGVyX18ubG9hZFZhbHVlLmNhbGwodGhpcywgaXRlbSk7XG4gICAgICAgIHRoaXMuJGlucHV0WzBdLmRlZmF1bHRWYWx1ZSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQuc2VsZWN0KCk7XG4gICAgfTtcbiAgICBOdW1iZXJFZGl0b3JWaWV3LnByb3RvdHlwZS52YWxpZGF0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1zZzogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBudW1iZXJcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXJFZGl0b3JWaWV3Ll9fc3VwZXJfXy52YWxpZGF0ZVZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTnVtYmVyRWRpdG9yVmlldztcbn0pKGV4cG9ydHMuQ2VsbEVkaXRvclZpZXcpO1xuZXhwb3J0cy5OdW1iZXJFZGl0b3IgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTnVtYmVyRWRpdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBOdW1iZXJFZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXJFZGl0b3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE51bWJlckVkaXRvci5wcm90b3R5cGUudHlwZSA9ICdOdW1iZXJFZGl0b3InO1xuICAgIE51bWJlckVkaXRvci5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5OdW1iZXJFZGl0b3JWaWV3O1xuICAgIE51bWJlckVkaXRvci5kZWZpbmUoe1xuICAgICAgICBzdGVwOiBbcC5OdW1iZXIsIDAuMDFdXG4gICAgfSk7XG4gICAgcmV0dXJuIE51bWJlckVkaXRvcjtcbn0pKGV4cG9ydHMuQ2VsbEVkaXRvcik7XG5leHBvcnRzLlRpbWVFZGl0b3JWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRpbWVFZGl0b3JWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUaW1lRWRpdG9yVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFRpbWVFZGl0b3JWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gVGltZUVkaXRvclZpZXc7XG59KShleHBvcnRzLkNlbGxFZGl0b3JWaWV3KTtcbmV4cG9ydHMuVGltZUVkaXRvciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUaW1lRWRpdG9yLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUaW1lRWRpdG9yKCkge1xuICAgICAgICByZXR1cm4gVGltZUVkaXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGltZUVkaXRvci5wcm90b3R5cGUudHlwZSA9ICdUaW1lRWRpdG9yJztcbiAgICBUaW1lRWRpdG9yLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlRpbWVFZGl0b3JWaWV3O1xuICAgIHJldHVybiBUaW1lRWRpdG9yO1xufSkoZXhwb3J0cy5DZWxsRWRpdG9yKTtcbmV4cG9ydHMuRGF0ZUVkaXRvclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGF0ZUVkaXRvclZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGVFZGl0b3JWaWV3KCkge1xuICAgICAgICByZXR1cm4gRGF0ZUVkaXRvclZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERhdGVFZGl0b3JWaWV3LnByb3RvdHlwZS5lbXB0eVZhbHVlID0gbmV3IHdpbmRvdy5EYXRlKCk7XG4gICAgRGF0ZUVkaXRvclZpZXcucHJvdG90eXBlLmlucHV0ID0gJzxpbnB1dCB0eXBlPVwidGV4dFwiIC8+JztcbiAgICBEYXRlRWRpdG9yVmlldy5wcm90b3R5cGUucmVuZGVyRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRpbnB1dC5kYXRlcGlja2VyKHtcbiAgICAgICAgICAgIHNob3dPbjogXCJidXR0b25cIixcbiAgICAgICAgICAgIGJ1dHRvbkltYWdlT25seTogdHJ1ZSxcbiAgICAgICAgICAgIGJlZm9yZVNob3c6IChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2FsZW5kYXJPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcyksXG4gICAgICAgICAgICBvbkNsb3NlOiAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNhbGVuZGFyT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kaW5wdXQuc2libGluZ3MoXCIuYmstdWktZGF0ZXBpY2tlci10cmlnZ2VyXCIpLmNzcyh7XG4gICAgICAgICAgICBcInZlcnRpY2FsLWFsaWduXCI6IFwibWlkZGxlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGlucHV0LndpZHRoKHRoaXMuJGlucHV0LndpZHRoKCkgLSAoMTQgKyAyICogNCArIDQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmZvY3VzKCkuc2VsZWN0KCk7XG4gICAgfTtcbiAgICBEYXRlRWRpdG9yVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJC5kYXRlcGlja2VyLmRwRGl2LnN0b3AodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuJGlucHV0LmRhdGVwaWNrZXIoXCJoaWRlXCIpO1xuICAgICAgICB0aGlzLiRpbnB1dC5kYXRlcGlja2VyKFwiZGVzdHJveVwiKTtcbiAgICAgICAgcmV0dXJuIERhdGVFZGl0b3JWaWV3Ll9fc3VwZXJfXy5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBEYXRlRWRpdG9yVmlldy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXJPcGVuKSB7XG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuZHBEaXYuc3RvcCh0cnVlLCB0cnVlKS5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGVFZGl0b3JWaWV3Ll9fc3VwZXJfXy5zaG93LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBEYXRlRWRpdG9yVmlldy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXJPcGVuKSB7XG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuZHBEaXYuc3RvcCh0cnVlLCB0cnVlKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGVFZGl0b3JWaWV3Ll9fc3VwZXJfXy5oaWRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBEYXRlRWRpdG9yVmlldy5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXJPcGVuKSB7XG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuZHBEaXYuY3NzKHtcbiAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCArIDMwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlRWRpdG9yVmlldy5fX3N1cGVyX18ucG9zaXRpb24uY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIERhdGVFZGl0b3JWaWV3LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmRhdGVwaWNrZXIoXCJnZXREYXRlXCIpLmdldFRpbWUoKTtcbiAgICB9O1xuICAgIERhdGVFZGl0b3JWaWV3LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmRhdGVwaWNrZXIoXCJzZXREYXRlXCIsIG5ldyB3aW5kb3cuRGF0ZSh2YWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlRWRpdG9yVmlldztcbn0pKGV4cG9ydHMuQ2VsbEVkaXRvclZpZXcpO1xuZXhwb3J0cy5EYXRlRWRpdG9yID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERhdGVFZGl0b3IsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGVFZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiBEYXRlRWRpdG9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEYXRlRWRpdG9yLnByb3RvdHlwZS50eXBlID0gJ0RhdGVFZGl0b3InO1xuICAgIERhdGVFZGl0b3IucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuRGF0ZUVkaXRvclZpZXc7XG4gICAgcmV0dXJuIERhdGVFZGl0b3I7XG59KShleHBvcnRzLkNlbGxFZGl0b3IpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbnZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbnZhciBOdW1icm8gPSByZXF1aXJlKFwibnVtYnJvXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG5leHBvcnRzLkNlbGxGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2VsbEZvcm1hdHRlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2VsbEZvcm1hdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIENlbGxGb3JtYXR0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENlbGxGb3JtYXR0ZXIucHJvdG90eXBlLmRvRm9ybWF0ID0gZnVuY3Rpb24gKHJvdywgY2VsbCwgdmFsdWUsIGNvbHVtbkRlZiwgZGF0YUNvbnRleHQpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgKyBcIlwiKS5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDZWxsRm9ybWF0dGVyO1xufSkobW9kZWxfMS5Nb2RlbCk7XG5leHBvcnRzLlN0cmluZ0Zvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTdHJpbmdGb3JtYXR0ZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFN0cmluZ0Zvcm1hdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZ0Zvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3RyaW5nRm9ybWF0dGVyLnByb3RvdHlwZS50eXBlID0gJ1N0cmluZ0Zvcm1hdHRlcic7XG4gICAgU3RyaW5nRm9ybWF0dGVyLmRlZmluZSh7XG4gICAgICAgIGZvbnRfc3R5bGU6IFtwLkZvbnRTdHlsZSwgXCJub3JtYWxcIl0sXG4gICAgICAgIHRleHRfYWxpZ246IFtwLlRleHRBbGlnbiwgXCJsZWZ0XCJdLFxuICAgICAgICB0ZXh0X2NvbG9yOiBbcC5Db2xvcl1cbiAgICB9KTtcbiAgICBTdHJpbmdGb3JtYXR0ZXIucHJvdG90eXBlLmRvRm9ybWF0ID0gZnVuY3Rpb24gKHJvdywgY2VsbCwgdmFsdWUsIGNvbHVtbkRlZiwgZGF0YUNvbnRleHQpIHtcbiAgICAgICAgdmFyIGZvbnRfc3R5bGUsIHRleHQsIHRleHRfYWxpZ24sIHRleHRfY29sb3I7XG4gICAgICAgIHRleHQgPSBTdHJpbmdGb3JtYXR0ZXIuX19zdXBlcl9fLmRvRm9ybWF0LmNhbGwodGhpcywgcm93LCBjZWxsLCB2YWx1ZSwgY29sdW1uRGVmLCBkYXRhQ29udGV4dCk7XG4gICAgICAgIGZvbnRfc3R5bGUgPSB0aGlzLmZvbnRfc3R5bGU7XG4gICAgICAgIHRleHRfYWxpZ24gPSB0aGlzLnRleHRfYWxpZ247XG4gICAgICAgIHRleHRfY29sb3IgPSB0aGlzLnRleHRfY29sb3I7XG4gICAgICAgIGlmICgoZm9udF9zdHlsZSAhPSBudWxsKSB8fCAodGV4dF9hbGlnbiAhPSBudWxsKSB8fCAodGV4dF9jb2xvciAhPSBudWxsKSkge1xuICAgICAgICAgICAgdGV4dCA9ICQoXCI8c3Bhbj5cIiArIHRleHQgKyBcIjwvc3Bhbj5cIik7XG4gICAgICAgICAgICBzd2l0Y2ggKGZvbnRfc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9sZFwiOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5jc3MoXCJmb250LXdlaWdodFwiLCBcImJvbGRcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpdGFsaWNcIjpcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuY3NzKFwiZm9udC1zdHlsZVwiLCBcIml0YWxpY1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0X2FsaWduICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5jc3MoXCJ0ZXh0LWFsaWduXCIsIHRleHRfYWxpZ24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHRfY29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LmNzcyhcImNvbG9yXCIsIHRleHRfY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCA9IHRleHQucHJvcCgnb3V0ZXJIVE1MJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gU3RyaW5nRm9ybWF0dGVyO1xufSkoZXhwb3J0cy5DZWxsRm9ybWF0dGVyKTtcbmV4cG9ydHMuTnVtYmVyRm9ybWF0dGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE51bWJlckZvcm1hdHRlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gTnVtYmVyRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyRm9ybWF0dGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSAnTnVtYmVyRm9ybWF0dGVyJztcbiAgICBOdW1iZXJGb3JtYXR0ZXIuZGVmaW5lKHtcbiAgICAgICAgZm9ybWF0OiBbcC5TdHJpbmcsICcwLDAnXSxcbiAgICAgICAgbGFuZ3VhZ2U6IFtwLlN0cmluZywgJ2VuJ10sXG4gICAgICAgIHJvdW5kaW5nOiBbcC5TdHJpbmcsICdyb3VuZCddXG4gICAgfSk7XG4gICAgTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS5kb0Zvcm1hdCA9IGZ1bmN0aW9uIChyb3csIGNlbGwsIHZhbHVlLCBjb2x1bW5EZWYsIGRhdGFDb250ZXh0KSB7XG4gICAgICAgIHZhciBmb3JtYXQsIGxhbmd1YWdlLCByb3VuZGluZztcbiAgICAgICAgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgICAgIGxhbmd1YWdlID0gdGhpcy5sYW5ndWFnZTtcbiAgICAgICAgcm91bmRpbmcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnJvdW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJvdW5kXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5lYXJlc3RcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQ7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZsb29yXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJvdW5kZG93blwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2VpbFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyb3VuZHVwXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgIHZhbHVlID0gTnVtYnJvLmZvcm1hdCh2YWx1ZSwgZm9ybWF0LCBsYW5ndWFnZSwgcm91bmRpbmcpO1xuICAgICAgICByZXR1cm4gTnVtYmVyRm9ybWF0dGVyLl9fc3VwZXJfXy5kb0Zvcm1hdC5jYWxsKHRoaXMsIHJvdywgY2VsbCwgdmFsdWUsIGNvbHVtbkRlZiwgZGF0YUNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE51bWJlckZvcm1hdHRlcjtcbn0pKGV4cG9ydHMuU3RyaW5nRm9ybWF0dGVyKTtcbmV4cG9ydHMuQm9vbGVhbkZvcm1hdHRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChCb29sZWFuRm9ybWF0dGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBCb29sZWFuRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbkZvcm1hdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQm9vbGVhbkZvcm1hdHRlci5wcm90b3R5cGUudHlwZSA9ICdCb29sZWFuRm9ybWF0dGVyJztcbiAgICBCb29sZWFuRm9ybWF0dGVyLmRlZmluZSh7XG4gICAgICAgIGljb246IFtwLlN0cmluZywgJ2NoZWNrJ11cbiAgICB9KTtcbiAgICBCb29sZWFuRm9ybWF0dGVyLnByb3RvdHlwZS5kb0Zvcm1hdCA9IGZ1bmN0aW9uIChyb3csIGNlbGwsIHZhbHVlLCBjb2x1bW5EZWYsIGRhdGFDb250ZXh0KSB7XG4gICAgICAgIGlmICghIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJCgnPGk+JykuYWRkQ2xhc3ModGhpcy5pY29uKS5odG1sKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJvb2xlYW5Gb3JtYXR0ZXI7XG59KShleHBvcnRzLkNlbGxGb3JtYXR0ZXIpO1xuZXhwb3J0cy5EYXRlRm9ybWF0dGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERhdGVGb3JtYXR0ZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGVGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBEYXRlRm9ybWF0dGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZS50eXBlID0gJ0RhdGVGb3JtYXR0ZXInO1xuICAgIERhdGVGb3JtYXR0ZXIuZGVmaW5lKHtcbiAgICAgICAgZm9ybWF0OiBbcC5TdHJpbmcsICd5eSBNIGQnXVxuICAgIH0pO1xuICAgIERhdGVGb3JtYXR0ZXIucHJvdG90eXBlLmdldEZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZvcm1hdCwgbmFtZTtcbiAgICAgICAgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgICAgIG5hbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiQVRPTVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJXM0NcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiUkZDLTMzMzlcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiSVNPLTg2MDFcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSVNPLTg2MDFcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiQ09PS0lFXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkNPT0tJRVwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJSRkMtODUwXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlJGQy04NTBcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiUkZDLTEwMzZcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUkZDLTEwMzZcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiUkZDLTExMjNcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUkZDLTExMjNcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiUkZDLTI4MjJcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUkZDLTI4MjJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiUlNTXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlJGQy04MjJcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUkZDLTgyMlwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJUSUNLU1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJUSUNLU1wiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJUSU1FU1RBTVBcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVElNRVNUQU1QXCI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAkLmRhdGVwaWNrZXJbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZS5kb0Zvcm1hdCA9IGZ1bmN0aW9uIChyb3csIGNlbGwsIHZhbHVlLCBjb2x1bW5EZWYsIGRhdGFDb250ZXh0KSB7XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICB2YWx1ZSA9IF8uaXNTdHJpbmcodmFsdWUpID8gcGFyc2VJbnQodmFsdWUsIDEwKSA6IHZhbHVlO1xuICAgICAgICBkYXRlID0gJC5kYXRlcGlja2VyLmZvcm1hdERhdGUodGhpcy5nZXRGb3JtYXQoKSwgbmV3IERhdGUodmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIERhdGVGb3JtYXR0ZXIuX19zdXBlcl9fLmRvRm9ybWF0LmNhbGwodGhpcywgcm93LCBjZWxsLCBkYXRlLCBjb2x1bW5EZWYsIGRhdGFDb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlRm9ybWF0dGVyO1xufSkoZXhwb3J0cy5DZWxsRm9ybWF0dGVyKTtcbmV4cG9ydHMuSFRNTFRlbXBsYXRlRm9ybWF0dGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEhUTUxUZW1wbGF0ZUZvcm1hdHRlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSFRNTFRlbXBsYXRlRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gSFRNTFRlbXBsYXRlRm9ybWF0dGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBIVE1MVGVtcGxhdGVGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSAnSFRNTFRlbXBsYXRlRm9ybWF0dGVyJztcbiAgICBIVE1MVGVtcGxhdGVGb3JtYXR0ZXIuZGVmaW5lKHtcbiAgICAgICAgdGVtcGxhdGU6IFtwLlN0cmluZywgJzwlPSB2YWx1ZSAlPiddXG4gICAgfSk7XG4gICAgSFRNTFRlbXBsYXRlRm9ybWF0dGVyLnByb3RvdHlwZS5kb0Zvcm1hdCA9IGZ1bmN0aW9uIChyb3csIGNlbGwsIHZhbHVlLCBjb2x1bW5EZWYsIGRhdGFDb250ZXh0KSB7XG4gICAgICAgIHZhciBjb21waWxlZF90ZW1wbGF0ZSwgdGVtcGxhdGU7XG4gICAgICAgIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFDb250ZXh0ID0gXy5leHRlbmQoe30sIGRhdGFDb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbXBpbGVkX3RlbXBsYXRlID0gXy50ZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZWRfdGVtcGxhdGUoZGF0YUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSFRNTFRlbXBsYXRlRm9ybWF0dGVyO1xufSkoZXhwb3J0cy5DZWxsRm9ybWF0dGVyKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSlcbiAgICAgICAgcmV0dXJuIGk7XG59IHJldHVybiAtMTsgfTtcbnZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbnJlcXVpcmUoXCJib290c3RyYXAvYnV0dG9uXCIpO1xudmFyIHdpZGdldF8xID0gcmVxdWlyZShcIi4vd2lkZ2V0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGJ1dHRvbl9ncm91cF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4vYnV0dG9uX2dyb3VwX3RlbXBsYXRlXCIpO1xuZXhwb3J0cy5DaGVja2JveEJ1dHRvbkdyb3VwVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDaGVja2JveEJ1dHRvbkdyb3VwVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2hlY2tib3hCdXR0b25Hcm91cFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBDaGVja2JveEJ1dHRvbkdyb3VwVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2hlY2tib3hCdXR0b25Hcm91cFZpZXcucHJvdG90eXBlLmV2ZW50cyA9IHtcbiAgICAgICAgXCJjaGFuZ2UgaW5wdXRcIjogXCJjaGFuZ2VfaW5wdXRcIlxuICAgIH07XG4gICAgQ2hlY2tib3hCdXR0b25Hcm91cFZpZXcucHJvdG90eXBlLnRlbXBsYXRlID0gYnV0dG9uX2dyb3VwX3RlbXBsYXRlXzEuZGVmYXVsdDtcbiAgICBDaGVja2JveEJ1dHRvbkdyb3VwVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIENoZWNrYm94QnV0dG9uR3JvdXBWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnJlbmRlcik7XG4gICAgfTtcbiAgICBDaGVja2JveEJ1dHRvbkdyb3VwVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGlucHV0LCAkbGFiZWwsIGFjdGl2ZSwgaHRtbCwgaSwgaiwgbGFiZWwsIGxlbiwgcmVmO1xuICAgICAgICBDaGVja2JveEJ1dHRvbkdyb3VwVmlldy5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIGh0bWwgPSB0aGlzLnRlbXBsYXRlKCk7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChodG1sKTtcbiAgICAgICAgYWN0aXZlID0gdGhpcy5tb2RlbC5hY3RpdmU7XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwubGFiZWxzO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgICAgICAgICAgbGFiZWwgPSByZWZbaV07XG4gICAgICAgICAgICAkaW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+JykuYXR0cih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIgKyBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbmRleE9mLmNhbGwoYWN0aXZlLCBpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgJGlucHV0LnByb3AoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJGxhYmVsID0gJCgnPGxhYmVsIGNsYXNzPVwiYmstYnMtYnRuXCI+PC9sYWJlbD4nKTtcbiAgICAgICAgICAgICRsYWJlbC50ZXh0KGxhYmVsKS5wcmVwZW5kKCRpbnB1dCk7XG4gICAgICAgICAgICAkbGFiZWwuYWRkQ2xhc3MoXCJiay1icy1idG4tXCIgKyB0aGlzLm1vZGVsLmJ1dHRvbl90eXBlKTtcbiAgICAgICAgICAgIGlmIChpbmRleE9mLmNhbGwoYWN0aXZlLCBpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgJGxhYmVsLmFkZENsYXNzKFwiYmstYnMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kZWwuZmluZCgnLmJrLWJzLWJ0bi1ncm91cCcpLmFwcGVuZCgkbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ2hlY2tib3hCdXR0b25Hcm91cFZpZXcucHJvdG90eXBlLmNoYW5nZV9pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZSwgY2hlY2tib3gsIGksIHJlZjtcbiAgICAgICAgYWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuJGVsLmZpbmQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tib3ggPSByZWZbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLm1vZGVsLmNhbGxiYWNrKSAhPSBudWxsID8gcmVmLmV4ZWN1dGUodGhpcy5tb2RlbCkgOiB2b2lkIDA7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hlY2tib3hCdXR0b25Hcm91cFZpZXc7XG59KSh3aWRnZXRfMS5XaWRnZXRWaWV3KTtcbmV4cG9ydHMuQ2hlY2tib3hCdXR0b25Hcm91cCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDaGVja2JveEJ1dHRvbkdyb3VwLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDaGVja2JveEJ1dHRvbkdyb3VwKCkge1xuICAgICAgICByZXR1cm4gQ2hlY2tib3hCdXR0b25Hcm91cC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2hlY2tib3hCdXR0b25Hcm91cC5wcm90b3R5cGUudHlwZSA9IFwiQ2hlY2tib3hCdXR0b25Hcm91cFwiO1xuICAgIENoZWNrYm94QnV0dG9uR3JvdXAucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQ2hlY2tib3hCdXR0b25Hcm91cFZpZXc7XG4gICAgQ2hlY2tib3hCdXR0b25Hcm91cC5kZWZpbmUoe1xuICAgICAgICBhY3RpdmU6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIGxhYmVsczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgYnV0dG9uX3R5cGU6IFtwLlN0cmluZywgXCJkZWZhdWx0XCJdLFxuICAgICAgICBjYWxsYmFjazogW3AuSW5zdGFuY2VdXG4gICAgfSk7XG4gICAgcmV0dXJuIENoZWNrYm94QnV0dG9uR3JvdXA7XG59KSh3aWRnZXRfMS5XaWRnZXQpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKVxuICAgICAgICByZXR1cm4gaTtcbn0gcmV0dXJuIC0xOyB9O1xudmFyICQgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xudmFyIHdpZGdldF8xID0gcmVxdWlyZShcIi4vd2lkZ2V0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5DaGVja2JveEdyb3VwVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDaGVja2JveEdyb3VwVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2hlY2tib3hHcm91cFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBDaGVja2JveEdyb3VwVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2hlY2tib3hHcm91cFZpZXcucHJvdG90eXBlLmV2ZW50cyA9IHtcbiAgICAgICAgXCJjaGFuZ2UgaW5wdXRcIjogXCJjaGFuZ2VfaW5wdXRcIlxuICAgIH07XG4gICAgQ2hlY2tib3hHcm91cFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBDaGVja2JveEdyb3VwVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgdGhpcy5yZW5kZXIpO1xuICAgIH07XG4gICAgQ2hlY2tib3hHcm91cFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRkaXYsICRpbnB1dCwgJGxhYmVsLCBhY3RpdmUsIGksIGosIGxhYmVsLCBsZW4sIHJlZjtcbiAgICAgICAgQ2hlY2tib3hHcm91cFZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgICAgICBhY3RpdmUgPSB0aGlzLm1vZGVsLmFjdGl2ZTtcbiAgICAgICAgcmVmID0gdGhpcy5tb2RlbC5sYWJlbHM7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHJlZltpXTtcbiAgICAgICAgICAgICRpbnB1dCA9ICQoJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIj4nKS5hdHRyKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIiArIGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAkaW5wdXQucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4T2YuY2FsbChhY3RpdmUsIGkpID49IDApIHtcbiAgICAgICAgICAgICAgICAkaW5wdXQucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkbGFiZWwgPSAkKCc8bGFiZWw+PC9sYWJlbD4nKS50ZXh0KGxhYmVsKS5wcmVwZW5kKCRpbnB1dCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAkbGFiZWwuYWRkQ2xhc3MoXCJiay1icy1jaGVja2JveC1pbmxpbmVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuYXBwZW5kKCRsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkZGl2ID0gJCgnPGRpdiBjbGFzcz1cImJrLWJzLWNoZWNrYm94XCI+PC9kaXY+JykuYXBwZW5kKCRsYWJlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuYXBwZW5kKCRkaXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ2hlY2tib3hHcm91cFZpZXcucHJvdG90eXBlLmNoYW5nZV9pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZSwgY2hlY2tib3gsIGksIHJlZjtcbiAgICAgICAgYWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuJGVsLmZpbmQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tib3ggPSByZWZbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLm1vZGVsLmNhbGxiYWNrKSAhPSBudWxsID8gcmVmLmV4ZWN1dGUodGhpcy5tb2RlbCkgOiB2b2lkIDA7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hlY2tib3hHcm91cFZpZXc7XG59KSh3aWRnZXRfMS5XaWRnZXRWaWV3KTtcbmV4cG9ydHMuQ2hlY2tib3hHcm91cCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDaGVja2JveEdyb3VwLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDaGVja2JveEdyb3VwKCkge1xuICAgICAgICByZXR1cm4gQ2hlY2tib3hHcm91cC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2hlY2tib3hHcm91cC5wcm90b3R5cGUudHlwZSA9IFwiQ2hlY2tib3hHcm91cFwiO1xuICAgIENoZWNrYm94R3JvdXAucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuQ2hlY2tib3hHcm91cFZpZXc7XG4gICAgQ2hlY2tib3hHcm91cC5kZWZpbmUoe1xuICAgICAgICBhY3RpdmU6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIGxhYmVsczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgaW5saW5lOiBbcC5Cb29sLCBmYWxzZV0sXG4gICAgICAgIGNhbGxiYWNrOiBbcC5JbnN0YW5jZV1cbiAgICB9KTtcbiAgICByZXR1cm4gQ2hlY2tib3hHcm91cDtcbn0pKHdpZGdldF8xLldpZGdldCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB3YWl0X2Zvcl9lbGVtZW50LCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xudmFyICQgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xucmVxdWlyZShcImpxdWVyeS11aS9zb3J0YWJsZVwiKTtcbnZhciBTbGlja0dyaWQgPSByZXF1aXJlKFwic2xpY2tfZ3JpZC9zbGljay5ncmlkXCIpO1xudmFyIFJvd1NlbGVjdGlvbk1vZGVsID0gcmVxdWlyZShcInNsaWNrX2dyaWQvcGx1Z2lucy9zbGljay5yb3dzZWxlY3Rpb25tb2RlbFwiKTtcbnZhciBDaGVja2JveFNlbGVjdENvbHVtbiA9IHJlcXVpcmUoXCJzbGlja19ncmlkL3BsdWdpbnMvc2xpY2suY2hlY2tib3hzZWxlY3Rjb2x1bW5cIik7XG52YXIgaGl0dGVzdCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2hpdHRlc3RcIik7XG52YXIgcCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgdGFibGVfd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi90YWJsZV93aWRnZXRcIik7XG52YXIgd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi93aWRnZXRcIik7XG53YWl0X2Zvcl9lbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBmbikge1xuICAgIHZhciBoYW5kbGVyLCBpbnRlcnZhbDtcbiAgICBoYW5kbGVyID0gKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCQuY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBlbCkpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KSh0aGlzKTtcbiAgICByZXR1cm4gaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChoYW5kbGVyLCA1MCk7XG59O1xuZXhwb3J0cy5EYXRhUHJvdmlkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGFQcm92aWRlcihzb3VyY2UxKSB7XG4gICAgICAgIHZhciBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlMTtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5zb3VyY2UuZGF0YTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBfLmtleXModGhpcy5kYXRhKTtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHRoaXMuZmllbGRzLCBcImluZGV4XCIpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbXCJpbmRleFwiXSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCByZWYgPSB0aGlzLmdldExlbmd0aCgpOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyAwIDw9IHJlZiA/IGorKyA6IGotLSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKFwiaW5kZXhcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGF0YVByb3ZpZGVyLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5nZXRfbGVuZ3RoKCk7XG4gICAgfTtcbiAgICBEYXRhUHJvdmlkZXIucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBmaWVsZCwgaXRlbSwgaiwgbGVuLCByZWY7XG4gICAgICAgIGl0ZW0gPSB7fTtcbiAgICAgICAgcmVmID0gdGhpcy5maWVsZHM7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgZmllbGQgPSByZWZbal07XG4gICAgICAgICAgICBpdGVtW2ZpZWxkXSA9IHRoaXMuZGF0YVtmaWVsZF1bb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICAgIERhdGFQcm92aWRlci5wcm90b3R5cGUuX3NldEl0ZW0gPSBmdW5jdGlvbiAob2Zmc2V0LCBpdGVtKSB7XG4gICAgICAgIHZhciBmaWVsZCwgdmFsdWU7XG4gICAgICAgIGZvciAoZmllbGQgaW4gaXRlbSkge1xuICAgICAgICAgICAgdmFsdWUgPSBpdGVtW2ZpZWxkXTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtmaWVsZF1bb2Zmc2V0XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhUHJvdmlkZXIucHJvdG90eXBlLnNldEl0ZW0gPSBmdW5jdGlvbiAob2Zmc2V0LCBpdGVtKSB7XG4gICAgICAgIHRoaXMuX3NldEl0ZW0ob2Zmc2V0LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlU291cmNlKCk7XG4gICAgfTtcbiAgICBEYXRhUHJvdmlkZXIucHJvdG90eXBlLmdldEZpZWxkID0gZnVuY3Rpb24gKGluZGV4LCBmaWVsZCkge1xuICAgICAgICB2YXIgb2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmRhdGFbXCJpbmRleFwiXS5pbmRleE9mKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtmaWVsZF1bb2Zmc2V0XTtcbiAgICB9O1xuICAgIERhdGFQcm92aWRlci5wcm90b3R5cGUuX3NldEZpZWxkID0gZnVuY3Rpb24gKGluZGV4LCBmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5kYXRhW1wiaW5kZXhcIl0uaW5kZXhPZihpbmRleCk7XG4gICAgICAgIHRoaXMuZGF0YVtmaWVsZF1bb2Zmc2V0XSA9IHZhbHVlO1xuICAgIH07XG4gICAgRGF0YVByb3ZpZGVyLnByb3RvdHlwZS5zZXRGaWVsZCA9IGZ1bmN0aW9uIChpbmRleCwgZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NldEZpZWxkKGluZGV4LCBmaWVsZCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVTb3VyY2UoKTtcbiAgICB9O1xuICAgIERhdGFQcm92aWRlci5wcm90b3R5cGUudXBkYXRlU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UudHJpZ2dlcihcImNoYW5nZTpkYXRhXCIsIHRoaXMsIHRoaXMuc291cmNlLmF0dHJpYnV0ZXNbJ2RhdGEnXSk7XG4gICAgfTtcbiAgICBEYXRhUHJvdmlkZXIucHJvdG90eXBlLmdldEl0ZW1NZXRhZGF0YSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIERhdGFQcm92aWRlci5wcm90b3R5cGUuZ2V0UmVjb3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB0aGlzLmdldExlbmd0aCgpOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5nZXRJdGVtKGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgRGF0YVByb3ZpZGVyLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIGNvbHMsIGNvbHVtbiwgaSwgaiwgbGVuLCByZWNvcmQsIHJlY29yZHM7XG4gICAgICAgIGNvbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGNvbHVtbnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2pdO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChbY29sdW1uLnNvcnRDb2wuZmllbGQsIGNvbHVtbi5zb3J0QXNjID8gMSA6IC0xXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgaWYgKF8uaXNFbXB0eShjb2xzKSkge1xuICAgICAgICAgICAgY29scyA9IFtbXCJpbmRleFwiLCAxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3JkcyA9IHRoaXMuZ2V0UmVjb3JkcygpO1xuICAgICAgICByZWNvcmRzLnNvcnQoZnVuY3Rpb24gKHJlY29yZDEsIHJlY29yZDIpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCwgaiwgbGVuLCByZWYsIHJlc3VsdCwgc2lnbiwgdmFsdWUxLCB2YWx1ZTI7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBjb2xzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVmID0gY29sc1tqXSwgZmllbGQgPSByZWZbMF0sIHNpZ24gPSByZWZbMV07XG4gICAgICAgICAgICAgICAgdmFsdWUxID0gcmVjb3JkMVtmaWVsZF07XG4gICAgICAgICAgICAgICAgdmFsdWUyID0gcmVjb3JkMltmaWVsZF07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUxID09PSB2YWx1ZTIgPyAwIDogdmFsdWUxID4gdmFsdWUyID8gc2lnbiA6IC1zaWduO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWNvcmRzLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgICAgICAgICAgcmVjb3JkID0gcmVjb3Jkc1tpXTtcbiAgICAgICAgICAgIHRoaXMuX3NldEl0ZW0oaSwgcmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVTb3VyY2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRhUHJvdmlkZXI7XG59KSgpO1xuZXhwb3J0cy5EYXRhVGFibGVWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERhdGFUYWJsZVZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGFUYWJsZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBEYXRhVGFibGVWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEYXRhVGFibGVWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgPSBcImJrLWRhdGEtdGFibGVcIjtcbiAgICBEYXRhVGFibGVWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgRGF0YVRhYmxlVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB3YWl0X2Zvcl9lbGVtZW50KHRoaXMuZWwsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5tb2RlbC5zb3VyY2U7XG4gICAgICAgIHRoaXMubGlzdGVuVG8oc291cmNlLCAnY2hhbmdlOmRhdGEnLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHNvdXJjZSwgJ2NoYW5nZTpzZWxlY3RlZCcsIChmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH07XG4gICAgRGF0YVRhYmxlVmlldy5wcm90b3R5cGUudXBkYXRlR3JpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhLmNvbnN0cnVjdG9yKHRoaXMubW9kZWwuc291cmNlKTtcbiAgICAgICAgdGhpcy5ncmlkLmludmFsaWRhdGUoKTtcbiAgICAgICAgdGhpcy5ncmlkLnJlbmRlcigpO1xuICAgICAgICB0aGlzLm1vZGVsLnNvdXJjZS5kYXRhID0gdGhpcy5tb2RlbC5zb3VyY2UuZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc291cmNlLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH07XG4gICAgRGF0YVRhYmxlVmlldy5wcm90b3R5cGUudXBkYXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VyX2dyaWRfcmFuZ2UsIGluZGljZXMsIG1pbl9pbmRleCwgc2VsZWN0ZWQ7XG4gICAgICAgIHNlbGVjdGVkID0gdGhpcy5tb2RlbC5zb3VyY2Uuc2VsZWN0ZWQ7XG4gICAgICAgIGluZGljZXMgPSBzZWxlY3RlZFsnMWQnXS5pbmRpY2VzO1xuICAgICAgICB0aGlzLmdyaWQuc2V0U2VsZWN0ZWRSb3dzKGluZGljZXMpO1xuICAgICAgICBjdXJfZ3JpZF9yYW5nZSA9IHRoaXMuZ3JpZC5nZXRWaWV3cG9ydCgpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5zY3JvbGxfdG9fc2VsZWN0aW9uICYmICFfLmFueShpbmRpY2VzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIChjdXJfZ3JpZF9yYW5nZS50b3AgPD0gaSAmJiBpIDw9IGN1cl9ncmlkX3JhbmdlLmJvdHRvbSk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICBtaW5faW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbi5hcHBseShudWxsLCBpbmRpY2VzKSAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zY3JvbGxSb3dUb1RvcChtaW5faW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhVGFibGVWaWV3LnByb3RvdHlwZS5uZXdJbmRleENvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBfLnVuaXF1ZUlkKCksXG4gICAgICAgICAgICBuYW1lOiBcIiNcIixcbiAgICAgICAgICAgIGZpZWxkOiBcImluZGV4XCIsXG4gICAgICAgICAgICB3aWR0aDogNDAsXG4gICAgICAgICAgICBiZWhhdmlvcjogXCJzZWxlY3RcIixcbiAgICAgICAgICAgIGNhbm5vdFRyaWdnZXJJbnNlcnQ6IHRydWUsXG4gICAgICAgICAgICByZXNpemFibGU6IGZhbHNlLFxuICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNzc0NsYXNzOiBcImJrLWNlbGwtaW5kZXhcIlxuICAgICAgICB9O1xuICAgIH07XG4gICAgRGF0YVRhYmxlVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hlY2tib3hTZWxlY3RvciwgY29sdW1uLCBjb2x1bW5zLCBoZWlnaHQsIG9wdGlvbnMsIHdpZHRoO1xuICAgICAgICBjb2x1bW5zID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlZiA9IHRoaXMubW9kZWwuY29sdW1ucztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHJlZltqXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY29sdW1uLnRvQ29sdW1uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNlbGVjdGFibGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgICAgY2hlY2tib3hTZWxlY3RvciA9IG5ldyBDaGVja2JveFNlbGVjdENvbHVtbih7XG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IFwiYmstY2VsbC1zZWxlY3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2x1bW5zLnVuc2hpZnQoY2hlY2tib3hTZWxlY3Rvci5nZXRDb2x1bW5EZWZpbml0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnJvd19oZWFkZXJzICYmICh0aGlzLm1vZGVsLnNvdXJjZS5nZXRfY29sdW1uKFwiaW5kZXhcIikgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIGNvbHVtbnMudW5zaGlmdCh0aGlzLm5ld0luZGV4Q29sdW1uKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdpZHRoID0gdGhpcy5tb2RlbC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5tb2RlbC5oZWlnaHQ7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlbmFibGVDZWxsTmF2aWdhdGlvbjogdGhpcy5tb2RlbC5zZWxlY3RhYmxlICE9PSBmYWxzZSxcbiAgICAgICAgICAgIGVuYWJsZUNvbHVtblJlb3JkZXI6IHRydWUsXG4gICAgICAgICAgICBmb3JjZUZpdENvbHVtbnM6IHRoaXMubW9kZWwuZml0X2NvbHVtbnMsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0OiBoZWlnaHQgPT09IFwiYXV0b1wiLFxuICAgICAgICAgICAgbXVsdGlDb2x1bW5Tb3J0OiB0aGlzLm1vZGVsLnNvcnRhYmxlLFxuICAgICAgICAgICAgZWRpdGFibGU6IHRoaXMubW9kZWwuZWRpdGFibGUsXG4gICAgICAgICAgICBhdXRvRWRpdDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmNzcyh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMubW9kZWwud2lkdGggKyBcInB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kZWwuY3NzKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5tb2RlbC5kZWZhdWx0X3dpZHRoICsgXCJweFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlaWdodCAhPSBudWxsKSAmJiBoZWlnaHQgIT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5jc3Moe1xuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5tb2RlbC5oZWlnaHQgKyBcInB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBleHBvcnRzLkRhdGFQcm92aWRlcih0aGlzLm1vZGVsLnNvdXJjZSk7XG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBTbGlja0dyaWQodGhpcy5lbCwgdGhpcy5kYXRhLCBjb2x1bW5zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmlkLm9uU29ydC5zdWJzY3JpYmUoKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgYXJncykge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBhcmdzLnNvcnRDb2xzO1xuICAgICAgICAgICAgICAgIF90aGlzLmRhdGEuc29ydChjb2x1bW5zKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ncmlkLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ3JpZC5yZW5kZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuc2VsZWN0YWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zZXRTZWxlY3Rpb25Nb2RlbChuZXcgUm93U2VsZWN0aW9uTW9kZWwoe1xuICAgICAgICAgICAgICAgIHNlbGVjdEFjdGl2ZVJvdzogY2hlY2tib3hTZWxlY3RvciA9PSBudWxsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoY2hlY2tib3hTZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnJlZ2lzdGVyUGx1Z2luKGNoZWNrYm94U2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ncmlkLm9uU2VsZWN0ZWRSb3dzQ2hhbmdlZC5zdWJzY3JpYmUoKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGhpdHRlc3QuY3JlYXRlX2hpdF90ZXN0X3Jlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFsnMWQnXS5pbmRpY2VzID0gYXJncy5yb3dzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubW9kZWwuc291cmNlLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBEYXRhVGFibGVWaWV3O1xufSkod2lkZ2V0XzEuV2lkZ2V0Vmlldyk7XG5leHBvcnRzLkRhdGFUYWJsZSA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEYXRhVGFibGUsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGFUYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIERhdGFUYWJsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS50eXBlID0gJ0RhdGFUYWJsZSc7XG4gICAgRGF0YVRhYmxlLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkRhdGFUYWJsZVZpZXc7XG4gICAgRGF0YVRhYmxlLmRlZmluZSh7XG4gICAgICAgIGNvbHVtbnM6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIGZpdF9jb2x1bW5zOiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgc29ydGFibGU6IFtwLkJvb2wsIHRydWVdLFxuICAgICAgICBlZGl0YWJsZTogW3AuQm9vbCwgZmFsc2VdLFxuICAgICAgICBzZWxlY3RhYmxlOiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgcm93X2hlYWRlcnM6IFtwLkJvb2wsIHRydWVdLFxuICAgICAgICBzY3JvbGxfdG9fc2VsZWN0aW9uOiBbcC5Cb29sLCB0cnVlXVxuICAgIH0pO1xuICAgIERhdGFUYWJsZS5vdmVycmlkZSh7XG4gICAgICAgIGhlaWdodDogNDAwXG4gICAgfSk7XG4gICAgRGF0YVRhYmxlLmludGVybmFsKHtcbiAgICAgICAgZGVmYXVsdF93aWR0aDogW3AuTnVtYmVyLCA2MDBdXG4gICAgfSk7XG4gICAgcmV0dXJuIERhdGFUYWJsZTtcbn0pKHRhYmxlX3dpZGdldF8xLlRhYmxlV2lkZ2V0KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGJpbmQgPSBmdW5jdGlvbiAoZm4sIG1lKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyICQgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xucmVxdWlyZShcImpxdWVyeS11aS9kYXRlcGlja2VyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGlucHV0X3dpZGdldF8xID0gcmVxdWlyZShcIi4vaW5wdXRfd2lkZ2V0XCIpO1xuZXhwb3J0cy5EYXRlUGlja2VyVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEYXRlUGlja2VyVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGF0ZVBpY2tlclZpZXcoKSB7XG4gICAgICAgIHRoaXMub25TZWxlY3QgPSBiaW5kKHRoaXMub25TZWxlY3QsIHRoaXMpO1xuICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERhdGVQaWNrZXJWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgRGF0ZVBpY2tlclZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9ICQoJzxsYWJlbD4nKS50ZXh0KHRoaXMubW9kZWwudGl0bGUpO1xuICAgICAgICB0aGlzLmlucHV0ID0gJCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCI+Jyk7XG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlciA9IHRoaXMuaW5wdXQuZGF0ZXBpY2tlcih7XG4gICAgICAgICAgICBkZWZhdWx0RGF0ZTogbmV3IERhdGUodGhpcy5tb2RlbC52YWx1ZSksXG4gICAgICAgICAgICBtaW5EYXRlOiB0aGlzLm1vZGVsLm1pbl9kYXRlICE9IG51bGwgPyBuZXcgRGF0ZSh0aGlzLm1vZGVsLm1pbl9kYXRlKSA6IG51bGwsXG4gICAgICAgICAgICBtYXhEYXRlOiB0aGlzLm1vZGVsLm1heF9kYXRlICE9IG51bGwgPyBuZXcgRGF0ZSh0aGlzLm1vZGVsLm1heF9kYXRlKSA6IG51bGwsXG4gICAgICAgICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmFwcGVuZChbdGhpcy5sYWJlbCwgdGhpcy5pbnB1dF0pO1xuICAgIH07XG4gICAgRGF0ZVBpY2tlclZpZXcucHJvdG90eXBlLm9uU2VsZWN0ID0gZnVuY3Rpb24gKGRhdGVUZXh0LCB1aSkge1xuICAgICAgICB2YXIgZCwgcmVmO1xuICAgICAgICBkID0gbmV3IERhdGUoZGF0ZVRleHQpO1xuICAgICAgICB0aGlzLm1vZGVsLnZhbHVlID0gZC50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gKHJlZiA9IHRoaXMubW9kZWwuY2FsbGJhY2spICE9IG51bGwgPyByZWYuZXhlY3V0ZSh0aGlzLm1vZGVsKSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlUGlja2VyVmlldztcbn0pKGlucHV0X3dpZGdldF8xLklucHV0V2lkZ2V0Vmlldyk7XG5leHBvcnRzLkRhdGVQaWNrZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGF0ZVBpY2tlciwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGF0ZVBpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIERhdGVQaWNrZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERhdGVQaWNrZXIucHJvdG90eXBlLnR5cGUgPSBcIkRhdGVQaWNrZXJcIjtcbiAgICBEYXRlUGlja2VyLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLkRhdGVQaWNrZXJWaWV3O1xuICAgIERhdGVQaWNrZXIuZGVmaW5lKHtcbiAgICAgICAgdmFsdWU6IFtwLkFueSwgRGF0ZS5ub3coKV0sXG4gICAgICAgIG1pbl9kYXRlOiBbcC5BbnldLFxuICAgICAgICBtYXhfZGF0ZTogW3AuQW55XVxuICAgIH0pO1xuICAgIHJldHVybiBEYXRlUGlja2VyO1xufSkoaW5wdXRfd2lkZ2V0XzEuSW5wdXRXaWRnZXQpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbnJlcXVpcmUoXCJqcXJhbmdlc2xpZGVyL2pRRGF0ZVJhbmdlU2xpZGVyXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIGlucHV0X3dpZGdldF8xID0gcmVxdWlyZShcIi4vaW5wdXRfd2lkZ2V0XCIpO1xuZXhwb3J0cy5EYXRlUmFuZ2VTbGlkZXJWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERhdGVSYW5nZVNsaWRlclZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGVSYW5nZVNsaWRlclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBEYXRlUmFuZ2VTbGlkZXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEYXRlUmFuZ2VTbGlkZXJWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgRGF0ZVJhbmdlU2xpZGVyVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgKGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVuZGVyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgIH07XG4gICAgRGF0ZVJhbmdlU2xpZGVyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm91bmRzX21heCwgYm91bmRzX21pbiwgcmFuZ2VfbWF4LCByYW5nZV9taW4sIHJlZiwgcmVmMSwgcmVmMiwgdmFsdWVfbWF4LCB2YWx1ZV9taW47XG4gICAgICAgIERhdGVSYW5nZVNsaWRlclZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgICAgICByZWYgPSB0aGlzLm1vZGVsLnZhbHVlLCB2YWx1ZV9taW4gPSByZWZbMF0sIHZhbHVlX21heCA9IHJlZlsxXTtcbiAgICAgICAgcmVmMSA9IHRoaXMubW9kZWwucmFuZ2UsIHJhbmdlX21pbiA9IHJlZjFbMF0sIHJhbmdlX21heCA9IHJlZjFbMV07XG4gICAgICAgIHJlZjIgPSB0aGlzLm1vZGVsLmJvdW5kcywgYm91bmRzX21pbiA9IHJlZjJbMF0sIGJvdW5kc19tYXggPSByZWYyWzFdO1xuICAgICAgICB0aGlzLiRlbC5kYXRlUmFuZ2VTbGlkZXIoe1xuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczoge1xuICAgICAgICAgICAgICAgIG1pbjogbmV3IERhdGUodmFsdWVfbWluKSxcbiAgICAgICAgICAgICAgICBtYXg6IG5ldyBEYXRlKHZhbHVlX21heClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgICAgICBtaW46IG5ldyBEYXRlKGJvdW5kc19taW4pLFxuICAgICAgICAgICAgICAgIG1heDogbmV3IERhdGUoYm91bmRzX21heClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgIG1pbjogXy5pc09iamVjdChyYW5nZV9taW4pID8gcmFuZ2VfbWluIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWF4OiBfLmlzT2JqZWN0KHJhbmdlX21heCkgPyByYW5nZV9tYXggOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0ZXA6IHRoaXMubW9kZWwuc3RlcCB8fCB7fSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMubW9kZWwuZW5hYmxlZCxcbiAgICAgICAgICAgIGFycm93czogdGhpcy5tb2RlbC5hcnJvd3MsXG4gICAgICAgICAgICB2YWx1ZUxhYmVsczogdGhpcy5tb2RlbC52YWx1ZV9sYWJlbHMsXG4gICAgICAgICAgICB3aGVlbE1vZGU6IHRoaXMubW9kZWwud2hlZWxfbW9kZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kZWwub24oXCJ1c2VyVmFsdWVzQ2hhbmdlZFwiLCAoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZjM7XG4gICAgICAgICAgICAgICAgX3RoaXMubW9kZWwudmFsdWUgPSBbZGF0YS52YWx1ZXMubWluLCBkYXRhLnZhbHVlcy5tYXhdO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVmMyA9IF90aGlzLm1vZGVsLmNhbGxiYWNrKSAhPSBudWxsID8gcmVmMy5leGVjdXRlKF90aGlzLm1vZGVsKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZVJhbmdlU2xpZGVyVmlldztcbn0pKGlucHV0X3dpZGdldF8xLklucHV0V2lkZ2V0Vmlldyk7XG5leHBvcnRzLkRhdGVSYW5nZVNsaWRlciA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEYXRlUmFuZ2VTbGlkZXIsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERhdGVSYW5nZVNsaWRlcigpIHtcbiAgICAgICAgcmV0dXJuIERhdGVSYW5nZVNsaWRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGF0ZVJhbmdlU2xpZGVyLnByb3RvdHlwZS50eXBlID0gXCJEYXRlUmFuZ2VTbGlkZXJcIjtcbiAgICBEYXRlUmFuZ2VTbGlkZXIucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuRGF0ZVJhbmdlU2xpZGVyVmlldztcbiAgICBEYXRlUmFuZ2VTbGlkZXIuZGVmaW5lKHtcbiAgICAgICAgdmFsdWU6IFtwLkFueV0sXG4gICAgICAgIHJhbmdlOiBbcC5BbnldLFxuICAgICAgICBib3VuZHM6IFtwLkFueV0sXG4gICAgICAgIHN0ZXA6IFtwLkFueSwge31dLFxuICAgICAgICBlbmFibGVkOiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgYXJyb3dzOiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgdmFsdWVfbGFiZWxzOiBbcC5TdHJpbmcsIFwic2hvd1wiXSxcbiAgICAgICAgd2hlZWxfbW9kZTogW3AuQW55XVxuICAgIH0pO1xuICAgIHJldHVybiBEYXRlUmFuZ2VTbGlkZXI7XG59KShpbnB1dF93aWRnZXRfMS5JbnB1dFdpZGdldCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgJCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XG52YXIgbWFya3VwXzEgPSByZXF1aXJlKFwiLi9tYXJrdXBcIik7XG52YXIgcCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3Byb3BlcnRpZXNcIik7XG5leHBvcnRzLkRpdlZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGl2Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gRGl2VmlldygpIHtcbiAgICAgICAgcmV0dXJuIERpdlZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpdlZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRjb250ZW50O1xuICAgICAgICBEaXZWaWV3Ll9fc3VwZXJfXy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucmVuZGVyX2FzX3RleHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICRjb250ZW50ID0gJCgnPGRpdj48L2Rpdj4nKS50ZXh0KHRoaXMubW9kZWwudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkY29udGVudCA9ICQoJzxkaXY+PC9kaXY+JykuaHRtbCh0aGlzLm1vZGVsLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVsLmZpbmQoJy5iay1tYXJrdXAnKS5hcHBlbmQoJGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBEaXZWaWV3O1xufSkobWFya3VwXzEuTWFya3VwVmlldyk7XG5leHBvcnRzLkRpdiA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEaXYsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERpdigpIHtcbiAgICAgICAgcmV0dXJuIERpdi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGl2LnByb3RvdHlwZS50eXBlID0gXCJEaXZcIjtcbiAgICBEaXYucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuRGl2VmlldztcbiAgICBEaXYuZGVmaW5lKHtcbiAgICAgICAgcmVuZGVyX2FzX3RleHQ6IFtwLkJvb2wsIGZhbHNlXVxuICAgIH0pO1xuICAgIHJldHVybiBEaXY7XG59KShtYXJrdXBfMS5NYXJrdXApO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyICQgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xucmVxdWlyZShcImJvb3RzdHJhcC9kcm9wZG93blwiKTtcbnZhciBwID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhYnN0cmFjdF9idXR0b25fMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0X2J1dHRvblwiKTtcbnZhciBkcm9wZG93bl90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4vZHJvcGRvd25fdGVtcGxhdGVcIik7XG5leHBvcnRzLkRyb3Bkb3duVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChEcm9wZG93blZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERyb3Bkb3duVmlldygpIHtcbiAgICAgICAgcmV0dXJuIERyb3Bkb3duVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRHJvcGRvd25WaWV3LnByb3RvdHlwZS50ZW1wbGF0ZSA9IGRyb3Bkb3duX3RlbXBsYXRlXzEuZGVmYXVsdDtcbiAgICBEcm9wZG93blZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRhLCAkaXRlbSwgaSwgaXRlbSwgaXRlbXMsIGxhYmVsLCBsZW4sIHJlZiwgdGhhdCwgdmFsdWU7XG4gICAgICAgIERyb3Bkb3duVmlldy5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwubWVudTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gcmVmW2ldO1xuICAgICAgICAgICAgJGl0ZW0gPSBpdGVtICE9IG51bGwgPyAoKGxhYmVsID0gaXRlbVswXSwgdmFsdWUgPSBpdGVtWzFdLCBpdGVtKSwgJGEgPSAkKFwiPGEgZGF0YS12YWx1ZT0nXCIgKyB2YWx1ZSArIFwiJz5cIiArIGxhYmVsICsgXCI8L2E+XCIpLCB0aGF0ID0gdGhpcywgJGEuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5zZXRfdmFsdWUoJCh0aGlzKS5kYXRhKCd2YWx1ZScpKTtcbiAgICAgICAgICAgIH0pLCAkKCc8bGk+PC9saT4nKS5hcHBlbmQoJGEpKSA6ICQoJzxsaSBjbGFzcz1cImJrLWJzLWRpdmlkZXJcIj48L2xpPicpO1xuICAgICAgICAgICAgaXRlbXMucHVzaCgkaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWwuZmluZCgnLmJrLWJzLWRyb3Bkb3duLW1lbnUnKS5hcHBlbmQoaXRlbXMpO1xuICAgICAgICB0aGlzLiRlbC5maW5kKCdidXR0b24nKS52YWwodGhpcy5tb2RlbC5kZWZhdWx0X3ZhbHVlKTtcbiAgICAgICAgdGhpcy4kZWwuZmluZCgnYnV0dG9uJykuZHJvcGRvd24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEcm9wZG93blZpZXcucHJvdG90eXBlLnNldF92YWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1vZGVsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5maW5kKCdidXR0b24nKS52YWwodmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIERyb3Bkb3duVmlldztcbn0pKGFic3RyYWN0X2J1dHRvbl8xLkFic3RyYWN0QnV0dG9uVmlldyk7XG5leHBvcnRzLkRyb3Bkb3duID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERyb3Bkb3duLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBEcm9wZG93bigpIHtcbiAgICAgICAgcmV0dXJuIERyb3Bkb3duLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEcm9wZG93bi5wcm90b3R5cGUudHlwZSA9IFwiRHJvcGRvd25cIjtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5Ecm9wZG93blZpZXc7XG4gICAgRHJvcGRvd24uZGVmaW5lKHtcbiAgICAgICAgdmFsdWU6IFtwLlN0cmluZ10sXG4gICAgICAgIGRlZmF1bHRfdmFsdWU6IFtwLlN0cmluZ10sXG4gICAgICAgIG1lbnU6IFtwLkFycmF5LCBbXV1cbiAgICB9KTtcbiAgICBEcm9wZG93bi5vdmVycmlkZSh7XG4gICAgICAgIGxhYmVsOiBcIkRyb3Bkb3duXCJcbiAgICB9KTtcbiAgICByZXR1cm4gRHJvcGRvd247XG59KShhYnN0cmFjdF9idXR0b25fMS5BYnN0cmFjdEJ1dHRvbik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBET00gPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsL2RvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBjbGFzc2VzID0gW1wiYmstYnMtYnRuXCIsIFwiYmstYnMtYnRuLVwiICsgcHJvcHMuYnV0dG9uX3R5cGUsIFwiYmstYnMtZHJvcGRvd24tdG9nZ2xlXCIsIFwiYmstYnMtZHJvcGRvd24tYnRuXCJdO1xuICAgIHJldHVybiAoRE9NLmNyZWF0ZUVsZW1lbnQoXCJmcmFnbWVudFwiLCBudWxsLFxuICAgICAgICBET00uY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzOiBjbGFzc2VzLCBcImRhdGEtYmstYnMtdG9nZ2xlXCI6IFwiZHJvcGRvd25cIiB9LFxuICAgICAgICAgICAgcHJvcHMubGFiZWwsXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzOiBcImJrLWJzLWNhcmV0XCIgfSkpLFxuICAgICAgICBET00uY3JlYXRlRWxlbWVudChcInVsXCIsIHsgY2xhc3M6IFwiYmstYnMtZHJvcGRvd24tbWVudVwiIH0pKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuX19leHBvcnQocmVxdWlyZShcIi4vY2VsbF9lZGl0b3JzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NlbGxfZm9ybWF0dGVyc1wiKSk7XG52YXIgYWJzdHJhY3RfYnV0dG9uXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdF9idXR0b25cIik7XG5leHBvcnRzLkFic3RyYWN0QnV0dG9uID0gYWJzdHJhY3RfYnV0dG9uXzEuQWJzdHJhY3RCdXR0b247XG52YXIgYWJzdHJhY3RfaWNvbl8xID0gcmVxdWlyZShcIi4vYWJzdHJhY3RfaWNvblwiKTtcbmV4cG9ydHMuQWJzdHJhY3RJY29uID0gYWJzdHJhY3RfaWNvbl8xLkFic3RyYWN0SWNvbjtcbnZhciB0YWJsZV93aWRnZXRfMSA9IHJlcXVpcmUoXCIuL3RhYmxlX3dpZGdldFwiKTtcbmV4cG9ydHMuVGFibGVXaWRnZXQgPSB0YWJsZV93aWRnZXRfMS5UYWJsZVdpZGdldDtcbnZhciBtYXJrdXBfMSA9IHJlcXVpcmUoXCIuL21hcmt1cFwiKTtcbmV4cG9ydHMuTWFya3VwID0gbWFya3VwXzEuTWFya3VwO1xudmFyIHdpZGdldF8xID0gcmVxdWlyZShcIi4vd2lkZ2V0XCIpO1xuZXhwb3J0cy5XaWRnZXQgPSB3aWRnZXRfMS5XaWRnZXQ7XG52YXIgaW5wdXRfd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi9pbnB1dF93aWRnZXRcIik7XG5leHBvcnRzLklucHV0V2lkZ2V0ID0gaW5wdXRfd2lkZ2V0XzEuSW5wdXRXaWRnZXQ7XG52YXIgdGFibGVfY29sdW1uXzEgPSByZXF1aXJlKFwiLi90YWJsZV9jb2x1bW5cIik7XG5leHBvcnRzLlRhYmxlQ29sdW1uID0gdGFibGVfY29sdW1uXzEuVGFibGVDb2x1bW47XG52YXIgZGF0YV90YWJsZV8xID0gcmVxdWlyZShcIi4vZGF0YV90YWJsZVwiKTtcbmV4cG9ydHMuRGF0YVRhYmxlID0gZGF0YV90YWJsZV8xLkRhdGFUYWJsZTtcbnZhciBwYXJhZ3JhcGhfMSA9IHJlcXVpcmUoXCIuL3BhcmFncmFwaFwiKTtcbmV4cG9ydHMuUGFyYWdyYXBoID0gcGFyYWdyYXBoXzEuUGFyYWdyYXBoO1xudmFyIGRpdl8xID0gcmVxdWlyZShcIi4vZGl2XCIpO1xuZXhwb3J0cy5EaXYgPSBkaXZfMS5EaXY7XG52YXIgdGV4dF9pbnB1dF8xID0gcmVxdWlyZShcIi4vdGV4dF9pbnB1dFwiKTtcbmV4cG9ydHMuVGV4dElucHV0ID0gdGV4dF9pbnB1dF8xLlRleHRJbnB1dDtcbnZhciBhdXRvY29tcGxldGVfaW5wdXRfMSA9IHJlcXVpcmUoXCIuL2F1dG9jb21wbGV0ZV9pbnB1dFwiKTtcbmV4cG9ydHMuQXV0b2NvbXBsZXRlSW5wdXQgPSBhdXRvY29tcGxldGVfaW5wdXRfMS5BdXRvY29tcGxldGVJbnB1dDtcbnZhciBwcmV0ZXh0XzEgPSByZXF1aXJlKFwiLi9wcmV0ZXh0XCIpO1xuZXhwb3J0cy5QcmVUZXh0ID0gcHJldGV4dF8xLlByZVRleHQ7XG52YXIgc2VsZWN0Ym94XzEgPSByZXF1aXJlKFwiLi9zZWxlY3Rib3hcIik7XG5leHBvcnRzLlNlbGVjdCA9IHNlbGVjdGJveF8xLlNlbGVjdDtcbnZhciBzbGlkZXJfMSA9IHJlcXVpcmUoXCIuL3NsaWRlclwiKTtcbmV4cG9ydHMuU2xpZGVyID0gc2xpZGVyXzEuU2xpZGVyO1xudmFyIHJhbmdlX3NsaWRlcl8xID0gcmVxdWlyZShcIi4vcmFuZ2Vfc2xpZGVyXCIpO1xuZXhwb3J0cy5SYW5nZVNsaWRlciA9IHJhbmdlX3NsaWRlcl8xLlJhbmdlU2xpZGVyO1xudmFyIG11bHRpc2VsZWN0XzEgPSByZXF1aXJlKFwiLi9tdWx0aXNlbGVjdFwiKTtcbmV4cG9ydHMuTXVsdGlTZWxlY3QgPSBtdWx0aXNlbGVjdF8xLk11bHRpU2VsZWN0O1xudmFyIGRhdGVfcmFuZ2Vfc2xpZGVyXzEgPSByZXF1aXJlKFwiLi9kYXRlX3JhbmdlX3NsaWRlclwiKTtcbmV4cG9ydHMuRGF0ZVJhbmdlU2xpZGVyID0gZGF0ZV9yYW5nZV9zbGlkZXJfMS5EYXRlUmFuZ2VTbGlkZXI7XG52YXIgZGF0ZV9waWNrZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGVfcGlja2VyXCIpO1xuZXhwb3J0cy5EYXRlUGlja2VyID0gZGF0ZV9waWNrZXJfMS5EYXRlUGlja2VyO1xudmFyIHBhbmVsXzEgPSByZXF1aXJlKFwiLi9wYW5lbFwiKTtcbmV4cG9ydHMuUGFuZWwgPSBwYW5lbF8xLlBhbmVsO1xudmFyIHRhYnNfMSA9IHJlcXVpcmUoXCIuL3RhYnNcIik7XG5leHBvcnRzLlRhYnMgPSB0YWJzXzEuVGFicztcbnZhciBidXR0b25fMSA9IHJlcXVpcmUoXCIuL2J1dHRvblwiKTtcbmV4cG9ydHMuQnV0dG9uID0gYnV0dG9uXzEuQnV0dG9uO1xudmFyIHRvZ2dsZV8xID0gcmVxdWlyZShcIi4vdG9nZ2xlXCIpO1xuZXhwb3J0cy5Ub2dnbGUgPSB0b2dnbGVfMS5Ub2dnbGU7XG52YXIgZHJvcGRvd25fMSA9IHJlcXVpcmUoXCIuL2Ryb3Bkb3duXCIpO1xuZXhwb3J0cy5Ecm9wZG93biA9IGRyb3Bkb3duXzEuRHJvcGRvd247XG52YXIgY2hlY2tib3hfZ3JvdXBfMSA9IHJlcXVpcmUoXCIuL2NoZWNrYm94X2dyb3VwXCIpO1xuZXhwb3J0cy5DaGVja2JveEdyb3VwID0gY2hlY2tib3hfZ3JvdXBfMS5DaGVja2JveEdyb3VwO1xudmFyIHJhZGlvX2dyb3VwXzEgPSByZXF1aXJlKFwiLi9yYWRpb19ncm91cFwiKTtcbmV4cG9ydHMuUmFkaW9Hcm91cCA9IHJhZGlvX2dyb3VwXzEuUmFkaW9Hcm91cDtcbnZhciBjaGVja2JveF9idXR0b25fZ3JvdXBfMSA9IHJlcXVpcmUoXCIuL2NoZWNrYm94X2J1dHRvbl9ncm91cFwiKTtcbmV4cG9ydHMuQ2hlY2tib3hCdXR0b25Hcm91cCA9IGNoZWNrYm94X2J1dHRvbl9ncm91cF8xLkNoZWNrYm94QnV0dG9uR3JvdXA7XG52YXIgcmFkaW9fYnV0dG9uX2dyb3VwXzEgPSByZXF1aXJlKFwiLi9yYWRpb19idXR0b25fZ3JvdXBcIik7XG5leHBvcnRzLlJhZGlvQnV0dG9uR3JvdXAgPSByYWRpb19idXR0b25fZ3JvdXBfMS5SYWRpb0J1dHRvbkdyb3VwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHdpZGdldF8xID0gcmVxdWlyZShcIi4vd2lkZ2V0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5JbnB1dFdpZGdldFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW5wdXRXaWRnZXRWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBJbnB1dFdpZGdldFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBJbnB1dFdpZGdldFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIElucHV0V2lkZ2V0Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBJbnB1dFdpZGdldFZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy4kZWwuZmluZCgnaW5wdXQnKS5wcm9wKFwiZGlzYWJsZWRcIiwgdGhpcy5tb2RlbC5kaXNhYmxlZCk7XG4gICAgfTtcbiAgICBJbnB1dFdpZGdldFZpZXcucHJvdG90eXBlLmNoYW5nZV9pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLm1vZGVsLmNhbGxiYWNrKSAhPSBudWxsID8gcmVmLmV4ZWN1dGUodGhpcy5tb2RlbCkgOiB2b2lkIDA7XG4gICAgfTtcbiAgICByZXR1cm4gSW5wdXRXaWRnZXRWaWV3O1xufSkod2lkZ2V0XzEuV2lkZ2V0Vmlldyk7XG5leHBvcnRzLklucHV0V2lkZ2V0ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKElucHV0V2lkZ2V0LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBJbnB1dFdpZGdldCgpIHtcbiAgICAgICAgcmV0dXJuIElucHV0V2lkZ2V0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJbnB1dFdpZGdldC5wcm90b3R5cGUudHlwZSA9IFwiSW5wdXRXaWRnZXRcIjtcbiAgICBJbnB1dFdpZGdldC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5JbnB1dFdpZGdldFZpZXc7XG4gICAgSW5wdXRXaWRnZXQuZGVmaW5lKHtcbiAgICAgICAgY2FsbGJhY2s6IFtwLkluc3RhbmNlXSxcbiAgICAgICAgdGl0bGU6IFtwLlN0cmluZywgJyddXG4gICAgfSk7XG4gICAgcmV0dXJuIElucHV0V2lkZ2V0O1xufSkod2lkZ2V0XzEuV2lkZ2V0KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIFdpZGdldHMgPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcbmV4cG9ydHMubW9kZWxzID0gV2lkZ2V0cztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvcHJvcGVydGllc1wiKTtcbnZhciB3aWRnZXRfMSA9IHJlcXVpcmUoXCIuL3dpZGdldFwiKTtcbnZhciBtYXJrdXBfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuL21hcmt1cF90ZW1wbGF0ZVwiKTtcbmV4cG9ydHMuTWFya3VwVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNYXJrdXBWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNYXJrdXBWaWV3KCkge1xuICAgICAgICByZXR1cm4gTWFya3VwVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWFya3VwVmlldy5wcm90b3R5cGUudGVtcGxhdGUgPSBtYXJrdXBfdGVtcGxhdGVfMS5kZWZhdWx0O1xuICAgIE1hcmt1cFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBNYXJrdXBWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnJlbmRlcik7XG4gICAgfTtcbiAgICBNYXJrdXBWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE1hcmt1cFZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgICAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoKSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy4kZWwuaGVpZ2h0KHRoaXMubW9kZWwuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC53aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGVsLndpZHRoKHRoaXMubW9kZWwud2lkdGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWFya3VwVmlldztcbn0pKHdpZGdldF8xLldpZGdldFZpZXcpO1xuZXhwb3J0cy5NYXJrdXAgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTWFya3VwLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNYXJrdXAoKSB7XG4gICAgICAgIHJldHVybiBNYXJrdXAuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1hcmt1cC5wcm90b3R5cGUudHlwZSA9IFwiTWFya3VwXCI7XG4gICAgTWFya3VwLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIE1hcmt1cC5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgTWFya3VwLmRlZmluZSh7XG4gICAgICAgIHRleHQ6IFtwLlN0cmluZywgJyddXG4gICAgfSk7XG4gICAgcmV0dXJuIE1hcmt1cDtcbn0pKHdpZGdldF8xLldpZGdldCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBET00gPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsL2RvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogXCJiay1tYXJrdXBcIiB9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBiaW5kID0gZnVuY3Rpb24gKGZuLCBtZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvcHJvcGVydGllc1wiKTtcbnZhciBpbnB1dF93aWRnZXRfMSA9IHJlcXVpcmUoXCIuL2lucHV0X3dpZGdldFwiKTtcbnZhciBtdWx0aXNlbGVjdHRlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi9tdWx0aXNlbGVjdHRlbXBsYXRlXCIpO1xuZXhwb3J0cy5NdWx0aVNlbGVjdFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoTXVsdGlTZWxlY3RWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNdWx0aVNlbGVjdFZpZXcoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyX3NlbGVjdGlvbiA9IGJpbmQodGhpcy5yZW5kZXJfc2VsZWN0aW9uLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIE11bHRpU2VsZWN0Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTXVsdGlTZWxlY3RWaWV3LnByb3RvdHlwZS50YWdOYW1lID0gXCJkaXZcIjtcbiAgICBNdWx0aVNlbGVjdFZpZXcucHJvdG90eXBlLnRlbXBsYXRlID0gbXVsdGlzZWxlY3R0ZW1wbGF0ZV8xLmRlZmF1bHQ7XG4gICAgTXVsdGlTZWxlY3RWaWV3LnByb3RvdHlwZS5ldmVudHMgPSB7XG4gICAgICAgIFwiY2hhbmdlIHNlbGVjdFwiOiBcImNoYW5nZV9pbnB1dFwiXG4gICAgfTtcbiAgICBNdWx0aVNlbGVjdFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBNdWx0aVNlbGVjdFZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOnZhbHVlJywgdGhpcy5yZW5kZXJfc2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOm9wdGlvbnMnLCB0aGlzLnJlbmRlcik7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZTpuYW1lJywgdGhpcy5yZW5kZXIpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6dGl0bGUnLCB0aGlzLnJlbmRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6c2l6ZScsIHRoaXMucmVuZGVyKTtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaHRtbDtcbiAgICAgICAgTXVsdGlTZWxlY3RWaWV3Ll9fc3VwZXJfXy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICAgICAgaHRtbCA9IHRoaXMudGVtcGxhdGUodGhpcy5tb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdGhpcy4kZWwuaHRtbChodG1sKTtcbiAgICAgICAgdGhpcy5yZW5kZXJfc2VsZWN0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTXVsdGlTZWxlY3RWaWV3LnByb3RvdHlwZS5yZW5kZXJfc2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgbGVuLCByZWYsIHZhbHVlcywgeDtcbiAgICAgICAgdmFsdWVzID0ge307XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwudmFsdWU7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgeCA9IHJlZltpXTtcbiAgICAgICAgICAgIHZhbHVlc1t4XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWwuZmluZCgnb3B0aW9uJykuZWFjaCgoZnVuY3Rpb24gKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBfdGhpcy4kZWwuZmluZChlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tlbC5hdHRyKCd2YWx1ZScpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuYXR0cignc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5maW5kKCdzZWxlY3QnKS5hdHRyKCdzaXplJywgdGhpcy5tb2RlbC5zaXplKTtcbiAgICB9O1xuICAgIE11bHRpU2VsZWN0Vmlldy5wcm90b3R5cGUuY2hhbmdlX2lucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNfZm9jdXNlZCwgdmFsdWU7XG4gICAgICAgIGlzX2ZvY3VzZWQgPSB0aGlzLiRlbC5maW5kKCdzZWxlY3Q6Zm9jdXMnKS5zaXplKCk7XG4gICAgICAgIHZhbHVlID0gdGhpcy4kZWwuZmluZCgnc2VsZWN0JykudmFsKCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC52YWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIE11bHRpU2VsZWN0Vmlldy5fX3N1cGVyX18uY2hhbmdlX2lucHV0LmNhbGwodGhpcyk7XG4gICAgICAgIGlmIChpc19mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZWwuZmluZCgnc2VsZWN0JykuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE11bHRpU2VsZWN0Vmlldztcbn0pKGlucHV0X3dpZGdldF8xLklucHV0V2lkZ2V0Vmlldyk7XG5leHBvcnRzLk11bHRpU2VsZWN0ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE11bHRpU2VsZWN0LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBNdWx0aVNlbGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIE11bHRpU2VsZWN0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUudHlwZSA9IFwiTXVsdGlTZWxlY3RcIjtcbiAgICBNdWx0aVNlbGVjdC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5NdWx0aVNlbGVjdFZpZXc7XG4gICAgTXVsdGlTZWxlY3QuZGVmaW5lKHtcbiAgICAgICAgdmFsdWU6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIG9wdGlvbnM6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIHNpemU6IFtwLk51bWJlciwgNF1cbiAgICB9KTtcbiAgICByZXR1cm4gTXVsdGlTZWxlY3Q7XG59KShpbnB1dF93aWRnZXRfMS5JbnB1dFdpZGdldCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG52YXIgRE9NID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdXRpbC9kb21cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICByZXR1cm4gKERPTS5jcmVhdGVFbGVtZW50KFwiZnJhZ21lbnRcIiwgbnVsbCxcbiAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLCB7IGZvcjogcHJvcHMuaWQgfSxcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgcHJvcHMudGl0bGUsXG4gICAgICAgICAgICBcIiBcIiksXG4gICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHsgbXVsdGlwbGU6IHRydWUsIGNsYXNzOiBcImJrLXdpZGdldC1mb3JtLWlucHV0XCIsIGlkOiBwcm9wcy5pZCwgbmFtZTogcHJvcHMubmFtZSB9LCBwcm9wcy5vcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsIGxhYmVsO1xuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGFiZWwgPSBvcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9wdGlvblswXSwgbGFiZWwgPSBvcHRpb25bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBwcm9wcy52YWx1ZS5pbmRleE9mKHZhbHVlKSA+IC0xO1xuICAgICAgICAgICAgcmV0dXJuIERPTS5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsgc2VsZWN0ZWQ6IHNlbGVjdGVkLCB2YWx1ZTogdmFsdWUgfSwgbGFiZWwpO1xuICAgICAgICB9KSkpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgcCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi93aWRnZXRcIik7XG5leHBvcnRzLlBhbmVsVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYW5lbFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFBhbmVsVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFBhbmVsVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFuZWxWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFBhbmVsVmlldy5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFBhbmVsVmlldztcbn0pKHdpZGdldF8xLldpZGdldFZpZXcpO1xuZXhwb3J0cy5QYW5lbCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYW5lbCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUGFuZWwoKSB7XG4gICAgICAgIHJldHVybiBQYW5lbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFuZWwucHJvdG90eXBlLnR5cGUgPSBcIlBhbmVsXCI7XG4gICAgUGFuZWwucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUGFuZWxWaWV3O1xuICAgIFBhbmVsLmRlZmluZSh7XG4gICAgICAgIHRpdGxlOiBbcC5TdHJpbmcsIFwiXCJdLFxuICAgICAgICBjaGlsZDogW3AuSW5zdGFuY2VdLFxuICAgICAgICBjbG9zYWJsZTogW3AuQm9vbCwgZmFsc2VdXG4gICAgfSk7XG4gICAgcmV0dXJuIFBhbmVsO1xufSkod2lkZ2V0XzEuV2lkZ2V0KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbnZhciBtYXJrdXBfMSA9IHJlcXVpcmUoXCIuL21hcmt1cFwiKTtcbmV4cG9ydHMuUGFyYWdyYXBoVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYXJhZ3JhcGhWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBQYXJhZ3JhcGhWaWV3KCkge1xuICAgICAgICByZXR1cm4gUGFyYWdyYXBoVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFyYWdyYXBoVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJHBhcmE7XG4gICAgICAgIFBhcmFncmFwaFZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICAkcGFyYSA9ICQoJzxwIHN0eWxlPVwibWFyZ2luOiAwO1wiPjwvcD4nKS50ZXh0KHRoaXMubW9kZWwudGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5maW5kKCcuYmstbWFya3VwJykuYXBwZW5kKCRwYXJhKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJhZ3JhcGhWaWV3O1xufSkobWFya3VwXzEuTWFya3VwVmlldyk7XG5leHBvcnRzLlBhcmFncmFwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYXJhZ3JhcGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFBhcmFncmFwaCgpIHtcbiAgICAgICAgcmV0dXJuIFBhcmFncmFwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS50eXBlID0gXCJQYXJhZ3JhcGhcIjtcbiAgICBQYXJhZ3JhcGgucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUGFyYWdyYXBoVmlldztcbiAgICByZXR1cm4gUGFyYWdyYXBoO1xufSkobWFya3VwXzEuTWFya3VwKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbnZhciBtYXJrdXBfMSA9IHJlcXVpcmUoXCIuL21hcmt1cFwiKTtcbmV4cG9ydHMuUHJlVGV4dFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUHJlVGV4dFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFByZVRleHRWaWV3KCkge1xuICAgICAgICByZXR1cm4gUHJlVGV4dFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFByZVRleHRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkcHJlO1xuICAgICAgICBQcmVUZXh0Vmlldy5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgICRwcmUgPSAkKCc8cHJlIHN0eWxlPVwib3ZlcmZsb3c6IGF1dG9cIj48L3ByZT4nKS50ZXh0KHRoaXMubW9kZWwudGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5maW5kKCcuYmstbWFya3VwJykuYXBwZW5kKCRwcmUpO1xuICAgIH07XG4gICAgcmV0dXJuIFByZVRleHRWaWV3O1xufSkobWFya3VwXzEuTWFya3VwVmlldyk7XG5leHBvcnRzLlByZVRleHQgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUHJlVGV4dCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gUHJlVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFByZVRleHQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFByZVRleHQucHJvdG90eXBlLnR5cGUgPSBcIlByZVRleHRcIjtcbiAgICBQcmVUZXh0LnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlByZVRleHRWaWV3O1xuICAgIHJldHVybiBQcmVUZXh0O1xufSkobWFya3VwXzEuTWFya3VwKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG52YXIgJCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XG5yZXF1aXJlKFwiYm9vdHN0cmFwL2J1dHRvblwiKTtcbnZhciBwID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvcHJvcGVydGllc1wiKTtcbnZhciB3aWRnZXRfMSA9IHJlcXVpcmUoXCIuL3dpZGdldFwiKTtcbnZhciBidXR0b25fZ3JvdXBfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuL2J1dHRvbl9ncm91cF90ZW1wbGF0ZVwiKTtcbmV4cG9ydHMuUmFkaW9CdXR0b25Hcm91cFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmFkaW9CdXR0b25Hcm91cFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJhZGlvQnV0dG9uR3JvdXBWaWV3KCkge1xuICAgICAgICByZXR1cm4gUmFkaW9CdXR0b25Hcm91cFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJhZGlvQnV0dG9uR3JvdXBWaWV3LnByb3RvdHlwZS5ldmVudHMgPSB7XG4gICAgICAgIFwiY2hhbmdlIGlucHV0XCI6IFwiY2hhbmdlX2lucHV0XCJcbiAgICB9O1xuICAgIFJhZGlvQnV0dG9uR3JvdXBWaWV3LnByb3RvdHlwZS50ZW1wbGF0ZSA9IGJ1dHRvbl9ncm91cF90ZW1wbGF0ZV8xLmRlZmF1bHQ7XG4gICAgUmFkaW9CdXR0b25Hcm91cFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBSYWRpb0J1dHRvbkdyb3VwVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgdGhpcy5yZW5kZXIpO1xuICAgIH07XG4gICAgUmFkaW9CdXR0b25Hcm91cFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRpbnB1dCwgJGxhYmVsLCBhY3RpdmUsIGh0bWwsIGksIGosIGxhYmVsLCBsZW4sIG5hbWUsIHJlZjtcbiAgICAgICAgUmFkaW9CdXR0b25Hcm91cFZpZXcuX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgICAgICBodG1sID0gdGhpcy50ZW1wbGF0ZSgpO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoaHRtbCk7XG4gICAgICAgIG5hbWUgPSBfLnVuaXF1ZUlkKFwiUmFkaW9CdXR0b25Hcm91cFwiKTtcbiAgICAgICAgYWN0aXZlID0gdGhpcy5tb2RlbC5hY3RpdmU7XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwubGFiZWxzO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgICAgICAgICAgbGFiZWwgPSByZWZbaV07XG4gICAgICAgICAgICAkaW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInJhZGlvXCI+JykuYXR0cih7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIiArIGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGkgPT09IGFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICRpbnB1dC5wcm9wKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRsYWJlbCA9ICQoJzxsYWJlbCBjbGFzcz1cImJrLWJzLWJ0blwiPjwvbGFiZWw+Jyk7XG4gICAgICAgICAgICAkbGFiZWwudGV4dChsYWJlbCkucHJlcGVuZCgkaW5wdXQpO1xuICAgICAgICAgICAgJGxhYmVsLmFkZENsYXNzKFwiYmstYnMtYnRuLVwiICsgdGhpcy5tb2RlbC5idXR0b25fdHlwZSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgJGxhYmVsLmFkZENsYXNzKFwiYmstYnMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kZWwuZmluZCgnLmJrLWJzLWJ0bi1ncm91cCcpLmFwcGVuZCgkbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmFkaW9CdXR0b25Hcm91cFZpZXcucHJvdG90eXBlLmNoYW5nZV9pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZSwgaSwgcmFkaW8sIHJlZjtcbiAgICAgICAgYWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuJGVsLmZpbmQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICAgICAgICAgICAgcmFkaW8gPSByZWZbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJhZGlvLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFjdGl2ZSA9IGFjdGl2ZVswXTtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLm1vZGVsLmNhbGxiYWNrKSAhPSBudWxsID8gcmVmLmV4ZWN1dGUodGhpcy5tb2RlbCkgOiB2b2lkIDA7XG4gICAgfTtcbiAgICByZXR1cm4gUmFkaW9CdXR0b25Hcm91cFZpZXc7XG59KSh3aWRnZXRfMS5XaWRnZXRWaWV3KTtcbmV4cG9ydHMuUmFkaW9CdXR0b25Hcm91cCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChSYWRpb0J1dHRvbkdyb3VwLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSYWRpb0J1dHRvbkdyb3VwKCkge1xuICAgICAgICByZXR1cm4gUmFkaW9CdXR0b25Hcm91cC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmFkaW9CdXR0b25Hcm91cC5wcm90b3R5cGUudHlwZSA9IFwiUmFkaW9CdXR0b25Hcm91cFwiO1xuICAgIFJhZGlvQnV0dG9uR3JvdXAucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuUmFkaW9CdXR0b25Hcm91cFZpZXc7XG4gICAgUmFkaW9CdXR0b25Hcm91cC5kZWZpbmUoe1xuICAgICAgICBhY3RpdmU6IFtwLkFueSwgbnVsbF0sXG4gICAgICAgIGxhYmVsczogW3AuQXJyYXksIFtdXSxcbiAgICAgICAgYnV0dG9uX3R5cGU6IFtwLlN0cmluZywgXCJkZWZhdWx0XCJdLFxuICAgICAgICBjYWxsYmFjazogW3AuSW5zdGFuY2VdXG4gICAgfSk7XG4gICAgcmV0dXJuIFJhZGlvQnV0dG9uR3JvdXA7XG59KSh3aWRnZXRfMS5XaWRnZXQpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbnZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbnZhciBwID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvcHJvcGVydGllc1wiKTtcbnZhciB3aWRnZXRfMSA9IHJlcXVpcmUoXCIuL3dpZGdldFwiKTtcbmV4cG9ydHMuUmFkaW9Hcm91cFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmFkaW9Hcm91cFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJhZGlvR3JvdXBWaWV3KCkge1xuICAgICAgICByZXR1cm4gUmFkaW9Hcm91cFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJhZGlvR3JvdXBWaWV3LnByb3RvdHlwZS50YWdOYW1lID0gXCJkaXZcIjtcbiAgICBSYWRpb0dyb3VwVmlldy5wcm90b3R5cGUuZXZlbnRzID0ge1xuICAgICAgICBcImNoYW5nZSBpbnB1dFwiOiBcImNoYW5nZV9pbnB1dFwiXG4gICAgfTtcbiAgICBSYWRpb0dyb3VwVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFJhZGlvR3JvdXBWaWV3Ll9fc3VwZXJfXy5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnJlbmRlcik7XG4gICAgfTtcbiAgICBSYWRpb0dyb3VwVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGRpdiwgJGlucHV0LCAkbGFiZWwsIGFjdGl2ZSwgaSwgaiwgbGFiZWwsIGxlbiwgbmFtZSwgcmVmO1xuICAgICAgICBSYWRpb0dyb3VwVmlldy5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIG5hbWUgPSBfLnVuaXF1ZUlkKFwiUmFkaW9Hcm91cFwiKTtcbiAgICAgICAgYWN0aXZlID0gdGhpcy5tb2RlbC5hY3RpdmU7XG4gICAgICAgIHJlZiA9IHRoaXMubW9kZWwubGFiZWxzO1xuICAgICAgICBmb3IgKGkgPSBqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgICAgICAgICAgbGFiZWwgPSByZWZbaV07XG4gICAgICAgICAgICAkaW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInJhZGlvXCI+JykuYXR0cih7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIiArIGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAkaW5wdXQucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IGFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICRpbnB1dC5wcm9wKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRsYWJlbCA9ICQoJzxsYWJlbD48L2xhYmVsPicpLnRleHQobGFiZWwpLnByZXBlbmQoJGlucHV0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLmlubGluZSkge1xuICAgICAgICAgICAgICAgICRsYWJlbC5hZGRDbGFzcyhcImJrLWJzLXJhZGlvLWlubGluZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5hcHBlbmQoJGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICRkaXYgPSAkKCc8ZGl2IGNsYXNzPVwiYmstYnMtcmFkaW9cIj48L2Rpdj4nKS5hcHBlbmQoJGxhYmVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5hcHBlbmQoJGRpdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSYWRpb0dyb3VwVmlldy5wcm90b3R5cGUuY2hhbmdlX2lucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aXZlLCBpLCByYWRpbywgcmVmO1xuICAgICAgICBhY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGosIGxlbiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVmID0gdGhpcy4kZWwuZmluZChcImlucHV0XCIpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGkgPSArK2opIHtcbiAgICAgICAgICAgICAgICByYWRpbyA9IHJlZltpXTtcbiAgICAgICAgICAgICAgICBpZiAocmFkaW8uY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubW9kZWwuYWN0aXZlID0gYWN0aXZlWzBdO1xuICAgICAgICByZXR1cm4gKHJlZiA9IHRoaXMubW9kZWwuY2FsbGJhY2spICE9IG51bGwgPyByZWYuZXhlY3V0ZSh0aGlzLm1vZGVsKSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIHJldHVybiBSYWRpb0dyb3VwVmlldztcbn0pKHdpZGdldF8xLldpZGdldFZpZXcpO1xuZXhwb3J0cy5SYWRpb0dyb3VwID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJhZGlvR3JvdXAsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFJhZGlvR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiBSYWRpb0dyb3VwLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSYWRpb0dyb3VwLnByb3RvdHlwZS50eXBlID0gXCJSYWRpb0dyb3VwXCI7XG4gICAgUmFkaW9Hcm91cC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5SYWRpb0dyb3VwVmlldztcbiAgICBSYWRpb0dyb3VwLmRlZmluZSh7XG4gICAgICAgIGFjdGl2ZTogW3AuQW55LCBudWxsXSxcbiAgICAgICAgbGFiZWxzOiBbcC5BcnJheSwgW11dLFxuICAgICAgICBpbmxpbmU6IFtwLkJvb2wsIGZhbHNlXSxcbiAgICAgICAgY2FsbGJhY2s6IFtwLkluc3RhbmNlXVxuICAgIH0pO1xuICAgIHJldHVybiBSYWRpb0dyb3VwO1xufSkod2lkZ2V0XzEuV2lkZ2V0KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGJpbmQgPSBmdW5jdGlvbiAoZm4sIG1lKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSwgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbnJlcXVpcmUoXCJqcXVlcnktdWkvc2xpZGVyXCIpO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2xvZ2dpbmdcIik7XG52YXIgcCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgaW5wdXRfd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi9pbnB1dF93aWRnZXRcIik7XG52YXIgc2xpZGVydGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuL3NsaWRlcnRlbXBsYXRlXCIpO1xuZXhwb3J0cy5SYW5nZVNsaWRlclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmFuZ2VTbGlkZXJWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSYW5nZVNsaWRlclZpZXcoKSB7XG4gICAgICAgIHRoaXMuc2xpZGUgPSBiaW5kKHRoaXMuc2xpZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLnNsaWRlc3RvcCA9IGJpbmQodGhpcy5zbGlkZXN0b3AsIHRoaXMpO1xuICAgICAgICByZXR1cm4gUmFuZ2VTbGlkZXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSYW5nZVNsaWRlclZpZXcucHJvdG90eXBlLnRhZ05hbWUgPSBcImRpdlwiO1xuICAgIFJhbmdlU2xpZGVyVmlldy5wcm90b3R5cGUudGVtcGxhdGUgPSBzbGlkZXJ0ZW1wbGF0ZV8xLmRlZmF1bHQ7XG4gICAgUmFuZ2VTbGlkZXJWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgIFJhbmdlU2xpZGVyVmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLnJlbmRlcik7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIGh0bWwgPSB0aGlzLnRlbXBsYXRlKHRoaXMubW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMuJGVsLmh0bWwoaHRtbCk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tXcmFwcGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuY2FsbGJhY2tfcG9saWN5ID09PSAnY29udGludW91cycpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLm1vZGVsLmNhbGxiYWNrKSAhPSBudWxsID8gcmVmLmV4ZWN1dGUodGhpcy5tb2RlbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmNhbGxiYWNrX3BvbGljeSA9PT0gJ3Rocm90dGxlJyAmJiB0aGlzLm1vZGVsLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrV3JhcHBlciA9IF8udGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLm1vZGVsLmNhbGxiYWNrKSAhPSBudWxsID8gcmVmLmV4ZWN1dGUodGhpcy5tb2RlbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICB9LCB0aGlzLm1vZGVsLmNhbGxiYWNrX3Rocm90dGxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcbiAgICB9O1xuICAgIFJhbmdlU2xpZGVyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmtfaGFuZGxlLCBtYXgsIG1pbiwgb3B0cywgc3RlcDtcbiAgICAgICAgUmFuZ2VTbGlkZXJWaWV3Ll9fc3VwZXJfXy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgbWF4ID0gdGhpcy5tb2RlbC5lbmQ7XG4gICAgICAgIG1pbiA9IHRoaXMubW9kZWwuc3RhcnQ7XG4gICAgICAgIHN0ZXAgPSB0aGlzLm1vZGVsLnN0ZXAgfHwgKChtYXggLSBtaW4pIC8gNTApO1xuICAgICAgICBsb2dnaW5nXzEubG9nZ2VyLmRlYnVnKFwicmFuZ2Utc2xpZGVyIHJlbmRlcjogbWluLCBtYXgsIHN0ZXAgPSAoXCIgKyBtaW4gKyBcIiwgXCIgKyBtYXggKyBcIiwgXCIgKyBzdGVwICsgXCIpXCIpO1xuICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgcmFuZ2U6IHRydWUsXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogdGhpcy5tb2RlbC5vcmllbnRhdGlvbixcbiAgICAgICAgICAgIGFuaW1hdGU6IFwiZmFzdFwiLFxuICAgICAgICAgICAgdmFsdWVzOiB0aGlzLm1vZGVsLnJhbmdlLFxuICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICBzdG9wOiB0aGlzLnNsaWRlc3RvcCxcbiAgICAgICAgICAgIHNsaWRlOiB0aGlzLnNsaWRlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuJGVsLmZpbmQoJy5zbGlkZXInKS5zbGlkZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoXCIjXCIgKyB0aGlzLm1vZGVsLmlkKS52YWwodGhpcy4kZWwuZmluZCgnLnNsaWRlcicpLnNsaWRlcigndmFsdWVzJykuam9pbignIC0gJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVsLmZpbmQoJy5iay1zbGlkZXItcGFyZW50JykuaGVpZ2h0KHRoaXMubW9kZWwuaGVpZ2h0KTtcbiAgICAgICAgYmtfaGFuZGxlID0gdGhpcy4kZWwuZmluZCgnLmJrLXVpLXNsaWRlci1oYW5kbGUnKTtcbiAgICAgICAgaWYgKGJrX2hhbmRsZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGJrX2hhbmRsZVswXS5zdHlsZS5sZWZ0ID0gdGhpcy4kZWwuZmluZCgnLnVpLXNsaWRlci1oYW5kbGUnKVswXS5zdHlsZS5sZWZ0O1xuICAgICAgICAgICAgYmtfaGFuZGxlWzFdLnN0eWxlLmxlZnQgPSB0aGlzLiRlbC5maW5kKCcudWktc2xpZGVyLWhhbmRsZScpWzFdLnN0eWxlLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSYW5nZVNsaWRlclZpZXcucHJvdG90eXBlLnNsaWRlc3RvcCA9IGZ1bmN0aW9uIChldmVudCwgdWkpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuY2FsbGJhY2tfcG9saWN5ID09PSAnbW91c2V1cCcgfHwgdGhpcy5tb2RlbC5jYWxsYmFja19wb2xpY3kgPT09ICd0aHJvdHRsZScpIHtcbiAgICAgICAgICAgIHJldHVybiAocmVmID0gdGhpcy5tb2RlbC5jYWxsYmFjaykgIT0gbnVsbCA/IHJlZi5leGVjdXRlKHRoaXMubW9kZWwpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYW5nZVNsaWRlclZpZXcucHJvdG90eXBlLnNsaWRlID0gZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xuICAgICAgICB2YXIgdmFsdWVzLCB2YWx1ZXNfc3RyO1xuICAgICAgICB2YWx1ZXMgPSB1aS52YWx1ZXM7XG4gICAgICAgIHZhbHVlc19zdHIgPSB2YWx1ZXMuam9pbignIC0gJyk7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJyYW5nZS1zbGlkZSB2YWx1ZSA9IFwiICsgdmFsdWVzX3N0cik7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoXCIjXCIgKyB0aGlzLm1vZGVsLmlkKS52YWwodmFsdWVzX3N0cik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5yYW5nZSA9IHZhbHVlcztcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tXcmFwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsYmFja1dyYXBwZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJhbmdlU2xpZGVyVmlldztcbn0pKGlucHV0X3dpZGdldF8xLklucHV0V2lkZ2V0Vmlldyk7XG5leHBvcnRzLlJhbmdlU2xpZGVyID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFJhbmdlU2xpZGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBSYW5nZVNsaWRlcigpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2xpZGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSYW5nZVNsaWRlci5wcm90b3R5cGUudHlwZSA9IFwiUmFuZ2VTbGlkZXJcIjtcbiAgICBSYW5nZVNsaWRlci5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5SYW5nZVNsaWRlclZpZXc7XG4gICAgUmFuZ2VTbGlkZXIuZGVmaW5lKHtcbiAgICAgICAgcmFuZ2U6IFtwLkFueSwgWzAuMSwgMC45XV0sXG4gICAgICAgIHN0YXJ0OiBbcC5OdW1iZXIsIDBdLFxuICAgICAgICBlbmQ6IFtwLk51bWJlciwgMV0sXG4gICAgICAgIHN0ZXA6IFtwLk51bWJlciwgMC4xXSxcbiAgICAgICAgb3JpZW50YXRpb246IFtwLk9yaWVudGF0aW9uLCBcImhvcml6b250YWxcIl0sXG4gICAgICAgIGNhbGxiYWNrX3Rocm90dGxlOiBbcC5OdW1iZXIsIDIwMF0sXG4gICAgICAgIGNhbGxiYWNrX3BvbGljeTogW3AuU3RyaW5nLCBcInRocm90dGxlXCJdXG4gICAgfSk7XG4gICAgcmV0dXJuIFJhbmdlU2xpZGVyO1xufSkoaW5wdXRfd2lkZ2V0XzEuSW5wdXRXaWRnZXQpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2xvZ2dpbmdcIik7XG52YXIgcCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgaW5wdXRfd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi9pbnB1dF93aWRnZXRcIik7XG52YXIgc2VsZWN0dGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuL3NlbGVjdHRlbXBsYXRlXCIpO1xuZXhwb3J0cy5TZWxlY3RWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNlbGVjdFZpZXcsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNlbGVjdFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3RWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZWxlY3RWaWV3LnByb3RvdHlwZS50ZW1wbGF0ZSA9IHNlbGVjdHRlbXBsYXRlXzEuZGVmYXVsdDtcbiAgICBTZWxlY3RWaWV3LnByb3RvdHlwZS5ldmVudHMgPSB7XG4gICAgICAgIFwiY2hhbmdlIHNlbGVjdFwiOiBcImNoYW5nZV9pbnB1dFwiXG4gICAgfTtcbiAgICBTZWxlY3RWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgU2VsZWN0Vmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgdGhpcy5yZW5kZXIpO1xuICAgIH07XG4gICAgU2VsZWN0Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaHRtbDtcbiAgICAgICAgU2VsZWN0Vmlldy5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIGh0bWwgPSB0aGlzLnRlbXBsYXRlKHRoaXMubW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMuJGVsLmh0bWwoaHRtbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VsZWN0Vmlldy5wcm90b3R5cGUuY2hhbmdlX2lucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHZhbHVlID0gdGhpcy4kZWwuZmluZCgnc2VsZWN0JykudmFsKCk7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2dnZXIuZGVidWcoXCJzZWxlY3Rib3g6IHZhbHVlID0gXCIgKyB2YWx1ZSk7XG4gICAgICAgIHRoaXMubW9kZWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIFNlbGVjdFZpZXcuX19zdXBlcl9fLmNoYW5nZV9pbnB1dC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdFZpZXc7XG59KShpbnB1dF93aWRnZXRfMS5JbnB1dFdpZGdldFZpZXcpO1xuZXhwb3J0cy5TZWxlY3QgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2VsZWN0LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTZWxlY3QoKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3QuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlbGVjdC5wcm90b3R5cGUudHlwZSA9IFwiU2VsZWN0XCI7XG4gICAgU2VsZWN0LnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlNlbGVjdFZpZXc7XG4gICAgU2VsZWN0LmRlZmluZSh7XG4gICAgICAgIHZhbHVlOiBbcC5TdHJpbmcsICcnXSxcbiAgICAgICAgb3B0aW9uczogW3AuQW55LCBbXV1cbiAgICB9KTtcbiAgICByZXR1cm4gU2VsZWN0O1xufSkoaW5wdXRfd2lkZ2V0XzEuSW5wdXRXaWRnZXQpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xudmFyIERPTSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3V0aWwvZG9tXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgcmV0dXJuIChET00uY3JlYXRlRWxlbWVudChcImZyYWdtZW50XCIsIG51bGwsXG4gICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgeyBmb3I6IHByb3BzLmlkIH0sXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIHByb3BzLnRpdGxlLFxuICAgICAgICAgICAgXCIgXCIpLFxuICAgICAgICBET00uY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCB7IGNsYXNzOiBcImJrLXdpZGdldC1mb3JtLWlucHV0XCIsIGlkOiBwcm9wcy5pZCwgbmFtZTogcHJvcHMubmFtZSB9LCBwcm9wcy5vcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsIGxhYmVsO1xuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGFiZWwgPSBvcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9wdGlvblswXSwgbGFiZWwgPSBvcHRpb25bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBwcm9wcy52YWx1ZSA9PSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBET00uY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IHNlbGVjdGVkOiBzZWxlY3RlZCwgdmFsdWU6IHZhbHVlIH0sIGxhYmVsKTtcbiAgICAgICAgfSkpKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYmluZCA9IGZ1bmN0aW9uIChmbiwgbWUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LCBleHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7XG4gICAgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpXG4gICAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbn0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LCBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xucmVxdWlyZShcImpxdWVyeS11aS9zbGlkZXJcIik7XG52YXIgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvbG9nZ2luZ1wiKTtcbnZhciBwID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvcHJvcGVydGllc1wiKTtcbnZhciBpbnB1dF93aWRnZXRfMSA9IHJlcXVpcmUoXCIuL2lucHV0X3dpZGdldFwiKTtcbnZhciBzbGlkZXJ0ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4vc2xpZGVydGVtcGxhdGVcIik7XG5leHBvcnRzLlNsaWRlclZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2xpZGVyVmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gU2xpZGVyVmlldygpIHtcbiAgICAgICAgdGhpcy5zbGlkZSA9IGJpbmQodGhpcy5zbGlkZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2xpZGVzdG9wID0gYmluZCh0aGlzLnNsaWRlc3RvcCwgdGhpcyk7XG4gICAgICAgIHJldHVybiBTbGlkZXJWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTbGlkZXJWaWV3LnByb3RvdHlwZS50YWdOYW1lID0gXCJkaXZcIjtcbiAgICBTbGlkZXJWaWV3LnByb3RvdHlwZS50ZW1wbGF0ZSA9IHNsaWRlcnRlbXBsYXRlXzEuZGVmYXVsdDtcbiAgICBTbGlkZXJWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgIFNsaWRlclZpZXcuX19zdXBlcl9fLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgdGhpcy5yZW5kZXIpO1xuICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgICAgICBodG1sID0gdGhpcy50ZW1wbGF0ZSh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLiRlbC5odG1sKGh0bWwpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrV3JhcHBlciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmNhbGxiYWNrX3BvbGljeSA9PT0gJ2NvbnRpbnVvdXMnKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVmID0gdGhpcy5tb2RlbC5jYWxsYmFjaykgIT0gbnVsbCA/IHJlZi5leGVjdXRlKHRoaXMubW9kZWwpIDogdm9pZCAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbC5jYWxsYmFja19wb2xpY3kgPT09ICd0aHJvdHRsZScgJiYgdGhpcy5tb2RlbC5jYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja1dyYXBwZXIgPSBfLnRocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVmID0gdGhpcy5tb2RlbC5jYWxsYmFjaykgIT0gbnVsbCA/IHJlZi5leGVjdXRlKHRoaXMubW9kZWwpIDogdm9pZCAwO1xuICAgICAgICAgICAgfSwgdGhpcy5tb2RlbC5jYWxsYmFja190aHJvdHRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKCk7XG4gICAgfTtcbiAgICBTbGlkZXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXgsIG1pbiwgb3B0cywgc3RlcDtcbiAgICAgICAgU2xpZGVyVmlldy5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIG1heCA9IHRoaXMubW9kZWwuZW5kO1xuICAgICAgICBtaW4gPSB0aGlzLm1vZGVsLnN0YXJ0O1xuICAgICAgICBzdGVwID0gdGhpcy5tb2RlbC5zdGVwIHx8ICgobWF4IC0gbWluKSAvIDUwKTtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcInNsaWRlciByZW5kZXI6IG1pbiwgbWF4LCBzdGVwID0gKFwiICsgbWluICsgXCIsIFwiICsgbWF4ICsgXCIsIFwiICsgc3RlcCArIFwiKVwiKTtcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiB0aGlzLm1vZGVsLm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgYW5pbWF0ZTogXCJmYXN0XCIsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5tb2RlbC52YWx1ZSxcbiAgICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgc3RvcDogdGhpcy5zbGlkZXN0b3AsXG4gICAgICAgICAgICBzbGlkZTogdGhpcy5zbGlkZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLiRlbC5maW5kKCcuc2xpZGVyJykuc2xpZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC50aXRsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5maW5kKFwiI1wiICsgdGhpcy5tb2RlbC5pZCkudmFsKHRoaXMuJGVsLmZpbmQoJy5zbGlkZXInKS5zbGlkZXIoJ3ZhbHVlJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVsLmZpbmQoJy5iay1zbGlkZXItcGFyZW50JykuaGVpZ2h0KHRoaXMubW9kZWwuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTbGlkZXJWaWV3LnByb3RvdHlwZS5zbGlkZXN0b3AgPSBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmNhbGxiYWNrX3BvbGljeSA9PT0gJ21vdXNldXAnIHx8IHRoaXMubW9kZWwuY2FsbGJhY2tfcG9saWN5ID09PSAndGhyb3R0bGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gKHJlZiA9IHRoaXMubW9kZWwuY2FsbGJhY2spICE9IG51bGwgPyByZWYuZXhlY3V0ZSh0aGlzLm1vZGVsKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2xpZGVyVmlldy5wcm90b3R5cGUuc2xpZGUgPSBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSB1aS52YWx1ZTtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcInNsaWRlIHZhbHVlID0gXCIgKyB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoXCIjXCIgKyB0aGlzLm1vZGVsLmlkKS52YWwodWkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tXcmFwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsYmFja1dyYXBwZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNsaWRlclZpZXc7XG59KShpbnB1dF93aWRnZXRfMS5JbnB1dFdpZGdldFZpZXcpO1xuZXhwb3J0cy5TbGlkZXIgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU2xpZGVyLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTbGlkZXIoKSB7XG4gICAgICAgIHJldHVybiBTbGlkZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNsaWRlci5wcm90b3R5cGUudHlwZSA9IFwiU2xpZGVyXCI7XG4gICAgU2xpZGVyLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlNsaWRlclZpZXc7XG4gICAgU2xpZGVyLmRlZmluZSh7XG4gICAgICAgIHZhbHVlOiBbcC5OdW1iZXIsIDAuNV0sXG4gICAgICAgIHN0YXJ0OiBbcC5OdW1iZXIsIDBdLFxuICAgICAgICBlbmQ6IFtwLk51bWJlciwgMV0sXG4gICAgICAgIHN0ZXA6IFtwLk51bWJlciwgMC4xXSxcbiAgICAgICAgb3JpZW50YXRpb246IFtwLk9yaWVudGF0aW9uLCBcImhvcml6b250YWxcIl0sXG4gICAgICAgIGNhbGxiYWNrX3Rocm90dGxlOiBbcC5OdW1iZXIsIDIwMF0sXG4gICAgICAgIGNhbGxiYWNrX3BvbGljeTogW3AuU3RyaW5nLCBcInRocm90dGxlXCJdXG4gICAgfSk7XG4gICAgcmV0dXJuIFNsaWRlcjtcbn0pKGlucHV0X3dpZGdldF8xLklucHV0V2lkZ2V0KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIERPTSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3V0aWwvZG9tXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIHRpdGxlLCB2YWx1ZTtcbiAgICBpZiAocHJvcHMudGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvcHMudGl0bGUubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgIHRpdGxlID0gRE9NLmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLCB7IGZvcjogcHJvcHMuaWQgfSxcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBwcm9wcy50aXRsZSxcbiAgICAgICAgICAgICAgICBcIjogXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gRE9NLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IHR5cGU6IFwidGV4dFwiLCBpZDogcHJvcHMuaWQsIHJlYWRvbmx5OiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKERPTS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3M6IFwiYmstc2xpZGVyLXBhcmVudFwiIH0sXG4gICAgICAgIHRpdGxlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogXCJiay1zbGlkZXItXCIgKyBwcm9wcy5vcmllbnRhdGlvbiB9LFxuICAgICAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzczogXCJzbGlkZXJcIiwgaWQ6IHByb3BzLmlkIH0pKSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG52YXIgY2VsbF9mb3JtYXR0ZXJzXzEgPSByZXF1aXJlKFwiLi9jZWxsX2Zvcm1hdHRlcnNcIik7XG52YXIgY2VsbF9lZGl0b3JzXzEgPSByZXF1aXJlKFwiLi9jZWxsX2VkaXRvcnNcIik7XG52YXIgcCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbFwiKTtcbmV4cG9ydHMuVGFibGVDb2x1bW4gPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVGFibGVDb2x1bW4sIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQ29sdW1uKCkge1xuICAgICAgICByZXR1cm4gVGFibGVDb2x1bW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRhYmxlQ29sdW1uLnByb3RvdHlwZS50eXBlID0gJ1RhYmxlQ29sdW1uJztcbiAgICBUYWJsZUNvbHVtbi5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gbnVsbDtcbiAgICBUYWJsZUNvbHVtbi5kZWZpbmUoe1xuICAgICAgICBmaWVsZDogW3AuU3RyaW5nXSxcbiAgICAgICAgdGl0bGU6IFtwLlN0cmluZ10sXG4gICAgICAgIHdpZHRoOiBbcC5OdW1iZXIsIDMwMF0sXG4gICAgICAgIGZvcm1hdHRlcjogW1xuICAgICAgICAgICAgcC5JbnN0YW5jZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY2VsbF9mb3JtYXR0ZXJzXzEuU3RyaW5nRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGVkaXRvcjogW1xuICAgICAgICAgICAgcC5JbnN0YW5jZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY2VsbF9lZGl0b3JzXzEuU3RyaW5nRWRpdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNvcnRhYmxlOiBbcC5Cb29sLCB0cnVlXSxcbiAgICAgICAgZGVmYXVsdF9zb3J0OiBbcC5TdHJpbmcsIFwiYXNjZW5kaW5nXCJdXG4gICAgfSk7XG4gICAgVGFibGVDb2x1bW4ucHJvdG90eXBlLnRvQ29sdW1uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IF8udW5pcXVlSWQoKSxcbiAgICAgICAgICAgIGZpZWxkOiB0aGlzLmZpZWxkLFxuICAgICAgICAgICAgbmFtZTogdGhpcy50aXRsZSxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiAocmVmID0gdGhpcy5mb3JtYXR0ZXIpICE9IG51bGwgPyByZWYuZG9Gb3JtYXQuYmluZCh0aGlzLmZvcm1hdHRlcikgOiB2b2lkIDAsXG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgc29ydGFibGU6IHRoaXMuc29ydGFibGUsXG4gICAgICAgICAgICBkZWZhdWx0U29ydEFzYzogdGhpcy5kZWZhdWx0X3NvcnQgPT09IFwiYXNjZW5kaW5nXCJcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUNvbHVtbjtcbn0pKG1vZGVsXzEuTW9kZWwpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIHdpZGdldF8xID0gcmVxdWlyZShcIi4vd2lkZ2V0XCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wcm9wZXJ0aWVzXCIpO1xuZXhwb3J0cy5UYWJsZVdpZGdldCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUYWJsZVdpZGdldCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVGFibGVXaWRnZXQoKSB7XG4gICAgICAgIHJldHVybiBUYWJsZVdpZGdldC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGFibGVXaWRnZXQucHJvdG90eXBlLnR5cGUgPSBcIlRhYmxlV2lkZ2V0XCI7XG4gICAgVGFibGVXaWRnZXQuZGVmaW5lKHtcbiAgICAgICAgc291cmNlOiBbcC5JbnN0YW5jZV1cbiAgICB9KTtcbiAgICByZXR1cm4gVGFibGVXaWRnZXQ7XG59KSh3aWRnZXRfMS5XaWRnZXQpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbnZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbnJlcXVpcmUoXCJib290c3RyYXAvdGFiXCIpO1xudmFyIHAgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9wcm9wZXJ0aWVzXCIpO1xudmFyIHRhYnNfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuL3RhYnNfdGVtcGxhdGVcIik7XG52YXIgd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi93aWRnZXRcIik7XG5leHBvcnRzLlRhYnNWaWV3ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRhYnNWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUYWJzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFRhYnNWaWV3Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUYWJzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJHBhbmVscywgYWN0aXZlLCBjaGlsZCwgY2hpbGRyZW4sIGh0bWwsIGksIGtleSwgbGVuLCBwYW5lbCwgcmVmLCByZWYxLCByZWYyLCB0YWJzLCB0aGF0LCB2YWw7XG4gICAgICAgIFRhYnNWaWV3Ll9fc3VwZXJfXy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgcmVmID0gdGhpcy5jaGlsZF92aWV3cztcbiAgICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YWwgPSByZWZba2V5XTtcbiAgICAgICAgICAgIHZhbC4kZWwuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICAgICAgdGFicyA9IHRoaXMubW9kZWwudGFicztcbiAgICAgICAgYWN0aXZlID0gdGhpcy5tb2RlbC5hY3RpdmU7XG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5tb2RlbC5jaGlsZHJlbjtcbiAgICAgICAgaHRtbCA9ICQodGFic190ZW1wbGF0ZV8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgdGFiczogdGFicyxcbiAgICAgICAgICAgIGFjdGl2ZV90YWJfaWQ6IHRhYnNbYWN0aXZlXS5pZFxuICAgICAgICB9KSk7XG4gICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICBodG1sLmZpbmQoXCIuYmstYnMtbmF2IGFcIikuY2xpY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcGFuZWxJZCwgcGFuZWxJZHgsIHJlZjE7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgJCh0aGlzKS50YWIoJ3Nob3cnKTtcbiAgICAgICAgICAgIHBhbmVsSWQgPSAkKHRoaXMpLmF0dHIoJ2hyZWYnKS5yZXBsYWNlKCcjdGFiLScsICcnKTtcbiAgICAgICAgICAgIHRhYnMgPSB0aGF0Lm1vZGVsLnRhYnM7XG4gICAgICAgICAgICBwYW5lbElkeCA9IF8uZmluZEluZGV4KHRhYnMsIGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5lbC5pZCA9PT0gcGFuZWxJZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhhdC5tb2RlbC5hY3RpdmUgPSBwYW5lbElkeDtcbiAgICAgICAgICAgIHJldHVybiAocmVmMSA9IHRoYXQubW9kZWwuY2FsbGJhY2spICE9IG51bGwgPyByZWYxLmV4ZWN1dGUodGhhdC5tb2RlbCkgOiB2b2lkIDA7XG4gICAgICAgIH0pO1xuICAgICAgICAkcGFuZWxzID0gaHRtbC5maW5kKFwiLmJrLWJzLXRhYi1wYW5lXCIpO1xuICAgICAgICByZWYxID0gXy56aXAoY2hpbGRyZW4sICRwYW5lbHMpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZWYyID0gcmVmMVtpXSwgY2hpbGQgPSByZWYyWzBdLCBwYW5lbCA9IHJlZjJbMV07XG4gICAgICAgICAgICAkKHBhbmVsKS5odG1sKHRoaXMuY2hpbGRfdmlld3NbY2hpbGQuaWRdLiRlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKGh0bWwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBUYWJzVmlldztcbn0pKHdpZGdldF8xLldpZGdldFZpZXcpO1xuZXhwb3J0cy5UYWJzID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRhYnMsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFRhYnMoKSB7XG4gICAgICAgIHJldHVybiBUYWJzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUYWJzLnByb3RvdHlwZS50eXBlID0gXCJUYWJzXCI7XG4gICAgVGFicy5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5UYWJzVmlldztcbiAgICBUYWJzLmRlZmluZSh7XG4gICAgICAgIHRhYnM6IFtwLkFycmF5LCBbXV0sXG4gICAgICAgIGFjdGl2ZTogW3AuTnVtYmVyLCAwXSxcbiAgICAgICAgY2FsbGJhY2s6IFtwLkluc3RhbmNlXVxuICAgIH0pO1xuICAgIFRhYnMuZ2V0dGVycyh7XG4gICAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSwgbGVuLCByZWYsIHJlc3VsdHMsIHRhYjtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMudGFicztcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRhYiA9IHJlZltpXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGFiLmNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgVGFicy5wcm90b3R5cGUuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xuICAgIH07XG4gICAgVGFicy5wcm90b3R5cGUuZ2V0X2VkaXRfdmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGVkaXRfdmFyaWFibGVzLCBpLCBsZW4sIHJlZjtcbiAgICAgICAgZWRpdF92YXJpYWJsZXMgPSBUYWJzLl9fc3VwZXJfXy5nZXRfZWRpdF92YXJpYWJsZXMuY2FsbCh0aGlzKTtcbiAgICAgICAgcmVmID0gdGhpcy5nZXRfbGF5b3V0YWJsZV9jaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICAgICAgZWRpdF92YXJpYWJsZXMgPSBlZGl0X3ZhcmlhYmxlcy5jb25jYXQoY2hpbGQuZ2V0X2VkaXRfdmFyaWFibGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0X3ZhcmlhYmxlcztcbiAgICB9O1xuICAgIFRhYnMucHJvdG90eXBlLmdldF9jb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBjb25zdHJhaW50cywgaSwgbGVuLCByZWY7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gVGFicy5fX3N1cGVyX18uZ2V0X2NvbnN0cmFpbnRzLmNhbGwodGhpcyk7XG4gICAgICAgIHJlZiA9IHRoaXMuZ2V0X2xheW91dGFibGVfY2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KGNoaWxkLmdldF9jb25zdHJhaW50cygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcbiAgICByZXR1cm4gVGFicztcbn0pKHdpZGdldF8xLldpZGdldCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBET00gPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsL2RvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBhY3RpdmUgPSBmdW5jdGlvbiAodGFiKSB7IHJldHVybiB0YWIuaWQgPT09IHByb3BzLmFjdGl2ZV90YWJfaWQgPyBcImJrLWJzLWFjdGl2ZVwiIDogbnVsbDsgfTtcbiAgICByZXR1cm4gKERPTS5jcmVhdGVFbGVtZW50KFwiZnJhZ21lbnRcIiwgbnVsbCxcbiAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7IGNsYXNzOiBcImJrLWJzLW5hdiBiay1icy1uYXYtdGFic1wiIH0sIHByb3BzLnRhYnMubWFwKGZ1bmN0aW9uICh0YWIpIHtcbiAgICAgICAgICAgIHJldHVybiBET00uY3JlYXRlRWxlbWVudChcImxpXCIsIHsgY2xhc3M6IGFjdGl2ZSh0YWIpIH0sXG4gICAgICAgICAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgaHJlZjogXCIjdGFiLVwiICsgdGFiLmlkIH0sIHRhYi50aXRsZSkpO1xuICAgICAgICB9KSksXG4gICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3M6IFwiYmstYnMtdGFiLWNvbnRlbnRcIiB9LCBwcm9wcy50YWJzLm1hcChmdW5jdGlvbiAodGFiKSB7IHJldHVybiBET00uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzOiBbXCJiay1icy10YWItcGFuZVwiLCBhY3RpdmUodGFiKV0sIGlkOiBcInRhYi1cIiArIHRhYi5pZCB9KTsgfSkpKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2xvZ2dpbmdcIik7XG52YXIgcCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3Byb3BlcnRpZXNcIik7XG52YXIgaW5wdXRfd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi9pbnB1dF93aWRnZXRcIik7XG52YXIgdGV4dF9pbnB1dF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4vdGV4dF9pbnB1dF90ZW1wbGF0ZVwiKTtcbmV4cG9ydHMuVGV4dElucHV0VmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUZXh0SW5wdXRWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUZXh0SW5wdXRWaWV3KCkge1xuICAgICAgICByZXR1cm4gVGV4dElucHV0Vmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGV4dElucHV0Vmlldy5wcm90b3R5cGUudGFnTmFtZSA9IFwiZGl2XCI7XG4gICAgVGV4dElucHV0Vmlldy5wcm90b3R5cGUuY2xhc3NOYW1lID0gXCJiay13aWRnZXQtZm9ybS1ncm91cFwiO1xuICAgIFRleHRJbnB1dFZpZXcucHJvdG90eXBlLnRlbXBsYXRlID0gdGV4dF9pbnB1dF90ZW1wbGF0ZV8xLmRlZmF1bHQ7XG4gICAgVGV4dElucHV0Vmlldy5wcm90b3R5cGUuZXZlbnRzID0ge1xuICAgICAgICBcImNoYW5nZSBpbnB1dFwiOiBcImNoYW5nZV9pbnB1dFwiXG4gICAgfTtcbiAgICBUZXh0SW5wdXRWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgVGV4dElucHV0Vmlldy5fX3N1cGVyX18uaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgdGhpcy5yZW5kZXIpO1xuICAgIH07XG4gICAgVGV4dElucHV0Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBUZXh0SW5wdXRWaWV3Ll9fc3VwZXJfXy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHRoaXMubW9kZWwuYXR0cmlidXRlcykpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoJ2lucHV0JykuaGVpZ2h0KHRoaXMubW9kZWwuaGVpZ2h0IC0gMzUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVGV4dElucHV0Vmlldy5wcm90b3R5cGUuY2hhbmdlX2lucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHZhbHVlID0gdGhpcy4kZWwuZmluZCgnaW5wdXQnKS52YWwoKTtcbiAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci5kZWJ1ZyhcIndpZGdldC90ZXh0X2lucHV0OiB2YWx1ZSA9IFwiICsgdmFsdWUpO1xuICAgICAgICB0aGlzLm1vZGVsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBUZXh0SW5wdXRWaWV3Ll9fc3VwZXJfXy5jaGFuZ2VfaW5wdXQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0SW5wdXRWaWV3O1xufSkoaW5wdXRfd2lkZ2V0XzEuSW5wdXRXaWRnZXRWaWV3KTtcbmV4cG9ydHMuVGV4dElucHV0ID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRleHRJbnB1dCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVGV4dElucHV0KCkge1xuICAgICAgICByZXR1cm4gVGV4dElucHV0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUZXh0SW5wdXQucHJvdG90eXBlLnR5cGUgPSBcIlRleHRJbnB1dFwiO1xuICAgIFRleHRJbnB1dC5wcm90b3R5cGUuZGVmYXVsdF92aWV3ID0gZXhwb3J0cy5UZXh0SW5wdXRWaWV3O1xuICAgIFRleHRJbnB1dC5kZWZpbmUoe1xuICAgICAgICB2YWx1ZTogW3AuU3RyaW5nLCBcIlwiXSxcbiAgICAgICAgcGxhY2Vob2xkZXI6IFtwLlN0cmluZywgXCJcIl1cbiAgICB9KTtcbiAgICByZXR1cm4gVGV4dElucHV0O1xufSkoaW5wdXRfd2lkZ2V0XzEuSW5wdXRXaWRnZXQpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRE9NID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdXRpbC9kb21cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICByZXR1cm4gKERPTS5jcmVhdGVFbGVtZW50KFwiZnJhZ21lbnRcIiwgbnVsbCxcbiAgICAgICAgRE9NLmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLCB7IGZvcjogcHJvcHMuaWQgfSxcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgcHJvcHMudGl0bGUsXG4gICAgICAgICAgICBcIiBcIiksXG4gICAgICAgIERPTS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgeyBjbGFzczogXCJiay13aWRnZXQtZm9ybS1pbnB1dFwiLCB0eXBlOiBcInRleHRcIiwgaWQ6IHByb3BzLmlkLCBuYW1lOiBwcm9wcy5uYW1lLCB2YWx1ZTogcHJvcHMudmFsdWUsIHBsYWNlaG9sZGVyOiBwcm9wcy5wbGFjZWhvbGRlciB9KSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvcHJvcGVydGllc1wiKTtcbnZhciBhYnN0cmFjdF9idXR0b25fMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0X2J1dHRvblwiKTtcbmV4cG9ydHMuVG9nZ2xlVmlldyA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChUb2dnbGVWaWV3LCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUb2dnbGVWaWV3KCkge1xuICAgICAgICByZXR1cm4gVG9nZ2xlVmlldy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVG9nZ2xlVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBUb2dnbGVWaWV3Ll9fc3VwZXJfXy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5maW5kKCdidXR0b24nKS5hZGRDbGFzcyhcImJrLWJzLWFjdGl2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoJ2J1dHRvbicpLnJlbW92ZUNsYXNzKFwiYmstYnMtYWN0aXZlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVG9nZ2xlVmlldy5wcm90b3R5cGUuY2hhbmdlX2lucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBUb2dnbGVWaWV3Ll9fc3VwZXJfXy5jaGFuZ2VfaW5wdXQuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYWN0aXZlID0gIXRoaXMubW9kZWwuYWN0aXZlO1xuICAgIH07XG4gICAgcmV0dXJuIFRvZ2dsZVZpZXc7XG59KShhYnN0cmFjdF9idXR0b25fMS5BYnN0cmFjdEJ1dHRvblZpZXcpO1xuZXhwb3J0cy5Ub2dnbGUgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVG9nZ2xlLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBUb2dnbGUoKSB7XG4gICAgICAgIHJldHVybiBUb2dnbGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRvZ2dsZS5wcm90b3R5cGUudHlwZSA9IFwiVG9nZ2xlXCI7XG4gICAgVG9nZ2xlLnByb3RvdHlwZS5kZWZhdWx0X3ZpZXcgPSBleHBvcnRzLlRvZ2dsZVZpZXc7XG4gICAgVG9nZ2xlLmRlZmluZSh7XG4gICAgICAgIGFjdGl2ZTogW3AuQm9vbCwgZmFsc2VdXG4gICAgfSk7XG4gICAgVG9nZ2xlLm92ZXJyaWRlKHtcbiAgICAgICAgbGFiZWw6IFwiVG9nZ2xlXCJcbiAgICB9KTtcbiAgICByZXR1cm4gVG9nZ2xlO1xufSkoYWJzdHJhY3RfYnV0dG9uXzEuQWJzdHJhY3RCdXR0b24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkge1xuICAgIGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKVxuICAgICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG59IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIGxheW91dF9kb21fMSA9IHJlcXVpcmUoXCIuLi9sYXlvdXRzL2xheW91dF9kb21cIik7XG5leHBvcnRzLldpZGdldFZpZXcgPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoV2lkZ2V0Vmlldywgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gV2lkZ2V0VmlldygpIHtcbiAgICAgICAgcmV0dXJuIFdpZGdldFZpZXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFdpZGdldFZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSA9IFwiYmstd2lkZ2V0XCI7XG4gICAgV2lkZ2V0Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmhlaWdodCh0aGlzLm1vZGVsLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwud2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRlbC53aWR0aCh0aGlzLm1vZGVsLndpZHRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFdpZGdldFZpZXc7XG59KShsYXlvdXRfZG9tXzEuTGF5b3V0RE9NVmlldyk7XG5leHBvcnRzLldpZGdldCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChXaWRnZXQsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFdpZGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFdpZGdldC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgV2lkZ2V0LnByb3RvdHlwZS50eXBlID0gXCJXaWRnZXRcIjtcbiAgICBXaWRnZXQucHJvdG90eXBlLmRlZmF1bHRfdmlldyA9IGV4cG9ydHMuV2lkZ2V0VmlldztcbiAgICByZXR1cm4gV2lkZ2V0O1xufSkobGF5b3V0X2RvbV8xLkxheW91dERPTSk7XG4iLCJ2YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5yZXF1aXJlKCcuL2NvcmUnKTtcbnJlcXVpcmUoJy4vd2lkZ2V0Jyk7XG5yZXF1aXJlKCcuL3Bvc2l0aW9uJyk7XG5yZXF1aXJlKCcuL21lbnUnKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgQXV0b2NvbXBsZXRlIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9hdXRvY29tcGxldGUvXG4gKlxuICogRGVwZW5kczpcbiAqXHRqcXVlcnkudWkuY29yZS5qc1xuICpcdGpxdWVyeS51aS53aWRnZXQuanNcbiAqXHRqcXVlcnkudWkucG9zaXRpb24uanNcbiAqXHRqcXVlcnkudWkubWVudS5qc1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoIFwidWkuYXV0b2NvbXBsZXRlXCIsIHtcblx0dmVyc2lvbjogXCIxLjEwLjRcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGlucHV0PlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0YXBwZW5kVG86IG51bGwsXG5cdFx0YXV0b0ZvY3VzOiBmYWxzZSxcblx0XHRkZWxheTogMzAwLFxuXHRcdG1pbkxlbmd0aDogMSxcblx0XHRwb3NpdGlvbjoge1xuXHRcdFx0bXk6IFwibGVmdCB0b3BcIixcblx0XHRcdGF0OiBcImxlZnQgYm90dG9tXCIsXG5cdFx0XHRjb2xsaXNpb246IFwibm9uZVwiXG5cdFx0fSxcblx0XHRzb3VyY2U6IG51bGwsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRjaGFuZ2U6IG51bGwsXG5cdFx0Y2xvc2U6IG51bGwsXG5cdFx0Zm9jdXM6IG51bGwsXG5cdFx0b3BlbjogbnVsbCxcblx0XHRyZXNwb25zZTogbnVsbCxcblx0XHRzZWFyY2g6IG51bGwsXG5cdFx0c2VsZWN0OiBudWxsXG5cdH0sXG5cblx0cmVxdWVzdEluZGV4OiAwLFxuXHRwZW5kaW5nOiAwLFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFNvbWUgYnJvd3NlcnMgb25seSByZXBlYXQga2V5ZG93biBldmVudHMsIG5vdCBrZXlwcmVzcyBldmVudHMsXG5cdFx0Ly8gc28gd2UgdXNlIHRoZSBzdXBwcmVzc0tleVByZXNzIGZsYWcgdG8gZGV0ZXJtaW5lIGlmIHdlJ3ZlIGFscmVhZHlcblx0XHQvLyBoYW5kbGVkIHRoZSBrZXlkb3duIGV2ZW50LiAjNzI2OVxuXHRcdC8vIFVuZm9ydHVuYXRlbHkgdGhlIGNvZGUgZm9yICYgaW4ga2V5cHJlc3MgaXMgdGhlIHNhbWUgYXMgdGhlIHVwIGFycm93LFxuXHRcdC8vIHNvIHdlIHVzZSB0aGUgc3VwcHJlc3NLZXlQcmVzc1JlcGVhdCBmbGFnIHRvIGF2b2lkIGhhbmRsaW5nIGtleXByZXNzXG5cdFx0Ly8gZXZlbnRzIHdoZW4gd2Uga25vdyB0aGUga2V5ZG93biBldmVudCB3YXMgdXNlZCB0byBtb2RpZnkgdGhlXG5cdFx0Ly8gc2VhcmNoIHRlcm0uICM3Nzk5XG5cdFx0dmFyIHN1cHByZXNzS2V5UHJlc3MsIHN1cHByZXNzS2V5UHJlc3NSZXBlYXQsIHN1cHByZXNzSW5wdXQsXG5cdFx0XHRub2RlTmFtZSA9IHRoaXMuZWxlbWVudFswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0aXNUZXh0YXJlYSA9IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIsXG5cdFx0XHRpc0lucHV0ID0gbm9kZU5hbWUgPT09IFwiaW5wdXRcIjtcblxuXHRcdHRoaXMuaXNNdWx0aUxpbmUgPVxuXHRcdFx0Ly8gVGV4dGFyZWFzIGFyZSBhbHdheXMgbXVsdGktbGluZVxuXHRcdFx0aXNUZXh0YXJlYSA/IHRydWUgOlxuXHRcdFx0Ly8gSW5wdXRzIGFyZSBhbHdheXMgc2luZ2xlLWxpbmUsIGV2ZW4gaWYgaW5zaWRlIGEgY29udGVudEVkaXRhYmxlIGVsZW1lbnRcblx0XHRcdC8vIElFIGFsc28gdHJlYXRzIGlucHV0cyBhcyBjb250ZW50RWRpdGFibGVcblx0XHRcdGlzSW5wdXQgPyBmYWxzZSA6XG5cdFx0XHQvLyBBbGwgb3RoZXIgZWxlbWVudCB0eXBlcyBhcmUgZGV0ZXJtaW5lZCBieSB3aGV0aGVyIG9yIG5vdCB0aGV5J3JlIGNvbnRlbnRFZGl0YWJsZVxuXHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiaXNDb250ZW50RWRpdGFibGVcIiApO1xuXG5cdFx0dGhpcy52YWx1ZU1ldGhvZCA9IHRoaXMuZWxlbWVudFsgaXNUZXh0YXJlYSB8fCBpc0lucHV0ID8gXCJ2YWxcIiA6IFwidGV4dFwiIF07XG5cdFx0dGhpcy5pc05ld01lbnUgPSB0cnVlO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlLWlucHV0XCIgKVxuXHRcdFx0LmF0dHIoIFwiYXV0b2NvbXBsZXRlXCIsIFwib2ZmXCIgKTtcblxuXHRcdHRoaXMuX29uKCB0aGlzLmVsZW1lbnQsIHtcblx0XHRcdGtleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmVsZW1lbnQucHJvcCggXCJyZWFkT25seVwiICkgKSB7XG5cdFx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzcyA9IHRydWU7XG5cdFx0XHRcdFx0c3VwcHJlc3NJbnB1dCA9IHRydWU7XG5cdFx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzc1JlcGVhdCA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzcyA9IGZhbHNlO1xuXHRcdFx0XHRzdXBwcmVzc0lucHV0ID0gZmFsc2U7XG5cdFx0XHRcdHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgPSBmYWxzZTtcblx0XHRcdFx0dmFyIGtleUNvZGUgPSAkLnVpLmtleUNvZGU7XG5cdFx0XHRcdHN3aXRjaCggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlBBR0VfVVA6XG5cdFx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzcyA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5fbW92ZSggXCJwcmV2aW91c1BhZ2VcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlBBR0VfRE9XTjpcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLl9tb3ZlKCBcIm5leHRQYWdlXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5VUDpcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLl9rZXlFdmVudCggXCJwcmV2aW91c1wiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuRE9XTjpcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLl9rZXlFdmVudCggXCJuZXh0XCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5FTlRFUjpcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLk5VTVBBRF9FTlRFUjpcblx0XHRcdFx0XHQvLyB3aGVuIG1lbnUgaXMgb3BlbiBhbmQgaGFzIGZvY3VzXG5cdFx0XHRcdFx0aWYgKCB0aGlzLm1lbnUuYWN0aXZlICkge1xuXHRcdFx0XHRcdFx0Ly8gIzYwNTUgLSBPcGVyYSBzdGlsbCBhbGxvd3MgdGhlIGtleXByZXNzIHRvIG9jY3VyXG5cdFx0XHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgZm9ybXMgdG8gc3VibWl0XG5cdFx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHR0aGlzLm1lbnUuc2VsZWN0KCBldmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlRBQjpcblx0XHRcdFx0XHRpZiAoIHRoaXMubWVudS5hY3RpdmUgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1lbnUuc2VsZWN0KCBldmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLkVTQ0FQRTpcblx0XHRcdFx0XHRpZiAoIHRoaXMubWVudS5lbGVtZW50LmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlKCB0aGlzLnRlcm0gKTtcblx0XHRcdFx0XHRcdHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cdFx0XHRcdFx0XHQvLyBEaWZmZXJlbnQgYnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgZGVmYXVsdCBiZWhhdmlvciBmb3IgZXNjYXBlXG5cdFx0XHRcdFx0XHQvLyBTaW5nbGUgcHJlc3MgY2FuIG1lYW4gdW5kbyBvciBjbGVhclxuXHRcdFx0XHRcdFx0Ly8gRG91YmxlIHByZXNzIGluIElFIG1lYW5zIGNsZWFyIHRoZSB3aG9sZSBmb3JtXG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzUmVwZWF0ID0gdHJ1ZTtcblx0XHRcdFx0XHQvLyBzZWFyY2ggdGltZW91dCBzaG91bGQgYmUgdHJpZ2dlcmVkIGJlZm9yZSB0aGUgaW5wdXQgdmFsdWUgaXMgY2hhbmdlZFxuXHRcdFx0XHRcdHRoaXMuX3NlYXJjaFRpbWVvdXQoIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRrZXlwcmVzczogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHN1cHByZXNzS2V5UHJlc3MgKSB7XG5cdFx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICggIXRoaXMuaXNNdWx0aUxpbmUgfHwgdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggc3VwcHJlc3NLZXlQcmVzc1JlcGVhdCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZXBsaWNhdGUgc29tZSBrZXkgaGFuZGxlcnMgdG8gYWxsb3cgdGhlbSB0byByZXBlYXQgaW4gRmlyZWZveCBhbmQgT3BlcmFcblx0XHRcdFx0dmFyIGtleUNvZGUgPSAkLnVpLmtleUNvZGU7XG5cdFx0XHRcdHN3aXRjaCggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlBBR0VfVVA6XG5cdFx0XHRcdFx0dGhpcy5fbW92ZSggXCJwcmV2aW91c1BhZ2VcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlBBR0VfRE9XTjpcblx0XHRcdFx0XHR0aGlzLl9tb3ZlKCBcIm5leHRQYWdlXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5VUDpcblx0XHRcdFx0XHR0aGlzLl9rZXlFdmVudCggXCJwcmV2aW91c1wiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuRE9XTjpcblx0XHRcdFx0XHR0aGlzLl9rZXlFdmVudCggXCJuZXh0XCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRpbnB1dDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHN1cHByZXNzSW5wdXQgKSB7XG5cdFx0XHRcdFx0c3VwcHJlc3NJbnB1dCA9IGZhbHNlO1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3NlYXJjaFRpbWVvdXQoIGV2ZW50ICk7XG5cdFx0XHR9LFxuXHRcdFx0Zm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG5cdFx0XHRcdHRoaXMucHJldmlvdXMgPSB0aGlzLl92YWx1ZSgpO1xuXHRcdFx0fSxcblx0XHRcdGJsdXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNhbmNlbEJsdXIgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuY2FuY2VsQmx1cjtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMuc2VhcmNoaW5nICk7XG5cdFx0XHRcdHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZSggZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuX2luaXRTb3VyY2UoKTtcblx0XHR0aGlzLm1lbnUgPSAkKCBcIjx1bD5cIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlIHVpLWZyb250XCIgKVxuXHRcdFx0LmFwcGVuZFRvKCB0aGlzLl9hcHBlbmRUbygpIClcblx0XHRcdC5tZW51KHtcblx0XHRcdFx0Ly8gZGlzYWJsZSBBUklBIHN1cHBvcnQsIHRoZSBsaXZlIHJlZ2lvbiB0YWtlcyBjYXJlIG9mIHRoYXRcblx0XHRcdFx0cm9sZTogbnVsbFxuXHRcdFx0fSlcblx0XHRcdC5oaWRlKClcblx0XHRcdC5kYXRhKCBcInVpLW1lbnVcIiApO1xuXG5cdFx0dGhpcy5fb24oIHRoaXMubWVudS5lbGVtZW50LCB7XG5cdFx0XHRtb3VzZWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0Ly8gcHJldmVudCBtb3ZpbmcgZm9jdXMgb3V0IG9mIHRoZSB0ZXh0IGZpZWxkXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0Ly8gSUUgZG9lc24ndCBwcmV2ZW50IG1vdmluZyBmb2N1cyBldmVuIHdpdGggZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdFx0XHQvLyBzbyB3ZSBzZXQgYSBmbGFnIHRvIGtub3cgd2hlbiB3ZSBzaG91bGQgaWdub3JlIHRoZSBibHVyIGV2ZW50XG5cdFx0XHRcdHRoaXMuY2FuY2VsQmx1ciA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIGNsaWNraW5nIG9uIHRoZSBzY3JvbGxiYXIgY2F1c2VzIGZvY3VzIHRvIHNoaWZ0IHRvIHRoZSBib2R5XG5cdFx0XHRcdC8vIGJ1dCB3ZSBjYW4ndCBkZXRlY3QgYSBtb3VzZXVwIG9yIGEgY2xpY2sgaW1tZWRpYXRlbHkgYWZ0ZXJ3YXJkXG5cdFx0XHRcdC8vIHNvIHdlIGhhdmUgdG8gdHJhY2sgdGhlIG5leHQgbW91c2Vkb3duIGFuZCBjbG9zZSB0aGUgbWVudSBpZlxuXHRcdFx0XHQvLyB0aGUgdXNlciBjbGlja3Mgc29tZXdoZXJlIG91dHNpZGUgb2YgdGhlIGF1dG9jb21wbGV0ZVxuXHRcdFx0XHR2YXIgbWVudUVsZW1lbnQgPSB0aGlzLm1lbnUuZWxlbWVudFsgMCBdO1xuXHRcdFx0XHRpZiAoICEkKCBldmVudC50YXJnZXQgKS5jbG9zZXN0KCBcIi51aS1tZW51LWl0ZW1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdFx0XHRcdHRoaXMuZG9jdW1lbnQub25lKCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ICE9PSB0aGF0LmVsZW1lbnRbIDAgXSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0ZXZlbnQudGFyZ2V0ICE9PSBtZW51RWxlbWVudCAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0ISQuY29udGFpbnMoIG1lbnVFbGVtZW50LCBldmVudC50YXJnZXQgKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGF0LmNsb3NlKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0bWVudWZvY3VzOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHQvLyBzdXBwb3J0OiBGaXJlZm94XG5cdFx0XHRcdC8vIFByZXZlbnQgYWNjaWRlbnRhbCBhY3RpdmF0aW9uIG9mIG1lbnUgaXRlbXMgaW4gRmlyZWZveCAoIzcwMjQgIzkxMTgpXG5cdFx0XHRcdGlmICggdGhpcy5pc05ld01lbnUgKSB7XG5cdFx0XHRcdFx0dGhpcy5pc05ld01lbnUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgL15tb3VzZS8udGVzdCggZXZlbnQub3JpZ2luYWxFdmVudC50eXBlICkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1lbnUuYmx1cigpO1xuXG5cdFx0XHRcdFx0XHR0aGlzLmRvY3VtZW50Lm9uZSggXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdCQoIGV2ZW50LnRhcmdldCApLnRyaWdnZXIoIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGl0ZW0gPSB1aS5pdGVtLmRhdGEoIFwidWktYXV0b2NvbXBsZXRlLWl0ZW1cIiApO1xuXHRcdFx0XHRpZiAoIGZhbHNlICE9PSB0aGlzLl90cmlnZ2VyKCBcImZvY3VzXCIsIGV2ZW50LCB7IGl0ZW06IGl0ZW0gfSApICkge1xuXHRcdFx0XHRcdC8vIHVzZSB2YWx1ZSB0byBtYXRjaCB3aGF0IHdpbGwgZW5kIHVwIGluIHRoZSBpbnB1dCwgaWYgaXQgd2FzIGEga2V5IGV2ZW50XG5cdFx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50ICYmIC9ea2V5Ly50ZXN0KCBldmVudC5vcmlnaW5hbEV2ZW50LnR5cGUgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlKCBpdGVtLnZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIE5vcm1hbGx5IHRoZSBpbnB1dCBpcyBwb3B1bGF0ZWQgd2l0aCB0aGUgaXRlbSdzIHZhbHVlIGFzIHRoZVxuXHRcdFx0XHRcdC8vIG1lbnUgaXMgbmF2aWdhdGVkLCBjYXVzaW5nIHNjcmVlbiByZWFkZXJzIHRvIG5vdGljZSBhIGNoYW5nZSBhbmRcblx0XHRcdFx0XHQvLyBhbm5vdW5jZSB0aGUgaXRlbS4gU2luY2UgdGhlIGZvY3VzIGV2ZW50IHdhcyBjYW5jZWxlZCwgdGhpcyBkb2Vzbid0XG5cdFx0XHRcdFx0Ly8gaGFwcGVuLCBzbyB3ZSB1cGRhdGUgdGhlIGxpdmUgcmVnaW9uIHNvIHRoYXQgc2NyZWVuIHJlYWRlcnMgY2FuXG5cdFx0XHRcdFx0Ly8gc3RpbGwgbm90aWNlIHRoZSBjaGFuZ2UgYW5kIGFubm91bmNlIGl0LlxuXHRcdFx0XHRcdHRoaXMubGl2ZVJlZ2lvbi50ZXh0KCBpdGVtLnZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRtZW51c2VsZWN0OiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHVpLml0ZW0uZGF0YSggXCJ1aS1hdXRvY29tcGxldGUtaXRlbVwiICksXG5cdFx0XHRcdFx0cHJldmlvdXMgPSB0aGlzLnByZXZpb3VzO1xuXG5cdFx0XHRcdC8vIG9ubHkgdHJpZ2dlciB3aGVuIGZvY3VzIHdhcyBsb3N0IChjbGljayBvbiBtZW51KVxuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudFswXSAhPT0gdGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudC5mb2N1cygpO1xuXHRcdFx0XHRcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcblx0XHRcdFx0XHQvLyAjNjEwOSAtIElFIHRyaWdnZXJzIHR3byBmb2N1cyBldmVudHMgYW5kIHRoZSBzZWNvbmRcblx0XHRcdFx0XHQvLyBpcyBhc3luY2hyb25vdXMsIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHByZXZpb3VzXG5cdFx0XHRcdFx0Ly8gdGVybSBzeW5jaHJvbm91c2x5IGFuZCBhc3luY2hyb25vdXNseSA6LShcblx0XHRcdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZmFsc2UgIT09IHRoaXMuX3RyaWdnZXIoIFwic2VsZWN0XCIsIGV2ZW50LCB7IGl0ZW06IGl0ZW0gfSApICkge1xuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlKCBpdGVtLnZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gcmVzZXQgdGhlIHRlcm0gYWZ0ZXIgdGhlIHNlbGVjdCBldmVudFxuXHRcdFx0XHQvLyB0aGlzIGFsbG93cyBjdXN0b20gc2VsZWN0IGhhbmRsaW5nIHRvIHdvcmsgcHJvcGVybHlcblx0XHRcdFx0dGhpcy50ZXJtID0gdGhpcy5fdmFsdWUoKTtcblxuXHRcdFx0XHR0aGlzLmNsb3NlKCBldmVudCApO1xuXHRcdFx0XHR0aGlzLnNlbGVjdGVkSXRlbSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmxpdmVSZWdpb24gPSAkKCBcIjxzcGFuPlwiLCB7XG5cdFx0XHRcdHJvbGU6IFwic3RhdHVzXCIsXG5cdFx0XHRcdFwiYXJpYS1saXZlXCI6IFwicG9saXRlXCJcblx0XHRcdH0pXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXCIgKVxuXHRcdFx0Lmluc2VydEJlZm9yZSggdGhpcy5lbGVtZW50ICk7XG5cblx0XHQvLyB0dXJuaW5nIG9mZiBhdXRvY29tcGxldGUgcHJldmVudHMgdGhlIGJyb3dzZXIgZnJvbSByZW1lbWJlcmluZyB0aGVcblx0XHQvLyB2YWx1ZSB3aGVuIG5hdmlnYXRpbmcgdGhyb3VnaCBoaXN0b3J5LCBzbyB3ZSByZS1lbmFibGUgYXV0b2NvbXBsZXRlXG5cdFx0Ly8gaWYgdGhlIHBhZ2UgaXMgdW5sb2FkZWQgYmVmb3JlIHRoZSB3aWRnZXQgaXMgZGVzdHJveWVkLiAjNzc5MFxuXHRcdHRoaXMuX29uKCB0aGlzLndpbmRvdywge1xuXHRcdFx0YmVmb3JldW5sb2FkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoIFwiYXV0b2NvbXBsZXRlXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnNlYXJjaGluZyApO1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWF1dG9jb21wbGV0ZS1pbnB1dFwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImF1dG9jb21wbGV0ZVwiICk7XG5cdFx0dGhpcy5tZW51LmVsZW1lbnQucmVtb3ZlKCk7XG5cdFx0dGhpcy5saXZlUmVnaW9uLnJlbW92ZSgpO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cdFx0aWYgKCBrZXkgPT09IFwic291cmNlXCIgKSB7XG5cdFx0XHR0aGlzLl9pbml0U291cmNlKCk7XG5cdFx0fVxuXHRcdGlmICgga2V5ID09PSBcImFwcGVuZFRvXCIgKSB7XG5cdFx0XHR0aGlzLm1lbnUuZWxlbWVudC5hcHBlbmRUbyggdGhpcy5fYXBwZW5kVG8oKSApO1xuXHRcdH1cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICYmIHZhbHVlICYmIHRoaXMueGhyICkge1xuXHRcdFx0dGhpcy54aHIuYWJvcnQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2FwcGVuZFRvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMub3B0aW9ucy5hcHBlbmRUbztcblxuXHRcdGlmICggZWxlbWVudCApIHtcblx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LmpxdWVyeSB8fCBlbGVtZW50Lm5vZGVUeXBlID9cblx0XHRcdFx0JCggZWxlbWVudCApIDpcblx0XHRcdFx0dGhpcy5kb2N1bWVudC5maW5kKCBlbGVtZW50ICkuZXEoIDAgKTtcblx0XHR9XG5cblx0XHRpZiAoICFlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudC5jbG9zZXN0KCBcIi51aS1mcm9udFwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhZWxlbWVudC5sZW5ndGggKSB7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5kb2N1bWVudFswXS5ib2R5O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtZW50O1xuXHR9LFxuXG5cdF9pbml0U291cmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJyYXksIHVybCxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXHRcdGlmICggJC5pc0FycmF5KHRoaXMub3B0aW9ucy5zb3VyY2UpICkge1xuXHRcdFx0YXJyYXkgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xuXHRcdFx0dGhpcy5zb3VyY2UgPSBmdW5jdGlvbiggcmVxdWVzdCwgcmVzcG9uc2UgKSB7XG5cdFx0XHRcdHJlc3BvbnNlKCAkLnVpLmF1dG9jb21wbGV0ZS5maWx0ZXIoIGFycmF5LCByZXF1ZXN0LnRlcm0gKSApO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLnNvdXJjZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHVybCA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IGZ1bmN0aW9uKCByZXF1ZXN0LCByZXNwb25zZSApIHtcblx0XHRcdFx0aWYgKCB0aGF0LnhociApIHtcblx0XHRcdFx0XHR0aGF0Lnhoci5hYm9ydCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoYXQueGhyID0gJC5hamF4KHtcblx0XHRcdFx0XHR1cmw6IHVybCxcblx0XHRcdFx0XHRkYXRhOiByZXF1ZXN0LFxuXHRcdFx0XHRcdGRhdGFUeXBlOiBcImpzb25cIixcblx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlKCBkYXRhICk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSggW10gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zb3VyY2UgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xuXHRcdH1cblx0fSxcblxuXHRfc2VhcmNoVGltZW91dDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy5zZWFyY2hpbmcgKTtcblx0XHR0aGlzLnNlYXJjaGluZyA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gb25seSBzZWFyY2ggaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG5cdFx0XHRpZiAoIHRoaXMudGVybSAhPT0gdGhpcy5fdmFsdWUoKSApIHtcblx0XHRcdFx0dGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuXHRcdFx0XHR0aGlzLnNlYXJjaCggbnVsbCwgZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzLm9wdGlvbnMuZGVsYXkgKTtcblx0fSxcblxuXHRzZWFyY2g6IGZ1bmN0aW9uKCB2YWx1ZSwgZXZlbnQgKSB7XG5cdFx0dmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLl92YWx1ZSgpO1xuXG5cdFx0Ly8gYWx3YXlzIHNhdmUgdGhlIGFjdHVhbCB2YWx1ZSwgbm90IHRoZSBvbmUgcGFzc2VkIGFzIGFuIGFyZ3VtZW50XG5cdFx0dGhpcy50ZXJtID0gdGhpcy5fdmFsdWUoKTtcblxuXHRcdGlmICggdmFsdWUubGVuZ3RoIDwgdGhpcy5vcHRpb25zLm1pbkxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmNsb3NlKCBldmVudCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fdHJpZ2dlciggXCJzZWFyY2hcIiwgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3NlYXJjaCggdmFsdWUgKTtcblx0fSxcblxuXHRfc2VhcmNoOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5wZW5kaW5nKys7XG5cdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCBcInVpLWF1dG9jb21wbGV0ZS1sb2FkaW5nXCIgKTtcblx0XHR0aGlzLmNhbmNlbFNlYXJjaCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zb3VyY2UoIHsgdGVybTogdmFsdWUgfSwgdGhpcy5fcmVzcG9uc2UoKSApO1xuXHR9LFxuXG5cdF9yZXNwb25zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGluZGV4ID0gKyt0aGlzLnJlcXVlc3RJbmRleDtcblxuXHRcdHJldHVybiAkLnByb3h5KGZ1bmN0aW9uKCBjb250ZW50ICkge1xuXHRcdFx0aWYgKCBpbmRleCA9PT0gdGhpcy5yZXF1ZXN0SW5kZXggKSB7XG5cdFx0XHRcdHRoaXMuX19yZXNwb25zZSggY29udGVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnBlbmRpbmctLTtcblx0XHRcdGlmICggIXRoaXMucGVuZGluZyApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLWF1dG9jb21wbGV0ZS1sb2FkaW5nXCIgKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzICk7XG5cdH0sXG5cblx0X19yZXNwb25zZTogZnVuY3Rpb24oIGNvbnRlbnQgKSB7XG5cdFx0aWYgKCBjb250ZW50ICkge1xuXHRcdFx0Y29udGVudCA9IHRoaXMuX25vcm1hbGl6ZSggY29udGVudCApO1xuXHRcdH1cblx0XHR0aGlzLl90cmlnZ2VyKCBcInJlc3BvbnNlXCIsIG51bGwsIHsgY29udGVudDogY29udGVudCB9ICk7XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIGNvbnRlbnQgJiYgY29udGVudC5sZW5ndGggJiYgIXRoaXMuY2FuY2VsU2VhcmNoICkge1xuXHRcdFx0dGhpcy5fc3VnZ2VzdCggY29udGVudCApO1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJvcGVuXCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gdXNlIC5fY2xvc2UoKSBpbnN0ZWFkIG9mIC5jbG9zZSgpIHNvIHdlIGRvbid0IGNhbmNlbCBmdXR1cmUgc2VhcmNoZXNcblx0XHRcdHRoaXMuX2Nsb3NlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb3NlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5jYW5jZWxTZWFyY2ggPSB0cnVlO1xuXHRcdHRoaXMuX2Nsb3NlKCBldmVudCApO1xuXHR9LFxuXG5cdF9jbG9zZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0dGhpcy5tZW51LmVsZW1lbnQuaGlkZSgpO1xuXHRcdFx0dGhpcy5tZW51LmJsdXIoKTtcblx0XHRcdHRoaXMuaXNOZXdNZW51ID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2xvc2VcIiwgZXZlbnQgKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggdGhpcy5wcmV2aW91cyAhPT0gdGhpcy5fdmFsdWUoKSApIHtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIsIGV2ZW50LCB7IGl0ZW06IHRoaXMuc2VsZWN0ZWRJdGVtIH0gKTtcblx0XHR9XG5cdH0sXG5cblx0X25vcm1hbGl6ZTogZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdC8vIGFzc3VtZSBhbGwgaXRlbXMgaGF2ZSB0aGUgcmlnaHQgZm9ybWF0IHdoZW4gdGhlIGZpcnN0IGl0ZW0gaXMgY29tcGxldGVcblx0XHRpZiAoIGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1swXS5sYWJlbCAmJiBpdGVtc1swXS52YWx1ZSApIHtcblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdFx0cmV0dXJuICQubWFwKCBpdGVtcywgZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGxhYmVsOiBpdGVtLFxuXHRcdFx0XHRcdHZhbHVlOiBpdGVtXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJC5leHRlbmQoe1xuXHRcdFx0XHRsYWJlbDogaXRlbS5sYWJlbCB8fCBpdGVtLnZhbHVlLFxuXHRcdFx0XHR2YWx1ZTogaXRlbS52YWx1ZSB8fCBpdGVtLmxhYmVsXG5cdFx0XHR9LCBpdGVtICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X3N1Z2dlc3Q6IGZ1bmN0aW9uKCBpdGVtcyApIHtcblx0XHR2YXIgdWwgPSB0aGlzLm1lbnUuZWxlbWVudC5lbXB0eSgpO1xuXHRcdHRoaXMuX3JlbmRlck1lbnUoIHVsLCBpdGVtcyApO1xuXHRcdHRoaXMuaXNOZXdNZW51ID0gdHJ1ZTtcblx0XHR0aGlzLm1lbnUucmVmcmVzaCgpO1xuXG5cdFx0Ly8gc2l6ZSBhbmQgcG9zaXRpb24gbWVudVxuXHRcdHVsLnNob3coKTtcblx0XHR0aGlzLl9yZXNpemVNZW51KCk7XG5cdFx0dWwucG9zaXRpb24oICQuZXh0ZW5kKHtcblx0XHRcdG9mOiB0aGlzLmVsZW1lbnRcblx0XHR9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKSk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hdXRvRm9jdXMgKSB7XG5cdFx0XHR0aGlzLm1lbnUubmV4dCgpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzaXplTWVudTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVsID0gdGhpcy5tZW51LmVsZW1lbnQ7XG5cdFx0dWwub3V0ZXJXaWR0aCggTWF0aC5tYXgoXG5cdFx0XHQvLyBGaXJlZm94IHdyYXBzIGxvbmcgdGV4dCAocG9zc2libHkgYSByb3VuZGluZyBidWcpXG5cdFx0XHQvLyBzbyB3ZSBhZGQgMXB4IHRvIGF2b2lkIHRoZSB3cmFwcGluZyAoIzc1MTMpXG5cdFx0XHR1bC53aWR0aCggXCJcIiApLm91dGVyV2lkdGgoKSArIDEsXG5cdFx0XHR0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpXG5cdFx0KSApO1xuXHR9LFxuXG5cdF9yZW5kZXJNZW51OiBmdW5jdGlvbiggdWwsIGl0ZW1zICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHQkLmVhY2goIGl0ZW1zLCBmdW5jdGlvbiggaW5kZXgsIGl0ZW0gKSB7XG5cdFx0XHR0aGF0Ll9yZW5kZXJJdGVtRGF0YSggdWwsIGl0ZW0gKTtcblx0XHR9KTtcblx0fSxcblxuXHRfcmVuZGVySXRlbURhdGE6IGZ1bmN0aW9uKCB1bCwgaXRlbSApIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVuZGVySXRlbSggdWwsIGl0ZW0gKS5kYXRhKCBcInVpLWF1dG9jb21wbGV0ZS1pdGVtXCIsIGl0ZW0gKTtcblx0fSxcblxuXHRfcmVuZGVySXRlbTogZnVuY3Rpb24oIHVsLCBpdGVtICkge1xuXHRcdHJldHVybiAkKCBcIjxsaT5cIiApXG5cdFx0XHQuYXBwZW5kKCAkKCBcIjxhPlwiICkudGV4dCggaXRlbS5sYWJlbCApIClcblx0XHRcdC5hcHBlbmRUbyggdWwgKTtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24oIGRpcmVjdGlvbiwgZXZlbnQgKSB7XG5cdFx0aWYgKCAhdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0dGhpcy5zZWFyY2goIG51bGwsIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5tZW51LmlzRmlyc3RJdGVtKCkgJiYgL15wcmV2aW91cy8udGVzdCggZGlyZWN0aW9uICkgfHxcblx0XHRcdFx0dGhpcy5tZW51LmlzTGFzdEl0ZW0oKSAmJiAvXm5leHQvLnRlc3QoIGRpcmVjdGlvbiApICkge1xuXHRcdFx0dGhpcy5fdmFsdWUoIHRoaXMudGVybSApO1xuXHRcdFx0dGhpcy5tZW51LmJsdXIoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5tZW51WyBkaXJlY3Rpb24gXSggZXZlbnQgKTtcblx0fSxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lbnUuZWxlbWVudDtcblx0fSxcblxuXHRfdmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlTWV0aG9kLmFwcGx5KCB0aGlzLmVsZW1lbnQsIGFyZ3VtZW50cyApO1xuXHR9LFxuXG5cdF9rZXlFdmVudDogZnVuY3Rpb24oIGtleUV2ZW50LCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLmlzTXVsdGlMaW5lIHx8IHRoaXMubWVudS5lbGVtZW50LmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcblx0XHRcdHRoaXMuX21vdmUoIGtleUV2ZW50LCBldmVudCApO1xuXG5cdFx0XHQvLyBwcmV2ZW50cyBtb3ZpbmcgY3Vyc29yIHRvIGJlZ2lubmluZy9lbmQgb2YgdGhlIHRleHQgZmllbGQgaW4gc29tZSBicm93c2Vyc1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4kLmV4dGVuZCggJC51aS5hdXRvY29tcGxldGUsIHtcblx0ZXNjYXBlUmVnZXg6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKGFycmF5LCB0ZXJtKSB7XG5cdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCAkLnVpLmF1dG9jb21wbGV0ZS5lc2NhcGVSZWdleCh0ZXJtKSwgXCJpXCIgKTtcblx0XHRyZXR1cm4gJC5ncmVwKCBhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiBtYXRjaGVyLnRlc3QoIHZhbHVlLmxhYmVsIHx8IHZhbHVlLnZhbHVlIHx8IHZhbHVlICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbi8vIGxpdmUgcmVnaW9uIGV4dGVuc2lvbiwgYWRkaW5nIGEgYG1lc3NhZ2VzYCBvcHRpb25cbi8vIE5PVEU6IFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIEFQSS4gV2UgYXJlIHN0aWxsIGludmVzdGlnYXRpbmdcbi8vIGEgZnVsbCBzb2x1dGlvbiBmb3Igc3RyaW5nIG1hbmlwdWxhdGlvbiBhbmQgaW50ZXJuYXRpb25hbGl6YXRpb24uXG4kLndpZGdldCggXCJ1aS5hdXRvY29tcGxldGVcIiwgJC51aS5hdXRvY29tcGxldGUsIHtcblx0b3B0aW9uczoge1xuXHRcdG1lc3NhZ2VzOiB7XG5cdFx0XHRub1Jlc3VsdHM6IFwiTm8gc2VhcmNoIHJlc3VsdHMuXCIsXG5cdFx0XHRyZXN1bHRzOiBmdW5jdGlvbiggYW1vdW50ICkge1xuXHRcdFx0XHRyZXR1cm4gYW1vdW50ICsgKCBhbW91bnQgPiAxID8gXCIgcmVzdWx0cyBhcmVcIiA6IFwiIHJlc3VsdCBpc1wiICkgK1xuXHRcdFx0XHRcdFwiIGF2YWlsYWJsZSwgdXNlIHVwIGFuZCBkb3duIGFycm93IGtleXMgdG8gbmF2aWdhdGUuXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9fcmVzcG9uc2U6IGZ1bmN0aW9uKCBjb250ZW50ICkge1xuXHRcdHZhciBtZXNzYWdlO1xuXHRcdHRoaXMuX3N1cGVyQXBwbHkoIGFyZ3VtZW50cyApO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IHRoaXMuY2FuY2VsU2VhcmNoICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIGNvbnRlbnQgJiYgY29udGVudC5sZW5ndGggKSB7XG5cdFx0XHRtZXNzYWdlID0gdGhpcy5vcHRpb25zLm1lc3NhZ2VzLnJlc3VsdHMoIGNvbnRlbnQubGVuZ3RoICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZXMubm9SZXN1bHRzO1xuXHRcdH1cblx0XHR0aGlzLmxpdmVSZWdpb24udGV4dCggbWVzc2FnZSApO1xuXHR9XG59KTtcblxufSggalF1ZXJ5ICkpO1xuIiwidmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xucmVxdWlyZSgnLi9jb3JlJyk7XG5yZXF1aXJlKCcuL3dpZGdldCcpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBCdXR0b24gMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2J1dHRvbi9cbiAqXG4gKiBEZXBlbmRzOlxuICpcdGpxdWVyeS51aS5jb3JlLmpzXG4gKlx0anF1ZXJ5LnVpLndpZGdldC5qc1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIGxhc3RBY3RpdmUsXG5cdGJhc2VDbGFzc2VzID0gXCJ1aS1idXR0b24gdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFwiLFxuXHR0eXBlQ2xhc3NlcyA9IFwidWktYnV0dG9uLWljb25zLW9ubHkgdWktYnV0dG9uLWljb24tb25seSB1aS1idXR0b24tdGV4dC1pY29ucyB1aS1idXR0b24tdGV4dC1pY29uLXByaW1hcnkgdWktYnV0dG9uLXRleHQtaWNvbi1zZWNvbmRhcnkgdWktYnV0dG9uLXRleHQtb25seVwiLFxuXHRmb3JtUmVzZXRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZvcm0gPSAkKCB0aGlzICk7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdGZvcm0uZmluZCggXCI6dWktYnV0dG9uXCIgKS5idXR0b24oIFwicmVmcmVzaFwiICk7XG5cdFx0fSwgMSApO1xuXHR9LFxuXHRyYWRpb0dyb3VwID0gZnVuY3Rpb24oIHJhZGlvICkge1xuXHRcdHZhciBuYW1lID0gcmFkaW8ubmFtZSxcblx0XHRcdGZvcm0gPSByYWRpby5mb3JtLFxuXHRcdFx0cmFkaW9zID0gJCggW10gKTtcblx0XHRpZiAoIG5hbWUgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKCAvJy9nLCBcIlxcXFwnXCIgKTtcblx0XHRcdGlmICggZm9ybSApIHtcblx0XHRcdFx0cmFkaW9zID0gJCggZm9ybSApLmZpbmQoIFwiW25hbWU9J1wiICsgbmFtZSArIFwiJ11cIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmFkaW9zID0gJCggXCJbbmFtZT0nXCIgKyBuYW1lICsgXCInXVwiLCByYWRpby5vd25lckRvY3VtZW50IClcblx0XHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICF0aGlzLmZvcm07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByYWRpb3M7XG5cdH07XG5cbiQud2lkZ2V0KCBcInVpLmJ1dHRvblwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC40XCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjxidXR0b24+XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRkaXNhYmxlZDogbnVsbCxcblx0XHR0ZXh0OiB0cnVlLFxuXHRcdGxhYmVsOiBudWxsLFxuXHRcdGljb25zOiB7XG5cdFx0XHRwcmltYXJ5OiBudWxsLFxuXHRcdFx0c2Vjb25kYXJ5OiBudWxsXG5cdFx0fVxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCJmb3JtXCIgKVxuXHRcdFx0LnVuYmluZCggXCJyZXNldFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQuYmluZCggXCJyZXNldFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZm9ybVJlc2V0SGFuZGxlciApO1xuXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLmRpc2FibGVkICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9ICEhdGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucHJvcCggXCJkaXNhYmxlZFwiLCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kZXRlcm1pbmVCdXR0b25UeXBlKCk7XG5cdFx0dGhpcy5oYXNUaXRsZSA9ICEhdGhpcy5idXR0b25FbGVtZW50LmF0dHIoIFwidGl0bGVcIiApO1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHRvZ2dsZUJ1dHRvbiA9IHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiLFxuXHRcdFx0YWN0aXZlQ2xhc3MgPSAhdG9nZ2xlQnV0dG9uID8gXCJ1aS1zdGF0ZS1hY3RpdmVcIiA6IFwiXCI7XG5cblx0XHRpZiAoIG9wdGlvbnMubGFiZWwgPT09IG51bGwgKSB7XG5cdFx0XHRvcHRpb25zLmxhYmVsID0gKHRoaXMudHlwZSA9PT0gXCJpbnB1dFwiID8gdGhpcy5idXR0b25FbGVtZW50LnZhbCgpIDogdGhpcy5idXR0b25FbGVtZW50Lmh0bWwoKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5faG92ZXJhYmxlKCB0aGlzLmJ1dHRvbkVsZW1lbnQgKTtcblxuXHRcdHRoaXMuYnV0dG9uRWxlbWVudFxuXHRcdFx0LmFkZENsYXNzKCBiYXNlQ2xhc3NlcyApXG5cdFx0XHQuYXR0ciggXCJyb2xlXCIsIFwiYnV0dG9uXCIgKVxuXHRcdFx0LmJpbmQoIFwibW91c2VlbnRlclwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzID09PSBsYXN0QWN0aXZlICkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoIFwibW91c2VsZWF2ZVwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0JCggdGhpcyApLnJlbW92ZUNsYXNzKCBhY3RpdmVDbGFzcyApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCBcImNsaWNrXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdC8vIENhbid0IHVzZSBfZm9jdXNhYmxlKCkgYmVjYXVzZSB0aGUgZWxlbWVudCB0aGF0IHJlY2VpdmVzIGZvY3VzXG5cdFx0Ly8gYW5kIHRoZSBlbGVtZW50IHRoYXQgZ2V0cyB0aGUgdWktc3RhdGUtZm9jdXMgY2xhc3MgYXJlIGRpZmZlcmVudFxuXHRcdHRoaXMuX29uKHtcblx0XHRcdGZvY3VzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5idXR0b25FbGVtZW50LmFkZENsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRibHVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmICggdG9nZ2xlQnV0dG9uICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LmJpbmQoIFwiY2hhbmdlXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICkge1xuXHRcdFx0dGhpcy5idXR0b25FbGVtZW50LmJpbmQoIFwiY2xpY2tcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudC5iaW5kKCBcImNsaWNrXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0dGhhdC5idXR0b25FbGVtZW50LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiICk7XG5cblx0XHRcdFx0dmFyIHJhZGlvID0gdGhhdC5lbGVtZW50WyAwIF07XG5cdFx0XHRcdHJhZGlvR3JvdXAoIHJhZGlvIClcblx0XHRcdFx0XHQubm90KCByYWRpbyApXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYnV0dG9uKCBcIndpZGdldFwiIClbIDAgXTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIiApO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudFxuXHRcdFx0XHQuYmluZCggXCJtb3VzZWRvd25cIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdFx0bGFzdEFjdGl2ZSA9IHRoaXM7XG5cdFx0XHRcdFx0dGhhdC5kb2N1bWVudC5vbmUoIFwibW91c2V1cFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGxhc3RBY3RpdmUgPSBudWxsO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZCggXCJtb3VzZXVwXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZCggXCJrZXlkb3duXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuU1BBQ0UgfHwgZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLkVOVEVSICkge1xuXHRcdFx0XHRcdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQvLyBzZWUgIzg1NTksIHdlIGJpbmQgdG8gYmx1ciBoZXJlIGluIGNhc2UgdGhlIGJ1dHRvbiBlbGVtZW50IGxvc2VzXG5cdFx0XHRcdC8vIGZvY3VzIGJldHdlZW4ga2V5ZG93biBhbmQga2V5dXAsIGl0IHdvdWxkIGJlIGxlZnQgaW4gYW4gXCJhY3RpdmVcIiBzdGF0ZVxuXHRcdFx0XHQuYmluZCggXCJrZXl1cFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIGJsdXJcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0aWYgKCB0aGlzLmJ1dHRvbkVsZW1lbnQuaXMoXCJhXCIpICkge1xuXHRcdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQua2V5dXAoZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRpZiAoIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5TUEFDRSApIHtcblx0XHRcdFx0XHRcdC8vIFRPRE8gcGFzcyB0aHJvdWdoIG9yaWdpbmFsIGV2ZW50IGNvcnJlY3RseSAoanVzdCBhcyAybmQgYXJndW1lbnQgZG9lc24ndCB3b3JrKVxuXHRcdFx0XHRcdFx0JCggdGhpcyApLmNsaWNrKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBUT0RPOiBwdWxsIG91dCAkLldpZGdldCdzIGhhbmRsaW5nIGZvciB0aGUgZGlzYWJsZWQgb3B0aW9uIGludG9cblx0XHQvLyAkLldpZGdldC5wcm90b3R5cGUuX3NldE9wdGlvbkRpc2FibGVkIHNvIGl0J3MgZWFzeSB0byBwcm94eSBhbmQgY2FuXG5cdFx0Ly8gYmUgb3ZlcnJpZGRlbiBieSBpbmRpdmlkdWFsIHBsdWdpbnNcblx0XHR0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgb3B0aW9ucy5kaXNhYmxlZCApO1xuXHRcdHRoaXMuX3Jlc2V0QnV0dG9uKCk7XG5cdH0sXG5cblx0X2RldGVybWluZUJ1dHRvblR5cGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbmNlc3RvciwgbGFiZWxTZWxlY3RvciwgY2hlY2tlZDtcblxuXHRcdGlmICggdGhpcy5lbGVtZW50LmlzKFwiW3R5cGU9Y2hlY2tib3hdXCIpICkge1xuXHRcdFx0dGhpcy50eXBlID0gXCJjaGVja2JveFwiO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMuZWxlbWVudC5pcyhcIlt0eXBlPXJhZGlvXVwiKSApIHtcblx0XHRcdHRoaXMudHlwZSA9IFwicmFkaW9cIjtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmVsZW1lbnQuaXMoXCJpbnB1dFwiKSApIHtcblx0XHRcdHRoaXMudHlwZSA9IFwiaW5wdXRcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50eXBlID0gXCJidXR0b25cIjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiICkge1xuXHRcdFx0Ly8gd2UgZG9uJ3Qgc2VhcmNoIGFnYWluc3QgdGhlIGRvY3VtZW50IGluIGNhc2UgdGhlIGVsZW1lbnRcblx0XHRcdC8vIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBET01cblx0XHRcdGFuY2VzdG9yID0gdGhpcy5lbGVtZW50LnBhcmVudHMoKS5sYXN0KCk7XG5cdFx0XHRsYWJlbFNlbGVjdG9yID0gXCJsYWJlbFtmb3I9J1wiICsgdGhpcy5lbGVtZW50LmF0dHIoXCJpZFwiKSArIFwiJ11cIjtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudCA9IGFuY2VzdG9yLmZpbmQoIGxhYmVsU2VsZWN0b3IgKTtcblx0XHRcdGlmICggIXRoaXMuYnV0dG9uRWxlbWVudC5sZW5ndGggKSB7XG5cdFx0XHRcdGFuY2VzdG9yID0gYW5jZXN0b3IubGVuZ3RoID8gYW5jZXN0b3Iuc2libGluZ3MoKSA6IHRoaXMuZWxlbWVudC5zaWJsaW5ncygpO1xuXHRcdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQgPSBhbmNlc3Rvci5maWx0ZXIoIGxhYmVsU2VsZWN0b3IgKTtcblx0XHRcdFx0aWYgKCAhdGhpcy5idXR0b25FbGVtZW50Lmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQgPSBhbmNlc3Rvci5maW5kKCBsYWJlbFNlbGVjdG9yICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyggXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcIiApO1xuXG5cdFx0XHRjaGVja2VkID0gdGhpcy5lbGVtZW50LmlzKCBcIjpjaGVja2VkXCIgKTtcblx0XHRcdGlmICggY2hlY2tlZCApIHtcblx0XHRcdFx0dGhpcy5idXR0b25FbGVtZW50LmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQucHJvcCggXCJhcmlhLXByZXNzZWRcIiwgY2hlY2tlZCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYnV0dG9uRWxlbWVudDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXCIgKTtcblx0XHR0aGlzLmJ1dHRvbkVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyggYmFzZUNsYXNzZXMgKyBcIiB1aS1zdGF0ZS1hY3RpdmUgXCIgKyB0eXBlQ2xhc3NlcyApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1wcmVzc2VkXCIgKVxuXHRcdFx0Lmh0bWwoIHRoaXMuYnV0dG9uRWxlbWVudC5maW5kKFwiLnVpLWJ1dHRvbi10ZXh0XCIpLmh0bWwoKSApO1xuXG5cdFx0aWYgKCAhdGhpcy5oYXNUaXRsZSApIHtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudC5yZW1vdmVBdHRyKCBcInRpdGxlXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgISF2YWx1ZSApO1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fcmVzZXRCdXR0b24oKTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHQvL1NlZSAjODIzNyAmICM4ODI4XG5cdFx0dmFyIGlzRGlzYWJsZWQgPSB0aGlzLmVsZW1lbnQuaXMoIFwiaW5wdXQsIGJ1dHRvblwiICkgPyB0aGlzLmVsZW1lbnQuaXMoIFwiOmRpc2FibGVkXCIgKSA6IHRoaXMuZWxlbWVudC5oYXNDbGFzcyggXCJ1aS1idXR0b24tZGlzYWJsZWRcIiApO1xuXG5cdFx0aWYgKCBpc0Rpc2FibGVkICE9PSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgaXNEaXNhYmxlZCApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiICkge1xuXHRcdFx0cmFkaW9Hcm91cCggdGhpcy5lbGVtZW50WzBdICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAkKCB0aGlzICkuaXMoIFwiOmNoZWNrZWRcIiApICkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5idXR0b24oIFwid2lkZ2V0XCIgKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5idXR0b24oIFwid2lkZ2V0XCIgKVxuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgKSB7XG5cdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5pcyggXCI6Y2hlY2tlZFwiICkgKSB7XG5cdFx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudFxuXHRcdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnRcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0QnV0dG9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMubGFiZWwgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC52YWwoIHRoaXMub3B0aW9ucy5sYWJlbCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgYnV0dG9uRWxlbWVudCA9IHRoaXMuYnV0dG9uRWxlbWVudC5yZW1vdmVDbGFzcyggdHlwZUNsYXNzZXMgKSxcblx0XHRcdGJ1dHRvblRleHQgPSAkKCBcIjxzcGFuPjwvc3Bhbj5cIiwgdGhpcy5kb2N1bWVudFswXSApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1idXR0b24tdGV4dFwiIClcblx0XHRcdFx0Lmh0bWwoIHRoaXMub3B0aW9ucy5sYWJlbCApXG5cdFx0XHRcdC5hcHBlbmRUbyggYnV0dG9uRWxlbWVudC5lbXB0eSgpIClcblx0XHRcdFx0LnRleHQoKSxcblx0XHRcdGljb25zID0gdGhpcy5vcHRpb25zLmljb25zLFxuXHRcdFx0bXVsdGlwbGVJY29ucyA9IGljb25zLnByaW1hcnkgJiYgaWNvbnMuc2Vjb25kYXJ5LFxuXHRcdFx0YnV0dG9uQ2xhc3NlcyA9IFtdO1xuXG5cdFx0aWYgKCBpY29ucy5wcmltYXJ5IHx8IGljb25zLnNlY29uZGFyeSApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnRleHQgKSB7XG5cdFx0XHRcdGJ1dHRvbkNsYXNzZXMucHVzaCggXCJ1aS1idXR0b24tdGV4dC1pY29uXCIgKyAoIG11bHRpcGxlSWNvbnMgPyBcInNcIiA6ICggaWNvbnMucHJpbWFyeSA/IFwiLXByaW1hcnlcIiA6IFwiLXNlY29uZGFyeVwiICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGljb25zLnByaW1hcnkgKSB7XG5cdFx0XHRcdGJ1dHRvbkVsZW1lbnQucHJlcGVuZCggXCI8c3BhbiBjbGFzcz0ndWktYnV0dG9uLWljb24tcHJpbWFyeSB1aS1pY29uIFwiICsgaWNvbnMucHJpbWFyeSArIFwiJz48L3NwYW4+XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpY29ucy5zZWNvbmRhcnkgKSB7XG5cdFx0XHRcdGJ1dHRvbkVsZW1lbnQuYXBwZW5kKCBcIjxzcGFuIGNsYXNzPSd1aS1idXR0b24taWNvbi1zZWNvbmRhcnkgdWktaWNvbiBcIiArIGljb25zLnNlY29uZGFyeSArIFwiJz48L3NwYW4+XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhdGhpcy5vcHRpb25zLnRleHQgKSB7XG5cdFx0XHRcdGJ1dHRvbkNsYXNzZXMucHVzaCggbXVsdGlwbGVJY29ucyA/IFwidWktYnV0dG9uLWljb25zLW9ubHlcIiA6IFwidWktYnV0dG9uLWljb24tb25seVwiICk7XG5cblx0XHRcdFx0aWYgKCAhdGhpcy5oYXNUaXRsZSApIHtcblx0XHRcdFx0XHRidXR0b25FbGVtZW50LmF0dHIoIFwidGl0bGVcIiwgJC50cmltKCBidXR0b25UZXh0ICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRidXR0b25DbGFzc2VzLnB1c2goIFwidWktYnV0dG9uLXRleHQtb25seVwiICk7XG5cdFx0fVxuXHRcdGJ1dHRvbkVsZW1lbnQuYWRkQ2xhc3MoIGJ1dHRvbkNsYXNzZXMuam9pbiggXCIgXCIgKSApO1xuXHR9XG59KTtcblxuJC53aWRnZXQoIFwidWkuYnV0dG9uc2V0XCIsIHtcblx0dmVyc2lvbjogXCIxLjEwLjRcIixcblx0b3B0aW9uczoge1xuXHRcdGl0ZW1zOiBcImJ1dHRvbiwgaW5wdXRbdHlwZT1idXR0b25dLCBpbnB1dFt0eXBlPXN1Ym1pdF0sIGlucHV0W3R5cGU9cmVzZXRdLCBpbnB1dFt0eXBlPWNoZWNrYm94XSwgaW5wdXRbdHlwZT1yYWRpb10sIGEsIDpkYXRhKHVpLWJ1dHRvbilcIlxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyggXCJ1aS1idXR0b25zZXRcIiApO1xuXHR9LFxuXG5cdF9pbml0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlZnJlc2goKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0dGhpcy5idXR0b25zLmJ1dHRvbiggXCJvcHRpb25cIiwga2V5LCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJ0bCA9IHRoaXMuZWxlbWVudC5jc3MoIFwiZGlyZWN0aW9uXCIgKSA9PT0gXCJydGxcIjtcblxuXHRcdHRoaXMuYnV0dG9ucyA9IHRoaXMuZWxlbWVudC5maW5kKCB0aGlzLm9wdGlvbnMuaXRlbXMgKVxuXHRcdFx0LmZpbHRlciggXCI6dWktYnV0dG9uXCIgKVxuXHRcdFx0XHQuYnV0dG9uKCBcInJlZnJlc2hcIiApXG5cdFx0XHQuZW5kKClcblx0XHRcdC5ub3QoIFwiOnVpLWJ1dHRvblwiIClcblx0XHRcdFx0LmJ1dHRvbigpXG5cdFx0XHQuZW5kKClcblx0XHRcdC5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYnV0dG9uKCBcIndpZGdldFwiIClbIDAgXTtcblx0XHRcdH0pXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1jb3JuZXItYWxsIHVpLWNvcm5lci1sZWZ0IHVpLWNvcm5lci1yaWdodFwiIClcblx0XHRcdFx0LmZpbHRlciggXCI6Zmlyc3RcIiApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBydGwgPyBcInVpLWNvcm5lci1yaWdodFwiIDogXCJ1aS1jb3JuZXItbGVmdFwiIClcblx0XHRcdFx0LmVuZCgpXG5cdFx0XHRcdC5maWx0ZXIoIFwiOmxhc3RcIiApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBydGwgPyBcInVpLWNvcm5lci1sZWZ0XCIgOiBcInVpLWNvcm5lci1yaWdodFwiIClcblx0XHRcdFx0LmVuZCgpXG5cdFx0XHQuZW5kKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS1idXR0b25zZXRcIiApO1xuXHRcdHRoaXMuYnV0dG9uc1xuXHRcdFx0Lm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICQoIHRoaXMgKS5idXR0b24oIFwid2lkZ2V0XCIgKVsgMCBdO1xuXHRcdFx0fSlcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWNvcm5lci1sZWZ0IHVpLWNvcm5lci1yaWdodFwiIClcblx0XHRcdC5lbmQoKVxuXHRcdFx0LmJ1dHRvbiggXCJkZXN0cm95XCIgKTtcblx0fVxufSk7XG5cbn0oIGpRdWVyeSApICk7XG4iLCJ2YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8qIVxuICogalF1ZXJ5IFVJIENvcmUgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L3VpLWNvcmUvXG4gKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHJ1bmlxdWVJZCA9IC9edWktaWQtXFxkKyQvO1xuXG4vLyAkLnVpIG1pZ2h0IGV4aXN0IGZyb20gY29tcG9uZW50cyB3aXRoIG5vIGRlcGVuZGVuY2llcywgZS5nLiwgJC51aS5wb3NpdGlvblxuJC51aSA9ICQudWkgfHwge307XG5cbiQuZXh0ZW5kKCAkLnVpLCB7XG5cdHZlcnNpb246IFwiMS4xMC40XCIsXG5cblx0a2V5Q29kZToge1xuXHRcdEJBQ0tTUEFDRTogOCxcblx0XHRDT01NQTogMTg4LFxuXHRcdERFTEVURTogNDYsXG5cdFx0RE9XTjogNDAsXG5cdFx0RU5EOiAzNSxcblx0XHRFTlRFUjogMTMsXG5cdFx0RVNDQVBFOiAyNyxcblx0XHRIT01FOiAzNixcblx0XHRMRUZUOiAzNyxcblx0XHROVU1QQURfQUREOiAxMDcsXG5cdFx0TlVNUEFEX0RFQ0lNQUw6IDExMCxcblx0XHROVU1QQURfRElWSURFOiAxMTEsXG5cdFx0TlVNUEFEX0VOVEVSOiAxMDgsXG5cdFx0TlVNUEFEX01VTFRJUExZOiAxMDYsXG5cdFx0TlVNUEFEX1NVQlRSQUNUOiAxMDksXG5cdFx0UEFHRV9ET1dOOiAzNCxcblx0XHRQQUdFX1VQOiAzMyxcblx0XHRQRVJJT0Q6IDE5MCxcblx0XHRSSUdIVDogMzksXG5cdFx0U1BBQ0U6IDMyLFxuXHRcdFRBQjogOSxcblx0XHRVUDogMzhcblx0fVxufSk7XG5cbi8vIHBsdWdpbnNcbiQuZm4uZXh0ZW5kKHtcblx0Zm9jdXM6IChmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGRlbGF5LCBmbiApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHQkKCBlbGVtICkuZm9jdXMoKTtcblx0XHRcdFx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdFx0XHRcdGZuLmNhbGwoIGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBkZWxheSApO1xuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cdH0pKCAkLmZuLmZvY3VzICksXG5cblx0c2Nyb2xsUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50O1xuXHRcdGlmICgoJC51aS5pZSAmJiAoLyhzdGF0aWN8cmVsYXRpdmUpLykudGVzdCh0aGlzLmNzcyhcInBvc2l0aW9uXCIpKSkgfHwgKC9hYnNvbHV0ZS8pLnRlc3QodGhpcy5jc3MoXCJwb3NpdGlvblwiKSkpIHtcblx0XHRcdHNjcm9sbFBhcmVudCA9IHRoaXMucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICgvKHJlbGF0aXZlfGFic29sdXRlfGZpeGVkKS8pLnRlc3QoJC5jc3ModGhpcyxcInBvc2l0aW9uXCIpKSAmJiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KCQuY3NzKHRoaXMsXCJvdmVyZmxvd1wiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteVwiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteFwiKSk7XG5cdFx0XHR9KS5lcSgwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKC8oYXV0b3xzY3JvbGwpLykudGVzdCgkLmNzcyh0aGlzLFwib3ZlcmZsb3dcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXlcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXhcIikpO1xuXHRcdFx0fSkuZXEoMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvZml4ZWQvKS50ZXN0KHRoaXMuY3NzKFwicG9zaXRpb25cIikpIHx8ICFzY3JvbGxQYXJlbnQubGVuZ3RoID8gJChkb2N1bWVudCkgOiBzY3JvbGxQYXJlbnQ7XG5cdH0sXG5cblx0ekluZGV4OiBmdW5jdGlvbiggekluZGV4ICkge1xuXHRcdGlmICggekluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jc3MoIFwiekluZGV4XCIsIHpJbmRleCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgZWxlbSA9ICQoIHRoaXNbIDAgXSApLCBwb3NpdGlvbiwgdmFsdWU7XG5cdFx0XHR3aGlsZSAoIGVsZW0ubGVuZ3RoICYmIGVsZW1bIDAgXSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdC8vIElnbm9yZSB6LWluZGV4IGlmIHBvc2l0aW9uIGlzIHNldCB0byBhIHZhbHVlIHdoZXJlIHotaW5kZXggaXMgaWdub3JlZCBieSB0aGUgYnJvd3NlclxuXHRcdFx0XHQvLyBUaGlzIG1ha2VzIGJlaGF2aW9yIG9mIHRoaXMgZnVuY3Rpb24gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnNcblx0XHRcdFx0Ly8gV2ViS2l0IGFsd2F5cyByZXR1cm5zIGF1dG8gaWYgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZFxuXHRcdFx0XHRwb3NpdGlvbiA9IGVsZW0uY3NzKCBcInBvc2l0aW9uXCIgKTtcblx0XHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdFx0XHQvLyBJRSByZXR1cm5zIDAgd2hlbiB6SW5kZXggaXMgbm90IHNwZWNpZmllZFxuXHRcdFx0XHRcdC8vIG90aGVyIGJyb3dzZXJzIHJldHVybiBhIHN0cmluZ1xuXHRcdFx0XHRcdC8vIHdlIGlnbm9yZSB0aGUgY2FzZSBvZiBuZXN0ZWQgZWxlbWVudHMgd2l0aCBhbiBleHBsaWNpdCB2YWx1ZSBvZiAwXG5cdFx0XHRcdFx0Ly8gPGRpdiBzdHlsZT1cInotaW5kZXg6IC0xMDtcIj48ZGl2IHN0eWxlPVwiei1pbmRleDogMDtcIj48L2Rpdj48L2Rpdj5cblx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlSW50KCBlbGVtLmNzcyggXCJ6SW5kZXhcIiApLCAxMCApO1xuXHRcdFx0XHRcdGlmICggIWlzTmFOKCB2YWx1ZSApICYmIHZhbHVlICE9PSAwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtID0gZWxlbS5wYXJlbnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHR1bmlxdWVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXMuaWQgKSB7XG5cdFx0XHRcdHRoaXMuaWQgPSBcInVpLWlkLVwiICsgKCsrdXVpZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cmVtb3ZlVW5pcXVlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJ1bmlxdWVJZC50ZXN0KCB0aGlzLmlkICkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVBdHRyKCBcImlkXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIHNlbGVjdG9yc1xuZnVuY3Rpb24gZm9jdXNhYmxlKCBlbGVtZW50LCBpc1RhYkluZGV4Tm90TmFOICkge1xuXHR2YXIgbWFwLCBtYXBOYW1lLCBpbWcsXG5cdFx0bm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGlmICggXCJhcmVhXCIgPT09IG5vZGVOYW1lICkge1xuXHRcdG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRtYXBOYW1lID0gbWFwLm5hbWU7XG5cdFx0aWYgKCAhZWxlbWVudC5ocmVmIHx8ICFtYXBOYW1lIHx8IG1hcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm1hcFwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpbWcgPSAkKCBcImltZ1t1c2VtYXA9I1wiICsgbWFwTmFtZSArIFwiXVwiIClbMF07XG5cdFx0cmV0dXJuICEhaW1nICYmIHZpc2libGUoIGltZyApO1xuXHR9XG5cdHJldHVybiAoIC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC8udGVzdCggbm9kZU5hbWUgKSA/XG5cdFx0IWVsZW1lbnQuZGlzYWJsZWQgOlxuXHRcdFwiYVwiID09PSBub2RlTmFtZSA/XG5cdFx0XHRlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6XG5cdFx0XHRpc1RhYkluZGV4Tm90TmFOKSAmJlxuXHRcdC8vIHRoZSBlbGVtZW50IGFuZCBhbGwgb2YgaXRzIGFuY2VzdG9ycyBtdXN0IGJlIHZpc2libGVcblx0XHR2aXNpYmxlKCBlbGVtZW50ICk7XG59XG5cbmZ1bmN0aW9uIHZpc2libGUoIGVsZW1lbnQgKSB7XG5cdHJldHVybiAkLmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtZW50ICkgJiZcblx0XHQhJCggZWxlbWVudCApLnBhcmVudHMoKS5hZGRCYWNrKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQuY3NzKCB0aGlzLCBcInZpc2liaWxpdHlcIiApID09PSBcImhpZGRlblwiO1xuXHRcdH0pLmxlbmd0aDtcbn1cblxuJC5leHRlbmQoICQuZXhwclsgXCI6XCIgXSwge1xuXHRkYXRhOiAkLmV4cHIuY3JlYXRlUHNldWRvID9cblx0XHQkLmV4cHIuY3JlYXRlUHNldWRvKGZ1bmN0aW9uKCBkYXRhTmFtZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBkYXRhTmFtZSApO1xuXHRcdFx0fTtcblx0XHR9KSA6XG5cdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRmdW5jdGlvbiggZWxlbSwgaSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIG1hdGNoWyAzIF0gKTtcblx0XHR9LFxuXG5cdGZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGZvY3VzYWJsZSggZWxlbWVudCwgIWlzTmFOKCAkLmF0dHIoIGVsZW1lbnQsIFwidGFiaW5kZXhcIiApICkgKTtcblx0fSxcblxuXHR0YWJiYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHRhYkluZGV4ID0gJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSxcblx0XHRcdGlzVGFiSW5kZXhOYU4gPSBpc05hTiggdGFiSW5kZXggKTtcblx0XHRyZXR1cm4gKCBpc1RhYkluZGV4TmFOIHx8IHRhYkluZGV4ID49IDAgKSAmJiBmb2N1c2FibGUoIGVsZW1lbnQsICFpc1RhYkluZGV4TmFOICk7XG5cdH1cbn0pO1xuXG4vLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuaWYgKCAhJCggXCI8YT5cIiApLm91dGVyV2lkdGgoIDEgKS5qcXVlcnkgKSB7XG5cdCQuZWFjaCggWyBcIldpZHRoXCIsIFwiSGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0dmFyIHNpZGUgPSBuYW1lID09PSBcIldpZHRoXCIgPyBbIFwiTGVmdFwiLCBcIlJpZ2h0XCIgXSA6IFsgXCJUb3BcIiwgXCJCb3R0b21cIiBdLFxuXHRcdFx0dHlwZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdG9yaWcgPSB7XG5cdFx0XHRcdGlubmVyV2lkdGg6ICQuZm4uaW5uZXJXaWR0aCxcblx0XHRcdFx0aW5uZXJIZWlnaHQ6ICQuZm4uaW5uZXJIZWlnaHQsXG5cdFx0XHRcdG91dGVyV2lkdGg6ICQuZm4ub3V0ZXJXaWR0aCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6ICQuZm4ub3V0ZXJIZWlnaHRcblx0XHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWR1Y2UoIGVsZW0sIHNpemUsIGJvcmRlciwgbWFyZ2luICkge1xuXHRcdFx0JC5lYWNoKCBzaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyB0aGlzICkgKSB8fCAwO1xuXHRcdFx0XHRpZiAoIGJvcmRlciApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgdGhpcyArIFwiV2lkdGhcIiApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hcmdpbiApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcIm1hcmdpblwiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHR9XG5cblx0XHQkLmZuWyBcImlubmVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggc2l6ZSApIHtcblx0XHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJpbm5lclwiICsgbmFtZSBdLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplICkgKyBcInB4XCIgKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQkLmZuWyBcIm91dGVyXCIgKyBuYW1lXSA9IGZ1bmN0aW9uKCBzaXplLCBtYXJnaW4gKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaXplICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJvdXRlclwiICsgbmFtZSBdLmNhbGwoIHRoaXMsIHNpemUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcykuY3NzKCB0eXBlLCByZWR1Y2UoIHRoaXMsIHNpemUsIHRydWUsIG1hcmdpbiApICsgXCJweFwiICk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcbmlmICggISQuZm4uYWRkQmFjayApIHtcblx0JC5mbi5hZGRCYWNrID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDEuNi4xLCAxLjYuMiAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxMylcbmlmICggJCggXCI8YT5cIiApLmRhdGEoIFwiYS1iXCIsIFwiYVwiICkucmVtb3ZlRGF0YSggXCJhLWJcIiApLmRhdGEoIFwiYS1iXCIgKSApIHtcblx0JC5mbi5yZW1vdmVEYXRhID0gKGZ1bmN0aW9uKCByZW1vdmVEYXRhICkge1xuXHRcdHJldHVybiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKCB0aGlzLCAkLmNhbWVsQ2FzZSgga2V5ICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVEYXRhLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSggJC5mbi5yZW1vdmVEYXRhICk7XG59XG5cblxuXG5cblxuLy8gZGVwcmVjYXRlZFxuJC51aS5pZSA9ICEhL21zaWUgW1xcdy5dKy8uZXhlYyggbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpICk7XG5cbiQuc3VwcG9ydC5zZWxlY3RzdGFydCA9IFwib25zZWxlY3RzdGFydFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcbiQuZm4uZXh0ZW5kKHtcblx0ZGlzYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmluZCggKCAkLnN1cHBvcnQuc2VsZWN0c3RhcnQgPyBcInNlbGVjdHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiICkgK1xuXHRcdFx0XCIudWktZGlzYWJsZVNlbGVjdGlvblwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9KTtcblx0fSxcblxuXHRlbmFibGVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnVuYmluZCggXCIudWktZGlzYWJsZVNlbGVjdGlvblwiICk7XG5cdH1cbn0pO1xuXG4kLmV4dGVuZCggJC51aSwge1xuXHQvLyAkLnVpLnBsdWdpbiBpcyBkZXByZWNhdGVkLiBVc2UgJC53aWRnZXQoKSBleHRlbnNpb25zIGluc3RlYWQuXG5cdHBsdWdpbjoge1xuXHRcdGFkZDogZnVuY3Rpb24oIG1vZHVsZSwgb3B0aW9uLCBzZXQgKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0cHJvdG8gPSAkLnVpWyBtb2R1bGUgXS5wcm90b3R5cGU7XG5cdFx0XHRmb3IgKCBpIGluIHNldCApIHtcblx0XHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdID0gcHJvdG8ucGx1Z2luc1sgaSBdIHx8IFtdO1xuXHRcdFx0XHRwcm90by5wbHVnaW5zWyBpIF0ucHVzaCggWyBvcHRpb24sIHNldFsgaSBdIF0gKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNhbGw6IGZ1bmN0aW9uKCBpbnN0YW5jZSwgbmFtZSwgYXJncyApIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRzZXQgPSBpbnN0YW5jZS5wbHVnaW5zWyBuYW1lIF07XG5cdFx0XHRpZiAoICFzZXQgfHwgIWluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlIHx8IGluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZS5vcHRpb25zWyBzZXRbIGkgXVsgMCBdIF0gKSB7XG5cdFx0XHRcdFx0c2V0WyBpIF1bIDEgXS5hcHBseSggaW5zdGFuY2UuZWxlbWVudCwgYXJncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIG9ubHkgdXNlZCBieSByZXNpemFibGVcblx0aGFzU2Nyb2xsOiBmdW5jdGlvbiggZWwsIGEgKSB7XG5cblx0XHQvL0lmIG92ZXJmbG93IGlzIGhpZGRlbiwgdGhlIGVsZW1lbnQgbWlnaHQgaGF2ZSBleHRyYSBjb250ZW50LCBidXQgdGhlIHVzZXIgd2FudHMgdG8gaGlkZSBpdFxuXHRcdGlmICggJCggZWwgKS5jc3MoIFwib3ZlcmZsb3dcIiApID09PSBcImhpZGRlblwiKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHNjcm9sbCA9ICggYSAmJiBhID09PSBcImxlZnRcIiApID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiLFxuXHRcdFx0aGFzID0gZmFsc2U7XG5cblx0XHRpZiAoIGVsWyBzY3JvbGwgXSA+IDAgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBkZXRlcm1pbmUgd2hpY2ggY2FzZXMgYWN0dWFsbHkgY2F1c2UgdGhpcyB0byBoYXBwZW5cblx0XHQvLyBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgdGhlIHNjcm9sbCBzZXQsIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvXG5cdFx0Ly8gc2V0IHRoZSBzY3JvbGxcblx0XHRlbFsgc2Nyb2xsIF0gPSAxO1xuXHRcdGhhcyA9ICggZWxbIHNjcm9sbCBdID4gMCApO1xuXHRcdGVsWyBzY3JvbGwgXSA9IDA7XG5cdFx0cmV0dXJuIGhhcztcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJy4vY29yZScpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBEYXRlcGlja2VyIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kYXRlcGlja2VyL1xuICpcbiAqIERlcGVuZHM6XG4gKlx0anF1ZXJ5LnVpLmNvcmUuanNcbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZXh0ZW5kKCQudWksIHsgZGF0ZXBpY2tlcjogeyB2ZXJzaW9uOiBcIjEuMTAuNFwiIH0gfSk7XG5cbnZhciBQUk9QX05BTUUgPSBcImRhdGVwaWNrZXJcIixcblx0aW5zdEFjdGl2ZTtcblxuLyogRGF0ZSBwaWNrZXIgbWFuYWdlci5cbiAgIFVzZSB0aGUgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MsICQuZGF0ZXBpY2tlciwgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgZGF0ZSBwaWNrZXIuXG4gICBTZXR0aW5ncyBmb3IgKGdyb3VwcyBvZikgZGF0ZSBwaWNrZXJzIGFyZSBtYWludGFpbmVkIGluIGFuIGluc3RhbmNlIG9iamVjdCxcbiAgIGFsbG93aW5nIG11bHRpcGxlIGRpZmZlcmVudCBzZXR0aW5ncyBvbiB0aGUgc2FtZSBwYWdlLiAqL1xuXG5mdW5jdGlvbiBEYXRlcGlja2VyKCkge1xuXHR0aGlzLl9jdXJJbnN0ID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgaW5zdGFuY2UgaW4gdXNlXG5cdHRoaXMuX2tleUV2ZW50ID0gZmFsc2U7IC8vIElmIHRoZSBsYXN0IGV2ZW50IHdhcyBhIGtleSBldmVudFxuXHR0aGlzLl9kaXNhYmxlZElucHV0cyA9IFtdOyAvLyBMaXN0IG9mIGRhdGUgcGlja2VyIGlucHV0cyB0aGF0IGhhdmUgYmVlbiBkaXNhYmxlZFxuXHR0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBwb3B1cCBwaWNrZXIgaXMgc2hvd2luZyAsIGZhbHNlIGlmIG5vdFxuXHR0aGlzLl9pbkRpYWxvZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHNob3dpbmcgd2l0aGluIGEgXCJkaWFsb2dcIiwgZmFsc2UgaWYgbm90XG5cdHRoaXMuX21haW5EaXZJZCA9IFwidWktZGF0ZXBpY2tlci1kaXZcIjsgLy8gVGhlIElEIG9mIHRoZSBtYWluIGRhdGVwaWNrZXIgZGl2aXNpb25cblx0dGhpcy5faW5saW5lQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItaW5saW5lXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBpbmxpbmUgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2FwcGVuZENsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWFwcGVuZFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgYXBwZW5kIG1hcmtlciBjbGFzc1xuXHR0aGlzLl90cmlnZ2VyQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItdHJpZ2dlclwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgdHJpZ2dlciBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGlhbG9nQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItZGlhbG9nXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaWFsb2cgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2Rpc2FibGVDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kaXNhYmxlZFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGlzYWJsZWQgY292ZXJpbmcgbWFya2VyIGNsYXNzXG5cdHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLXVuc2VsZWN0YWJsZVwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgdW5zZWxlY3RhYmxlIGNlbGwgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2N1cnJlbnRDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1jdXJyZW50LWRheVwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBkYXkgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2RheU92ZXJDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kYXlzLWNlbGwtb3ZlclwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGF5IGhvdmVyIG1hcmtlciBjbGFzc1xuXHR0aGlzLnJlZ2lvbmFsID0gW107IC8vIEF2YWlsYWJsZSByZWdpb25hbCBzZXR0aW5ncywgaW5kZXhlZCBieSBsYW5ndWFnZSBjb2RlXG5cdHRoaXMucmVnaW9uYWxbXCJcIl0gPSB7IC8vIERlZmF1bHQgcmVnaW9uYWwgc2V0dGluZ3Ncblx0XHRjbG9zZVRleHQ6IFwiRG9uZVwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIGNsb3NlIGxpbmtcblx0XHRwcmV2VGV4dDogXCJQcmV2XCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgcHJldmlvdXMgbW9udGggbGlua1xuXHRcdG5leHRUZXh0OiBcIk5leHRcIiwgLy8gRGlzcGxheSB0ZXh0IGZvciBuZXh0IG1vbnRoIGxpbmtcblx0XHRjdXJyZW50VGV4dDogXCJUb2RheVwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIGN1cnJlbnQgbW9udGggbGlua1xuXHRcdG1vbnRoTmFtZXM6IFtcIkphbnVhcnlcIixcIkZlYnJ1YXJ5XCIsXCJNYXJjaFwiLFwiQXByaWxcIixcIk1heVwiLFwiSnVuZVwiLFxuXHRcdFx0XCJKdWx5XCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2N0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlY2VtYmVyXCJdLCAvLyBOYW1lcyBvZiBtb250aHMgZm9yIGRyb3AtZG93biBhbmQgZm9ybWF0dGluZ1xuXHRcdG1vbnRoTmFtZXNTaG9ydDogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdLCAvLyBGb3IgZm9ybWF0dGluZ1xuXHRcdGRheU5hbWVzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSwgLy8gRm9yIGZvcm1hdHRpbmdcblx0XHRkYXlOYW1lc1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXNNaW46IFtcIlN1XCIsXCJNb1wiLFwiVHVcIixcIldlXCIsXCJUaFwiLFwiRnJcIixcIlNhXCJdLCAvLyBDb2x1bW4gaGVhZGluZ3MgZm9yIGRheXMgc3RhcnRpbmcgYXQgU3VuZGF5XG5cdFx0d2Vla0hlYWRlcjogXCJXa1wiLCAvLyBDb2x1bW4gaGVhZGVyIGZvciB3ZWVrIG9mIHRoZSB5ZWFyXG5cdFx0ZGF0ZUZvcm1hdDogXCJtbS9kZC95eVwiLCAvLyBTZWUgZm9ybWF0IG9wdGlvbnMgb24gcGFyc2VEYXRlXG5cdFx0Zmlyc3REYXk6IDAsIC8vIFRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWssIFN1biA9IDAsIE1vbiA9IDEsIC4uLlxuXHRcdGlzUlRMOiBmYWxzZSwgLy8gVHJ1ZSBpZiByaWdodC10by1sZWZ0IGxhbmd1YWdlLCBmYWxzZSBpZiBsZWZ0LXRvLXJpZ2h0XG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSwgLy8gVHJ1ZSBpZiB0aGUgeWVhciBzZWxlY3QgcHJlY2VkZXMgbW9udGgsIGZhbHNlIGZvciBtb250aCB0aGVuIHllYXJcblx0XHR5ZWFyU3VmZml4OiBcIlwiIC8vIEFkZGl0aW9uYWwgdGV4dCB0byBhcHBlbmQgdG8gdGhlIHllYXIgaW4gdGhlIG1vbnRoIGhlYWRlcnNcblx0fTtcblx0dGhpcy5fZGVmYXVsdHMgPSB7IC8vIEdsb2JhbCBkZWZhdWx0cyBmb3IgYWxsIHRoZSBkYXRlIHBpY2tlciBpbnN0YW5jZXNcblx0XHRzaG93T246IFwiZm9jdXNcIiwgLy8gXCJmb2N1c1wiIGZvciBwb3B1cCBvbiBmb2N1cyxcblx0XHRcdC8vIFwiYnV0dG9uXCIgZm9yIHRyaWdnZXIgYnV0dG9uLCBvciBcImJvdGhcIiBmb3IgZWl0aGVyXG5cdFx0c2hvd0FuaW06IFwiZmFkZUluXCIsIC8vIE5hbWUgb2YgalF1ZXJ5IGFuaW1hdGlvbiBmb3IgcG9wdXBcblx0XHRzaG93T3B0aW9uczoge30sIC8vIE9wdGlvbnMgZm9yIGVuaGFuY2VkIGFuaW1hdGlvbnNcblx0XHRkZWZhdWx0RGF0ZTogbnVsbCwgLy8gVXNlZCB3aGVuIGZpZWxkIGlzIGJsYW5rOiBhY3R1YWwgZGF0ZSxcblx0XHRcdC8vICsvLW51bWJlciBmb3Igb2Zmc2V0IGZyb20gdG9kYXksIG51bGwgZm9yIHRvZGF5XG5cdFx0YXBwZW5kVGV4dDogXCJcIiwgLy8gRGlzcGxheSB0ZXh0IGZvbGxvd2luZyB0aGUgaW5wdXQgYm94LCBlLmcuIHNob3dpbmcgdGhlIGZvcm1hdFxuXHRcdGJ1dHRvblRleHQ6IFwiLi4uXCIsIC8vIFRleHQgZm9yIHRyaWdnZXIgYnV0dG9uXG5cdFx0YnV0dG9uSW1hZ2U6IFwiXCIsIC8vIFVSTCBmb3IgdHJpZ2dlciBidXR0b24gaW1hZ2Vcblx0XHRidXR0b25JbWFnZU9ubHk6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSBpbWFnZSBhcHBlYXJzIGFsb25lLCBmYWxzZSBpZiBpdCBhcHBlYXJzIG9uIGEgYnV0dG9uXG5cdFx0aGlkZUlmTm9QcmV2TmV4dDogZmFsc2UsIC8vIFRydWUgdG8gaGlkZSBuZXh0L3ByZXZpb3VzIG1vbnRoIGxpbmtzXG5cdFx0XHQvLyBpZiBub3QgYXBwbGljYWJsZSwgZmFsc2UgdG8ganVzdCBkaXNhYmxlIHRoZW1cblx0XHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0OiBmYWxzZSwgLy8gVHJ1ZSBpZiBkYXRlIGZvcm1hdHRpbmcgYXBwbGllZCB0byBwcmV2L3RvZGF5L25leHQgbGlua3Ncblx0XHRnb3RvQ3VycmVudDogZmFsc2UsIC8vIFRydWUgaWYgdG9kYXkgbGluayBnb2VzIGJhY2sgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5zdGVhZFxuXHRcdGNoYW5nZU1vbnRoOiBmYWxzZSwgLy8gVHJ1ZSBpZiBtb250aCBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XG5cdFx0Y2hhbmdlWWVhcjogZmFsc2UsIC8vIFRydWUgaWYgeWVhciBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XG5cdFx0eWVhclJhbmdlOiBcImMtMTA6YysxMFwiLCAvLyBSYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5IGluIGRyb3AtZG93bixcblx0XHRcdC8vIGVpdGhlciByZWxhdGl2ZSB0byB0b2RheSdzIHllYXIgKC1ubjorbm4pLCByZWxhdGl2ZSB0byBjdXJyZW50bHkgZGlzcGxheWVkIHllYXJcblx0XHRcdC8vIChjLW5uOmMrbm4pLCBhYnNvbHV0ZSAobm5ubjpubm5uKSwgb3IgYSBjb21iaW5hdGlvbiBvZiB0aGUgYWJvdmUgKG5ubm46LW4pXG5cdFx0c2hvd090aGVyTW9udGhzOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgdG8gbGVhdmUgYmxhbmtcblx0XHRzZWxlY3RPdGhlck1vbnRoczogZmFsc2UsIC8vIFRydWUgdG8gYWxsb3cgc2VsZWN0aW9uIG9mIGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgZm9yIHVuc2VsZWN0YWJsZVxuXHRcdHNob3dXZWVrOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IHdlZWsgb2YgdGhlIHllYXIsIGZhbHNlIHRvIG5vdCBzaG93IGl0XG5cdFx0Y2FsY3VsYXRlV2VlazogdGhpcy5pc284NjAxV2VlaywgLy8gSG93IHRvIGNhbGN1bGF0ZSB0aGUgd2VlayBvZiB0aGUgeWVhcixcblx0XHRcdC8vIHRha2VzIGEgRGF0ZSBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRoZSB3ZWVrIGZvciBpdFxuXHRcdHNob3J0WWVhckN1dG9mZjogXCIrMTBcIiwgLy8gU2hvcnQgeWVhciB2YWx1ZXMgPCB0aGlzIGFyZSBpbiB0aGUgY3VycmVudCBjZW50dXJ5LFxuXHRcdFx0Ly8gPiB0aGlzIGFyZSBpbiB0aGUgcHJldmlvdXMgY2VudHVyeSxcblx0XHRcdC8vIHN0cmluZyB2YWx1ZSBzdGFydGluZyB3aXRoIFwiK1wiIGZvciBjdXJyZW50IHllYXIgKyB2YWx1ZVxuXHRcdG1pbkRhdGU6IG51bGwsIC8vIFRoZSBlYXJsaWVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XG5cdFx0bWF4RGF0ZTogbnVsbCwgLy8gVGhlIGxhdGVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XG5cdFx0ZHVyYXRpb246IFwiZmFzdFwiLCAvLyBEdXJhdGlvbiBvZiBkaXNwbGF5L2Nsb3N1cmVcblx0XHRiZWZvcmVTaG93RGF5OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGEgZGF0ZSBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoXG5cdFx0XHQvLyBbMF0gPSB0cnVlIGlmIHNlbGVjdGFibGUsIGZhbHNlIGlmIG5vdCwgWzFdID0gY3VzdG9tIENTUyBjbGFzcyBuYW1lKHMpIG9yIFwiXCIsXG5cdFx0XHQvLyBbMl0gPSBjZWxsIHRpdGxlIChvcHRpb25hbCksIGUuZy4gJC5kYXRlcGlja2VyLm5vV2Vla2VuZHNcblx0XHRiZWZvcmVTaG93OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGFuIGlucHV0IGZpZWxkIGFuZFxuXHRcdFx0Ly8gcmV0dXJucyBhIHNldCBvZiBjdXN0b20gc2V0dGluZ3MgZm9yIHRoZSBkYXRlIHBpY2tlclxuXHRcdG9uU2VsZWN0OiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZFxuXHRcdG9uQ2hhbmdlTW9udGhZZWFyOiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBtb250aCBvciB5ZWFyIGlzIGNoYW5nZWRcblx0XHRvbkNsb3NlOiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBkYXRlcGlja2VyIGlzIGNsb3NlZFxuXHRcdG51bWJlck9mTW9udGhzOiAxLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHNob3cgYXQgYSB0aW1lXG5cdFx0c2hvd0N1cnJlbnRBdFBvczogMCwgLy8gVGhlIHBvc2l0aW9uIGluIG11bHRpcGUgbW9udGhzIGF0IHdoaWNoIHRvIHNob3cgdGhlIGN1cnJlbnQgbW9udGggKHN0YXJ0aW5nIGF0IDApXG5cdFx0c3RlcE1vbnRoczogMSwgLy8gTnVtYmVyIG9mIG1vbnRocyB0byBzdGVwIGJhY2svZm9yd2FyZFxuXHRcdHN0ZXBCaWdNb250aHM6IDEyLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHN0ZXAgYmFjay9mb3J3YXJkIGZvciB0aGUgYmlnIGxpbmtzXG5cdFx0YWx0RmllbGQ6IFwiXCIsIC8vIFNlbGVjdG9yIGZvciBhbiBhbHRlcm5hdGUgZmllbGQgdG8gc3RvcmUgc2VsZWN0ZWQgZGF0ZXMgaW50b1xuXHRcdGFsdEZvcm1hdDogXCJcIiwgLy8gVGhlIGRhdGUgZm9ybWF0IHRvIHVzZSBmb3IgdGhlIGFsdGVybmF0ZSBmaWVsZFxuXHRcdGNvbnN0cmFpbklucHV0OiB0cnVlLCAvLyBUaGUgaW5wdXQgaXMgY29uc3RyYWluZWQgYnkgdGhlIGN1cnJlbnQgZGF0ZSBmb3JtYXRcblx0XHRzaG93QnV0dG9uUGFuZWw6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgYnV0dG9uIHBhbmVsLCBmYWxzZSB0byBub3Qgc2hvdyBpdFxuXHRcdGF1dG9TaXplOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaXplIHRoZSBpbnB1dCBmb3IgdGhlIGRhdGUgZm9ybWF0LCBmYWxzZSB0byBsZWF2ZSBhcyBpc1xuXHRcdGRpc2FibGVkOiBmYWxzZSAvLyBUaGUgaW5pdGlhbCBkaXNhYmxlZCBzdGF0ZVxuXHR9O1xuXHQkLmV4dGVuZCh0aGlzLl9kZWZhdWx0cywgdGhpcy5yZWdpb25hbFtcIlwiXSk7XG5cdHRoaXMuZHBEaXYgPSBiaW5kSG92ZXIoJChcIjxkaXYgaWQ9J1wiICsgdGhpcy5fbWFpbkRpdklkICsgXCInIGNsYXNzPSd1aS1kYXRlcGlja2VyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbCc+PC9kaXY+XCIpKTtcbn1cblxuJC5leHRlbmQoRGF0ZXBpY2tlci5wcm90b3R5cGUsIHtcblx0LyogQ2xhc3MgbmFtZSBhZGRlZCB0byBlbGVtZW50cyB0byBpbmRpY2F0ZSBhbHJlYWR5IGNvbmZpZ3VyZWQgd2l0aCBhIGRhdGUgcGlja2VyLiAqL1xuXHRtYXJrZXJDbGFzc05hbWU6IFwiaGFzRGF0ZXBpY2tlclwiLFxuXG5cdC8vS2VlcCB0cmFjayBvZiB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyBkaXNwbGF5ZWQgKHNlZSAjNzA0Mylcblx0bWF4Um93czogNCxcblxuXHQvLyBUT0RPIHJlbmFtZSB0byBcIndpZGdldFwiIHdoZW4gc3dpdGNoaW5nIHRvIHdpZGdldCBmYWN0b3J5XG5cdF93aWRnZXREYXRlcGlja2VyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kcERpdjtcblx0fSxcblxuXHQvKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIGluc3RhbmNlcyBvZiB0aGUgZGF0ZSBwaWNrZXIuXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGFzIGRlZmF1bHRzIChhbm9ueW1vdXMgb2JqZWN0KVxuXHQgKiBAcmV0dXJuIHRoZSBtYW5hZ2VyIG9iamVjdFxuXHQgKi9cblx0c2V0RGVmYXVsdHM6IGZ1bmN0aW9uKHNldHRpbmdzKSB7XG5cdFx0ZXh0ZW5kUmVtb3ZlKHRoaXMuX2RlZmF1bHRzLCBzZXR0aW5ncyB8fCB7fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyogQXR0YWNoIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGZvciB0aGlzIGRhdGUgcGlja2VyIGluc3RhbmNlIChhbm9ueW1vdXMpXG5cdCAqL1xuXHRfYXR0YWNoRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBzZXR0aW5ncykge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLCBpbnN0O1xuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aW5saW5lID0gKG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIik7XG5cdFx0aWYgKCF0YXJnZXQuaWQpIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0dGFyZ2V0LmlkID0gXCJkcFwiICsgdGhpcy51dWlkO1xuXHRcdH1cblx0XHRpbnN0ID0gdGhpcy5fbmV3SW5zdCgkKHRhcmdldCksIGlubGluZSk7XG5cdFx0aW5zdC5zZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBzZXR0aW5ncyB8fCB7fSk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdHRoaXMuX2Nvbm5lY3REYXRlcGlja2VyKHRhcmdldCwgaW5zdCk7XG5cdFx0fSBlbHNlIGlmIChpbmxpbmUpIHtcblx0XHRcdHRoaXMuX2lubGluZURhdGVwaWNrZXIodGFyZ2V0LCBpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9iamVjdC4gKi9cblx0X25ld0luc3Q6IGZ1bmN0aW9uKHRhcmdldCwgaW5saW5lKSB7XG5cdFx0dmFyIGlkID0gdGFyZ2V0WzBdLmlkLnJlcGxhY2UoLyhbXkEtWmEtejAtOV9cXC1dKS9nLCBcIlxcXFxcXFxcJDFcIik7IC8vIGVzY2FwZSBqUXVlcnkgbWV0YSBjaGFyc1xuXHRcdHJldHVybiB7aWQ6IGlkLCBpbnB1dDogdGFyZ2V0LCAvLyBhc3NvY2lhdGVkIHRhcmdldFxuXHRcdFx0c2VsZWN0ZWREYXk6IDAsIHNlbGVjdGVkTW9udGg6IDAsIHNlbGVjdGVkWWVhcjogMCwgLy8gY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdGRyYXdNb250aDogMCwgZHJhd1llYXI6IDAsIC8vIG1vbnRoIGJlaW5nIGRyYXduXG5cdFx0XHRpbmxpbmU6IGlubGluZSwgLy8gaXMgZGF0ZXBpY2tlciBpbmxpbmUgb3Igbm90XG5cdFx0XHRkcERpdjogKCFpbmxpbmUgPyB0aGlzLmRwRGl2IDogLy8gcHJlc2VudGF0aW9uIGRpdlxuXHRcdFx0YmluZEhvdmVyKCQoXCI8ZGl2IGNsYXNzPSdcIiArIHRoaXMuX2lubGluZUNsYXNzICsgXCIgdWktZGF0ZXBpY2tlciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGwnPjwvZGl2PlwiKSkpfTtcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGFuIGlucHV0IGZpZWxkLiAqL1xuXHRfY29ubmVjdERhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgaW5zdCkge1xuXHRcdHZhciBpbnB1dCA9ICQodGFyZ2V0KTtcblx0XHRpbnN0LmFwcGVuZCA9ICQoW10pO1xuXHRcdGluc3QudHJpZ2dlciA9ICQoW10pO1xuXHRcdGlmIChpbnB1dC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fYXR0YWNobWVudHMoaW5wdXQsIGluc3QpO1xuXHRcdGlucHV0LmFkZENsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKS5rZXlkb3duKHRoaXMuX2RvS2V5RG93bikuXG5cdFx0XHRrZXlwcmVzcyh0aGlzLl9kb0tleVByZXNzKS5rZXl1cCh0aGlzLl9kb0tleVVwKTtcblx0XHR0aGlzLl9hdXRvU2l6ZShpbnN0KTtcblx0XHQkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdC8vSWYgZGlzYWJsZWQgb3B0aW9uIGlzIHRydWUsIGRpc2FibGUgdGhlIGRhdGVwaWNrZXIgb25jZSBpdCBoYXMgYmVlbiBhdHRhY2hlZCB0byB0aGUgaW5wdXQgKHNlZSB0aWNrZXQgIzU2NjUpXG5cdFx0aWYoIGluc3Quc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlciggdGFyZ2V0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIE1ha2UgYXR0YWNobWVudHMgYmFzZWQgb24gc2V0dGluZ3MuICovXG5cdF9hdHRhY2htZW50czogZnVuY3Rpb24oaW5wdXQsIGluc3QpIHtcblx0XHR2YXIgc2hvd09uLCBidXR0b25UZXh0LCBidXR0b25JbWFnZSxcblx0XHRcdGFwcGVuZFRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXCJhcHBlbmRUZXh0XCIpLFxuXHRcdFx0aXNSVEwgPSB0aGlzLl9nZXQoaW5zdCwgXCJpc1JUTFwiKTtcblxuXHRcdGlmIChpbnN0LmFwcGVuZCkge1xuXHRcdFx0aW5zdC5hcHBlbmQucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdGlmIChhcHBlbmRUZXh0KSB7XG5cdFx0XHRpbnN0LmFwcGVuZCA9ICQoXCI8c3BhbiBjbGFzcz0nXCIgKyB0aGlzLl9hcHBlbmRDbGFzcyArIFwiJz5cIiArIGFwcGVuZFRleHQgKyBcIjwvc3Bhbj5cIik7XG5cdFx0XHRpbnB1dFtpc1JUTCA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCJdKGluc3QuYXBwZW5kKTtcblx0XHR9XG5cblx0XHRpbnB1dC51bmJpbmQoXCJmb2N1c1wiLCB0aGlzLl9zaG93RGF0ZXBpY2tlcik7XG5cblx0XHRpZiAoaW5zdC50cmlnZ2VyKSB7XG5cdFx0XHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0c2hvd09uID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd09uXCIpO1xuXHRcdGlmIChzaG93T24gPT09IFwiZm9jdXNcIiB8fCBzaG93T24gPT09IFwiYm90aFwiKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGluIHRoZSBtYXJrZWQgZmllbGRcblx0XHRcdGlucHV0LmZvY3VzKHRoaXMuX3Nob3dEYXRlcGlja2VyKTtcblx0XHR9XG5cdFx0aWYgKHNob3dPbiA9PT0gXCJidXR0b25cIiB8fCBzaG93T24gPT09IFwiYm90aFwiKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGJ1dHRvbiBjbGlja2VkXG5cdFx0XHRidXR0b25UZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwiYnV0dG9uVGV4dFwiKTtcblx0XHRcdGJ1dHRvbkltYWdlID0gdGhpcy5fZ2V0KGluc3QsIFwiYnV0dG9uSW1hZ2VcIik7XG5cdFx0XHRpbnN0LnRyaWdnZXIgPSAkKHRoaXMuX2dldChpbnN0LCBcImJ1dHRvbkltYWdlT25seVwiKSA/XG5cdFx0XHRcdCQoXCI8aW1nLz5cIikuYWRkQ2xhc3ModGhpcy5fdHJpZ2dlckNsYXNzKS5cblx0XHRcdFx0XHRhdHRyKHsgc3JjOiBidXR0b25JbWFnZSwgYWx0OiBidXR0b25UZXh0LCB0aXRsZTogYnV0dG9uVGV4dCB9KSA6XG5cdFx0XHRcdCQoXCI8YnV0dG9uIHR5cGU9J2J1dHRvbic+PC9idXR0b24+XCIpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcykuXG5cdFx0XHRcdFx0aHRtbCghYnV0dG9uSW1hZ2UgPyBidXR0b25UZXh0IDogJChcIjxpbWcvPlwiKS5hdHRyKFxuXHRcdFx0XHRcdHsgc3JjOmJ1dHRvbkltYWdlLCBhbHQ6YnV0dG9uVGV4dCwgdGl0bGU6YnV0dG9uVGV4dCB9KSkpO1xuXHRcdFx0aW5wdXRbaXNSVEwgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiXShpbnN0LnRyaWdnZXIpO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmNsaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9PT0gaW5wdXRbMF0pIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCAhPT0gaW5wdXRbMF0pIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlcihpbnB1dFswXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlcihpbnB1dFswXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEFwcGx5IHRoZSBtYXhpbXVtIGxlbmd0aCBmb3IgdGhlIGRhdGUgZm9ybWF0LiAqL1xuXHRfYXV0b1NpemU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRpZiAodGhpcy5fZ2V0KGluc3QsIFwiYXV0b1NpemVcIikgJiYgIWluc3QuaW5saW5lKSB7XG5cdFx0XHR2YXIgZmluZE1heCwgbWF4LCBtYXhJLCBpLFxuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoMjAwOSwgMTIgLSAxLCAyMCksIC8vIEVuc3VyZSBkb3VibGUgZGlnaXRzXG5cdFx0XHRcdGRhdGVGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXCJkYXRlRm9ybWF0XCIpO1xuXG5cdFx0XHRpZiAoZGF0ZUZvcm1hdC5tYXRjaCgvW0RNXS8pKSB7XG5cdFx0XHRcdGZpbmRNYXggPSBmdW5jdGlvbihuYW1lcykge1xuXHRcdFx0XHRcdG1heCA9IDA7XG5cdFx0XHRcdFx0bWF4SSA9IDA7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAobmFtZXNbaV0ubGVuZ3RoID4gbWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1heCA9IG5hbWVzW2ldLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0bWF4SSA9IGk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXhJO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRkYXRlLnNldE1vbnRoKGZpbmRNYXgodGhpcy5fZ2V0KGluc3QsIChkYXRlRm9ybWF0Lm1hdGNoKC9NTS8pID9cblx0XHRcdFx0XHRcIm1vbnRoTmFtZXNcIiA6IFwibW9udGhOYW1lc1Nob3J0XCIpKSkpO1xuXHRcdFx0XHRkYXRlLnNldERhdGUoZmluZE1heCh0aGlzLl9nZXQoaW5zdCwgKGRhdGVGb3JtYXQubWF0Y2goL0RELykgP1xuXHRcdFx0XHRcdFwiZGF5TmFtZXNcIiA6IFwiZGF5TmFtZXNTaG9ydFwiKSkpICsgMjAgLSBkYXRlLmdldERheSgpKTtcblx0XHRcdH1cblx0XHRcdGluc3QuaW5wdXQuYXR0cihcInNpemVcIiwgdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBkYXRlKS5sZW5ndGgpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBBdHRhY2ggYW4gaW5saW5lIGRhdGUgcGlja2VyIHRvIGEgZGl2LiAqL1xuXHRfaW5saW5lRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBpbnN0KSB7XG5cdFx0dmFyIGRpdlNwYW4gPSAkKHRhcmdldCk7XG5cdFx0aWYgKGRpdlNwYW4uaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGRpdlNwYW4uYWRkQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmFwcGVuZChpbnN0LmRwRGl2KTtcblx0XHQkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdHRoaXMuX3NldERhdGUoaW5zdCwgdGhpcy5fZ2V0RGVmYXVsdERhdGUoaW5zdCksIHRydWUpO1xuXHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdC8vSWYgZGlzYWJsZWQgb3B0aW9uIGlzIHRydWUsIGRpc2FibGUgdGhlIGRhdGVwaWNrZXIgYmVmb3JlIHNob3dpbmcgaXQgKHNlZSB0aWNrZXQgIzU2NjUpXG5cdFx0aWYoIGluc3Quc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlciggdGFyZ2V0ICk7XG5cdFx0fVxuXHRcdC8vIFNldCBkaXNwbGF5OmJsb2NrIGluIHBsYWNlIG9mIGluc3QuZHBEaXYuc2hvdygpIHdoaWNoIHdvbid0IHdvcmsgb24gZGlzY29ubmVjdGVkIGVsZW1lbnRzXG5cdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5dWkuY29tL3RpY2tldC83NTUyIC0gQSBEYXRlcGlja2VyIGNyZWF0ZWQgb24gYSBkZXRhY2hlZCBkaXYgaGFzIHplcm8gaGVpZ2h0XG5cdFx0aW5zdC5kcERpdi5jc3MoIFwiZGlzcGxheVwiLCBcImJsb2NrXCIgKTtcblx0fSxcblxuXHQvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGluIGEgXCJkaWFsb2dcIiBib3guXG5cdCAqIEBwYXJhbSAgaW5wdXQgZWxlbWVudCAtIGlnbm9yZWRcblx0ICogQHBhcmFtICBkYXRlXHRzdHJpbmcgb3IgRGF0ZSAtIHRoZSBpbml0aWFsIGRhdGUgdG8gZGlzcGxheVxuXHQgKiBAcGFyYW0gIG9uU2VsZWN0ICBmdW5jdGlvbiAtIHRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHVwZGF0ZSB0aGUgZGlhbG9nIGRhdGUgcGlja2VyIGluc3RhbmNlJ3Mgc2V0dGluZ3MgKGFub255bW91cyBvYmplY3QpXG5cdCAqIEBwYXJhbSAgcG9zIGludFsyXSAtIGNvb3JkaW5hdGVzIGZvciB0aGUgZGlhbG9nJ3MgcG9zaXRpb24gd2l0aGluIHRoZSBzY3JlZW4gb3Jcblx0ICpcdFx0XHRcdFx0ZXZlbnQgLSB3aXRoIHgveSBjb29yZGluYXRlcyBvclxuXHQgKlx0XHRcdFx0XHRsZWF2ZSBlbXB0eSBmb3IgZGVmYXVsdCAoc2NyZWVuIGNlbnRyZSlcblx0ICogQHJldHVybiB0aGUgbWFuYWdlciBvYmplY3Rcblx0ICovXG5cdF9kaWFsb2dEYXRlcGlja2VyOiBmdW5jdGlvbihpbnB1dCwgZGF0ZSwgb25TZWxlY3QsIHNldHRpbmdzLCBwb3MpIHtcblx0XHR2YXIgaWQsIGJyb3dzZXJXaWR0aCwgYnJvd3NlckhlaWdodCwgc2Nyb2xsWCwgc2Nyb2xsWSxcblx0XHRcdGluc3QgPSB0aGlzLl9kaWFsb2dJbnN0OyAvLyBpbnRlcm5hbCBpbnN0YW5jZVxuXG5cdFx0aWYgKCFpbnN0KSB7XG5cdFx0XHR0aGlzLnV1aWQgKz0gMTtcblx0XHRcdGlkID0gXCJkcFwiICsgdGhpcy51dWlkO1xuXHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQgPSAkKFwiPGlucHV0IHR5cGU9J3RleHQnIGlkPSdcIiArIGlkICtcblx0XHRcdFx0XCInIHN0eWxlPSdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMHB4OyB3aWR0aDogMHB4OycvPlwiKTtcblx0XHRcdHRoaXMuX2RpYWxvZ0lucHV0LmtleWRvd24odGhpcy5fZG9LZXlEb3duKTtcblx0XHRcdCQoXCJib2R5XCIpLmFwcGVuZCh0aGlzLl9kaWFsb2dJbnB1dCk7XG5cdFx0XHRpbnN0ID0gdGhpcy5fZGlhbG9nSW5zdCA9IHRoaXMuX25ld0luc3QodGhpcy5fZGlhbG9nSW5wdXQsIGZhbHNlKTtcblx0XHRcdGluc3Quc2V0dGluZ3MgPSB7fTtcblx0XHRcdCQuZGF0YSh0aGlzLl9kaWFsb2dJbnB1dFswXSwgUFJPUF9OQU1FLCBpbnN0KTtcblx0XHR9XG5cdFx0ZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzIHx8IHt9KTtcblx0XHRkYXRlID0gKGRhdGUgJiYgZGF0ZS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSA/IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgZGF0ZSkgOiBkYXRlKTtcblx0XHR0aGlzLl9kaWFsb2dJbnB1dC52YWwoZGF0ZSk7XG5cblx0XHR0aGlzLl9wb3MgPSAocG9zID8gKHBvcy5sZW5ndGggPyBwb3MgOiBbcG9zLnBhZ2VYLCBwb3MucGFnZVldKSA6IG51bGwpO1xuXHRcdGlmICghdGhpcy5fcG9zKSB7XG5cdFx0XHRicm93c2VyV2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cdFx0XHRicm93c2VySGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcblx0XHRcdHNjcm9sbFggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG5cdFx0XHRzY3JvbGxZID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcblx0XHRcdHRoaXMuX3BvcyA9IC8vIHNob3VsZCB1c2UgYWN0dWFsIHdpZHRoL2hlaWdodCBiZWxvd1xuXHRcdFx0XHRbKGJyb3dzZXJXaWR0aCAvIDIpIC0gMTAwICsgc2Nyb2xsWCwgKGJyb3dzZXJIZWlnaHQgLyAyKSAtIDE1MCArIHNjcm9sbFldO1xuXHRcdH1cblxuXHRcdC8vIG1vdmUgaW5wdXQgb24gc2NyZWVuIGZvciBmb2N1cywgYnV0IGhpZGRlbiBiZWhpbmQgZGlhbG9nXG5cdFx0dGhpcy5fZGlhbG9nSW5wdXQuY3NzKFwibGVmdFwiLCAodGhpcy5fcG9zWzBdICsgMjApICsgXCJweFwiKS5jc3MoXCJ0b3BcIiwgdGhpcy5fcG9zWzFdICsgXCJweFwiKTtcblx0XHRpbnN0LnNldHRpbmdzLm9uU2VsZWN0ID0gb25TZWxlY3Q7XG5cdFx0dGhpcy5faW5EaWFsb2cgPSB0cnVlO1xuXHRcdHRoaXMuZHBEaXYuYWRkQ2xhc3ModGhpcy5fZGlhbG9nQ2xhc3MpO1xuXHRcdHRoaXMuX3Nob3dEYXRlcGlja2VyKHRoaXMuX2RpYWxvZ0lucHV0WzBdKTtcblx0XHRpZiAoJC5ibG9ja1VJKSB7XG5cdFx0XHQkLmJsb2NrVUkodGhpcy5kcERpdik7XG5cdFx0fVxuXHRcdCQuZGF0YSh0aGlzLl9kaWFsb2dJbnB1dFswXSwgUFJPUF9OQU1FLCBpbnN0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiBEZXRhY2ggYSBkYXRlcGlja2VyIGZyb20gaXRzIGNvbnRyb2wuXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfZGVzdHJveURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBub2RlTmFtZSxcblx0XHRcdCR0YXJnZXQgPSAkKHRhcmdldCksXG5cdFx0XHRpbnN0ID0gJC5kYXRhKHRhcmdldCwgUFJPUF9OQU1FKTtcblxuXHRcdGlmICghJHRhcmdldC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdCQucmVtb3ZlRGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdGluc3QuYXBwZW5kLnJlbW92ZSgpO1xuXHRcdFx0aW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xuXHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuXG5cdFx0XHRcdHVuYmluZChcImZvY3VzXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyKS5cblx0XHRcdFx0dW5iaW5kKFwia2V5ZG93blwiLCB0aGlzLl9kb0tleURvd24pLlxuXHRcdFx0XHR1bmJpbmQoXCJrZXlwcmVzc1wiLCB0aGlzLl9kb0tleVByZXNzKS5cblx0XHRcdFx0dW5iaW5kKFwia2V5dXBcIiwgdGhpcy5fZG9LZXlVcCk7XG5cdFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJkaXZcIiB8fCBub2RlTmFtZSA9PT0gXCJzcGFuXCIpIHtcblx0XHRcdCR0YXJnZXQucmVtb3ZlQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmVtcHR5KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEVuYWJsZSB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgKiBAcGFyYW0gIHRhcmdldFx0ZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKi9cblx0X2VuYWJsZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLFxuXHRcdFx0JHRhcmdldCA9ICQodGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXG5cdFx0aWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdHRhcmdldC5kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlcihcImJ1dHRvblwiKS5cblx0XHRcdFx0ZWFjaChmdW5jdGlvbigpIHsgdGhpcy5kaXNhYmxlZCA9IGZhbHNlOyB9KS5lbmQoKS5cblx0XHRcdFx0ZmlsdGVyKFwiaW1nXCIpLmNzcyh7b3BhY2l0eTogXCIxLjBcIiwgY3Vyc29yOiBcIlwifSk7XG5cdFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJkaXZcIiB8fCBub2RlTmFtZSA9PT0gXCJzcGFuXCIpIHtcblx0XHRcdGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oXCIuXCIgKyB0aGlzLl9pbmxpbmVDbGFzcyk7XG5cdFx0XHRpbmxpbmUuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWRpc2FibGVkXCIpO1xuXHRcdFx0aW5saW5lLmZpbmQoXCJzZWxlY3QudWktZGF0ZXBpY2tlci1tb250aCwgc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhclwiKS5cblx0XHRcdFx0cHJvcChcImRpc2FibGVkXCIsIGZhbHNlKTtcblx0XHR9XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZElucHV0cyxcblx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IHRhcmdldCA/IG51bGwgOiB2YWx1ZSk7IH0pOyAvLyBkZWxldGUgZW50cnlcblx0fSxcblxuXHQvKiBEaXNhYmxlIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfZGlzYWJsZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLFxuXHRcdFx0JHRhcmdldCA9ICQodGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXG5cdFx0aWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdHRhcmdldC5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpbnN0LnRyaWdnZXIuZmlsdGVyKFwiYnV0dG9uXCIpLlxuXHRcdFx0XHRlYWNoKGZ1bmN0aW9uKCkgeyB0aGlzLmRpc2FibGVkID0gdHJ1ZTsgfSkuZW5kKCkuXG5cdFx0XHRcdGZpbHRlcihcImltZ1wiKS5jc3Moe29wYWNpdHk6IFwiMC41XCIsIGN1cnNvcjogXCJkZWZhdWx0XCJ9KTtcblx0XHR9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIikge1xuXHRcdFx0aW5saW5lID0gJHRhcmdldC5jaGlsZHJlbihcIi5cIiArIHRoaXMuX2lubGluZUNsYXNzKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLmFkZENsYXNzKFwidWktc3RhdGUtZGlzYWJsZWRcIik7XG5cdFx0XHRpbmxpbmUuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIpLlxuXHRcdFx0XHRwcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gJC5tYXAodGhpcy5fZGlzYWJsZWRJbnB1dHMsXG5cdFx0XHRmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gKHZhbHVlID09PSB0YXJnZXQgPyBudWxsIDogdmFsdWUpOyB9KTsgLy8gZGVsZXRlIGVudHJ5XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHNbdGhpcy5fZGlzYWJsZWRJbnB1dHMubGVuZ3RoXSA9IHRhcmdldDtcblx0fSxcblxuXHQvKiBJcyB0aGUgZmlyc3QgZmllbGQgaW4gYSBqUXVlcnkgY29sbGVjdGlvbiBkaXNhYmxlZCBhcyBhIGRhdGVwaWNrZXI/XG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEByZXR1cm4gYm9vbGVhbiAtIHRydWUgaWYgZGlzYWJsZWQsIGZhbHNlIGlmIGVuYWJsZWRcblx0ICovXG5cdF9pc0Rpc2FibGVkRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2Rpc2FibGVkSW5wdXRzW2ldID09PSB0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKiBSZXRyaWV2ZSB0aGUgaW5zdGFuY2UgZGF0YSBmb3IgdGhlIHRhcmdldCBjb250cm9sLlxuXHQgKiBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKiBAcmV0dXJuICBvYmplY3QgLSB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZSBkYXRhXG5cdCAqIEB0aHJvd3MgIGVycm9yIGlmIGEgalF1ZXJ5IHByb2JsZW0gZ2V0dGluZyBkYXRhXG5cdCAqL1xuXHRfZ2V0SW5zdDogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXHRcdH1cblx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHR0aHJvdyBcIk1pc3NpbmcgaW5zdGFuY2UgZGF0YSBmb3IgdGhpcyBkYXRlcGlja2VyXCI7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFVwZGF0ZSBvciByZXRyaWV2ZSB0aGUgc2V0dGluZ3MgZm9yIGEgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgbmFtZVx0b2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1cGRhdGUgb3Jcblx0ICpcdFx0XHRcdHN0cmluZyAtIHRoZSBuYW1lIG9mIHRoZSBzZXR0aW5nIHRvIGNoYW5nZSBvciByZXRyaWV2ZSxcblx0ICpcdFx0XHRcdHdoZW4gcmV0cmlldmluZyBhbHNvIFwiYWxsXCIgZm9yIGFsbCBpbnN0YW5jZSBzZXR0aW5ncyBvclxuXHQgKlx0XHRcdFx0XCJkZWZhdWx0c1wiIGZvciBhbGwgZ2xvYmFsIGRlZmF1bHRzXG5cdCAqIEBwYXJhbSAgdmFsdWUgICBhbnkgLSB0aGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZ1xuXHQgKlx0XHRcdFx0KG9taXQgaWYgYWJvdmUgaXMgYW4gb2JqZWN0IG9yIHRvIHJldHJpZXZlIGEgdmFsdWUpXG5cdCAqL1xuXHRfb3B0aW9uRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXHRcdHZhciBzZXR0aW5ncywgZGF0ZSwgbWluRGF0ZSwgbWF4RGF0ZSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0cmV0dXJuIChuYW1lID09PSBcImRlZmF1bHRzXCIgPyAkLmV4dGVuZCh7fSwgJC5kYXRlcGlja2VyLl9kZWZhdWx0cykgOlxuXHRcdFx0XHQoaW5zdCA/IChuYW1lID09PSBcImFsbFwiID8gJC5leHRlbmQoe30sIGluc3Quc2V0dGluZ3MpIDpcblx0XHRcdFx0dGhpcy5fZ2V0KGluc3QsIG5hbWUpKSA6IG51bGwpKTtcblx0XHR9XG5cblx0XHRzZXR0aW5ncyA9IG5hbWUgfHwge307XG5cdFx0aWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRzZXR0aW5ncyA9IHt9O1xuXHRcdFx0c2V0dGluZ3NbbmFtZV0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoaW5zdCkge1xuXHRcdFx0aWYgKHRoaXMuX2N1ckluc3QgPT09IGluc3QpIHtcblx0XHRcdFx0dGhpcy5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0ZGF0ZSA9IHRoaXMuX2dldERhdGVEYXRlcGlja2VyKHRhcmdldCwgdHJ1ZSk7XG5cdFx0XHRtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1pblwiKTtcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWF4XCIpO1xuXHRcdFx0ZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzKTtcblx0XHRcdC8vIHJlZm9ybWF0IHRoZSBvbGQgbWluRGF0ZS9tYXhEYXRlIHZhbHVlcyBpZiBkYXRlRm9ybWF0IGNoYW5nZXMgYW5kIGEgbmV3IG1pbkRhdGUvbWF4RGF0ZSBpc24ndCBwcm92aWRlZFxuXHRcdFx0aWYgKG1pbkRhdGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLm1pbkRhdGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpbnN0LnNldHRpbmdzLm1pbkRhdGUgPSB0aGlzLl9mb3JtYXREYXRlKGluc3QsIG1pbkRhdGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1heERhdGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLm1heERhdGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpbnN0LnNldHRpbmdzLm1heERhdGUgPSB0aGlzLl9mb3JtYXREYXRlKGluc3QsIG1heERhdGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBcImRpc2FibGVkXCIgaW4gc2V0dGluZ3MgKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGlzYWJsZURhdGVwaWNrZXIodGFyZ2V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9lbmFibGVEYXRlcGlja2VyKHRhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2F0dGFjaG1lbnRzKCQodGFyZ2V0KSwgaW5zdCk7XG5cdFx0XHR0aGlzLl9hdXRvU2l6ZShpbnN0KTtcblx0XHRcdHRoaXMuX3NldERhdGUoaW5zdCwgZGF0ZSk7XG5cdFx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBjaGFuZ2UgbWV0aG9kIGRlcHJlY2F0ZWRcblx0X2NoYW5nZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLl9vcHRpb25EYXRlcGlja2VyKHRhcmdldCwgbmFtZSwgdmFsdWUpO1xuXHR9LFxuXG5cdC8qIFJlZHJhdyB0aGUgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfcmVmcmVzaERhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChpbnN0KSB7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBTZXQgdGhlIGRhdGVzIGZvciBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0IGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBkYXRlXHREYXRlIC0gdGhlIG5ldyBkYXRlXG5cdCAqL1xuXHRfc2V0RGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgZGF0ZSkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChpbnN0KSB7XG5cdFx0XHR0aGlzLl9zZXREYXRlKGluc3QsIGRhdGUpO1xuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogR2V0IHRoZSBkYXRlKHMpIGZvciB0aGUgZmlyc3QgZW50cnkgaW4gYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgKiBAcGFyYW0gIHRhcmdldCBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgbm9EZWZhdWx0IGJvb2xlYW4gLSB0cnVlIGlmIG5vIGRlZmF1bHQgZGF0ZSBpcyB0byBiZSB1c2VkXG5cdCAqIEByZXR1cm4gRGF0ZSAtIHRoZSBjdXJyZW50IGRhdGVcblx0ICovXG5cdF9nZXREYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBub0RlZmF1bHQpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoaW5zdCAmJiAhaW5zdC5pbmxpbmUpIHtcblx0XHRcdHRoaXMuX3NldERhdGVGcm9tRmllbGQoaW5zdCwgbm9EZWZhdWx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIChpbnN0ID8gdGhpcy5fZ2V0RGF0ZShpbnN0KSA6IG51bGwpO1xuXHR9LFxuXG5cdC8qIEhhbmRsZSBrZXlzdHJva2VzLiAqL1xuXHRfZG9LZXlEb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBvblNlbGVjdCwgZGF0ZVN0ciwgc2VsLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpLFxuXHRcdFx0aGFuZGxlZCA9IHRydWUsXG5cdFx0XHRpc1JUTCA9IGluc3QuZHBEaXYuaXMoXCIudWktZGF0ZXBpY2tlci1ydGxcIik7XG5cblx0XHRpbnN0Ll9rZXlFdmVudCA9IHRydWU7XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcpIHtcblx0XHRcdHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuXHRcdFx0XHRjYXNlIDk6ICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBoaWRlIG9uIHRhYiBvdXRcblx0XHRcdFx0Y2FzZSAxMzogc2VsID0gJChcInRkLlwiICsgJC5kYXRlcGlja2VyLl9kYXlPdmVyQ2xhc3MgKyBcIjpub3QoLlwiICtcblx0XHRcdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fY3VycmVudENsYXNzICsgXCIpXCIsIGluc3QuZHBEaXYpO1xuXHRcdFx0XHRcdFx0aWYgKHNlbFswXSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdERheShldmVudC50YXJnZXQsIGluc3Quc2VsZWN0ZWRNb250aCwgaW5zdC5zZWxlY3RlZFllYXIsIHNlbFswXSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG9uU2VsZWN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJvblNlbGVjdFwiKTtcblx0XHRcdFx0XHRcdGlmIChvblNlbGVjdCkge1xuXHRcdFx0XHRcdFx0XHRkYXRlU3RyID0gJC5kYXRlcGlja2VyLl9mb3JtYXREYXRlKGluc3QpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIHRyaWdnZXIgY3VzdG9tIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRcdG9uU2VsZWN0LmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLCBbZGF0ZVN0ciwgaW5zdF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGRvbid0IHN1Ym1pdCB0aGUgZm9ybVxuXHRcdFx0XHRjYXNlIDI3OiAkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gaGlkZSBvbiBlc2NhcGVcblx0XHRcdFx0Y2FzZSAzMzogJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIpIDpcblx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcE1vbnRoc1wiKSksIFwiTVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBwcmV2aW91cyBtb250aC95ZWFyIG9uIHBhZ2UgdXAvKyBjdHJsXG5cdFx0XHRcdGNhc2UgMzQ6ICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcEJpZ01vbnRoc1wiKSA6XG5cdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBNb250aHNcIikpLCBcIk1cIik7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gbmV4dCBtb250aC95ZWFyIG9uIHBhZ2UgZG93bi8rIGN0cmxcblx0XHRcdFx0Y2FzZSAzNTogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2NsZWFyRGF0ZShldmVudC50YXJnZXQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBjbGVhciBvbiBjdHJsIG9yIGNvbW1hbmQgK2VuZFxuXHRcdFx0XHRjYXNlIDM2OiBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KGV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGN1cnJlbnQgb24gY3RybCBvciBjb21tYW5kICtob21lXG5cdFx0XHRcdGNhc2UgMzc6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGlzUlRMID8gKzEgOiAtMSksIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHQvLyAtMSBkYXkgb24gY3RybCBvciBjb21tYW5kICtsZWZ0XG5cdFx0XHRcdFx0XHRpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBCaWdNb250aHNcIikgOlxuXHRcdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBNb250aHNcIikpLCBcIk1cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBuZXh0IG1vbnRoL3llYXIgb24gYWx0ICtsZWZ0IG9uIE1hY1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMzg6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgLTcsIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gLTEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK3VwXG5cdFx0XHRcdGNhc2UgMzk6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGlzUlRMID8gLTEgOiArMSksIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHQvLyArMSBkYXkgb24gY3RybCBvciBjb21tYW5kICtyaWdodFxuXHRcdFx0XHRcdFx0aWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQuYWx0S2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0XHQrJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIpIDpcblx0XHRcdFx0XHRcdFx0XHQrJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwTW9udGhzXCIpKSwgXCJNXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gbmV4dCBtb250aC95ZWFyIG9uIGFsdCArcmlnaHRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDQwOiBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsICs3LCBcIkRcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vICsxIHdlZWsgb24gY3RybCBvciBjb21tYW5kICtkb3duXG5cdFx0XHRcdGRlZmF1bHQ6IGhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDM2ICYmIGV2ZW50LmN0cmxLZXkpIHsgLy8gZGlzcGxheSB0aGUgZGF0ZSBwaWNrZXIgb24gY3RybCtob21lXG5cdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoYW5kbGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGhhbmRsZWQpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cblx0LyogRmlsdGVyIGVudGVyZWQgY2hhcmFjdGVycyAtIGJhc2VkIG9uIGRhdGUgZm9ybWF0LiAqL1xuXHRfZG9LZXlQcmVzczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgY2hhcnMsIGNocixcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcblxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImNvbnN0cmFpbklucHV0XCIpKSB7XG5cdFx0XHRjaGFycyA9ICQuZGF0ZXBpY2tlci5fcG9zc2libGVDaGFycygkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIikpO1xuXHRcdFx0Y2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSA9PSBudWxsID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlKTtcblx0XHRcdHJldHVybiBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgKGNociA8IFwiIFwiIHx8ICFjaGFycyB8fCBjaGFycy5pbmRleE9mKGNocikgPiAtMSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFN5bmNocm9uaXNlIG1hbnVhbCBlbnRyeSBhbmQgZmllbGQvYWx0ZXJuYXRlIGZpZWxkLiAqL1xuXHRfZG9LZXlVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgZGF0ZSxcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcblxuXHRcdGlmIChpbnN0LmlucHV0LnZhbCgpICE9PSBpbnN0Lmxhc3RWYWwpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGUgPSAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKSxcblx0XHRcdFx0XHQoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsKSxcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cblx0XHRcdFx0aWYgKGRhdGUpIHsgLy8gb25seSBpZiB2YWxpZFxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyogUG9wLXVwIHRoZSBkYXRlIHBpY2tlciBmb3IgYSBnaXZlbiBpbnB1dCBmaWVsZC5cblx0ICogSWYgZmFsc2UgcmV0dXJuZWQgZnJvbSBiZWZvcmVTaG93IGV2ZW50IGhhbmRsZXIgZG8gbm90IHNob3cuXG5cdCAqIEBwYXJhbSAgaW5wdXQgIGVsZW1lbnQgLSB0aGUgaW5wdXQgZmllbGQgYXR0YWNoZWQgdG8gdGhlIGRhdGUgcGlja2VyIG9yXG5cdCAqXHRcdFx0XHRcdGV2ZW50IC0gaWYgdHJpZ2dlcmVkIGJ5IGZvY3VzXG5cdCAqL1xuXHRfc2hvd0RhdGVwaWNrZXI6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0aW5wdXQgPSBpbnB1dC50YXJnZXQgfHwgaW5wdXQ7XG5cdFx0aWYgKGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiaW5wdXRcIikgeyAvLyBmaW5kIGZyb20gYnV0dG9uL2ltYWdlIHRyaWdnZXJcblx0XHRcdGlucHV0ID0gJChcImlucHV0XCIsIGlucHV0LnBhcmVudE5vZGUpWzBdO1xuXHRcdH1cblxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2lzRGlzYWJsZWREYXRlcGlja2VyKGlucHV0KSB8fCAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9PT0gaW5wdXQpIHsgLy8gYWxyZWFkeSBoZXJlXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluc3QsIGJlZm9yZVNob3csIGJlZm9yZVNob3dTZXR0aW5ncywgaXNGaXhlZCxcblx0XHRcdG9mZnNldCwgc2hvd0FuaW0sIGR1cmF0aW9uO1xuXG5cdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChpbnB1dCk7XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fY3VySW5zdCAmJiAkLmRhdGVwaWNrZXIuX2N1ckluc3QgIT09IGluc3QpIHtcblx0XHRcdCQuZGF0ZXBpY2tlci5fY3VySW5zdC5kcERpdi5zdG9wKHRydWUsIHRydWUpO1xuXHRcdFx0aWYgKCBpbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoICQuZGF0ZXBpY2tlci5fY3VySW5zdC5pbnB1dFswXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJlZm9yZVNob3cgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImJlZm9yZVNob3dcIik7XG5cdFx0YmVmb3JlU2hvd1NldHRpbmdzID0gYmVmb3JlU2hvdyA/IGJlZm9yZVNob3cuYXBwbHkoaW5wdXQsIFtpbnB1dCwgaW5zdF0pIDoge307XG5cdFx0aWYoYmVmb3JlU2hvd1NldHRpbmdzID09PSBmYWxzZSl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGV4dGVuZFJlbW92ZShpbnN0LnNldHRpbmdzLCBiZWZvcmVTaG93U2V0dGluZ3MpO1xuXG5cdFx0aW5zdC5sYXN0VmFsID0gbnVsbDtcblx0XHQkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9IGlucHV0O1xuXHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcblxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2luRGlhbG9nKSB7IC8vIGhpZGUgY3Vyc29yXG5cdFx0XHRpbnB1dC52YWx1ZSA9IFwiXCI7XG5cdFx0fVxuXHRcdGlmICghJC5kYXRlcGlja2VyLl9wb3MpIHsgLy8gcG9zaXRpb24gYmVsb3cgaW5wdXRcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zID0gJC5kYXRlcGlja2VyLl9maW5kUG9zKGlucHV0KTtcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zWzFdICs9IGlucHV0Lm9mZnNldEhlaWdodDsgLy8gYWRkIHRoZSBoZWlnaHRcblx0XHR9XG5cblx0XHRpc0ZpeGVkID0gZmFsc2U7XG5cdFx0JChpbnB1dCkucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpc0ZpeGVkIHw9ICQodGhpcykuY3NzKFwicG9zaXRpb25cIikgPT09IFwiZml4ZWRcIjtcblx0XHRcdHJldHVybiAhaXNGaXhlZDtcblx0XHR9KTtcblxuXHRcdG9mZnNldCA9IHtsZWZ0OiAkLmRhdGVwaWNrZXIuX3Bvc1swXSwgdG9wOiAkLmRhdGVwaWNrZXIuX3Bvc1sxXX07XG5cdFx0JC5kYXRlcGlja2VyLl9wb3MgPSBudWxsO1xuXHRcdC8vdG8gYXZvaWQgZmxhc2hlcyBvbiBGaXJlZm94XG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpO1xuXHRcdC8vIGRldGVybWluZSBzaXppbmcgb2Zmc2NyZWVuXG5cdFx0aW5zdC5kcERpdi5jc3Moe3Bvc2l0aW9uOiBcImFic29sdXRlXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiwgdG9wOiBcIi0xMDAwcHhcIn0pO1xuXHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHQvLyBmaXggd2lkdGggZm9yIGR5bmFtaWMgbnVtYmVyIG9mIGRhdGUgcGlja2Vyc1xuXHRcdC8vIGFuZCBhZGp1c3QgcG9zaXRpb24gYmVmb3JlIHNob3dpbmdcblx0XHRvZmZzZXQgPSAkLmRhdGVwaWNrZXIuX2NoZWNrT2Zmc2V0KGluc3QsIG9mZnNldCwgaXNGaXhlZCk7XG5cdFx0aW5zdC5kcERpdi5jc3Moe3Bvc2l0aW9uOiAoJC5kYXRlcGlja2VyLl9pbkRpYWxvZyAmJiAkLmJsb2NrVUkgP1xuXHRcdFx0XCJzdGF0aWNcIiA6IChpc0ZpeGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiKSksIGRpc3BsYXk6IFwibm9uZVwiLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgKyBcInB4XCIsIHRvcDogb2Zmc2V0LnRvcCArIFwicHhcIn0pO1xuXG5cdFx0aWYgKCFpbnN0LmlubGluZSkge1xuXHRcdFx0c2hvd0FuaW0gPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInNob3dBbmltXCIpO1xuXHRcdFx0ZHVyYXRpb24gPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImR1cmF0aW9uXCIpO1xuXHRcdFx0aW5zdC5kcERpdi56SW5kZXgoJChpbnB1dCkuekluZGV4KCkrMSk7XG5cdFx0XHQkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgc2hvd0FuaW0gXSApIHtcblx0XHRcdFx0aW5zdC5kcERpdi5zaG93KHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInNob3dPcHRpb25zXCIpLCBkdXJhdGlvbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbnN0LmRwRGl2W3Nob3dBbmltIHx8IFwic2hvd1wiXShzaG93QW5pbSA/IGR1cmF0aW9uIDogbnVsbCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggJC5kYXRlcGlja2VyLl9zaG91bGRGb2N1c0lucHV0KCBpbnN0ICkgKSB7XG5cdFx0XHRcdGluc3QuaW5wdXQuZm9jdXMoKTtcblx0XHRcdH1cblxuXHRcdFx0JC5kYXRlcGlja2VyLl9jdXJJbnN0ID0gaW5zdDtcblx0XHR9XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIGRhdGUgcGlja2VyIGNvbnRlbnQuICovXG5cdF91cGRhdGVEYXRlcGlja2VyOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dGhpcy5tYXhSb3dzID0gNDsgLy9SZXNldCB0aGUgbWF4IG51bWJlciBvZiByb3dzIGJlaW5nIGRpc3BsYXllZCAoc2VlICM3MDQzKVxuXHRcdGluc3RBY3RpdmUgPSBpbnN0OyAvLyBmb3IgZGVsZWdhdGUgaG92ZXIgZXZlbnRzXG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpLmFwcGVuZCh0aGlzLl9nZW5lcmF0ZUhUTUwoaW5zdCkpO1xuXHRcdHRoaXMuX2F0dGFjaEhhbmRsZXJzKGluc3QpO1xuXHRcdGluc3QuZHBEaXYuZmluZChcIi5cIiArIHRoaXMuX2RheU92ZXJDbGFzcyArIFwiIGFcIikubW91c2VvdmVyKCk7XG5cblx0XHR2YXIgb3JpZ3llYXJzaHRtbCxcblx0XHRcdG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpLFxuXHRcdFx0Y29scyA9IG51bU1vbnRoc1sxXSxcblx0XHRcdHdpZHRoID0gMTc7XG5cblx0XHRpbnN0LmRwRGl2LnJlbW92ZUNsYXNzKFwidWktZGF0ZXBpY2tlci1tdWx0aS0yIHVpLWRhdGVwaWNrZXItbXVsdGktMyB1aS1kYXRlcGlja2VyLW11bHRpLTRcIikud2lkdGgoXCJcIik7XG5cdFx0aWYgKGNvbHMgPiAxKSB7XG5cdFx0XHRpbnN0LmRwRGl2LmFkZENsYXNzKFwidWktZGF0ZXBpY2tlci1tdWx0aS1cIiArIGNvbHMpLmNzcyhcIndpZHRoXCIsICh3aWR0aCAqIGNvbHMpICsgXCJlbVwiKTtcblx0XHR9XG5cdFx0aW5zdC5kcERpdlsobnVtTW9udGhzWzBdICE9PSAxIHx8IG51bU1vbnRoc1sxXSAhPT0gMSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArXG5cdFx0XHRcIkNsYXNzXCJdKFwidWktZGF0ZXBpY2tlci1tdWx0aVwiKTtcblx0XHRpbnN0LmRwRGl2Wyh0aGlzLl9nZXQoaW5zdCwgXCJpc1JUTFwiKSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArXG5cdFx0XHRcIkNsYXNzXCJdKFwidWktZGF0ZXBpY2tlci1ydGxcIik7XG5cblx0XHRpZiAoaW5zdCA9PT0gJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9zaG91bGRGb2N1c0lucHV0KCBpbnN0ICkgKSB7XG5cdFx0XHRpbnN0LmlucHV0LmZvY3VzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gZGVmZmVyZWQgcmVuZGVyIG9mIHRoZSB5ZWFycyBzZWxlY3QgKHRvIGF2b2lkIGZsYXNoZXMgb24gRmlyZWZveClcblx0XHRpZiggaW5zdC55ZWFyc2h0bWwgKXtcblx0XHRcdG9yaWd5ZWFyc2h0bWwgPSBpbnN0LnllYXJzaHRtbDtcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0Ly9hc3N1cmUgdGhhdCBpbnN0LnllYXJzaHRtbCBkaWRuJ3QgY2hhbmdlLlxuXHRcdFx0XHRpZiggb3JpZ3llYXJzaHRtbCA9PT0gaW5zdC55ZWFyc2h0bWwgJiYgaW5zdC55ZWFyc2h0bWwgKXtcblx0XHRcdFx0XHRpbnN0LmRwRGl2LmZpbmQoXCJzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyOmZpcnN0XCIpLnJlcGxhY2VXaXRoKGluc3QueWVhcnNodG1sKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcmlneWVhcnNodG1sID0gaW5zdC55ZWFyc2h0bWwgPSBudWxsO1xuXHRcdFx0fSwgMCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vICM2Njk0IC0gZG9uJ3QgZm9jdXMgdGhlIGlucHV0IGlmIGl0J3MgYWxyZWFkeSBmb2N1c2VkXG5cdC8vIHRoaXMgYnJlYWtzIHRoZSBjaGFuZ2UgZXZlbnQgaW4gSUVcblx0Ly8gU3VwcG9ydDogSUUgYW5kIGpRdWVyeSA8MS45XG5cdF9zaG91bGRGb2N1c0lucHV0OiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHRyZXR1cm4gaW5zdC5pbnB1dCAmJiBpbnN0LmlucHV0LmlzKCBcIjp2aXNpYmxlXCIgKSAmJiAhaW5zdC5pbnB1dC5pcyggXCI6ZGlzYWJsZWRcIiApICYmICFpbnN0LmlucHV0LmlzKCBcIjpmb2N1c1wiICk7XG5cdH0sXG5cblx0LyogQ2hlY2sgcG9zaXRpb25pbmcgdG8gcmVtYWluIG9uIHNjcmVlbi4gKi9cblx0X2NoZWNrT2Zmc2V0OiBmdW5jdGlvbihpbnN0LCBvZmZzZXQsIGlzRml4ZWQpIHtcblx0XHR2YXIgZHBXaWR0aCA9IGluc3QuZHBEaXYub3V0ZXJXaWR0aCgpLFxuXHRcdFx0ZHBIZWlnaHQgPSBpbnN0LmRwRGl2Lm91dGVySGVpZ2h0KCksXG5cdFx0XHRpbnB1dFdpZHRoID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJXaWR0aCgpIDogMCxcblx0XHRcdGlucHV0SGVpZ2h0ID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJIZWlnaHQoKSA6IDAsXG5cdFx0XHR2aWV3V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyAoaXNGaXhlZCA/IDAgOiAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpLFxuXHRcdFx0dmlld0hlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgKyAoaXNGaXhlZCA/IDAgOiAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSk7XG5cblx0XHRvZmZzZXQubGVmdCAtPSAodGhpcy5fZ2V0KGluc3QsIFwiaXNSVExcIikgPyAoZHBXaWR0aCAtIGlucHV0V2lkdGgpIDogMCk7XG5cdFx0b2Zmc2V0LmxlZnQgLT0gKGlzRml4ZWQgJiYgb2Zmc2V0LmxlZnQgPT09IGluc3QuaW5wdXQub2Zmc2V0KCkubGVmdCkgPyAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgOiAwO1xuXHRcdG9mZnNldC50b3AgLT0gKGlzRml4ZWQgJiYgb2Zmc2V0LnRvcCA9PT0gKGluc3QuaW5wdXQub2Zmc2V0KCkudG9wICsgaW5wdXRIZWlnaHQpKSA/ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDogMDtcblxuXHRcdC8vIG5vdyBjaGVjayBpZiBkYXRlcGlja2VyIGlzIHNob3dpbmcgb3V0c2lkZSB3aW5kb3cgdmlld3BvcnQgLSBtb3ZlIHRvIGEgYmV0dGVyIHBsYWNlIGlmIHNvLlxuXHRcdG9mZnNldC5sZWZ0IC09IE1hdGgubWluKG9mZnNldC5sZWZ0LCAob2Zmc2V0LmxlZnQgKyBkcFdpZHRoID4gdmlld1dpZHRoICYmIHZpZXdXaWR0aCA+IGRwV2lkdGgpID9cblx0XHRcdE1hdGguYWJzKG9mZnNldC5sZWZ0ICsgZHBXaWR0aCAtIHZpZXdXaWR0aCkgOiAwKTtcblx0XHRvZmZzZXQudG9wIC09IE1hdGgubWluKG9mZnNldC50b3AsIChvZmZzZXQudG9wICsgZHBIZWlnaHQgPiB2aWV3SGVpZ2h0ICYmIHZpZXdIZWlnaHQgPiBkcEhlaWdodCkgP1xuXHRcdFx0TWF0aC5hYnMoZHBIZWlnaHQgKyBpbnB1dEhlaWdodCkgOiAwKTtcblxuXHRcdHJldHVybiBvZmZzZXQ7XG5cdH0sXG5cblx0LyogRmluZCBhbiBvYmplY3QncyBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuLiAqL1xuXHRfZmluZFBvczogZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIHBvc2l0aW9uLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3Qob2JqKSxcblx0XHRcdGlzUlRMID0gdGhpcy5fZ2V0KGluc3QsIFwiaXNSVExcIik7XG5cblx0XHR3aGlsZSAob2JqICYmIChvYmoudHlwZSA9PT0gXCJoaWRkZW5cIiB8fCBvYmoubm9kZVR5cGUgIT09IDEgfHwgJC5leHByLmZpbHRlcnMuaGlkZGVuKG9iaikpKSB7XG5cdFx0XHRvYmogPSBvYmpbaXNSVEwgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiXTtcblx0XHR9XG5cblx0XHRwb3NpdGlvbiA9ICQob2JqKS5vZmZzZXQoKTtcblx0XHRyZXR1cm4gW3Bvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcF07XG5cdH0sXG5cblx0LyogSGlkZSB0aGUgZGF0ZSBwaWNrZXIgZnJvbSB2aWV3LlxuXHQgKiBAcGFyYW0gIGlucHV0ICBlbGVtZW50IC0gdGhlIGlucHV0IGZpZWxkIGF0dGFjaGVkIHRvIHRoZSBkYXRlIHBpY2tlclxuXHQgKi9cblx0X2hpZGVEYXRlcGlja2VyOiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdHZhciBzaG93QW5pbSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzLCBvbkNsb3NlLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2N1ckluc3Q7XG5cblx0XHRpZiAoIWluc3QgfHwgKGlucHV0ICYmIGluc3QgIT09ICQuZGF0YShpbnB1dCwgUFJPUF9OQU1FKSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fZGF0ZXBpY2tlclNob3dpbmcpIHtcblx0XHRcdHNob3dBbmltID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd0FuaW1cIik7XG5cdFx0XHRkdXJhdGlvbiA9IHRoaXMuX2dldChpbnN0LCBcImR1cmF0aW9uXCIpO1xuXHRcdFx0cG9zdFByb2Nlc3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0JC5kYXRlcGlja2VyLl90aWR5RGlhbG9nKGluc3QpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gREVQUkVDQVRFRDogYWZ0ZXIgQkMgZm9yIDEuOC54ICQuZWZmZWN0c1sgc2hvd0FuaW0gXSBpcyBub3QgbmVlZGVkXG5cdFx0XHRpZiAoICQuZWZmZWN0cyAmJiAoICQuZWZmZWN0cy5lZmZlY3RbIHNob3dBbmltIF0gfHwgJC5lZmZlY3RzWyBzaG93QW5pbSBdICkgKSB7XG5cdFx0XHRcdGluc3QuZHBEaXYuaGlkZShzaG93QW5pbSwgJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzaG93T3B0aW9uc1wiKSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluc3QuZHBEaXZbKHNob3dBbmltID09PSBcInNsaWRlRG93blwiID8gXCJzbGlkZVVwXCIgOlxuXHRcdFx0XHRcdChzaG93QW5pbSA9PT0gXCJmYWRlSW5cIiA/IFwiZmFkZU91dFwiIDogXCJoaWRlXCIpKV0oKHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsKSwgcG9zdFByb2Nlc3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNob3dBbmltKSB7XG5cdFx0XHRcdHBvc3RQcm9jZXNzKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlO1xuXG5cdFx0XHRvbkNsb3NlID0gdGhpcy5fZ2V0KGluc3QsIFwib25DbG9zZVwiKTtcblx0XHRcdGlmIChvbkNsb3NlKSB7XG5cdFx0XHRcdG9uQ2xvc2UuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFsoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBcIlwiKSwgaW5zdF0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xuXHRcdFx0aWYgKHRoaXMuX2luRGlhbG9nKSB7XG5cdFx0XHRcdHRoaXMuX2RpYWxvZ0lucHV0LmNzcyh7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIGxlZnQ6IFwiMFwiLCB0b3A6IFwiLTEwMHB4XCIgfSk7XG5cdFx0XHRcdGlmICgkLmJsb2NrVUkpIHtcblx0XHRcdFx0XHQkLnVuYmxvY2tVSSgpO1xuXHRcdFx0XHRcdCQoXCJib2R5XCIpLmFwcGVuZCh0aGlzLmRwRGl2KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5faW5EaWFsb2cgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0LyogVGlkeSB1cCBhZnRlciBhIGRpYWxvZyBkaXNwbGF5LiAqL1xuXHRfdGlkeURpYWxvZzogZnVuY3Rpb24oaW5zdCkge1xuXHRcdGluc3QuZHBEaXYucmVtb3ZlQ2xhc3ModGhpcy5fZGlhbG9nQ2xhc3MpLnVuYmluZChcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXCIpO1xuXHR9LFxuXG5cdC8qIENsb3NlIGRhdGUgcGlja2VyIGlmIGNsaWNrZWQgZWxzZXdoZXJlLiAqL1xuXHRfY2hlY2tFeHRlcm5hbENsaWNrOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmICghJC5kYXRlcGlja2VyLl9jdXJJbnN0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyICR0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCksXG5cdFx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCR0YXJnZXRbMF0pO1xuXG5cdFx0aWYgKCAoICggJHRhcmdldFswXS5pZCAhPT0gJC5kYXRlcGlja2VyLl9tYWluRGl2SWQgJiZcblx0XHRcdFx0JHRhcmdldC5wYXJlbnRzKFwiI1wiICsgJC5kYXRlcGlja2VyLl9tYWluRGl2SWQpLmxlbmd0aCA9PT0gMCAmJlxuXHRcdFx0XHQhJHRhcmdldC5oYXNDbGFzcygkLmRhdGVwaWNrZXIubWFya2VyQ2xhc3NOYW1lKSAmJlxuXHRcdFx0XHQhJHRhcmdldC5jbG9zZXN0KFwiLlwiICsgJC5kYXRlcGlja2VyLl90cmlnZ2VyQ2xhc3MpLmxlbmd0aCAmJlxuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICEoJC5kYXRlcGlja2VyLl9pbkRpYWxvZyAmJiAkLmJsb2NrVUkpICkgKSB8fFxuXHRcdFx0KCAkdGFyZ2V0Lmhhc0NsYXNzKCQuZGF0ZXBpY2tlci5tYXJrZXJDbGFzc05hbWUpICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCApICkge1xuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEFkanVzdCBvbmUgb2YgdGhlIGRhdGUgc3ViLWZpZWxkcy4gKi9cblx0X2FkanVzdERhdGU6IGZ1bmN0aW9uKGlkLCBvZmZzZXQsIHBlcmlvZCkge1xuXHRcdHZhciB0YXJnZXQgPSAkKGlkKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldFswXSk7XG5cblx0XHRpZiAodGhpcy5faXNEaXNhYmxlZERhdGVwaWNrZXIodGFyZ2V0WzBdKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9hZGp1c3RJbnN0RGF0ZShpbnN0LCBvZmZzZXQgK1xuXHRcdFx0KHBlcmlvZCA9PT0gXCJNXCIgPyB0aGlzLl9nZXQoaW5zdCwgXCJzaG93Q3VycmVudEF0UG9zXCIpIDogMCksIC8vIHVuZG8gcG9zaXRpb25pbmdcblx0XHRcdHBlcmlvZCk7XG5cdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIGN1cnJlbnQgbGluay4gKi9cblx0X2dvdG9Ub2RheTogZnVuY3Rpb24oaWQpIHtcblx0XHR2YXIgZGF0ZSxcblx0XHRcdHRhcmdldCA9ICQoaWQpLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblxuXHRcdGlmICh0aGlzLl9nZXQoaW5zdCwgXCJnb3RvQ3VycmVudFwiKSAmJiBpbnN0LmN1cnJlbnREYXkpIHtcblx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoO1xuXHRcdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHR9XG5cdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdHRoaXMuX2FkanVzdERhdGUodGFyZ2V0KTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIHNlbGVjdGluZyBhIG5ldyBtb250aC95ZWFyLiAqL1xuXHRfc2VsZWN0TW9udGhZZWFyOiBmdW5jdGlvbihpZCwgc2VsZWN0LCBwZXJpb2QpIHtcblx0XHR2YXIgdGFyZ2V0ID0gJChpZCksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXG5cdFx0aW5zdFtcInNlbGVjdGVkXCIgKyAocGVyaW9kID09PSBcIk1cIiA/IFwiTW9udGhcIiA6IFwiWWVhclwiKV0gPVxuXHRcdGluc3RbXCJkcmF3XCIgKyAocGVyaW9kID09PSBcIk1cIiA/IFwiTW9udGhcIiA6IFwiWWVhclwiKV0gPVxuXHRcdFx0cGFyc2VJbnQoc2VsZWN0Lm9wdGlvbnNbc2VsZWN0LnNlbGVjdGVkSW5kZXhdLnZhbHVlLDEwKTtcblxuXHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR0aGlzLl9hZGp1c3REYXRlKHRhcmdldCk7XG5cdH0sXG5cblx0LyogQWN0aW9uIGZvciBzZWxlY3RpbmcgYSBkYXkuICovXG5cdF9zZWxlY3REYXk6IGZ1bmN0aW9uKGlkLCBtb250aCwgeWVhciwgdGQpIHtcblx0XHR2YXIgaW5zdCxcblx0XHRcdHRhcmdldCA9ICQoaWQpO1xuXG5cdFx0aWYgKCQodGQpLmhhc0NsYXNzKHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzKSB8fCB0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXRbMF0pKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gJChcImFcIiwgdGQpLmh0bWwoKTtcblx0XHRpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aCA9IG1vbnRoO1xuXHRcdGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhciA9IHllYXI7XG5cdFx0dGhpcy5fc2VsZWN0RGF0ZShpZCwgdGhpcy5fZm9ybWF0RGF0ZShpbnN0LFxuXHRcdFx0aW5zdC5jdXJyZW50RGF5LCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50WWVhcikpO1xuXHR9LFxuXG5cdC8qIEVyYXNlIHRoZSBpbnB1dCBmaWVsZCBhbmQgaGlkZSB0aGUgZGF0ZSBwaWNrZXIuICovXG5cdF9jbGVhckRhdGU6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoaWQpO1xuXHRcdHRoaXMuX3NlbGVjdERhdGUodGFyZ2V0LCBcIlwiKTtcblx0fSxcblxuXHQvKiBVcGRhdGUgdGhlIGlucHV0IGZpZWxkIHdpdGggdGhlIHNlbGVjdGVkIGRhdGUuICovXG5cdF9zZWxlY3REYXRlOiBmdW5jdGlvbihpZCwgZGF0ZVN0cikge1xuXHRcdHZhciBvblNlbGVjdCxcblx0XHRcdHRhcmdldCA9ICQoaWQpLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblxuXHRcdGRhdGVTdHIgPSAoZGF0ZVN0ciAhPSBudWxsID8gZGF0ZVN0ciA6IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCkpO1xuXHRcdGlmIChpbnN0LmlucHV0KSB7XG5cdFx0XHRpbnN0LmlucHV0LnZhbChkYXRlU3RyKTtcblx0XHR9XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXG5cdFx0b25TZWxlY3QgPSB0aGlzLl9nZXQoaW5zdCwgXCJvblNlbGVjdFwiKTtcblx0XHRpZiAob25TZWxlY3QpIHtcblx0XHRcdG9uU2VsZWN0LmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLCBbZGF0ZVN0ciwgaW5zdF0pOyAgLy8gdHJpZ2dlciBjdXN0b20gY2FsbGJhY2tcblx0XHR9IGVsc2UgaWYgKGluc3QuaW5wdXQpIHtcblx0XHRcdGluc3QuaW5wdXQudHJpZ2dlcihcImNoYW5nZVwiKTsgLy8gZmlyZSB0aGUgY2hhbmdlIGV2ZW50XG5cdFx0fVxuXG5cdFx0aWYgKGluc3QuaW5saW5lKXtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBpbnN0LmlucHV0WzBdO1xuXHRcdFx0aWYgKHR5cGVvZihpbnN0LmlucHV0WzBdKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRpbnN0LmlucHV0LmZvY3VzKCk7IC8vIHJlc3RvcmUgZm9jdXNcblx0XHRcdH1cblx0XHRcdHRoaXMuX2xhc3RJbnB1dCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFVwZGF0ZSBhbnkgYWx0ZXJuYXRlIGZpZWxkIHRvIHN5bmNocm9uaXNlIHdpdGggdGhlIG1haW4gZmllbGQuICovXG5cdF91cGRhdGVBbHRlcm5hdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgYWx0Rm9ybWF0LCBkYXRlLCBkYXRlU3RyLFxuXHRcdFx0YWx0RmllbGQgPSB0aGlzLl9nZXQoaW5zdCwgXCJhbHRGaWVsZFwiKTtcblxuXHRcdGlmIChhbHRGaWVsZCkgeyAvLyB1cGRhdGUgYWx0ZXJuYXRlIGZpZWxkIHRvb1xuXHRcdFx0YWx0Rm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsIFwiYWx0Rm9ybWF0XCIpIHx8IHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIik7XG5cdFx0XHRkYXRlID0gdGhpcy5fZ2V0RGF0ZShpbnN0KTtcblx0XHRcdGRhdGVTdHIgPSB0aGlzLmZvcm1hdERhdGUoYWx0Rm9ybWF0LCBkYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xuXHRcdFx0JChhbHRGaWVsZCkuZWFjaChmdW5jdGlvbigpIHsgJCh0aGlzKS52YWwoZGF0ZVN0cik7IH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKiBTZXQgYXMgYmVmb3JlU2hvd0RheSBmdW5jdGlvbiB0byBwcmV2ZW50IHNlbGVjdGlvbiBvZiB3ZWVrZW5kcy5cblx0ICogQHBhcmFtICBkYXRlICBEYXRlIC0gdGhlIGRhdGUgdG8gY3VzdG9taXNlXG5cdCAqIEByZXR1cm4gW2Jvb2xlYW4sIHN0cmluZ10gLSBpcyB0aGlzIGRhdGUgc2VsZWN0YWJsZT8sIHdoYXQgaXMgaXRzIENTUyBjbGFzcz9cblx0ICovXG5cdG5vV2Vla2VuZHM6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcblx0XHRyZXR1cm4gWyhkYXkgPiAwICYmIGRheSA8IDYpLCBcIlwiXTtcblx0fSxcblxuXHQvKiBTZXQgYXMgY2FsY3VsYXRlV2VlayB0byBkZXRlcm1pbmUgdGhlIHdlZWsgb2YgdGhlIHllYXIgYmFzZWQgb24gdGhlIElTTyA4NjAxIGRlZmluaXRpb24uXG5cdCAqIEBwYXJhbSAgZGF0ZSAgRGF0ZSAtIHRoZSBkYXRlIHRvIGdldCB0aGUgd2VlayBmb3Jcblx0ICogQHJldHVybiAgbnVtYmVyIC0gdGhlIG51bWJlciBvZiB0aGUgd2VlayB3aXRoaW4gdGhlIHllYXIgdGhhdCBjb250YWlucyB0aGlzIGRhdGVcblx0ICovXG5cdGlzbzg2MDFXZWVrOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIHRpbWUsXG5cdFx0XHRjaGVja0RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG5cblx0XHQvLyBGaW5kIFRodXJzZGF5IG9mIHRoaXMgd2VlayBzdGFydGluZyBvbiBNb25kYXlcblx0XHRjaGVja0RhdGUuc2V0RGF0ZShjaGVja0RhdGUuZ2V0RGF0ZSgpICsgNCAtIChjaGVja0RhdGUuZ2V0RGF5KCkgfHwgNykpO1xuXG5cdFx0dGltZSA9IGNoZWNrRGF0ZS5nZXRUaW1lKCk7XG5cdFx0Y2hlY2tEYXRlLnNldE1vbnRoKDApOyAvLyBDb21wYXJlIHdpdGggSmFuIDFcblx0XHRjaGVja0RhdGUuc2V0RGF0ZSgxKTtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJvdW5kKCh0aW1lIC0gY2hlY2tEYXRlKSAvIDg2NDAwMDAwKSAvIDcpICsgMTtcblx0fSxcblxuXHQvKiBQYXJzZSBhIHN0cmluZyB2YWx1ZSBpbnRvIGEgZGF0ZSBvYmplY3QuXG5cdCAqIFNlZSBmb3JtYXREYXRlIGJlbG93IGZvciB0aGUgcG9zc2libGUgZm9ybWF0cy5cblx0ICpcblx0ICogQHBhcmFtICBmb3JtYXQgc3RyaW5nIC0gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgZGF0ZVxuXHQgKiBAcGFyYW0gIHZhbHVlIHN0cmluZyAtIHRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXRcblx0ICogQHBhcmFtICBzZXR0aW5ncyBPYmplY3QgLSBhdHRyaWJ1dGVzIGluY2x1ZGU6XG5cdCAqXHRcdFx0XHRcdHNob3J0WWVhckN1dG9mZiAgbnVtYmVyIC0gdGhlIGN1dG9mZiB5ZWFyIGZvciBkZXRlcm1pbmluZyB0aGUgY2VudHVyeSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzU2hvcnRcdHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNcdFx0c3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzU2hvcnQgc3RyaW5nWzEyXSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzXHRcdHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICogQHJldHVybiAgRGF0ZSAtIHRoZSBleHRyYWN0ZWQgZGF0ZSB2YWx1ZSBvciBudWxsIGlmIHZhbHVlIGlzIGJsYW5rXG5cdCAqL1xuXHRwYXJzZURhdGU6IGZ1bmN0aW9uIChmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncykge1xuXHRcdGlmIChmb3JtYXQgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBcIkludmFsaWQgYXJndW1lbnRzXCI7XG5cdFx0fVxuXG5cdFx0dmFsdWUgPSAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlICsgXCJcIik7XG5cdFx0aWYgKHZhbHVlID09PSBcIlwiKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgaUZvcm1hdCwgZGltLCBleHRyYSxcblx0XHRcdGlWYWx1ZSA9IDAsXG5cdFx0XHRzaG9ydFllYXJDdXRvZmZUZW1wID0gKHNldHRpbmdzID8gc2V0dGluZ3Muc2hvcnRZZWFyQ3V0b2ZmIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuc2hvcnRZZWFyQ3V0b2ZmLFxuXHRcdFx0c2hvcnRZZWFyQ3V0b2ZmID0gKHR5cGVvZiBzaG9ydFllYXJDdXRvZmZUZW1wICE9PSBcInN0cmluZ1wiID8gc2hvcnRZZWFyQ3V0b2ZmVGVtcCA6XG5cdFx0XHRcdG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArIHBhcnNlSW50KHNob3J0WWVhckN1dG9mZlRlbXAsIDEwKSksXG5cdFx0XHRkYXlOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzU2hvcnQsXG5cdFx0XHRkYXlOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXMsXG5cdFx0XHRtb250aE5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzU2hvcnQsXG5cdFx0XHRtb250aE5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXMsXG5cdFx0XHR5ZWFyID0gLTEsXG5cdFx0XHRtb250aCA9IC0xLFxuXHRcdFx0ZGF5ID0gLTEsXG5cdFx0XHRkb3kgPSAtMSxcblx0XHRcdGxpdGVyYWwgPSBmYWxzZSxcblx0XHRcdGRhdGUsXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHRsb29rQWhlYWQgPSBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IChpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT09IG1hdGNoKTtcblx0XHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gRXh0cmFjdCBhIG51bWJlciBmcm9tIHRoZSBzdHJpbmcgdmFsdWVcblx0XHRcdGdldE51bWJlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdHZhciBpc0RvdWJsZWQgPSBsb29rQWhlYWQobWF0Y2gpLFxuXHRcdFx0XHRcdHNpemUgPSAobWF0Y2ggPT09IFwiQFwiID8gMTQgOiAobWF0Y2ggPT09IFwiIVwiID8gMjAgOlxuXHRcdFx0XHRcdChtYXRjaCA9PT0gXCJ5XCIgJiYgaXNEb3VibGVkID8gNCA6IChtYXRjaCA9PT0gXCJvXCIgPyAzIDogMikpKSksXG5cdFx0XHRcdFx0ZGlnaXRzID0gbmV3IFJlZ0V4cChcIl5cXFxcZHsxLFwiICsgc2l6ZSArIFwifVwiKSxcblx0XHRcdFx0XHRudW0gPSB2YWx1ZS5zdWJzdHJpbmcoaVZhbHVlKS5tYXRjaChkaWdpdHMpO1xuXHRcdFx0XHRpZiAoIW51bSkge1xuXHRcdFx0XHRcdHRocm93IFwiTWlzc2luZyBudW1iZXIgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aVZhbHVlICs9IG51bVswXS5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiBwYXJzZUludChudW1bMF0sIDEwKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBFeHRyYWN0IGEgbmFtZSBmcm9tIHRoZSBzdHJpbmcgdmFsdWUgYW5kIGNvbnZlcnQgdG8gYW4gaW5kZXhcblx0XHRcdGdldE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgc2hvcnROYW1lcywgbG9uZ05hbWVzKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IC0xLFxuXHRcdFx0XHRcdG5hbWVzID0gJC5tYXAobG9va0FoZWFkKG1hdGNoKSA/IGxvbmdOYW1lcyA6IHNob3J0TmFtZXMsIGZ1bmN0aW9uICh2LCBrKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBbaywgdl0gXTtcblx0XHRcdFx0XHR9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gLShhWzFdLmxlbmd0aCAtIGJbMV0ubGVuZ3RoKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHQkLmVhY2gobmFtZXMsIGZ1bmN0aW9uIChpLCBwYWlyKSB7XG5cdFx0XHRcdFx0dmFyIG5hbWUgPSBwYWlyWzFdO1xuXHRcdFx0XHRcdGlmICh2YWx1ZS5zdWJzdHIoaVZhbHVlLCBuYW1lLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHBhaXJbMF07XG5cdFx0XHRcdFx0XHRpVmFsdWUgKz0gbmFtZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdHJldHVybiBpbmRleCArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJVbmtub3duIG5hbWUgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBDb25maXJtIHRoYXQgYSBsaXRlcmFsIGNoYXJhY3RlciBtYXRjaGVzIHRoZSBzdHJpbmcgdmFsdWVcblx0XHRcdGNoZWNrTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodmFsdWUuY2hhckF0KGlWYWx1ZSkgIT09IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHR0aHJvdyBcIlVuZXhwZWN0ZWQgbGl0ZXJhbCBhdCBwb3NpdGlvbiBcIiArIGlWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpVmFsdWUrKztcblx0XHRcdH07XG5cblx0XHRmb3IgKGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XG5cdFx0XHRpZiAobGl0ZXJhbCkge1xuXHRcdFx0XHRpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZChcIidcIikpIHtcblx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdGNhc2UgXCJkXCI6XG5cdFx0XHRcdFx0XHRkYXkgPSBnZXROdW1iZXIoXCJkXCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkRcIjpcblx0XHRcdFx0XHRcdGdldE5hbWUoXCJEXCIsIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJvXCI6XG5cdFx0XHRcdFx0XHRkb3kgPSBnZXROdW1iZXIoXCJvXCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIm1cIjpcblx0XHRcdFx0XHRcdG1vbnRoID0gZ2V0TnVtYmVyKFwibVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRtb250aCA9IGdldE5hbWUoXCJNXCIsIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwieVwiOlxuXHRcdFx0XHRcdFx0eWVhciA9IGdldE51bWJlcihcInlcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiQFwiOlxuXHRcdFx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKGdldE51bWJlcihcIkBcIikpO1xuXHRcdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIiFcIjpcblx0XHRcdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSgoZ2V0TnVtYmVyKFwiIVwiKSAtIHRoaXMuX3RpY2tzVG8xOTcwKSAvIDEwMDAwKTtcblx0XHRcdFx0XHRcdHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdFx0XHRtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG5cdFx0XHRcdFx0XHRkYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRpZiAobG9va0FoZWFkKFwiJ1wiKSl7XG5cdFx0XHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaVZhbHVlIDwgdmFsdWUubGVuZ3RoKXtcblx0XHRcdGV4dHJhID0gdmFsdWUuc3Vic3RyKGlWYWx1ZSk7XG5cdFx0XHRpZiAoIS9eXFxzKy8udGVzdChleHRyYSkpIHtcblx0XHRcdFx0dGhyb3cgXCJFeHRyYS91bnBhcnNlZCBjaGFyYWN0ZXJzIGZvdW5kIGluIGRhdGU6IFwiICsgZXh0cmE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHllYXIgPT09IC0xKSB7XG5cdFx0XHR5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdH0gZWxzZSBpZiAoeWVhciA8IDEwMCkge1xuXHRcdFx0eWVhciArPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgLSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgK1xuXHRcdFx0XHQoeWVhciA8PSBzaG9ydFllYXJDdXRvZmYgPyAwIDogLTEwMCk7XG5cdFx0fVxuXG5cdFx0aWYgKGRveSA+IC0xKSB7XG5cdFx0XHRtb250aCA9IDE7XG5cdFx0XHRkYXkgPSBkb3k7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGRpbSA9IHRoaXMuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoIC0gMSk7XG5cdFx0XHRcdGlmIChkYXkgPD0gZGltKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bW9udGgrKztcblx0XHRcdFx0ZGF5IC09IGRpbTtcblx0XHRcdH0gd2hpbGUgKHRydWUpO1xuXHRcdH1cblxuXHRcdGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSkpO1xuXHRcdGlmIChkYXRlLmdldEZ1bGxZZWFyKCkgIT09IHllYXIgfHwgZGF0ZS5nZXRNb250aCgpICsgMSAhPT0gbW9udGggfHwgZGF0ZS5nZXREYXRlKCkgIT09IGRheSkge1xuXHRcdFx0dGhyb3cgXCJJbnZhbGlkIGRhdGVcIjsgLy8gRS5nLiAzMS8wMi8wMFxuXHRcdH1cblx0XHRyZXR1cm4gZGF0ZTtcblx0fSxcblxuXHQvKiBTdGFuZGFyZCBkYXRlIGZvcm1hdHMuICovXG5cdEFUT006IFwieXktbW0tZGRcIiwgLy8gUkZDIDMzMzkgKElTTyA4NjAxKVxuXHRDT09LSUU6IFwiRCwgZGQgTSB5eVwiLFxuXHRJU09fODYwMTogXCJ5eS1tbS1kZFwiLFxuXHRSRkNfODIyOiBcIkQsIGQgTSB5XCIsXG5cdFJGQ184NTA6IFwiREQsIGRkLU0teVwiLFxuXHRSRkNfMTAzNjogXCJELCBkIE0geVwiLFxuXHRSRkNfMTEyMzogXCJELCBkIE0geXlcIixcblx0UkZDXzI4MjI6IFwiRCwgZCBNIHl5XCIsXG5cdFJTUzogXCJELCBkIE0geVwiLCAvLyBSRkMgODIyXG5cdFRJQ0tTOiBcIiFcIixcblx0VElNRVNUQU1QOiBcIkBcIixcblx0VzNDOiBcInl5LW1tLWRkXCIsIC8vIElTTyA4NjAxXG5cblx0X3RpY2tzVG8xOTcwOiAoKCgxOTcwIC0gMSkgKiAzNjUgKyBNYXRoLmZsb29yKDE5NzAgLyA0KSAtIE1hdGguZmxvb3IoMTk3MCAvIDEwMCkgK1xuXHRcdE1hdGguZmxvb3IoMTk3MCAvIDQwMCkpICogMjQgKiA2MCAqIDYwICogMTAwMDAwMDApLFxuXG5cdC8qIEZvcm1hdCBhIGRhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgdmFsdWUuXG5cdCAqIFRoZSBmb3JtYXQgY2FuIGJlIGNvbWJpbmF0aW9ucyBvZiB0aGUgZm9sbG93aW5nOlxuXHQgKiBkICAtIGRheSBvZiBtb250aCAobm8gbGVhZGluZyB6ZXJvKVxuXHQgKiBkZCAtIGRheSBvZiBtb250aCAodHdvIGRpZ2l0KVxuXHQgKiBvICAtIGRheSBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm9zKVxuXHQgKiBvbyAtIGRheSBvZiB5ZWFyICh0aHJlZSBkaWdpdClcblx0ICogRCAgLSBkYXkgbmFtZSBzaG9ydFxuXHQgKiBERCAtIGRheSBuYW1lIGxvbmdcblx0ICogbSAgLSBtb250aCBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pXG5cdCAqIG1tIC0gbW9udGggb2YgeWVhciAodHdvIGRpZ2l0KVxuXHQgKiBNICAtIG1vbnRoIG5hbWUgc2hvcnRcblx0ICogTU0gLSBtb250aCBuYW1lIGxvbmdcblx0ICogeSAgLSB5ZWFyICh0d28gZGlnaXQpXG5cdCAqIHl5IC0geWVhciAoZm91ciBkaWdpdClcblx0ICogQCAtIFVuaXggdGltZXN0YW1wIChtcyBzaW5jZSAwMS8wMS8xOTcwKVxuXHQgKiAhIC0gV2luZG93cyB0aWNrcyAoMTAwbnMgc2luY2UgMDEvMDEvMDAwMSlcblx0ICogXCIuLi5cIiAtIGxpdGVyYWwgdGV4dFxuXHQgKiAnJyAtIHNpbmdsZSBxdW90ZVxuXHQgKlxuXHQgKiBAcGFyYW0gIGZvcm1hdCBzdHJpbmcgLSB0aGUgZGVzaXJlZCBmb3JtYXQgb2YgdGhlIGRhdGVcblx0ICogQHBhcmFtICBkYXRlIERhdGUgLSB0aGUgZGF0ZSB2YWx1ZSB0byBmb3JtYXRcblx0ICogQHBhcmFtICBzZXR0aW5ncyBPYmplY3QgLSBhdHRyaWJ1dGVzIGluY2x1ZGU6XG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzU2hvcnRcdHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNcdFx0c3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzU2hvcnQgc3RyaW5nWzEyXSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzXHRcdHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICogQHJldHVybiAgc3RyaW5nIC0gdGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdFxuXHQgKi9cblx0Zm9ybWF0RGF0ZTogZnVuY3Rpb24gKGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MpIHtcblx0XHRpZiAoIWRhdGUpIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblxuXHRcdHZhciBpRm9ybWF0LFxuXHRcdFx0ZGF5TmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lc1Nob3J0LFxuXHRcdFx0ZGF5TmFtZXMgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzLFxuXHRcdFx0bW9udGhOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lc1Nob3J0IDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lc1Nob3J0LFxuXHRcdFx0bW9udGhOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzLFxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0bG9va0FoZWFkID0gZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMgPSAoaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09PSBtYXRjaCk7XG5cdFx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdFx0fSxcblx0XHRcdC8vIEZvcm1hdCBhIG51bWJlciwgd2l0aCBsZWFkaW5nIHplcm8gaWYgbmVjZXNzYXJ5XG5cdFx0XHRmb3JtYXROdW1iZXIgPSBmdW5jdGlvbihtYXRjaCwgdmFsdWUsIGxlbikge1xuXHRcdFx0XHR2YXIgbnVtID0gXCJcIiArIHZhbHVlO1xuXHRcdFx0XHRpZiAobG9va0FoZWFkKG1hdGNoKSkge1xuXHRcdFx0XHRcdHdoaWxlIChudW0ubGVuZ3RoIDwgbGVuKSB7XG5cdFx0XHRcdFx0XHRudW0gPSBcIjBcIiArIG51bTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bTtcblx0XHRcdH0sXG5cdFx0XHQvLyBGb3JtYXQgYSBuYW1lLCBzaG9ydCBvciBsb25nIGFzIHJlcXVlc3RlZFxuXHRcdFx0Zm9ybWF0TmFtZSA9IGZ1bmN0aW9uKG1hdGNoLCB2YWx1ZSwgc2hvcnROYW1lcywgbG9uZ05hbWVzKSB7XG5cdFx0XHRcdHJldHVybiAobG9va0FoZWFkKG1hdGNoKSA/IGxvbmdOYW1lc1t2YWx1ZV0gOiBzaG9ydE5hbWVzW3ZhbHVlXSk7XG5cdFx0XHR9LFxuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblxuXHRcdGlmIChkYXRlKSB7XG5cdFx0XHRmb3IgKGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XG5cdFx0XHRcdGlmIChsaXRlcmFsKSB7XG5cdFx0XHRcdFx0aWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT09IFwiJ1wiICYmICFsb29rQWhlYWQoXCInXCIpKSB7XG5cdFx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJkXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoXCJkXCIsIGRhdGUuZ2V0RGF0ZSgpLCAyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiRFwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TmFtZShcIkRcIiwgZGF0ZS5nZXREYXkoKSwgZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJvXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoXCJvXCIsXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZCgobmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDApLmdldFRpbWUoKSkgLyA4NjQwMDAwMCksIDMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoXCJtXCIsIGRhdGUuZ2V0TW9udGgoKSArIDEsIDIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROYW1lKFwiTVwiLCBkYXRlLmdldE1vbnRoKCksIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcInlcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IChsb29rQWhlYWQoXCJ5XCIpID8gZGF0ZS5nZXRGdWxsWWVhcigpIDpcblx0XHRcdFx0XHRcdFx0XHQoZGF0ZS5nZXRZZWFyKCkgJSAxMDAgPCAxMCA/IFwiMFwiIDogXCJcIikgKyBkYXRlLmdldFllYXIoKSAlIDEwMCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkBcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCIhXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBkYXRlLmdldFRpbWUoKSAqIDEwMDAwICsgdGhpcy5fdGlja3NUbzE5NzA7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdFx0aWYgKGxvb2tBaGVhZChcIidcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gXCInXCI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fSxcblxuXHQvKiBFeHRyYWN0IGFsbCBwb3NzaWJsZSBjaGFyYWN0ZXJzIGZyb20gdGhlIGRhdGUgZm9ybWF0LiAqL1xuXHRfcG9zc2libGVDaGFyczogZnVuY3Rpb24gKGZvcm1hdCkge1xuXHRcdHZhciBpRm9ybWF0LFxuXHRcdFx0Y2hhcnMgPSBcIlwiLFxuXHRcdFx0bGl0ZXJhbCA9IGZhbHNlLFxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0bG9va0FoZWFkID0gZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMgPSAoaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09PSBtYXRjaCk7XG5cdFx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdFx0fTtcblxuXHRcdGZvciAoaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdGlmIChsaXRlcmFsKSB7XG5cdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcIidcIiAmJiAhbG9va0FoZWFkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGFycyArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHRjYXNlIFwiZFwiOiBjYXNlIFwibVwiOiBjYXNlIFwieVwiOiBjYXNlIFwiQFwiOlxuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gXCIwMTIzNDU2Nzg5XCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiRFwiOiBjYXNlIFwiTVwiOlxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIEFjY2VwdCBhbnl0aGluZ1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRpZiAobG9va0FoZWFkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdFx0XHRjaGFycyArPSBcIidcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNoYXJzICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNoYXJzO1xuXHR9LFxuXG5cdC8qIEdldCBhIHNldHRpbmcgdmFsdWUsIGRlZmF1bHRpbmcgaWYgbmVjZXNzYXJ5LiAqL1xuXHRfZ2V0OiBmdW5jdGlvbihpbnN0LCBuYW1lKSB7XG5cdFx0cmV0dXJuIGluc3Quc2V0dGluZ3NbbmFtZV0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRpbnN0LnNldHRpbmdzW25hbWVdIDogdGhpcy5fZGVmYXVsdHNbbmFtZV07XG5cdH0sXG5cblx0LyogUGFyc2UgZXhpc3RpbmcgZGF0ZSBhbmQgaW5pdGlhbGlzZSBkYXRlIHBpY2tlci4gKi9cblx0X3NldERhdGVGcm9tRmllbGQ6IGZ1bmN0aW9uKGluc3QsIG5vRGVmYXVsdCkge1xuXHRcdGlmIChpbnN0LmlucHV0LnZhbCgpID09PSBpbnN0Lmxhc3RWYWwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZGF0ZUZvcm1hdCA9IHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIiksXG5cdFx0XHRkYXRlcyA9IGluc3QubGFzdFZhbCA9IGluc3QuaW5wdXQgPyBpbnN0LmlucHV0LnZhbCgpIDogbnVsbCxcblx0XHRcdGRlZmF1bHREYXRlID0gdGhpcy5fZ2V0RGVmYXVsdERhdGUoaW5zdCksXG5cdFx0XHRkYXRlID0gZGVmYXVsdERhdGUsXG5cdFx0XHRzZXR0aW5ncyA9IHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRkYXRlID0gdGhpcy5wYXJzZURhdGUoZGF0ZUZvcm1hdCwgZGF0ZXMsIHNldHRpbmdzKSB8fCBkZWZhdWx0RGF0ZTtcblx0XHR9IGNhdGNoIChldmVudCkge1xuXHRcdFx0ZGF0ZXMgPSAobm9EZWZhdWx0ID8gXCJcIiA6IGRhdGVzKTtcblx0XHR9XG5cdFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRpbnN0LmN1cnJlbnREYXkgPSAoZGF0ZXMgPyBkYXRlLmdldERhdGUoKSA6IDApO1xuXHRcdGluc3QuY3VycmVudE1vbnRoID0gKGRhdGVzID8gZGF0ZS5nZXRNb250aCgpIDogMCk7XG5cdFx0aW5zdC5jdXJyZW50WWVhciA9IChkYXRlcyA/IGRhdGUuZ2V0RnVsbFllYXIoKSA6IDApO1xuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QpO1xuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBkZWZhdWx0IGRhdGUgc2hvd24gb24gb3BlbmluZy4gKi9cblx0X2dldERlZmF1bHREYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Jlc3RyaWN0TWluTWF4KGluc3QsXG5cdFx0XHR0aGlzLl9kZXRlcm1pbmVEYXRlKGluc3QsIHRoaXMuX2dldChpbnN0LCBcImRlZmF1bHREYXRlXCIpLCBuZXcgRGF0ZSgpKSk7XG5cdH0sXG5cblx0LyogQSBkYXRlIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gZXhhY3QgdmFsdWUgb3IgYSByZWxhdGl2ZSBvbmUuICovXG5cdF9kZXRlcm1pbmVEYXRlOiBmdW5jdGlvbihpbnN0LCBkYXRlLCBkZWZhdWx0RGF0ZSkge1xuXHRcdHZhciBvZmZzZXROdW1lcmljID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdFx0ZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0KTtcblx0XHRcdFx0cmV0dXJuIGRhdGU7XG5cdFx0XHR9LFxuXHRcdFx0b2Zmc2V0U3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5wYXJzZURhdGUoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJkYXRlRm9ybWF0XCIpLFxuXHRcdFx0XHRcdFx0b2Zmc2V0LCAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvLyBJZ25vcmVcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkYXRlID0gKG9mZnNldC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9eYy8pID9cblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2dldERhdGUoaW5zdCkgOiBudWxsKSB8fCBuZXcgRGF0ZSgpLFxuXHRcdFx0XHRcdHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCksXG5cdFx0XHRcdFx0bW9udGggPSBkYXRlLmdldE1vbnRoKCksXG5cdFx0XHRcdFx0ZGF5ID0gZGF0ZS5nZXREYXRlKCksXG5cdFx0XHRcdFx0cGF0dGVybiA9IC8oWytcXC1dP1swLTldKylcXHMqKGR8RHx3fFd8bXxNfHl8WSk/L2csXG5cdFx0XHRcdFx0bWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xuXG5cdFx0XHRcdHdoaWxlIChtYXRjaGVzKSB7XG5cdFx0XHRcdFx0c3dpdGNoIChtYXRjaGVzWzJdIHx8IFwiZFwiKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiZFwiIDogY2FzZSBcIkRcIiA6XG5cdFx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwid1wiIDogY2FzZSBcIldcIiA6XG5cdFx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKSAqIDc7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIm1cIiA6IGNhc2UgXCJNXCIgOlxuXHRcdFx0XHRcdFx0XHRtb250aCArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKTtcblx0XHRcdFx0XHRcdFx0ZGF5ID0gTWF0aC5taW4oZGF5LCAkLmRhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcInlcIjogY2FzZSBcIllcIiA6XG5cdFx0XHRcdFx0XHRcdHllYXIgKz0gcGFyc2VJbnQobWF0Y2hlc1sxXSwxMCk7XG5cdFx0XHRcdFx0XHRcdGRheSA9IE1hdGgubWluKGRheSwgJC5kYXRlcGlja2VyLl9nZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcblx0XHRcdH0sXG5cdFx0XHRuZXdEYXRlID0gKGRhdGUgPT0gbnVsbCB8fCBkYXRlID09PSBcIlwiID8gZGVmYXVsdERhdGUgOiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIgPyBvZmZzZXRTdHJpbmcoZGF0ZSkgOlxuXHRcdFx0XHQodHlwZW9mIGRhdGUgPT09IFwibnVtYmVyXCIgPyAoaXNOYU4oZGF0ZSkgPyBkZWZhdWx0RGF0ZSA6IG9mZnNldE51bWVyaWMoZGF0ZSkpIDogbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpKSkpO1xuXG5cdFx0bmV3RGF0ZSA9IChuZXdEYXRlICYmIG5ld0RhdGUudG9TdHJpbmcoKSA9PT0gXCJJbnZhbGlkIERhdGVcIiA/IGRlZmF1bHREYXRlIDogbmV3RGF0ZSk7XG5cdFx0aWYgKG5ld0RhdGUpIHtcblx0XHRcdG5ld0RhdGUuc2V0SG91cnMoMCk7XG5cdFx0XHRuZXdEYXRlLnNldE1pbnV0ZXMoMCk7XG5cdFx0XHRuZXdEYXRlLnNldFNlY29uZHMoMCk7XG5cdFx0XHRuZXdEYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ld0RhdGUpO1xuXHR9LFxuXG5cdC8qIEhhbmRsZSBzd2l0Y2ggdG8vZnJvbSBkYXlsaWdodCBzYXZpbmcuXG5cdCAqIEhvdXJzIG1heSBiZSBub24temVybyBvbiBkYXlsaWdodCBzYXZpbmcgY3V0LW92ZXI6XG5cdCAqID4gMTIgd2hlbiBtaWRuaWdodCBjaGFuZ2VvdmVyLCBidXQgdGhlbiBjYW5ub3QgZ2VuZXJhdGVcblx0ICogbWlkbmlnaHQgZGF0ZXRpbWUsIHNvIGp1bXAgdG8gMUFNLCBvdGhlcndpc2UgcmVzZXQuXG5cdCAqIEBwYXJhbSAgZGF0ZSAgKERhdGUpIHRoZSBkYXRlIHRvIGNoZWNrXG5cdCAqIEByZXR1cm4gIChEYXRlKSB0aGUgY29ycmVjdGVkIGRhdGVcblx0ICovXG5cdF9kYXlsaWdodFNhdmluZ0FkanVzdDogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdGlmICghZGF0ZSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGRhdGUuc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpID4gMTIgPyBkYXRlLmdldEhvdXJzKCkgKyAyIDogMCk7XG5cdFx0cmV0dXJuIGRhdGU7XG5cdH0sXG5cblx0LyogU2V0IHRoZSBkYXRlKHMpIGRpcmVjdGx5LiAqL1xuXHRfc2V0RGF0ZTogZnVuY3Rpb24oaW5zdCwgZGF0ZSwgbm9DaGFuZ2UpIHtcblx0XHR2YXIgY2xlYXIgPSAhZGF0ZSxcblx0XHRcdG9yaWdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCxcblx0XHRcdG9yaWdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIsXG5cdFx0XHRuZXdEYXRlID0gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCwgdGhpcy5fZGV0ZXJtaW5lRGF0ZShpbnN0LCBkYXRlLCBuZXcgRGF0ZSgpKSk7XG5cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gbmV3RGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aCA9IG5ld0RhdGUuZ2V0TW9udGgoKTtcblx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyID0gbmV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmICgob3JpZ01vbnRoICE9PSBpbnN0LnNlbGVjdGVkTW9udGggfHwgb3JpZ1llYXIgIT09IGluc3Quc2VsZWN0ZWRZZWFyKSAmJiAhbm9DaGFuZ2UpIHtcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR9XG5cdFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoaW5zdCk7XG5cdFx0aWYgKGluc3QuaW5wdXQpIHtcblx0XHRcdGluc3QuaW5wdXQudmFsKGNsZWFyID8gXCJcIiA6IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCkpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBSZXRyaWV2ZSB0aGUgZGF0ZShzKSBkaXJlY3RseS4gKi9cblx0X2dldERhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgc3RhcnREYXRlID0gKCFpbnN0LmN1cnJlbnRZZWFyIHx8IChpbnN0LmlucHV0ICYmIGluc3QuaW5wdXQudmFsKCkgPT09IFwiXCIpID8gbnVsbCA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShcblx0XHRcdGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkpKSk7XG5cdFx0XHRyZXR1cm4gc3RhcnREYXRlO1xuXHR9LFxuXG5cdC8qIEF0dGFjaCB0aGUgb254eHggaGFuZGxlcnMuICBUaGVzZSBhcmUgZGVjbGFyZWQgc3RhdGljYWxseSBzb1xuXHQgKiB0aGV5IHdvcmsgd2l0aCBzdGF0aWMgY29kZSB0cmFuc2Zvcm1lcnMgbGlrZSBDYWphLlxuXHQgKi9cblx0X2F0dGFjaEhhbmRsZXJzOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIHN0ZXBNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJzdGVwTW9udGhzXCIpLFxuXHRcdFx0aWQgPSBcIiNcIiArIGluc3QuaWQucmVwbGFjZSggL1xcXFxcXFxcL2csIFwiXFxcXFwiICk7XG5cdFx0aW5zdC5kcERpdi5maW5kKFwiW2RhdGEtaGFuZGxlcl1cIikubWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBoYW5kbGVyID0ge1xuXHRcdFx0XHRwcmV2OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGlkLCAtc3RlcE1vbnRocywgXCJNXCIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGlkLCArc3RlcE1vbnRocywgXCJNXCIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRoaWRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0b2RheTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KGlkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0RGF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3REYXkoaWQsICt0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtbW9udGhcIiksICt0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEteWVhclwiKSwgdGhpcyk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RNb250aDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2VsZWN0TW9udGhZZWFyKGlkLCB0aGlzLCBcIk1cIik7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RZZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3RNb250aFllYXIoaWQsIHRoaXMsIFwiWVwiKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHQkKHRoaXMpLmJpbmQodGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWV2ZW50XCIpLCBoYW5kbGVyW3RoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1oYW5kbGVyXCIpXSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIEhUTUwgZm9yIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkYXRlIHBpY2tlci4gKi9cblx0X2dlbmVyYXRlSFRNTDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBtYXhEcmF3LCBwcmV2VGV4dCwgcHJldiwgbmV4dFRleHQsIG5leHQsIGN1cnJlbnRUZXh0LCBnb3RvRGF0ZSxcblx0XHRcdGNvbnRyb2xzLCBidXR0b25QYW5lbCwgZmlyc3REYXksIHNob3dXZWVrLCBkYXlOYW1lcywgZGF5TmFtZXNNaW4sXG5cdFx0XHRtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQsIGJlZm9yZVNob3dEYXksIHNob3dPdGhlck1vbnRocyxcblx0XHRcdHNlbGVjdE90aGVyTW9udGhzLCBkZWZhdWx0RGF0ZSwgaHRtbCwgZG93LCByb3csIGdyb3VwLCBjb2wsIHNlbGVjdGVkRGF0ZSxcblx0XHRcdGNvcm5lckNsYXNzLCBjYWxlbmRlciwgdGhlYWQsIGRheSwgZGF5c0luTW9udGgsIGxlYWREYXlzLCBjdXJSb3dzLCBudW1Sb3dzLFxuXHRcdFx0cHJpbnREYXRlLCBkUm93LCB0Ym9keSwgZGF5U2V0dGluZ3MsIG90aGVyTW9udGgsIHVuc2VsZWN0YWJsZSxcblx0XHRcdHRlbXBEYXRlID0gbmV3IERhdGUoKSxcblx0XHRcdHRvZGF5ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoXG5cdFx0XHRcdG5ldyBEYXRlKHRlbXBEYXRlLmdldEZ1bGxZZWFyKCksIHRlbXBEYXRlLmdldE1vbnRoKCksIHRlbXBEYXRlLmdldERhdGUoKSkpLCAvLyBjbGVhciB0aW1lXG5cdFx0XHRpc1JUTCA9IHRoaXMuX2dldChpbnN0LCBcImlzUlRMXCIpLFxuXHRcdFx0c2hvd0J1dHRvblBhbmVsID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd0J1dHRvblBhbmVsXCIpLFxuXHRcdFx0aGlkZUlmTm9QcmV2TmV4dCA9IHRoaXMuX2dldChpbnN0LCBcImhpZGVJZk5vUHJldk5leHRcIiksXG5cdFx0XHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsIFwibmF2aWdhdGlvbkFzRGF0ZUZvcm1hdFwiKSxcblx0XHRcdG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpLFxuXHRcdFx0c2hvd0N1cnJlbnRBdFBvcyA9IHRoaXMuX2dldChpbnN0LCBcInNob3dDdXJyZW50QXRQb3NcIiksXG5cdFx0XHRzdGVwTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwic3RlcE1vbnRoc1wiKSxcblx0XHRcdGlzTXVsdGlNb250aCA9IChudW1Nb250aHNbMF0gIT09IDEgfHwgbnVtTW9udGhzWzFdICE9PSAxKSxcblx0XHRcdGN1cnJlbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoKCFpbnN0LmN1cnJlbnREYXkgPyBuZXcgRGF0ZSg5OTk5LCA5LCA5KSA6XG5cdFx0XHRcdG5ldyBEYXRlKGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkpKSksXG5cdFx0XHRtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1pblwiKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWF4XCIpLFxuXHRcdFx0ZHJhd01vbnRoID0gaW5zdC5kcmF3TW9udGggLSBzaG93Q3VycmVudEF0UG9zLFxuXHRcdFx0ZHJhd1llYXIgPSBpbnN0LmRyYXdZZWFyO1xuXG5cdFx0aWYgKGRyYXdNb250aCA8IDApIHtcblx0XHRcdGRyYXdNb250aCArPSAxMjtcblx0XHRcdGRyYXdZZWFyLS07XG5cdFx0fVxuXHRcdGlmIChtYXhEYXRlKSB7XG5cdFx0XHRtYXhEcmF3ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUobWF4RGF0ZS5nZXRGdWxsWWVhcigpLFxuXHRcdFx0XHRtYXhEYXRlLmdldE1vbnRoKCkgLSAobnVtTW9udGhzWzBdICogbnVtTW9udGhzWzFdKSArIDEsIG1heERhdGUuZ2V0RGF0ZSgpKSk7XG5cdFx0XHRtYXhEcmF3ID0gKG1pbkRhdGUgJiYgbWF4RHJhdyA8IG1pbkRhdGUgPyBtaW5EYXRlIDogbWF4RHJhdyk7XG5cdFx0XHR3aGlsZSAodGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgMSkpID4gbWF4RHJhdykge1xuXHRcdFx0XHRkcmF3TW9udGgtLTtcblx0XHRcdFx0aWYgKGRyYXdNb250aCA8IDApIHtcblx0XHRcdFx0XHRkcmF3TW9udGggPSAxMTtcblx0XHRcdFx0XHRkcmF3WWVhci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGluc3QuZHJhd01vbnRoID0gZHJhd01vbnRoO1xuXHRcdGluc3QuZHJhd1llYXIgPSBkcmF3WWVhcjtcblxuXHRcdHByZXZUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwicHJldlRleHRcIik7XG5cdFx0cHJldlRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBwcmV2VGV4dCA6IHRoaXMuZm9ybWF0RGF0ZShwcmV2VGV4dCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGggLSBzdGVwTW9udGhzLCAxKSksXG5cdFx0XHR0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblxuXHRcdHByZXYgPSAodGhpcy5fY2FuQWRqdXN0TW9udGgoaW5zdCwgLTEsIGRyYXdZZWFyLCBkcmF3TW9udGgpID9cblx0XHRcdFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItcHJldiB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J3ByZXYnIGRhdGEtZXZlbnQ9J2NsaWNrJ1wiICtcblx0XHRcdFwiIHRpdGxlPSdcIiArIHByZXZUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwiZVwiIDogXCJ3XCIpICsgXCInPlwiICsgcHJldlRleHQgKyBcIjwvc3Bhbj48L2E+XCIgOlxuXHRcdFx0KGhpZGVJZk5vUHJldk5leHQgPyBcIlwiIDogXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWQnIHRpdGxlPSdcIisgcHJldlRleHQgK1wiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcImVcIiA6IFwid1wiKSArIFwiJz5cIiArIHByZXZUZXh0ICsgXCI8L3NwYW4+PC9hPlwiKSk7XG5cblx0XHRuZXh0VGV4dCA9IHRoaXMuX2dldChpbnN0LCBcIm5leHRUZXh0XCIpO1xuXHRcdG5leHRUZXh0ID0gKCFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gbmV4dFRleHQgOiB0aGlzLmZvcm1hdERhdGUobmV4dFRleHQsXG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcmF3WWVhciwgZHJhd01vbnRoICsgc3RlcE1vbnRocywgMSkpLFxuXHRcdFx0dGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKSk7XG5cblx0XHRuZXh0ID0gKHRoaXMuX2NhbkFkanVzdE1vbnRoKGluc3QsICsxLCBkcmF3WWVhciwgZHJhd01vbnRoKSA/XG5cdFx0XHRcIjxhIGNsYXNzPSd1aS1kYXRlcGlja2VyLW5leHQgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSduZXh0JyBkYXRhLWV2ZW50PSdjbGljaydcIiArXG5cdFx0XHRcIiB0aXRsZT0nXCIgKyBuZXh0VGV4dCArIFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcIndcIiA6IFwiZVwiKSArIFwiJz5cIiArIG5leHRUZXh0ICsgXCI8L3NwYW4+PC9hPlwiIDpcblx0XHRcdChoaWRlSWZOb1ByZXZOZXh0ID8gXCJcIiA6IFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRpc2FibGVkJyB0aXRsZT0nXCIrIG5leHRUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwid1wiIDogXCJlXCIpICsgXCInPlwiICsgbmV4dFRleHQgKyBcIjwvc3Bhbj48L2E+XCIpKTtcblxuXHRcdGN1cnJlbnRUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwiY3VycmVudFRleHRcIik7XG5cdFx0Z290b0RhdGUgPSAodGhpcy5fZ2V0KGluc3QsIFwiZ290b0N1cnJlbnRcIikgJiYgaW5zdC5jdXJyZW50RGF5ID8gY3VycmVudERhdGUgOiB0b2RheSk7XG5cdFx0Y3VycmVudFRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBjdXJyZW50VGV4dCA6XG5cdFx0XHR0aGlzLmZvcm1hdERhdGUoY3VycmVudFRleHQsIGdvdG9EYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblxuXHRcdGNvbnRyb2xzID0gKCFpbnN0LmlubGluZSA/IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd1aS1kYXRlcGlja2VyLWNsb3NlIHVpLXN0YXRlLWRlZmF1bHQgdWktcHJpb3JpdHktcHJpbWFyeSB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J2hpZGUnIGRhdGEtZXZlbnQ9J2NsaWNrJz5cIiArXG5cdFx0XHR0aGlzLl9nZXQoaW5zdCwgXCJjbG9zZVRleHRcIikgKyBcIjwvYnV0dG9uPlwiIDogXCJcIik7XG5cblx0XHRidXR0b25QYW5lbCA9IChzaG93QnV0dG9uUGFuZWwpID8gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWJ1dHRvbnBhbmUgdWktd2lkZ2V0LWNvbnRlbnQnPlwiICsgKGlzUlRMID8gY29udHJvbHMgOiBcIlwiKSArXG5cdFx0XHQodGhpcy5faXNJblJhbmdlKGluc3QsIGdvdG9EYXRlKSA/IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd1aS1kYXRlcGlja2VyLWN1cnJlbnQgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1zZWNvbmRhcnkgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSd0b2RheScgZGF0YS1ldmVudD0nY2xpY2snXCIgK1xuXHRcdFx0XCI+XCIgKyBjdXJyZW50VGV4dCArIFwiPC9idXR0b24+XCIgOiBcIlwiKSArIChpc1JUTCA/IFwiXCIgOiBjb250cm9scykgKyBcIjwvZGl2PlwiIDogXCJcIjtcblxuXHRcdGZpcnN0RGF5ID0gcGFyc2VJbnQodGhpcy5fZ2V0KGluc3QsIFwiZmlyc3REYXlcIiksMTApO1xuXHRcdGZpcnN0RGF5ID0gKGlzTmFOKGZpcnN0RGF5KSA/IDAgOiBmaXJzdERheSk7XG5cblx0XHRzaG93V2VlayA9IHRoaXMuX2dldChpbnN0LCBcInNob3dXZWVrXCIpO1xuXHRcdGRheU5hbWVzID0gdGhpcy5fZ2V0KGluc3QsIFwiZGF5TmFtZXNcIik7XG5cdFx0ZGF5TmFtZXNNaW4gPSB0aGlzLl9nZXQoaW5zdCwgXCJkYXlOYW1lc01pblwiKTtcblx0XHRtb250aE5hbWVzID0gdGhpcy5fZ2V0KGluc3QsIFwibW9udGhOYW1lc1wiKTtcblx0XHRtb250aE5hbWVzU2hvcnQgPSB0aGlzLl9nZXQoaW5zdCwgXCJtb250aE5hbWVzU2hvcnRcIik7XG5cdFx0YmVmb3JlU2hvd0RheSA9IHRoaXMuX2dldChpbnN0LCBcImJlZm9yZVNob3dEYXlcIik7XG5cdFx0c2hvd090aGVyTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd090aGVyTW9udGhzXCIpO1xuXHRcdHNlbGVjdE90aGVyTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwic2VsZWN0T3RoZXJNb250aHNcIik7XG5cdFx0ZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KTtcblx0XHRodG1sID0gXCJcIjtcblx0XHRkb3c7XG5cdFx0Zm9yIChyb3cgPSAwOyByb3cgPCBudW1Nb250aHNbMF07IHJvdysrKSB7XG5cdFx0XHRncm91cCA9IFwiXCI7XG5cdFx0XHR0aGlzLm1heFJvd3MgPSA0O1xuXHRcdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCBudW1Nb250aHNbMV07IGNvbCsrKSB7XG5cdFx0XHRcdHNlbGVjdGVkRGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGgsIGluc3Quc2VsZWN0ZWREYXkpKTtcblx0XHRcdFx0Y29ybmVyQ2xhc3MgPSBcIiB1aS1jb3JuZXItYWxsXCI7XG5cdFx0XHRcdGNhbGVuZGVyID0gXCJcIjtcblx0XHRcdFx0aWYgKGlzTXVsdGlNb250aCkge1xuXHRcdFx0XHRcdGNhbGVuZGVyICs9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci1ncm91cFwiO1xuXHRcdFx0XHRcdGlmIChudW1Nb250aHNbMV0gPiAxKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGNvbCkge1xuXHRcdFx0XHRcdFx0XHRjYXNlIDA6IGNhbGVuZGVyICs9IFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtZmlyc3RcIjtcblx0XHRcdFx0XHRcdFx0XHRjb3JuZXJDbGFzcyA9IFwiIHVpLWNvcm5lci1cIiArIChpc1JUTCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgbnVtTW9udGhzWzFdLTE6IGNhbGVuZGVyICs9IFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtbGFzdFwiO1xuXHRcdFx0XHRcdFx0XHRcdGNvcm5lckNsYXNzID0gXCIgdWktY29ybmVyLVwiICsgKGlzUlRMID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpOyBicmVhaztcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1taWRkbGVcIjsgY29ybmVyQ2xhc3MgPSBcIlwiOyBicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gXCInPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci1oZWFkZXIgdWktd2lkZ2V0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXhcIiArIGNvcm5lckNsYXNzICsgXCInPlwiICtcblx0XHRcdFx0XHQoL2FsbHxsZWZ0Ly50ZXN0KGNvcm5lckNsYXNzKSAmJiByb3cgPT09IDAgPyAoaXNSVEwgPyBuZXh0IDogcHJldikgOiBcIlwiKSArXG5cdFx0XHRcdFx0KC9hbGx8cmlnaHQvLnRlc3QoY29ybmVyQ2xhc3MpICYmIHJvdyA9PT0gMCA/IChpc1JUTCA/IHByZXYgOiBuZXh0KSA6IFwiXCIpICtcblx0XHRcdFx0XHR0aGlzLl9nZW5lcmF0ZU1vbnRoWWVhckhlYWRlcihpbnN0LCBkcmF3TW9udGgsIGRyYXdZZWFyLCBtaW5EYXRlLCBtYXhEYXRlLFxuXHRcdFx0XHRcdHJvdyA+IDAgfHwgY29sID4gMCwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0KSArIC8vIGRyYXcgbW9udGggaGVhZGVyc1xuXHRcdFx0XHRcdFwiPC9kaXY+PHRhYmxlIGNsYXNzPSd1aS1kYXRlcGlja2VyLWNhbGVuZGFyJz48dGhlYWQ+XCIgK1xuXHRcdFx0XHRcdFwiPHRyPlwiO1xuXHRcdFx0XHR0aGVhZCA9IChzaG93V2VlayA/IFwiPHRoIGNsYXNzPSd1aS1kYXRlcGlja2VyLXdlZWstY29sJz5cIiArIHRoaXMuX2dldChpbnN0LCBcIndlZWtIZWFkZXJcIikgKyBcIjwvdGg+XCIgOiBcIlwiKTtcblx0XHRcdFx0Zm9yIChkb3cgPSAwOyBkb3cgPCA3OyBkb3crKykgeyAvLyBkYXlzIG9mIHRoZSB3ZWVrXG5cdFx0XHRcdFx0ZGF5ID0gKGRvdyArIGZpcnN0RGF5KSAlIDc7XG5cdFx0XHRcdFx0dGhlYWQgKz0gXCI8dGhcIiArICgoZG93ICsgZmlyc3REYXkgKyA2KSAlIDcgPj0gNSA/IFwiIGNsYXNzPSd1aS1kYXRlcGlja2VyLXdlZWstZW5kJ1wiIDogXCJcIikgKyBcIj5cIiArXG5cdFx0XHRcdFx0XHRcIjxzcGFuIHRpdGxlPSdcIiArIGRheU5hbWVzW2RheV0gKyBcIic+XCIgKyBkYXlOYW1lc01pbltkYXldICsgXCI8L3NwYW4+PC90aD5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxlbmRlciArPSB0aGVhZCArIFwiPC90cj48L3RoZWFkPjx0Ym9keT5cIjtcblx0XHRcdFx0ZGF5c0luTW9udGggPSB0aGlzLl9nZXREYXlzSW5Nb250aChkcmF3WWVhciwgZHJhd01vbnRoKTtcblx0XHRcdFx0aWYgKGRyYXdZZWFyID09PSBpbnN0LnNlbGVjdGVkWWVhciAmJiBkcmF3TW9udGggPT09IGluc3Quc2VsZWN0ZWRNb250aCkge1xuXHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBNYXRoLm1pbihpbnN0LnNlbGVjdGVkRGF5LCBkYXlzSW5Nb250aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVhZERheXMgPSAodGhpcy5fZ2V0Rmlyc3REYXlPZk1vbnRoKGRyYXdZZWFyLCBkcmF3TW9udGgpIC0gZmlyc3REYXkgKyA3KSAlIDc7XG5cdFx0XHRcdGN1clJvd3MgPSBNYXRoLmNlaWwoKGxlYWREYXlzICsgZGF5c0luTW9udGgpIC8gNyk7IC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gZ2VuZXJhdGVcblx0XHRcdFx0bnVtUm93cyA9IChpc011bHRpTW9udGggPyB0aGlzLm1heFJvd3MgPiBjdXJSb3dzID8gdGhpcy5tYXhSb3dzIDogY3VyUm93cyA6IGN1clJvd3MpOyAvL0lmIG11bHRpcGxlIG1vbnRocywgdXNlIHRoZSBoaWdoZXIgbnVtYmVyIG9mIHJvd3MgKHNlZSAjNzA0Mylcblx0XHRcdFx0dGhpcy5tYXhSb3dzID0gbnVtUm93cztcblx0XHRcdFx0cHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgMSAtIGxlYWREYXlzKSk7XG5cdFx0XHRcdGZvciAoZFJvdyA9IDA7IGRSb3cgPCBudW1Sb3dzOyBkUm93KyspIHsgLy8gY3JlYXRlIGRhdGUgcGlja2VyIHJvd3Ncblx0XHRcdFx0XHRjYWxlbmRlciArPSBcIjx0cj5cIjtcblx0XHRcdFx0XHR0Ym9keSA9ICghc2hvd1dlZWsgPyBcIlwiIDogXCI8dGQgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1jb2wnPlwiICtcblx0XHRcdFx0XHRcdHRoaXMuX2dldChpbnN0LCBcImNhbGN1bGF0ZVdlZWtcIikocHJpbnREYXRlKSArIFwiPC90ZD5cIik7XG5cdFx0XHRcdFx0Zm9yIChkb3cgPSAwOyBkb3cgPCA3OyBkb3crKykgeyAvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgZGF5c1xuXHRcdFx0XHRcdFx0ZGF5U2V0dGluZ3MgPSAoYmVmb3JlU2hvd0RheSA/XG5cdFx0XHRcdFx0XHRcdGJlZm9yZVNob3dEYXkuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFtwcmludERhdGVdKSA6IFt0cnVlLCBcIlwiXSk7XG5cdFx0XHRcdFx0XHRvdGhlck1vbnRoID0gKHByaW50RGF0ZS5nZXRNb250aCgpICE9PSBkcmF3TW9udGgpO1xuXHRcdFx0XHRcdFx0dW5zZWxlY3RhYmxlID0gKG90aGVyTW9udGggJiYgIXNlbGVjdE90aGVyTW9udGhzKSB8fCAhZGF5U2V0dGluZ3NbMF0gfHxcblx0XHRcdFx0XHRcdFx0KG1pbkRhdGUgJiYgcHJpbnREYXRlIDwgbWluRGF0ZSkgfHwgKG1heERhdGUgJiYgcHJpbnREYXRlID4gbWF4RGF0ZSk7XG5cdFx0XHRcdFx0XHR0Ym9keSArPSBcIjx0ZCBjbGFzcz0nXCIgK1xuXHRcdFx0XHRcdFx0XHQoKGRvdyArIGZpcnN0RGF5ICsgNikgJSA3ID49IDUgPyBcIiB1aS1kYXRlcGlja2VyLXdlZWstZW5kXCIgOiBcIlwiKSArIC8vIGhpZ2hsaWdodCB3ZWVrZW5kc1xuXHRcdFx0XHRcdFx0XHQob3RoZXJNb250aCA/IFwiIHVpLWRhdGVwaWNrZXItb3RoZXItbW9udGhcIiA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IGRheXMgZnJvbSBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0KChwcmludERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpICYmIGRyYXdNb250aCA9PT0gaW5zdC5zZWxlY3RlZE1vbnRoICYmIGluc3QuX2tleUV2ZW50KSB8fCAvLyB1c2VyIHByZXNzZWQga2V5XG5cdFx0XHRcdFx0XHRcdChkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT09IHByaW50RGF0ZS5nZXRUaW1lKCkgJiYgZGVmYXVsdERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpKSA/XG5cdFx0XHRcdFx0XHRcdC8vIG9yIGRlZmF1bHREYXRlIGlzIGN1cnJlbnQgcHJpbnRlZERhdGUgYW5kIGRlZmF1bHREYXRlIGlzIHNlbGVjdGVkRGF0ZVxuXHRcdFx0XHRcdFx0XHRcIiBcIiArIHRoaXMuX2RheU92ZXJDbGFzcyA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQodW5zZWxlY3RhYmxlID8gXCIgXCIgKyB0aGlzLl91bnNlbGVjdGFibGVDbGFzcyArIFwiIHVpLXN0YXRlLWRpc2FibGVkXCI6IFwiXCIpICsgIC8vIGhpZ2hsaWdodCB1bnNlbGVjdGFibGUgZGF5c1xuXHRcdFx0XHRcdFx0XHQob3RoZXJNb250aCAmJiAhc2hvd090aGVyTW9udGhzID8gXCJcIiA6IFwiIFwiICsgZGF5U2V0dGluZ3NbMV0gKyAvLyBoaWdobGlnaHQgY3VzdG9tIGRhdGVzXG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09PSBjdXJyZW50RGF0ZS5nZXRUaW1lKCkgPyBcIiBcIiArIHRoaXMuX2N1cnJlbnRDbGFzcyA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQocHJpbnREYXRlLmdldFRpbWUoKSA9PT0gdG9kYXkuZ2V0VGltZSgpID8gXCIgdWktZGF0ZXBpY2tlci10b2RheVwiIDogXCJcIikpICsgXCInXCIgKyAvLyBoaWdobGlnaHQgdG9kYXkgKGlmIGRpZmZlcmVudClcblx0XHRcdFx0XHRcdFx0KCghb3RoZXJNb250aCB8fCBzaG93T3RoZXJNb250aHMpICYmIGRheVNldHRpbmdzWzJdID8gXCIgdGl0bGU9J1wiICsgZGF5U2V0dGluZ3NbMl0ucmVwbGFjZSgvJy9nLCBcIiYjMzk7XCIpICsgXCInXCIgOiBcIlwiKSArIC8vIGNlbGwgdGl0bGVcblx0XHRcdFx0XHRcdFx0KHVuc2VsZWN0YWJsZSA/IFwiXCIgOiBcIiBkYXRhLWhhbmRsZXI9J3NlbGVjdERheScgZGF0YS1ldmVudD0nY2xpY2snIGRhdGEtbW9udGg9J1wiICsgcHJpbnREYXRlLmdldE1vbnRoKCkgKyBcIicgZGF0YS15ZWFyPSdcIiArIHByaW50RGF0ZS5nZXRGdWxsWWVhcigpICsgXCInXCIpICsgXCI+XCIgKyAvLyBhY3Rpb25zXG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyBcIiYjeGEwO1wiIDogLy8gZGlzcGxheSBmb3Igb3RoZXIgbW9udGhzXG5cdFx0XHRcdFx0XHRcdCh1bnNlbGVjdGFibGUgPyBcIjxzcGFuIGNsYXNzPSd1aS1zdGF0ZS1kZWZhdWx0Jz5cIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcIjwvc3Bhbj5cIiA6IFwiPGEgY2xhc3M9J3VpLXN0YXRlLWRlZmF1bHRcIiArXG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09PSB0b2RheS5nZXRUaW1lKCkgPyBcIiB1aS1zdGF0ZS1oaWdobGlnaHRcIiA6IFwiXCIpICtcblx0XHRcdFx0XHRcdFx0KHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IGN1cnJlbnREYXRlLmdldFRpbWUoKSA/IFwiIHVpLXN0YXRlLWFjdGl2ZVwiIDogXCJcIikgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoID8gXCIgdWktcHJpb3JpdHktc2Vjb25kYXJ5XCIgOiBcIlwiKSArIC8vIGRpc3Rpbmd1aXNoIGRhdGVzIGZyb20gb3RoZXIgbW9udGhzXG5cdFx0XHRcdFx0XHRcdFwiJyBocmVmPScjJz5cIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcIjwvYT5cIikpICsgXCI8L3RkPlwiOyAvLyBkaXNwbGF5IHNlbGVjdGFibGUgZGF0ZVxuXHRcdFx0XHRcdFx0cHJpbnREYXRlLnNldERhdGUocHJpbnREYXRlLmdldERhdGUoKSArIDEpO1xuXHRcdFx0XHRcdFx0cHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QocHJpbnREYXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gdGJvZHkgKyBcIjwvdHI+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZHJhd01vbnRoKys7XG5cdFx0XHRcdGlmIChkcmF3TW9udGggPiAxMSkge1xuXHRcdFx0XHRcdGRyYXdNb250aCA9IDA7XG5cdFx0XHRcdFx0ZHJhd1llYXIrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxlbmRlciArPSBcIjwvdGJvZHk+PC90YWJsZT5cIiArIChpc011bHRpTW9udGggPyBcIjwvZGl2PlwiICtcblx0XHRcdFx0XHRcdFx0KChudW1Nb250aHNbMF0gPiAwICYmIGNvbCA9PT0gbnVtTW9udGhzWzFdLTEpID8gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLXJvdy1icmVhayc+PC9kaXY+XCIgOiBcIlwiKSA6IFwiXCIpO1xuXHRcdFx0XHRncm91cCArPSBjYWxlbmRlcjtcblx0XHRcdH1cblx0XHRcdGh0bWwgKz0gZ3JvdXA7XG5cdFx0fVxuXHRcdGh0bWwgKz0gYnV0dG9uUGFuZWw7XG5cdFx0aW5zdC5fa2V5RXZlbnQgPSBmYWxzZTtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgbW9udGggYW5kIHllYXIgaGVhZGVyLiAqL1xuXHRfZ2VuZXJhdGVNb250aFllYXJIZWFkZXI6IGZ1bmN0aW9uKGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRzZWNvbmRhcnksIG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCkge1xuXG5cdFx0dmFyIGluTWluWWVhciwgaW5NYXhZZWFyLCBtb250aCwgeWVhcnMsIHRoaXNZZWFyLCBkZXRlcm1pbmVZZWFyLCB5ZWFyLCBlbmRZZWFyLFxuXHRcdFx0Y2hhbmdlTW9udGggPSB0aGlzLl9nZXQoaW5zdCwgXCJjaGFuZ2VNb250aFwiKSxcblx0XHRcdGNoYW5nZVllYXIgPSB0aGlzLl9nZXQoaW5zdCwgXCJjaGFuZ2VZZWFyXCIpLFxuXHRcdFx0c2hvd01vbnRoQWZ0ZXJZZWFyID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd01vbnRoQWZ0ZXJZZWFyXCIpLFxuXHRcdFx0aHRtbCA9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci10aXRsZSc+XCIsXG5cdFx0XHRtb250aEh0bWwgPSBcIlwiO1xuXG5cdFx0Ly8gbW9udGggc2VsZWN0aW9uXG5cdFx0aWYgKHNlY29uZGFyeSB8fCAhY2hhbmdlTW9udGgpIHtcblx0XHRcdG1vbnRoSHRtbCArPSBcIjxzcGFuIGNsYXNzPSd1aS1kYXRlcGlja2VyLW1vbnRoJz5cIiArIG1vbnRoTmFtZXNbZHJhd01vbnRoXSArIFwiPC9zcGFuPlwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbk1pblllYXIgPSAobWluRGF0ZSAmJiBtaW5EYXRlLmdldEZ1bGxZZWFyKCkgPT09IGRyYXdZZWFyKTtcblx0XHRcdGluTWF4WWVhciA9IChtYXhEYXRlICYmIG1heERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZHJhd1llYXIpO1xuXHRcdFx0bW9udGhIdG1sICs9IFwiPHNlbGVjdCBjbGFzcz0ndWktZGF0ZXBpY2tlci1tb250aCcgZGF0YS1oYW5kbGVyPSdzZWxlY3RNb250aCcgZGF0YS1ldmVudD0nY2hhbmdlJz5cIjtcblx0XHRcdGZvciAoIG1vbnRoID0gMDsgbW9udGggPCAxMjsgbW9udGgrKykge1xuXHRcdFx0XHRpZiAoKCFpbk1pblllYXIgfHwgbW9udGggPj0gbWluRGF0ZS5nZXRNb250aCgpKSAmJiAoIWluTWF4WWVhciB8fCBtb250aCA8PSBtYXhEYXRlLmdldE1vbnRoKCkpKSB7XG5cdFx0XHRcdFx0bW9udGhIdG1sICs9IFwiPG9wdGlvbiB2YWx1ZT0nXCIgKyBtb250aCArIFwiJ1wiICtcblx0XHRcdFx0XHRcdChtb250aCA9PT0gZHJhd01vbnRoID8gXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1wiIDogXCJcIikgK1xuXHRcdFx0XHRcdFx0XCI+XCIgKyBtb250aE5hbWVzU2hvcnRbbW9udGhdICsgXCI8L29wdGlvbj5cIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bW9udGhIdG1sICs9IFwiPC9zZWxlY3Q+XCI7XG5cdFx0fVxuXG5cdFx0aWYgKCFzaG93TW9udGhBZnRlclllYXIpIHtcblx0XHRcdGh0bWwgKz0gbW9udGhIdG1sICsgKHNlY29uZGFyeSB8fCAhKGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIpID8gXCImI3hhMDtcIiA6IFwiXCIpO1xuXHRcdH1cblxuXHRcdC8vIHllYXIgc2VsZWN0aW9uXG5cdFx0aWYgKCAhaW5zdC55ZWFyc2h0bWwgKSB7XG5cdFx0XHRpbnN0LnllYXJzaHRtbCA9IFwiXCI7XG5cdFx0XHRpZiAoc2Vjb25kYXJ5IHx8ICFjaGFuZ2VZZWFyKSB7XG5cdFx0XHRcdGh0bWwgKz0gXCI8c3BhbiBjbGFzcz0ndWktZGF0ZXBpY2tlci15ZWFyJz5cIiArIGRyYXdZZWFyICsgXCI8L3NwYW4+XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBkZXRlcm1pbmUgcmFuZ2Ugb2YgeWVhcnMgdG8gZGlzcGxheVxuXHRcdFx0XHR5ZWFycyA9IHRoaXMuX2dldChpbnN0LCBcInllYXJSYW5nZVwiKS5zcGxpdChcIjpcIik7XG5cdFx0XHRcdHRoaXNZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRkZXRlcm1pbmVZZWFyID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgeWVhciA9ICh2YWx1ZS5tYXRjaCgvY1srXFwtXS4qLykgPyBkcmF3WWVhciArIHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZygxKSwgMTApIDpcblx0XHRcdFx0XHRcdCh2YWx1ZS5tYXRjaCgvWytcXC1dLiovKSA/IHRoaXNZZWFyICsgcGFyc2VJbnQodmFsdWUsIDEwKSA6XG5cdFx0XHRcdFx0XHRwYXJzZUludCh2YWx1ZSwgMTApKSk7XG5cdFx0XHRcdFx0cmV0dXJuIChpc05hTih5ZWFyKSA/IHRoaXNZZWFyIDogeWVhcik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHllYXIgPSBkZXRlcm1pbmVZZWFyKHllYXJzWzBdKTtcblx0XHRcdFx0ZW5kWWVhciA9IE1hdGgubWF4KHllYXIsIGRldGVybWluZVllYXIoeWVhcnNbMV0gfHwgXCJcIikpO1xuXHRcdFx0XHR5ZWFyID0gKG1pbkRhdGUgPyBNYXRoLm1heCh5ZWFyLCBtaW5EYXRlLmdldEZ1bGxZZWFyKCkpIDogeWVhcik7XG5cdFx0XHRcdGVuZFllYXIgPSAobWF4RGF0ZSA/IE1hdGgubWluKGVuZFllYXIsIG1heERhdGUuZ2V0RnVsbFllYXIoKSkgOiBlbmRZZWFyKTtcblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8c2VsZWN0IGNsYXNzPSd1aS1kYXRlcGlja2VyLXllYXInIGRhdGEtaGFuZGxlcj0nc2VsZWN0WWVhcicgZGF0YS1ldmVudD0nY2hhbmdlJz5cIjtcblx0XHRcdFx0Zm9yICg7IHllYXIgPD0gZW5kWWVhcjsgeWVhcisrKSB7XG5cdFx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIHllYXIgKyBcIidcIiArXG5cdFx0XHRcdFx0XHQoeWVhciA9PT0gZHJhd1llYXIgPyBcIiBzZWxlY3RlZD0nc2VsZWN0ZWQnXCIgOiBcIlwiKSArXG5cdFx0XHRcdFx0XHRcIj5cIiArIHllYXIgKyBcIjwvb3B0aW9uPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3QueWVhcnNodG1sICs9IFwiPC9zZWxlY3Q+XCI7XG5cblx0XHRcdFx0aHRtbCArPSBpbnN0LnllYXJzaHRtbDtcblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGh0bWwgKz0gdGhpcy5fZ2V0KGluc3QsIFwieWVhclN1ZmZpeFwiKTtcblx0XHRpZiAoc2hvd01vbnRoQWZ0ZXJZZWFyKSB7XG5cdFx0XHRodG1sICs9IChzZWNvbmRhcnkgfHwgIShjaGFuZ2VNb250aCAmJiBjaGFuZ2VZZWFyKSA/IFwiJiN4YTA7XCIgOiBcIlwiKSArIG1vbnRoSHRtbDtcblx0XHR9XG5cdFx0aHRtbCArPSBcIjwvZGl2PlwiOyAvLyBDbG9zZSBkYXRlcGlja2VyX2hlYWRlclxuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdC8qIEFkanVzdCBvbmUgb2YgdGhlIGRhdGUgc3ViLWZpZWxkcy4gKi9cblx0X2FkanVzdEluc3REYXRlOiBmdW5jdGlvbihpbnN0LCBvZmZzZXQsIHBlcmlvZCkge1xuXHRcdHZhciB5ZWFyID0gaW5zdC5kcmF3WWVhciArIChwZXJpb2QgPT09IFwiWVwiID8gb2Zmc2V0IDogMCksXG5cdFx0XHRtb250aCA9IGluc3QuZHJhd01vbnRoICsgKHBlcmlvZCA9PT0gXCJNXCIgPyBvZmZzZXQgOiAwKSxcblx0XHRcdGRheSA9IE1hdGgubWluKGluc3Quc2VsZWN0ZWREYXksIHRoaXMuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkgKyAocGVyaW9kID09PSBcIkRcIiA/IG9mZnNldCA6IDApLFxuXHRcdFx0ZGF0ZSA9IHRoaXMuX3Jlc3RyaWN0TWluTWF4KGluc3QsIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSk7XG5cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmIChwZXJpb2QgPT09IFwiTVwiIHx8IHBlcmlvZCA9PT0gXCJZXCIpIHtcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogRW5zdXJlIGEgZGF0ZSBpcyB3aXRoaW4gYW55IG1pbi9tYXggYm91bmRzLiAqL1xuXHRfcmVzdHJpY3RNaW5NYXg6IGZ1bmN0aW9uKGluc3QsIGRhdGUpIHtcblx0XHR2YXIgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtaW5cIiksXG5cdFx0XHRtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1heFwiKSxcblx0XHRcdG5ld0RhdGUgPSAobWluRGF0ZSAmJiBkYXRlIDwgbWluRGF0ZSA/IG1pbkRhdGUgOiBkYXRlKTtcblx0XHRyZXR1cm4gKG1heERhdGUgJiYgbmV3RGF0ZSA+IG1heERhdGUgPyBtYXhEYXRlIDogbmV3RGF0ZSk7XG5cdH0sXG5cblx0LyogTm90aWZ5IGNoYW5nZSBvZiBtb250aC95ZWFyLiAqL1xuXHRfbm90aWZ5Q2hhbmdlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIG9uQ2hhbmdlID0gdGhpcy5fZ2V0KGluc3QsIFwib25DaGFuZ2VNb250aFllYXJcIik7XG5cdFx0aWYgKG9uQ2hhbmdlKSB7XG5cdFx0XHRvbkNoYW5nZS5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSxcblx0XHRcdFx0W2luc3Quc2VsZWN0ZWRZZWFyLCBpbnN0LnNlbGVjdGVkTW9udGggKyAxLCBpbnN0XSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIG1vbnRocyB0byBzaG93LiAqL1xuXHRfZ2V0TnVtYmVyT2ZNb250aHM6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgbnVtTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwibnVtYmVyT2ZNb250aHNcIik7XG5cdFx0cmV0dXJuIChudW1Nb250aHMgPT0gbnVsbCA/IFsxLCAxXSA6ICh0eXBlb2YgbnVtTW9udGhzID09PSBcIm51bWJlclwiID8gWzEsIG51bU1vbnRoc10gOiBudW1Nb250aHMpKTtcblx0fSxcblxuXHQvKiBEZXRlcm1pbmUgdGhlIGN1cnJlbnQgbWF4aW11bSBkYXRlIC0gZW5zdXJlIG5vIHRpbWUgY29tcG9uZW50cyBhcmUgc2V0LiAqL1xuXHRfZ2V0TWluTWF4RGF0ZTogZnVuY3Rpb24oaW5zdCwgbWluTWF4KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RldGVybWluZURhdGUoaW5zdCwgdGhpcy5fZ2V0KGluc3QsIG1pbk1heCArIFwiRGF0ZVwiKSwgbnVsbCk7XG5cdH0sXG5cblx0LyogRmluZCB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSBnaXZlbiBtb250aC4gKi9cblx0X2dldERheXNJbk1vbnRoOiBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuXHRcdHJldHVybiAzMiAtIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCAzMikpLmdldERhdGUoKTtcblx0fSxcblxuXHQvKiBGaW5kIHRoZSBkYXkgb2YgdGhlIHdlZWsgb2YgdGhlIGZpcnN0IG9mIGEgbW9udGguICovXG5cdF9nZXRGaXJzdERheU9mTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKS5nZXREYXkoKTtcblx0fSxcblxuXHQvKiBEZXRlcm1pbmVzIGlmIHdlIHNob3VsZCBhbGxvdyBhIFwibmV4dC9wcmV2XCIgbW9udGggZGlzcGxheSBjaGFuZ2UuICovXG5cdF9jYW5BZGp1c3RNb250aDogZnVuY3Rpb24oaW5zdCwgb2Zmc2V0LCBjdXJZZWFyLCBjdXJNb250aCkge1xuXHRcdHZhciBudW1Nb250aHMgPSB0aGlzLl9nZXROdW1iZXJPZk1vbnRocyhpbnN0KSxcblx0XHRcdGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShjdXJZZWFyLFxuXHRcdFx0Y3VyTW9udGggKyAob2Zmc2V0IDwgMCA/IG9mZnNldCA6IG51bU1vbnRoc1swXSAqIG51bU1vbnRoc1sxXSksIDEpKTtcblxuXHRcdGlmIChvZmZzZXQgPCAwKSB7XG5cdFx0XHRkYXRlLnNldERhdGUodGhpcy5fZ2V0RGF5c0luTW9udGgoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2lzSW5SYW5nZShpbnN0LCBkYXRlKTtcblx0fSxcblxuXHQvKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgYWNjZXB0ZWQgcmFuZ2U/ICovXG5cdF9pc0luUmFuZ2U6IGZ1bmN0aW9uKGluc3QsIGRhdGUpIHtcblx0XHR2YXIgeWVhclNwbGl0LCBjdXJyZW50WWVhcixcblx0XHRcdG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWluXCIpLFxuXHRcdFx0bWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtYXhcIiksXG5cdFx0XHRtaW5ZZWFyID0gbnVsbCxcblx0XHRcdG1heFllYXIgPSBudWxsLFxuXHRcdFx0eWVhcnMgPSB0aGlzLl9nZXQoaW5zdCwgXCJ5ZWFyUmFuZ2VcIik7XG5cdFx0XHRpZiAoeWVhcnMpe1xuXHRcdFx0XHR5ZWFyU3BsaXQgPSB5ZWFycy5zcGxpdChcIjpcIik7XG5cdFx0XHRcdGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRtaW5ZZWFyID0gcGFyc2VJbnQoeWVhclNwbGl0WzBdLCAxMCk7XG5cdFx0XHRcdG1heFllYXIgPSBwYXJzZUludCh5ZWFyU3BsaXRbMV0sIDEwKTtcblx0XHRcdFx0aWYgKCB5ZWFyU3BsaXRbMF0ubWF0Y2goL1srXFwtXS4qLykgKSB7XG5cdFx0XHRcdFx0bWluWWVhciArPSBjdXJyZW50WWVhcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHllYXJTcGxpdFsxXS5tYXRjaCgvWytcXC1dLiovKSApIHtcblx0XHRcdFx0XHRtYXhZZWFyICs9IGN1cnJlbnRZZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRyZXR1cm4gKCghbWluRGF0ZSB8fCBkYXRlLmdldFRpbWUoKSA+PSBtaW5EYXRlLmdldFRpbWUoKSkgJiZcblx0XHRcdCghbWF4RGF0ZSB8fCBkYXRlLmdldFRpbWUoKSA8PSBtYXhEYXRlLmdldFRpbWUoKSkgJiZcblx0XHRcdCghbWluWWVhciB8fCBkYXRlLmdldEZ1bGxZZWFyKCkgPj0gbWluWWVhcikgJiZcblx0XHRcdCghbWF4WWVhciB8fCBkYXRlLmdldEZ1bGxZZWFyKCkgPD0gbWF4WWVhcikpO1xuXHR9LFxuXG5cdC8qIFByb3ZpZGUgdGhlIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZm9yIGZvcm1hdHRpbmcvcGFyc2luZy4gKi9cblx0X2dldEZvcm1hdENvbmZpZzogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBzaG9ydFllYXJDdXRvZmYgPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG9ydFllYXJDdXRvZmZcIik7XG5cdFx0c2hvcnRZZWFyQ3V0b2ZmID0gKHR5cGVvZiBzaG9ydFllYXJDdXRvZmYgIT09IFwic3RyaW5nXCIgPyBzaG9ydFllYXJDdXRvZmYgOlxuXHRcdFx0bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoc2hvcnRZZWFyQ3V0b2ZmLCAxMCkpO1xuXHRcdHJldHVybiB7c2hvcnRZZWFyQ3V0b2ZmOiBzaG9ydFllYXJDdXRvZmYsXG5cdFx0XHRkYXlOYW1lc1Nob3J0OiB0aGlzLl9nZXQoaW5zdCwgXCJkYXlOYW1lc1Nob3J0XCIpLCBkYXlOYW1lczogdGhpcy5fZ2V0KGluc3QsIFwiZGF5TmFtZXNcIiksXG5cdFx0XHRtb250aE5hbWVzU2hvcnQ6IHRoaXMuX2dldChpbnN0LCBcIm1vbnRoTmFtZXNTaG9ydFwiKSwgbW9udGhOYW1lczogdGhpcy5fZ2V0KGluc3QsIFwibW9udGhOYW1lc1wiKX07XG5cdH0sXG5cblx0LyogRm9ybWF0IHRoZSBnaXZlbiBkYXRlIGZvciBkaXNwbGF5LiAqL1xuXHRfZm9ybWF0RGF0ZTogZnVuY3Rpb24oaW5zdCwgZGF5LCBtb250aCwgeWVhcikge1xuXHRcdGlmICghZGF5KSB7XG5cdFx0XHRpbnN0LmN1cnJlbnREYXkgPSBpbnN0LnNlbGVjdGVkRGF5O1xuXHRcdFx0aW5zdC5jdXJyZW50TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGg7XG5cdFx0XHRpbnN0LmN1cnJlbnRZZWFyID0gaW5zdC5zZWxlY3RlZFllYXI7XG5cdFx0fVxuXHRcdHZhciBkYXRlID0gKGRheSA/ICh0eXBlb2YgZGF5ID09PSBcIm9iamVjdFwiID8gZGF5IDpcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSkgOlxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoaW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpKTtcblx0XHRyZXR1cm4gdGhpcy5mb3JtYXREYXRlKHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIiksIGRhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cdH1cbn0pO1xuXG4vKlxuICogQmluZCBob3ZlciBldmVudHMgZm9yIGRhdGVwaWNrZXIgZWxlbWVudHMuXG4gKiBEb25lIHZpYSBkZWxlZ2F0ZSBzbyB0aGUgYmluZGluZyBvbmx5IG9jY3VycyBvbmNlIGluIHRoZSBsaWZldGltZSBvZiB0aGUgcGFyZW50IGRpdi5cbiAqIEdsb2JhbCBpbnN0QWN0aXZlLCBzZXQgYnkgX3VwZGF0ZURhdGVwaWNrZXIgYWxsb3dzIHRoZSBoYW5kbGVycyB0byBmaW5kIHRoZWlyIHdheSBiYWNrIHRvIHRoZSBhY3RpdmUgcGlja2VyLlxuICovXG5mdW5jdGlvbiBiaW5kSG92ZXIoZHBEaXYpIHtcblx0dmFyIHNlbGVjdG9yID0gXCJidXR0b24sIC51aS1kYXRlcGlja2VyLXByZXYsIC51aS1kYXRlcGlja2VyLW5leHQsIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyIHRkIGFcIjtcblx0cmV0dXJuIGRwRGl2LmRlbGVnYXRlKHNlbGVjdG9yLCBcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWhvdmVyXCIpO1xuXHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoXCJ1aS1kYXRlcGlja2VyLXByZXZcIikgIT09IC0xKSB7XG5cdFx0XHRcdCQodGhpcykucmVtb3ZlQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLXByZXYtaG92ZXJcIik7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcInVpLWRhdGVwaWNrZXItbmV4dFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLWRhdGVwaWNrZXItbmV4dC1ob3ZlclwiKTtcblx0XHRcdH1cblx0XHR9KVxuXHRcdC5kZWxlZ2F0ZShzZWxlY3RvciwgXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKXtcblx0XHRcdGlmICghJC5kYXRlcGlja2VyLl9pc0Rpc2FibGVkRGF0ZXBpY2tlciggaW5zdEFjdGl2ZS5pbmxpbmUgPyBkcERpdi5wYXJlbnQoKVswXSA6IGluc3RBY3RpdmUuaW5wdXRbMF0pKSB7XG5cdFx0XHRcdCQodGhpcykucGFyZW50cyhcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXCIpLmZpbmQoXCJhXCIpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtaG92ZXJcIik7XG5cdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKTtcblx0XHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoXCJ1aS1kYXRlcGlja2VyLXByZXZcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5hZGRDbGFzcyhcInVpLWRhdGVwaWNrZXItcHJldi1ob3ZlclwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcInVpLWRhdGVwaWNrZXItbmV4dFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG59XG5cbi8qIGpRdWVyeSBleHRlbmQgbm93IGlnbm9yZXMgbnVsbHMhICovXG5mdW5jdGlvbiBleHRlbmRSZW1vdmUodGFyZ2V0LCBwcm9wcykge1xuXHQkLmV4dGVuZCh0YXJnZXQsIHByb3BzKTtcblx0Zm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xuXHRcdGlmIChwcm9wc1tuYW1lXSA9PSBudWxsKSB7XG5cdFx0XHR0YXJnZXRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSW52b2tlIHRoZSBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHkuXG4gICBAcGFyYW0gIG9wdGlvbnMgIHN0cmluZyAtIGEgY29tbWFuZCwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgb3Jcblx0XHRcdFx0XHRPYmplY3QgLSBzZXR0aW5ncyBmb3IgYXR0YWNoaW5nIG5ldyBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHlcbiAgIEByZXR1cm4gIGpRdWVyeSBvYmplY3QgKi9cbiQuZm4uZGF0ZXBpY2tlciA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXG5cdC8qIFZlcmlmeSBhbiBlbXB0eSBjb2xsZWN0aW9uIHdhc24ndCBwYXNzZWQgLSBGaXhlcyAjNjk3NiAqL1xuXHRpZiAoICF0aGlzLmxlbmd0aCApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qIEluaXRpYWxpc2UgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRpZiAoISQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCkge1xuXHRcdCQoZG9jdW1lbnQpLm1vdXNlZG93bigkLmRhdGVwaWNrZXIuX2NoZWNrRXh0ZXJuYWxDbGljayk7XG5cdFx0JC5kYXRlcGlja2VyLmluaXRpYWxpemVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qIEFwcGVuZCBkYXRlcGlja2VyIG1haW4gY29udGFpbmVyIHRvIGJvZHkgaWYgbm90IGV4aXN0LiAqL1xuXHRpZiAoJChcIiNcIiskLmRhdGVwaWNrZXIuX21haW5EaXZJZCkubGVuZ3RoID09PSAwKSB7XG5cdFx0JChcImJvZHlcIikuYXBwZW5kKCQuZGF0ZXBpY2tlci5kcERpdik7XG5cdH1cblxuXHR2YXIgb3RoZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICYmIChvcHRpb25zID09PSBcImlzRGlzYWJsZWRcIiB8fCBvcHRpb25zID09PSBcImdldERhdGVcIiB8fCBvcHRpb25zID09PSBcIndpZGdldFwiKSkge1xuXHRcdHJldHVybiAkLmRhdGVwaWNrZXJbXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCJdLlxuXHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xuXHR9XG5cdGlmIChvcHRpb25zID09PSBcIm9wdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiAkLmRhdGVwaWNrZXJbXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCJdLlxuXHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xuXHR9XG5cdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0dHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0JC5kYXRlcGlja2VyW1wiX1wiICsgb3B0aW9ucyArIFwiRGF0ZXBpY2tlclwiXS5cblx0XHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc10uY29uY2F0KG90aGVyQXJncykpIDpcblx0XHRcdCQuZGF0ZXBpY2tlci5fYXR0YWNoRGF0ZXBpY2tlcih0aGlzLCBvcHRpb25zKTtcblx0fSk7XG59O1xuXG4kLmRhdGVwaWNrZXIgPSBuZXcgRGF0ZXBpY2tlcigpOyAvLyBzaW5nbGV0b24gaW5zdGFuY2VcbiQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCA9IGZhbHNlO1xuJC5kYXRlcGlja2VyLnV1aWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiQuZGF0ZXBpY2tlci52ZXJzaW9uID0gXCIxLjEwLjRcIjtcblxufSkoalF1ZXJ5KTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJy4vY29yZScpO1xucmVxdWlyZSgnLi93aWRnZXQnKTtcbnJlcXVpcmUoJy4vcG9zaXRpb24nKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgTWVudSAxLjEwLjRcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vbWVudS9cbiAqXG4gKiBEZXBlbmRzOlxuICpcdGpxdWVyeS51aS5jb3JlLmpzXG4gKlx0anF1ZXJ5LnVpLndpZGdldC5qc1xuICpcdGpxdWVyeS51aS5wb3NpdGlvbi5qc1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoIFwidWkubWVudVwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC40XCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjx1bD5cIixcblx0ZGVsYXk6IDMwMCxcblx0b3B0aW9uczoge1xuXHRcdGljb25zOiB7XG5cdFx0XHRzdWJtZW51OiBcInVpLWljb24tY2FyYXQtMS1lXCJcblx0XHR9LFxuXHRcdG1lbnVzOiBcInVsXCIsXG5cdFx0cG9zaXRpb246IHtcblx0XHRcdG15OiBcImxlZnQgdG9wXCIsXG5cdFx0XHRhdDogXCJyaWdodCB0b3BcIlxuXHRcdH0sXG5cdFx0cm9sZTogXCJtZW51XCIsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRibHVyOiBudWxsLFxuXHRcdGZvY3VzOiBudWxsLFxuXHRcdHNlbGVjdDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYWN0aXZlTWVudSA9IHRoaXMuZWxlbWVudDtcblx0XHQvLyBmbGFnIHVzZWQgdG8gcHJldmVudCBmaXJpbmcgb2YgdGhlIGNsaWNrIGhhbmRsZXJcblx0XHQvLyBhcyB0aGUgZXZlbnQgYnViYmxlcyB1cCB0aHJvdWdoIG5lc3RlZCBtZW51c1xuXHRcdHRoaXMubW91c2VIYW5kbGVkID0gZmFsc2U7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5pcXVlSWQoKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktbWVudS1pY29uc1wiLCAhIXRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1pY29uXCIgKS5sZW5ndGggKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiB0aGlzLm9wdGlvbnMucm9sZSxcblx0XHRcdFx0dGFiSW5kZXg6IDBcblx0XHRcdH0pXG5cdFx0XHQvLyBuZWVkIHRvIGNhdGNoIGFsbCBjbGlja3Mgb24gZGlzYWJsZWQgbWVudVxuXHRcdFx0Ly8gbm90IHBvc3NpYmxlIHRocm91Z2ggX29uXG5cdFx0XHQuYmluZCggXCJjbGlja1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgJC5wcm94eShmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMgKSk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9vbih7XG5cdFx0XHQvLyBQcmV2ZW50IGZvY3VzIGZyb20gc3RpY2tpbmcgdG8gbGlua3MgaW5zaWRlIG1lbnUgYWZ0ZXIgY2xpY2tpbmdcblx0XHRcdC8vIHRoZW0gKGZvY3VzIHNob3VsZCBhbHdheXMgc3RheSBvbiBVTCBkdXJpbmcgbmF2aWdhdGlvbikuXG5cdFx0XHRcIm1vdXNlZG93biAudWktbWVudS1pdGVtID4gYVwiOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9LFxuXHRcdFx0XCJjbGljayAudWktc3RhdGUtZGlzYWJsZWQgPiBhXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0sXG5cdFx0XHRcImNsaWNrIC51aS1tZW51LWl0ZW06aGFzKGEpXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9ICQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLW1lbnUtaXRlbVwiICk7XG5cdFx0XHRcdGlmICggIXRoaXMubW91c2VIYW5kbGVkICYmIHRhcmdldC5ub3QoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3QoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHQvLyBPbmx5IHNldCB0aGUgbW91c2VIYW5kbGVkIGZsYWcgaWYgdGhlIGV2ZW50IHdpbGwgYnViYmxlLCBzZWUgIzk0NjkuXG5cdFx0XHRcdFx0aWYgKCAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdHRoaXMubW91c2VIYW5kbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPcGVuIHN1Ym1lbnUgb24gY2xpY2tcblx0XHRcdFx0XHRpZiAoIHRhcmdldC5oYXMoIFwiLnVpLW1lbnVcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHRoaXMuZXhwYW5kKCBldmVudCApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICF0aGlzLmVsZW1lbnQuaXMoIFwiOmZvY3VzXCIgKSAmJiAkKCB0aGlzLmRvY3VtZW50WyAwIF0uYWN0aXZlRWxlbWVudCApLmNsb3Nlc3QoIFwiLnVpLW1lbnVcIiApLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVkaXJlY3QgZm9jdXMgdG8gdGhlIG1lbnVcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBcImZvY3VzXCIsIFsgdHJ1ZSBdICk7XG5cblx0XHRcdFx0XHRcdC8vIElmIHRoZSBhY3RpdmUgaXRlbSBpcyBvbiB0aGUgdG9wIGxldmVsLCBsZXQgaXQgc3RheSBhY3RpdmUuXG5cdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGJsdXIgdGhlIGFjdGl2ZSBpdGVtIHNpbmNlIGl0IGlzIG5vIGxvbmdlciB2aXNpYmxlLlxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmFjdGl2ZSAmJiB0aGlzLmFjdGl2ZS5wYXJlbnRzKCBcIi51aS1tZW51XCIgKS5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdFwibW91c2VlbnRlciAudWktbWVudS1pdGVtXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9ICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKTtcblx0XHRcdFx0Ly8gUmVtb3ZlIHVpLXN0YXRlLWFjdGl2ZSBjbGFzcyBmcm9tIHNpYmxpbmdzIG9mIHRoZSBuZXdseSBmb2N1c2VkIG1lbnUgaXRlbVxuXHRcdFx0XHQvLyB0byBhdm9pZCBhIGp1bXAgY2F1c2VkIGJ5IGFkamFjZW50IGVsZW1lbnRzIGJvdGggaGF2aW5nIGEgY2xhc3Mgd2l0aCBhIGJvcmRlclxuXHRcdFx0XHR0YXJnZXQuc2libGluZ3MoKS5jaGlsZHJlbiggXCIudWktc3RhdGUtYWN0aXZlXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgdGFyZ2V0ICk7XG5cdFx0XHR9LFxuXHRcdFx0bW91c2VsZWF2ZTogXCJjb2xsYXBzZUFsbFwiLFxuXHRcdFx0XCJtb3VzZWxlYXZlIC51aS1tZW51XCI6IFwiY29sbGFwc2VBbGxcIixcblx0XHRcdGZvY3VzOiBmdW5jdGlvbiggZXZlbnQsIGtlZXBBY3RpdmVJdGVtICkge1xuXHRcdFx0XHQvLyBJZiB0aGVyZSdzIGFscmVhZHkgYW4gYWN0aXZlIGl0ZW0sIGtlZXAgaXQgYWN0aXZlXG5cdFx0XHRcdC8vIElmIG5vdCwgYWN0aXZhdGUgdGhlIGZpcnN0IGl0ZW1cblx0XHRcdFx0dmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZSB8fCB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiICkuZXEoIDAgKTtcblxuXHRcdFx0XHRpZiAoICFrZWVwQWN0aXZlSXRlbSApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgaXRlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Ymx1cjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoICEkLmNvbnRhaW5zKCB0aGlzLmVsZW1lbnRbMF0sIHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5jb2xsYXBzZUFsbCggZXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGtleWRvd246IFwiX2tleWRvd25cIlxuXHRcdH0pO1xuXG5cdFx0dGhpcy5yZWZyZXNoKCk7XG5cblx0XHQvLyBDbGlja3Mgb3V0c2lkZSBvZiBhIG1lbnUgY29sbGFwc2UgYW55IG9wZW4gbWVudXNcblx0XHR0aGlzLl9vbiggdGhpcy5kb2N1bWVudCwge1xuXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCAhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktbWVudVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMuY29sbGFwc2VBbGwoIGV2ZW50ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNldCB0aGUgbW91c2VIYW5kbGVkIGZsYWdcblx0XHRcdFx0dGhpcy5tb3VzZUhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gRGVzdHJveSAoc3ViKW1lbnVzXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiApXG5cdFx0XHQuZmluZCggXCIudWktbWVudVwiICkuYWRkQmFjaygpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1tZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIHVpLW1lbnUtaWNvbnNcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcInRhYkluZGV4XCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZXhwYW5kZWRcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtaGlkZGVuXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKVxuXHRcdFx0XHQucmVtb3ZlVW5pcXVlSWQoKVxuXHRcdFx0XHQuc2hvdygpO1xuXG5cdFx0Ly8gRGVzdHJveSBtZW51IGl0ZW1zXG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1tZW51LWl0ZW1cIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiIClcblx0XHRcdC5jaGlsZHJlbiggXCJhXCIgKVxuXHRcdFx0XHQucmVtb3ZlVW5pcXVlSWQoKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktY29ybmVyLWFsbCB1aS1zdGF0ZS1ob3ZlclwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwidGFiSW5kZXhcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtaGFzcG9wdXBcIiApXG5cdFx0XHRcdC5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBlbGVtID0gJCggdGhpcyApO1xuXHRcdFx0XHRcdGlmICggZWxlbS5kYXRhKCBcInVpLW1lbnUtc3VibWVudS1jYXJhdFwiICkgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnJlbW92ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHQvLyBEZXN0cm95IG1lbnUgZGl2aWRlcnNcblx0XHR0aGlzLmVsZW1lbnQuZmluZCggXCIudWktbWVudS1kaXZpZGVyXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1tZW51LWRpdmlkZXIgdWktd2lkZ2V0LWNvbnRlbnRcIiApO1xuXHR9LFxuXG5cdF9rZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG1hdGNoLCBwcmV2LCBjaGFyYWN0ZXIsIHNraXAsIHJlZ2V4LFxuXHRcdFx0cHJldmVudERlZmF1bHQgPSB0cnVlO1xuXG5cdFx0ZnVuY3Rpb24gZXNjYXBlKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKCAvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIgKTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfVVA6XG5cdFx0XHR0aGlzLnByZXZpb3VzUGFnZSggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfRE9XTjpcblx0XHRcdHRoaXMubmV4dFBhZ2UoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxuXHRcdFx0dGhpcy5fbW92ZSggXCJmaXJzdFwiLCBcImZpcnN0XCIsIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHR0aGlzLl9tb3ZlKCBcImxhc3RcIiwgXCJsYXN0XCIsIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRcdHRoaXMucHJldmlvdXMoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuXHRcdFx0dGhpcy5uZXh0KCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuTEVGVDpcblx0XHRcdHRoaXMuY29sbGFwc2UoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcblx0XHRcdGlmICggdGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdHRoaXMuZXhwYW5kKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5URVI6XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuU1BBQ0U6XG5cdFx0XHR0aGlzLl9hY3RpdmF0ZSggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkVTQ0FQRTpcblx0XHRcdHRoaXMuY29sbGFwc2UoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cHJldmVudERlZmF1bHQgPSBmYWxzZTtcblx0XHRcdHByZXYgPSB0aGlzLnByZXZpb3VzRmlsdGVyIHx8IFwiXCI7XG5cdFx0XHRjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBldmVudC5rZXlDb2RlICk7XG5cdFx0XHRza2lwID0gZmFsc2U7XG5cblx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5maWx0ZXJUaW1lciApO1xuXG5cdFx0XHRpZiAoIGNoYXJhY3RlciA9PT0gcHJldiApIHtcblx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGFyYWN0ZXIgPSBwcmV2ICsgY2hhcmFjdGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWdleCA9IG5ldyBSZWdFeHAoIFwiXlwiICsgZXNjYXBlKCBjaGFyYWN0ZXIgKSwgXCJpXCIgKTtcblx0XHRcdG1hdGNoID0gdGhpcy5hY3RpdmVNZW51LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHJlZ2V4LnRlc3QoICQoIHRoaXMgKS5jaGlsZHJlbiggXCJhXCIgKS50ZXh0KCkgKTtcblx0XHRcdH0pO1xuXHRcdFx0bWF0Y2ggPSBza2lwICYmIG1hdGNoLmluZGV4KCB0aGlzLmFjdGl2ZS5uZXh0KCkgKSAhPT0gLTEgP1xuXHRcdFx0XHR0aGlzLmFjdGl2ZS5uZXh0QWxsKCBcIi51aS1tZW51LWl0ZW1cIiApIDpcblx0XHRcdFx0bWF0Y2g7XG5cblx0XHRcdC8vIElmIG5vIG1hdGNoZXMgb24gdGhlIGN1cnJlbnQgZmlsdGVyLCByZXNldCB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJlc3NlZFxuXHRcdFx0Ly8gdG8gbW92ZSBkb3duIHRoZSBtZW51IHRvIHRoZSBmaXJzdCBpdGVtIHRoYXQgc3RhcnRzIHdpdGggdGhhdCBjaGFyYWN0ZXJcblx0XHRcdGlmICggIW1hdGNoLmxlbmd0aCApIHtcblx0XHRcdFx0Y2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZSggZXZlbnQua2V5Q29kZSApO1xuXHRcdFx0XHRyZWdleCA9IG5ldyBSZWdFeHAoIFwiXlwiICsgZXNjYXBlKCBjaGFyYWN0ZXIgKSwgXCJpXCIgKTtcblx0XHRcdFx0bWF0Y2ggPSB0aGlzLmFjdGl2ZU1lbnUuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiByZWdleC50ZXN0KCAkKCB0aGlzICkuY2hpbGRyZW4oIFwiYVwiICkudGV4dCgpICk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGNoLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIG1hdGNoICk7XG5cdFx0XHRcdGlmICggbWF0Y2gubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHR0aGlzLnByZXZpb3VzRmlsdGVyID0gY2hhcmFjdGVyO1xuXHRcdFx0XHRcdHRoaXMuZmlsdGVyVGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnByZXZpb3VzRmlsdGVyO1xuXHRcdFx0XHRcdH0sIDEwMDAgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5wcmV2aW91c0ZpbHRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMucHJldmlvdXNGaWx0ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBwcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hY3RpdmF0ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggIXRoaXMuYWN0aXZlLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRpZiAoIHRoaXMuYWN0aXZlLmNoaWxkcmVuKCBcImFbYXJpYS1oYXNwb3B1cD0ndHJ1ZSddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMuZXhwYW5kKCBldmVudCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZWxlY3QoIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZW51cyxcblx0XHRcdGljb24gPSB0aGlzLm9wdGlvbnMuaWNvbnMuc3VibWVudSxcblx0XHRcdHN1Ym1lbnVzID0gdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5tZW51cyApO1xuXG5cdFx0dGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKCBcInVpLW1lbnUtaWNvbnNcIiwgISF0aGlzLmVsZW1lbnQuZmluZCggXCIudWktaWNvblwiICkubGVuZ3RoICk7XG5cblx0XHQvLyBJbml0aWFsaXplIG5lc3RlZCBtZW51c1xuXHRcdHN1Ym1lbnVzLmZpbHRlciggXCI6bm90KC51aS1tZW51KVwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1tZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiB0aGlzLm9wdGlvbnMucm9sZSxcblx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcblx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIlxuXHRcdFx0fSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbWVudSA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRpdGVtID0gbWVudS5wcmV2KCBcImFcIiApLFxuXHRcdFx0XHRcdHN1Ym1lbnVDYXJhdCA9ICQoIFwiPHNwYW4+XCIgKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLW1lbnUtaWNvbiB1aS1pY29uIFwiICsgaWNvbiApXG5cdFx0XHRcdFx0XHQuZGF0YSggXCJ1aS1tZW51LXN1Ym1lbnUtY2FyYXRcIiwgdHJ1ZSApO1xuXG5cdFx0XHRcdGl0ZW1cblx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLWhhc3BvcHVwXCIsIFwidHJ1ZVwiIClcblx0XHRcdFx0XHQucHJlcGVuZCggc3VibWVudUNhcmF0ICk7XG5cdFx0XHRcdG1lbnUuYXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiwgaXRlbS5hdHRyKCBcImlkXCIgKSApO1xuXHRcdFx0fSk7XG5cblx0XHRtZW51cyA9IHN1Ym1lbnVzLmFkZCggdGhpcy5lbGVtZW50ICk7XG5cblx0XHQvLyBEb24ndCByZWZyZXNoIGxpc3QgaXRlbXMgdGhhdCBhcmUgYWxyZWFkeSBhZGFwdGVkXG5cdFx0bWVudXMuY2hpbGRyZW4oIFwiOm5vdCgudWktbWVudS1pdGVtKTpoYXMoYSlcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktbWVudS1pdGVtXCIgKVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiIClcblx0XHRcdC5jaGlsZHJlbiggXCJhXCIgKVxuXHRcdFx0XHQudW5pcXVlSWQoKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiIClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdHRhYkluZGV4OiAtMSxcblx0XHRcdFx0XHRyb2xlOiB0aGlzLl9pdGVtUm9sZSgpXG5cdFx0XHRcdH0pO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB1bmxpbmtlZCBtZW51LWl0ZW1zIGNvbnRhaW5pbmcgc3BhY2VzIGFuZC9vciBkYXNoZXMgb25seSBhcyBkaXZpZGVyc1xuXHRcdG1lbnVzLmNoaWxkcmVuKCBcIjpub3QoLnVpLW1lbnUtaXRlbSlcIiApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaXRlbSA9ICQoIHRoaXMgKTtcblx0XHRcdC8vIGh5cGhlbiwgZW0gZGFzaCwgZW4gZGFzaFxuXHRcdFx0aWYgKCAhL1teXFwtXFx1MjAxNFxcdTIwMTNcXHNdLy50ZXN0KCBpdGVtLnRleHQoKSApICkge1xuXHRcdFx0XHRpdGVtLmFkZENsYXNzKCBcInVpLXdpZGdldC1jb250ZW50IHVpLW1lbnUtZGl2aWRlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBBZGQgYXJpYS1kaXNhYmxlZCBhdHRyaWJ1dGUgdG8gYW55IGRpc2FibGVkIG1lbnUgaXRlbVxuXHRcdG1lbnVzLmNoaWxkcmVuKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkuYXR0ciggXCJhcmlhLWRpc2FibGVkXCIsIFwidHJ1ZVwiICk7XG5cblx0XHQvLyBJZiB0aGUgYWN0aXZlIGl0ZW0gaGFzIGJlZW4gcmVtb3ZlZCwgYmx1ciB0aGUgbWVudVxuXHRcdGlmICggdGhpcy5hY3RpdmUgJiYgISQuY29udGFpbnMoIHRoaXMuZWxlbWVudFsgMCBdLCB0aGlzLmFjdGl2ZVsgMCBdICkgKSB7XG5cdFx0XHR0aGlzLmJsdXIoKTtcblx0XHR9XG5cdH0sXG5cblx0X2l0ZW1Sb2xlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bWVudTogXCJtZW51aXRlbVwiLFxuXHRcdFx0bGlzdGJveDogXCJvcHRpb25cIlxuXHRcdH1bIHRoaXMub3B0aW9ucy5yb2xlIF07XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiaWNvbnNcIiApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51LWljb25cIiApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5vcHRpb25zLmljb25zLnN1Ym1lbnUgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHZhbHVlLnN1Ym1lbnUgKTtcblx0XHR9XG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblx0fSxcblxuXHRmb2N1czogZnVuY3Rpb24oIGV2ZW50LCBpdGVtICkge1xuXHRcdHZhciBuZXN0ZWQsIGZvY3VzZWQ7XG5cdFx0dGhpcy5ibHVyKCBldmVudCwgZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJmb2N1c1wiICk7XG5cblx0XHR0aGlzLl9zY3JvbGxJbnRvVmlldyggaXRlbSApO1xuXG5cdFx0dGhpcy5hY3RpdmUgPSBpdGVtLmZpcnN0KCk7XG5cdFx0Zm9jdXNlZCA9IHRoaXMuYWN0aXZlLmNoaWxkcmVuKCBcImFcIiApLmFkZENsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHQvLyBPbmx5IHVwZGF0ZSBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQgaWYgdGhlcmUncyBhIHJvbGVcblx0XHQvLyBvdGhlcndpc2Ugd2UgYXNzdW1lIGZvY3VzIGlzIG1hbmFnZWQgZWxzZXdoZXJlXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucm9sZSApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBmb2N1c2VkLmF0dHIoIFwiaWRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gSGlnaGxpZ2h0IGFjdGl2ZSBwYXJlbnQgbWVudSBpdGVtLCBpZiBhbnlcblx0XHR0aGlzLmFjdGl2ZVxuXHRcdFx0LnBhcmVudCgpXG5cdFx0XHQuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0LmNoaWxkcmVuKCBcImE6Zmlyc3RcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblxuXHRcdGlmICggZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCIgKSB7XG5cdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX2Nsb3NlKCk7XG5cdFx0XHR9LCB0aGlzLmRlbGF5ICk7XG5cdFx0fVxuXG5cdFx0bmVzdGVkID0gaXRlbS5jaGlsZHJlbiggXCIudWktbWVudVwiICk7XG5cdFx0aWYgKCBuZXN0ZWQubGVuZ3RoICYmIGV2ZW50ICYmICggL15tb3VzZS8udGVzdCggZXZlbnQudHlwZSApICkgKSB7XG5cdFx0XHR0aGlzLl9zdGFydE9wZW5pbmcobmVzdGVkKTtcblx0XHR9XG5cdFx0dGhpcy5hY3RpdmVNZW51ID0gaXRlbS5wYXJlbnQoKTtcblxuXHRcdHRoaXMuX3RyaWdnZXIoIFwiZm9jdXNcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICk7XG5cdH0sXG5cblx0X3Njcm9sbEludG9WaWV3OiBmdW5jdGlvbiggaXRlbSApIHtcblx0XHR2YXIgYm9yZGVyVG9wLCBwYWRkaW5nVG9wLCBvZmZzZXQsIHNjcm9sbCwgZWxlbWVudEhlaWdodCwgaXRlbUhlaWdodDtcblx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbCgpICkge1xuXHRcdFx0Ym9yZGVyVG9wID0gcGFyc2VGbG9hdCggJC5jc3MoIHRoaXMuYWN0aXZlTWVudVswXSwgXCJib3JkZXJUb3BXaWR0aFwiICkgKSB8fCAwO1xuXHRcdFx0cGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoICQuY3NzKCB0aGlzLmFjdGl2ZU1lbnVbMF0sIFwicGFkZGluZ1RvcFwiICkgKSB8fCAwO1xuXHRcdFx0b2Zmc2V0ID0gaXRlbS5vZmZzZXQoKS50b3AgLSB0aGlzLmFjdGl2ZU1lbnUub2Zmc2V0KCkudG9wIC0gYm9yZGVyVG9wIC0gcGFkZGluZ1RvcDtcblx0XHRcdHNjcm9sbCA9IHRoaXMuYWN0aXZlTWVudS5zY3JvbGxUb3AoKTtcblx0XHRcdGVsZW1lbnRIZWlnaHQgPSB0aGlzLmFjdGl2ZU1lbnUuaGVpZ2h0KCk7XG5cdFx0XHRpdGVtSGVpZ2h0ID0gaXRlbS5oZWlnaHQoKTtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPCAwICkge1xuXHRcdFx0XHR0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCBzY3JvbGwgKyBvZmZzZXQgKTtcblx0XHRcdH0gZWxzZSBpZiAoIG9mZnNldCArIGl0ZW1IZWlnaHQgPiBlbGVtZW50SGVpZ2h0ICkge1xuXHRcdFx0XHR0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCBzY3JvbGwgKyBvZmZzZXQgLSBlbGVtZW50SGVpZ2h0ICsgaXRlbUhlaWdodCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRibHVyOiBmdW5jdGlvbiggZXZlbnQsIGZyb21Gb2N1cyApIHtcblx0XHRpZiAoICFmcm9tRm9jdXMgKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmFjdGl2ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmFjdGl2ZS5jaGlsZHJlbiggXCJhXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0dGhpcy5hY3RpdmUgPSBudWxsO1xuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJibHVyXCIsIGV2ZW50LCB7IGl0ZW06IHRoaXMuYWN0aXZlIH0gKTtcblx0fSxcblxuXHRfc3RhcnRPcGVuaW5nOiBmdW5jdGlvbiggc3VibWVudSApIHtcblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblxuXHRcdC8vIERvbid0IG9wZW4gaWYgYWxyZWFkeSBvcGVuIGZpeGVzIGEgRmlyZWZveCBidWcgdGhhdCBjYXVzZWQgYSAuNSBwaXhlbFxuXHRcdC8vIHNoaWZ0IGluIHRoZSBzdWJtZW51IHBvc2l0aW9uIHdoZW4gbW91c2luZyBvdmVyIHRoZSBjYXJhdCBpY29uXG5cdFx0aWYgKCBzdWJtZW51LmF0dHIoIFwiYXJpYS1oaWRkZW5cIiApICE9PSBcInRydWVcIiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdFx0dGhpcy5fb3Blbiggc3VibWVudSApO1xuXHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0fSxcblxuXHRfb3BlbjogZnVuY3Rpb24oIHN1Ym1lbnUgKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gJC5leHRlbmQoe1xuXHRcdFx0b2Y6IHRoaXMuYWN0aXZlXG5cdFx0fSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uICk7XG5cblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR0aGlzLmVsZW1lbnQuZmluZCggXCIudWktbWVudVwiICkubm90KCBzdWJtZW51LnBhcmVudHMoIFwiLnVpLW1lbnVcIiApIClcblx0XHRcdC5oaWRlKClcblx0XHRcdC5hdHRyKCBcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiICk7XG5cblx0XHRzdWJtZW51XG5cdFx0XHQuc2hvdygpXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWhpZGRlblwiIClcblx0XHRcdC5hdHRyKCBcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIgKVxuXHRcdFx0LnBvc2l0aW9uKCBwb3NpdGlvbiApO1xuXHR9LFxuXG5cdGNvbGxhcHNlQWxsOiBmdW5jdGlvbiggZXZlbnQsIGFsbCApIHtcblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBJZiB3ZSB3ZXJlIHBhc3NlZCBhbiBldmVudCwgbG9vayBmb3IgdGhlIHN1Ym1lbnUgdGhhdCBjb250YWlucyB0aGUgZXZlbnRcblx0XHRcdHZhciBjdXJyZW50TWVudSA9IGFsbCA/IHRoaXMuZWxlbWVudCA6XG5cdFx0XHRcdCQoIGV2ZW50ICYmIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51XCIgKSApO1xuXG5cdFx0XHQvLyBJZiB3ZSBmb3VuZCBubyB2YWxpZCBzdWJtZW51IGFuY2VzdG9yLCB1c2UgdGhlIG1haW4gbWVudSB0byBjbG9zZSBhbGwgc3ViIG1lbnVzIGFueXdheVxuXHRcdFx0aWYgKCAhY3VycmVudE1lbnUubGVuZ3RoICkge1xuXHRcdFx0XHRjdXJyZW50TWVudSA9IHRoaXMuZWxlbWVudDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY2xvc2UoIGN1cnJlbnRNZW51ICk7XG5cblx0XHRcdHRoaXMuYmx1ciggZXZlbnQgKTtcblx0XHRcdHRoaXMuYWN0aXZlTWVudSA9IGN1cnJlbnRNZW51O1xuXHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0fSxcblxuXHQvLyBXaXRoIG5vIGFyZ3VtZW50cywgY2xvc2VzIHRoZSBjdXJyZW50bHkgYWN0aXZlIG1lbnUgLSBpZiBub3RoaW5nIGlzIGFjdGl2ZVxuXHQvLyBpdCBjbG9zZXMgYWxsIG1lbnVzLiAgSWYgcGFzc2VkIGFuIGFyZ3VtZW50LCBpdCB3aWxsIHNlYXJjaCBmb3IgbWVudXMgQkVMT1dcblx0X2Nsb3NlOiBmdW5jdGlvbiggc3RhcnRNZW51ICkge1xuXHRcdGlmICggIXN0YXJ0TWVudSApIHtcblx0XHRcdHN0YXJ0TWVudSA9IHRoaXMuYWN0aXZlID8gdGhpcy5hY3RpdmUucGFyZW50KCkgOiB0aGlzLmVsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0c3RhcnRNZW51XG5cdFx0XHQuZmluZCggXCIudWktbWVudVwiIClcblx0XHRcdFx0LmhpZGUoKVxuXHRcdFx0XHQuYXR0ciggXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIiApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiIClcblx0XHRcdC5lbmQoKVxuXHRcdFx0LmZpbmQoIFwiYS51aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHR9LFxuXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG5ld0l0ZW0gPSB0aGlzLmFjdGl2ZSAmJlxuXHRcdFx0dGhpcy5hY3RpdmUucGFyZW50KCkuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIsIHRoaXMuZWxlbWVudCApO1xuXHRcdGlmICggbmV3SXRlbSAmJiBuZXdJdGVtLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuX2Nsb3NlKCk7XG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgbmV3SXRlbSApO1xuXHRcdH1cblx0fSxcblxuXHRleHBhbmQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgbmV3SXRlbSA9IHRoaXMuYWN0aXZlICYmXG5cdFx0XHR0aGlzLmFjdGl2ZVxuXHRcdFx0XHQuY2hpbGRyZW4oIFwiLnVpLW1lbnUgXCIgKVxuXHRcdFx0XHQuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdFx0LmZpcnN0KCk7XG5cblx0XHRpZiAoIG5ld0l0ZW0gJiYgbmV3SXRlbS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9vcGVuKCBuZXdJdGVtLnBhcmVudCgpICk7XG5cblx0XHRcdC8vIERlbGF5IHNvIEZpcmVmb3ggd2lsbCBub3QgaGlkZSBhY3RpdmVkZXNjZW5kYW50IGNoYW5nZSBpbiBleHBhbmRpbmcgc3VibWVudSBmcm9tIEFUXG5cdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIG5ld0l0ZW0gKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRuZXh0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5fbW92ZSggXCJuZXh0XCIsIFwiZmlyc3RcIiwgZXZlbnQgKTtcblx0fSxcblxuXHRwcmV2aW91czogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHRoaXMuX21vdmUoIFwicHJldlwiLCBcImxhc3RcIiwgZXZlbnQgKTtcblx0fSxcblxuXHRpc0ZpcnN0SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5wcmV2QWxsKCBcIi51aS1tZW51LWl0ZW1cIiApLmxlbmd0aDtcblx0fSxcblxuXHRpc0xhc3RJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLm5leHRBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkubGVuZ3RoO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiggZGlyZWN0aW9uLCBmaWx0ZXIsIGV2ZW50ICkge1xuXHRcdHZhciBuZXh0O1xuXHRcdGlmICggdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHRpZiAoIGRpcmVjdGlvbiA9PT0gXCJmaXJzdFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsYXN0XCIgKSB7XG5cdFx0XHRcdG5leHQgPSB0aGlzLmFjdGl2ZVxuXHRcdFx0XHRcdFsgZGlyZWN0aW9uID09PSBcImZpcnN0XCIgPyBcInByZXZBbGxcIiA6IFwibmV4dEFsbFwiIF0oIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdFx0XHQuZXEoIC0xICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXh0ID0gdGhpcy5hY3RpdmVcblx0XHRcdFx0XHRbIGRpcmVjdGlvbiArIFwiQWxsXCIgXSggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0XHRcdC5lcSggMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoICFuZXh0IHx8ICFuZXh0Lmxlbmd0aCB8fCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHRuZXh0ID0gdGhpcy5hY3RpdmVNZW51LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApWyBmaWx0ZXIgXSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZm9jdXMoIGV2ZW50LCBuZXh0ICk7XG5cdH0sXG5cblx0bmV4dFBhZ2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgaXRlbSwgYmFzZSwgaGVpZ2h0O1xuXG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHR0aGlzLm5leHQoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5pc0xhc3RJdGVtKCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5faGFzU2Nyb2xsKCkgKSB7XG5cdFx0XHRiYXNlID0gdGhpcy5hY3RpdmUub2Zmc2V0KCkudG9wO1xuXHRcdFx0aGVpZ2h0ID0gdGhpcy5lbGVtZW50LmhlaWdodCgpO1xuXHRcdFx0dGhpcy5hY3RpdmUubmV4dEFsbCggXCIudWktbWVudS1pdGVtXCIgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpdGVtID0gJCggdGhpcyApO1xuXHRcdFx0XHRyZXR1cm4gaXRlbS5vZmZzZXQoKS50b3AgLSBiYXNlIC0gaGVpZ2h0IDwgMDtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgaXRlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgdGhpcy5hY3RpdmVNZW51LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApXG5cdFx0XHRcdFsgIXRoaXMuYWN0aXZlID8gXCJmaXJzdFwiIDogXCJsYXN0XCIgXSgpICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZXZpb3VzUGFnZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBpdGVtLCBiYXNlLCBoZWlnaHQ7XG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHR0aGlzLm5leHQoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5pc0ZpcnN0SXRlbSgpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbCgpICkge1xuXHRcdFx0YmFzZSA9IHRoaXMuYWN0aXZlLm9mZnNldCgpLnRvcDtcblx0XHRcdGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcblx0XHRcdHRoaXMuYWN0aXZlLnByZXZBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aXRlbSA9ICQoIHRoaXMgKTtcblx0XHRcdFx0cmV0dXJuIGl0ZW0ub2Zmc2V0KCkudG9wIC0gYmFzZSArIGhlaWdodCA+IDA7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIGl0ZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIHRoaXMuYWN0aXZlTWVudS5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtXCIgKS5maXJzdCgpICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYXNTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSA8IHRoaXMuZWxlbWVudC5wcm9wKCBcInNjcm9sbEhlaWdodFwiICk7XG5cdH0sXG5cblx0c2VsZWN0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0Ly8gVE9ETzogSXQgc2hvdWxkIG5ldmVyIGJlIHBvc3NpYmxlIHRvIG5vdCBoYXZlIGFuIGFjdGl2ZSBpdGVtIGF0IHRoaXNcblx0XHQvLyBwb2ludCwgYnV0IHRoZSB0ZXN0cyBkb24ndCB0cmlnZ2VyIG1vdXNlZW50ZXIgYmVmb3JlIGNsaWNrLlxuXHRcdHRoaXMuYWN0aXZlID0gdGhpcy5hY3RpdmUgfHwgJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIgKTtcblx0XHR2YXIgdWkgPSB7IGl0ZW06IHRoaXMuYWN0aXZlIH07XG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUuaGFzKCBcIi51aS1tZW51XCIgKS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmNvbGxhcHNlQWxsKCBldmVudCwgdHJ1ZSApO1xuXHRcdH1cblx0XHR0aGlzLl90cmlnZ2VyKCBcInNlbGVjdFwiLCBldmVudCwgdWkgKTtcblx0fVxufSk7XG5cbn0oIGpRdWVyeSApKTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJy4vd2lkZ2V0Jyk7XG5cbi8qIVxuICogalF1ZXJ5IFVJIE1vdXNlIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9tb3VzZS9cbiAqXG4gKiBEZXBlbmRzOlxuICpcdGpxdWVyeS51aS53aWRnZXQuanNcbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciBtb3VzZUhhbmRsZWQgPSBmYWxzZTtcbiQoIGRvY3VtZW50ICkubW91c2V1cCggZnVuY3Rpb24oKSB7XG5cdG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xufSk7XG5cbiQud2lkZ2V0KFwidWkubW91c2VcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuNFwiLFxuXHRvcHRpb25zOiB7XG5cdFx0Y2FuY2VsOiBcImlucHV0LHRleHRhcmVhLGJ1dHRvbixzZWxlY3Qsb3B0aW9uXCIsXG5cdFx0ZGlzdGFuY2U6IDEsXG5cdFx0ZGVsYXk6IDBcblx0fSxcblx0X21vdXNlSW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQuYmluZChcIm1vdXNlZG93bi5cIit0aGlzLndpZGdldE5hbWUsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZURvd24oZXZlbnQpO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKFwiY2xpY2suXCIrdGhpcy53aWRnZXROYW1lLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRpZiAodHJ1ZSA9PT0gJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIikpIHtcblx0XHRcdFx0XHQkLnJlbW92ZURhdGEoZXZlbnQudGFyZ2V0LCB0aGF0LndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKTtcblx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0dGhpcy5zdGFydGVkID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gVE9ETzogbWFrZSBzdXJlIGRlc3Ryb3lpbmcgb25lIGluc3RhbmNlIG9mIG1vdXNlIGRvZXNuJ3QgbWVzcyB3aXRoXG5cdC8vIG90aGVyIGluc3RhbmNlcyBvZiBtb3VzZVxuXHRfbW91c2VEZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQudW5iaW5kKFwiLlwiK3RoaXMud2lkZ2V0TmFtZSk7XG5cdFx0aWYgKCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSApIHtcblx0XHRcdCQoZG9jdW1lbnQpXG5cdFx0XHRcdC51bmJpbmQoXCJtb3VzZW1vdmUuXCIrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSlcblx0XHRcdFx0LnVuYmluZChcIm1vdXNldXAuXCIrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfbW91c2VEb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vIGRvbid0IGxldCBtb3JlIHRoYW4gb25lIHdpZGdldCBoYW5kbGUgbW91c2VTdGFydFxuXHRcdGlmKCBtb3VzZUhhbmRsZWQgKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gd2UgbWF5IGhhdmUgbWlzc2VkIG1vdXNldXAgKG91dCBvZiB3aW5kb3cpXG5cdFx0KHRoaXMuX21vdXNlU3RhcnRlZCAmJiB0aGlzLl9tb3VzZVVwKGV2ZW50KSk7XG5cblx0XHR0aGlzLl9tb3VzZURvd25FdmVudCA9IGV2ZW50O1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0YnRuSXNMZWZ0ID0gKGV2ZW50LndoaWNoID09PSAxKSxcblx0XHRcdC8vIGV2ZW50LnRhcmdldC5ub2RlTmFtZSB3b3JrcyBhcm91bmQgYSBidWcgaW4gSUUgOCB3aXRoXG5cdFx0XHQvLyBkaXNhYmxlZCBpbnB1dHMgKCM3NjIwKVxuXHRcdFx0ZWxJc0NhbmNlbCA9ICh0eXBlb2YgdGhpcy5vcHRpb25zLmNhbmNlbCA9PT0gXCJzdHJpbmdcIiAmJiBldmVudC50YXJnZXQubm9kZU5hbWUgPyAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdCh0aGlzLm9wdGlvbnMuY2FuY2VsKS5sZW5ndGggOiBmYWxzZSk7XG5cdFx0aWYgKCFidG5Jc0xlZnQgfHwgZWxJc0NhbmNlbCB8fCAhdGhpcy5fbW91c2VDYXB0dXJlKGV2ZW50KSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb3VzZURlbGF5TWV0ID0gIXRoaXMub3B0aW9ucy5kZWxheTtcblx0XHRpZiAoIXRoaXMubW91c2VEZWxheU1ldCkge1xuXHRcdFx0dGhpcy5fbW91c2VEZWxheVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5tb3VzZURlbGF5TWV0ID0gdHJ1ZTtcblx0XHRcdH0sIHRoaXMub3B0aW9ucy5kZWxheSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoZXZlbnQpICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPSAodGhpcy5fbW91c2VTdGFydChldmVudCkgIT09IGZhbHNlKTtcblx0XHRcdGlmICghdGhpcy5fbW91c2VTdGFydGVkKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENsaWNrIGV2ZW50IG1heSBuZXZlciBoYXZlIGZpcmVkIChHZWNrbyAmIE9wZXJhKVxuXHRcdGlmICh0cnVlID09PSAkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKSkge1xuXHRcdFx0JC5yZW1vdmVEYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIik7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlc2UgZGVsZWdhdGVzIGFyZSByZXF1aXJlZCB0byBrZWVwIGNvbnRleHRcblx0XHR0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gdGhhdC5fbW91c2VNb3ZlKGV2ZW50KTtcblx0XHR9O1xuXHRcdHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gdGhhdC5fbW91c2VVcChldmVudCk7XG5cdFx0fTtcblx0XHQkKGRvY3VtZW50KVxuXHRcdFx0LmJpbmQoXCJtb3VzZW1vdmUuXCIrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSlcblx0XHRcdC5iaW5kKFwibW91c2V1cC5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0bW91c2VIYW5kbGVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VNb3ZlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vIElFIG1vdXNldXAgY2hlY2sgLSBtb3VzZXVwIGhhcHBlbmVkIHdoZW4gbW91c2Ugd2FzIG91dCBvZiB3aW5kb3dcblx0XHRpZiAoJC51aS5pZSAmJiAoICFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgOSApICYmICFldmVudC5idXR0b24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9tb3VzZVVwKGV2ZW50KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VTdGFydGVkKSB7XG5cdFx0XHR0aGlzLl9tb3VzZURyYWcoZXZlbnQpO1xuXHRcdFx0cmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoZXZlbnQpICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPVxuXHRcdFx0XHQodGhpcy5fbW91c2VTdGFydCh0aGlzLl9tb3VzZURvd25FdmVudCwgZXZlbnQpICE9PSBmYWxzZSk7XG5cdFx0XHQodGhpcy5fbW91c2VTdGFydGVkID8gdGhpcy5fbW91c2VEcmFnKGV2ZW50KSA6IHRoaXMuX21vdXNlVXAoZXZlbnQpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gIXRoaXMuX21vdXNlU3RhcnRlZDtcblx0fSxcblxuXHRfbW91c2VVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQkKGRvY3VtZW50KVxuXHRcdFx0LnVuYmluZChcIm1vdXNlbW92ZS5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0LnVuYmluZChcIm1vdXNldXAuXCIrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUpO1xuXG5cdFx0aWYgKHRoaXMuX21vdXNlU3RhcnRlZCkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID0gZmFsc2U7XG5cblx0XHRcdGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuX21vdXNlRG93bkV2ZW50LnRhcmdldCkge1xuXHRcdFx0XHQkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbW91c2VTdG9wKGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlRGlzdGFuY2VNZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIChNYXRoLm1heChcblx0XHRcdFx0TWF0aC5hYnModGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVggLSBldmVudC5wYWdlWCksXG5cdFx0XHRcdE1hdGguYWJzKHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VZIC0gZXZlbnQucGFnZVkpXG5cdFx0XHQpID49IHRoaXMub3B0aW9ucy5kaXN0YW5jZVxuXHRcdCk7XG5cdH0sXG5cblx0X21vdXNlRGVsYXlNZXQ6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VEZWxheU1ldDtcblx0fSxcblxuXHQvLyBUaGVzZSBhcmUgcGxhY2Vob2xkZXIgbWV0aG9kcywgdG8gYmUgb3ZlcnJpZGVuIGJ5IGV4dGVuZGluZyBwbHVnaW5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7fSxcblx0X21vdXNlRHJhZzogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHt9LFxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbigvKiBldmVudCAqLykge30sXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7IHJldHVybiB0cnVlOyB9XG59KTtcblxufSkoalF1ZXJ5KTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgUG9zaXRpb24gMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC51aSA9ICQudWkgfHwge307XG5cbnZhciBjYWNoZWRTY3JvbGxiYXJXaWR0aCxcblx0bWF4ID0gTWF0aC5tYXgsXG5cdGFicyA9IE1hdGguYWJzLFxuXHRyb3VuZCA9IE1hdGgucm91bmQsXG5cdHJob3Jpem9udGFsID0gL2xlZnR8Y2VudGVyfHJpZ2h0Lyxcblx0cnZlcnRpY2FsID0gL3RvcHxjZW50ZXJ8Ym90dG9tLyxcblx0cm9mZnNldCA9IC9bXFwrXFwtXVxcZCsoXFwuW1xcZF0rKT8lPy8sXG5cdHJwb3NpdGlvbiA9IC9eXFx3Ky8sXG5cdHJwZXJjZW50ID0gLyUkLyxcblx0X3Bvc2l0aW9uID0gJC5mbi5wb3NpdGlvbjtcblxuZnVuY3Rpb24gZ2V0T2Zmc2V0cyggb2Zmc2V0cywgd2lkdGgsIGhlaWdodCApIHtcblx0cmV0dXJuIFtcblx0XHRwYXJzZUZsb2F0KCBvZmZzZXRzWyAwIF0gKSAqICggcnBlcmNlbnQudGVzdCggb2Zmc2V0c1sgMCBdICkgPyB3aWR0aCAvIDEwMCA6IDEgKSxcblx0XHRwYXJzZUZsb2F0KCBvZmZzZXRzWyAxIF0gKSAqICggcnBlcmNlbnQudGVzdCggb2Zmc2V0c1sgMSBdICkgPyBoZWlnaHQgLyAxMDAgOiAxIClcblx0XTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDc3MoIGVsZW1lbnQsIHByb3BlcnR5ICkge1xuXHRyZXR1cm4gcGFyc2VJbnQoICQuY3NzKCBlbGVtZW50LCBwcm9wZXJ0eSApLCAxMCApIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoIGVsZW0gKSB7XG5cdHZhciByYXcgPSBlbGVtWzBdO1xuXHRpZiAoIHJhdy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGVsZW0ud2lkdGgoKSxcblx0XHRcdGhlaWdodDogZWxlbS5oZWlnaHQoKSxcblx0XHRcdG9mZnNldDogeyB0b3A6IDAsIGxlZnQ6IDAgfVxuXHRcdH07XG5cdH1cblx0aWYgKCAkLmlzV2luZG93KCByYXcgKSApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGVsZW0ud2lkdGgoKSxcblx0XHRcdGhlaWdodDogZWxlbS5oZWlnaHQoKSxcblx0XHRcdG9mZnNldDogeyB0b3A6IGVsZW0uc2Nyb2xsVG9wKCksIGxlZnQ6IGVsZW0uc2Nyb2xsTGVmdCgpIH1cblx0XHR9O1xuXHR9XG5cdGlmICggcmF3LnByZXZlbnREZWZhdWx0ICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMCxcblx0XHRcdG9mZnNldDogeyB0b3A6IHJhdy5wYWdlWSwgbGVmdDogcmF3LnBhZ2VYIH1cblx0XHR9O1xuXHR9XG5cdHJldHVybiB7XG5cdFx0d2lkdGg6IGVsZW0ub3V0ZXJXaWR0aCgpLFxuXHRcdGhlaWdodDogZWxlbS5vdXRlckhlaWdodCgpLFxuXHRcdG9mZnNldDogZWxlbS5vZmZzZXQoKVxuXHR9O1xufVxuXG4kLnBvc2l0aW9uID0ge1xuXHRzY3JvbGxiYXJXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBjYWNoZWRTY3JvbGxiYXJXaWR0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGNhY2hlZFNjcm9sbGJhcldpZHRoO1xuXHRcdH1cblx0XHR2YXIgdzEsIHcyLFxuXHRcdFx0ZGl2ID0gJCggXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7b3ZlcmZsb3c6aGlkZGVuOyc+PGRpdiBzdHlsZT0naGVpZ2h0OjEwMHB4O3dpZHRoOmF1dG87Jz48L2Rpdj48L2Rpdj5cIiApLFxuXHRcdFx0aW5uZXJEaXYgPSBkaXYuY2hpbGRyZW4oKVswXTtcblxuXHRcdCQoIFwiYm9keVwiICkuYXBwZW5kKCBkaXYgKTtcblx0XHR3MSA9IGlubmVyRGl2Lm9mZnNldFdpZHRoO1xuXHRcdGRpdi5jc3MoIFwib3ZlcmZsb3dcIiwgXCJzY3JvbGxcIiApO1xuXG5cdFx0dzIgPSBpbm5lckRpdi5vZmZzZXRXaWR0aDtcblxuXHRcdGlmICggdzEgPT09IHcyICkge1xuXHRcdFx0dzIgPSBkaXZbMF0uY2xpZW50V2lkdGg7XG5cdFx0fVxuXG5cdFx0ZGl2LnJlbW92ZSgpO1xuXG5cdFx0cmV0dXJuIChjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IHcxIC0gdzIpO1xuXHR9LFxuXHRnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbiggd2l0aGluICkge1xuXHRcdHZhciBvdmVyZmxvd1ggPSB3aXRoaW4uaXNXaW5kb3cgfHwgd2l0aGluLmlzRG9jdW1lbnQgPyBcIlwiIDpcblx0XHRcdFx0d2l0aGluLmVsZW1lbnQuY3NzKCBcIm92ZXJmbG93LXhcIiApLFxuXHRcdFx0b3ZlcmZsb3dZID0gd2l0aGluLmlzV2luZG93IHx8IHdpdGhpbi5pc0RvY3VtZW50ID8gXCJcIiA6XG5cdFx0XHRcdHdpdGhpbi5lbGVtZW50LmNzcyggXCJvdmVyZmxvdy15XCIgKSxcblx0XHRcdGhhc092ZXJmbG93WCA9IG92ZXJmbG93WCA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdFx0XHQoIG92ZXJmbG93WCA9PT0gXCJhdXRvXCIgJiYgd2l0aGluLndpZHRoIDwgd2l0aGluLmVsZW1lbnRbMF0uc2Nyb2xsV2lkdGggKSxcblx0XHRcdGhhc092ZXJmbG93WSA9IG92ZXJmbG93WSA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdFx0XHQoIG92ZXJmbG93WSA9PT0gXCJhdXRvXCIgJiYgd2l0aGluLmhlaWdodCA8IHdpdGhpbi5lbGVtZW50WzBdLnNjcm9sbEhlaWdodCApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogaGFzT3ZlcmZsb3dZID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMCxcblx0XHRcdGhlaWdodDogaGFzT3ZlcmZsb3dYID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMFxuXHRcdH07XG5cdH0sXG5cdGdldFdpdGhpbkluZm86IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciB3aXRoaW5FbGVtZW50ID0gJCggZWxlbWVudCB8fCB3aW5kb3cgKSxcblx0XHRcdGlzV2luZG93ID0gJC5pc1dpbmRvdyggd2l0aGluRWxlbWVudFswXSApLFxuXHRcdFx0aXNEb2N1bWVudCA9ICEhd2l0aGluRWxlbWVudFsgMCBdICYmIHdpdGhpbkVsZW1lbnRbIDAgXS5ub2RlVHlwZSA9PT0gOTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogd2l0aGluRWxlbWVudCxcblx0XHRcdGlzV2luZG93OiBpc1dpbmRvdyxcblx0XHRcdGlzRG9jdW1lbnQ6IGlzRG9jdW1lbnQsXG5cdFx0XHRvZmZzZXQ6IHdpdGhpbkVsZW1lbnQub2Zmc2V0KCkgfHwgeyBsZWZ0OiAwLCB0b3A6IDAgfSxcblx0XHRcdHNjcm9sbExlZnQ6IHdpdGhpbkVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0c2Nyb2xsVG9wOiB3aXRoaW5FbGVtZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0d2lkdGg6IGlzV2luZG93ID8gd2l0aGluRWxlbWVudC53aWR0aCgpIDogd2l0aGluRWxlbWVudC5vdXRlcldpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGlzV2luZG93ID8gd2l0aGluRWxlbWVudC5oZWlnaHQoKSA6IHdpdGhpbkVsZW1lbnQub3V0ZXJIZWlnaHQoKVxuXHRcdH07XG5cdH1cbn07XG5cbiQuZm4ucG9zaXRpb24gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0aWYgKCAhb3B0aW9ucyB8fCAhb3B0aW9ucy5vZiApIHtcblx0XHRyZXR1cm4gX3Bvc2l0aW9uLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdC8vIG1ha2UgYSBjb3B5LCB3ZSBkb24ndCB3YW50IHRvIG1vZGlmeSBhcmd1bWVudHNcblx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciBhdE9mZnNldCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgdGFyZ2V0T2Zmc2V0LCBiYXNlUG9zaXRpb24sIGRpbWVuc2lvbnMsXG5cdFx0dGFyZ2V0ID0gJCggb3B0aW9ucy5vZiApLFxuXHRcdHdpdGhpbiA9ICQucG9zaXRpb24uZ2V0V2l0aGluSW5mbyggb3B0aW9ucy53aXRoaW4gKSxcblx0XHRzY3JvbGxJbmZvID0gJC5wb3NpdGlvbi5nZXRTY3JvbGxJbmZvKCB3aXRoaW4gKSxcblx0XHRjb2xsaXNpb24gPSAoIG9wdGlvbnMuY29sbGlzaW9uIHx8IFwiZmxpcFwiICkuc3BsaXQoIFwiIFwiICksXG5cdFx0b2Zmc2V0cyA9IHt9O1xuXG5cdGRpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKCB0YXJnZXQgKTtcblx0aWYgKCB0YXJnZXRbMF0ucHJldmVudERlZmF1bHQgKSB7XG5cdFx0Ly8gZm9yY2UgbGVmdCB0b3AgdG8gYWxsb3cgZmxpcHBpbmdcblx0XHRvcHRpb25zLmF0ID0gXCJsZWZ0IHRvcFwiO1xuXHR9XG5cdHRhcmdldFdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcblx0dGFyZ2V0SGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG5cdHRhcmdldE9mZnNldCA9IGRpbWVuc2lvbnMub2Zmc2V0O1xuXHQvLyBjbG9uZSB0byByZXVzZSBvcmlnaW5hbCB0YXJnZXRPZmZzZXQgbGF0ZXJcblx0YmFzZVBvc2l0aW9uID0gJC5leHRlbmQoIHt9LCB0YXJnZXRPZmZzZXQgKTtcblxuXHQvLyBmb3JjZSBteSBhbmQgYXQgdG8gaGF2ZSB2YWxpZCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbnNcblx0Ly8gaWYgYSB2YWx1ZSBpcyBtaXNzaW5nIG9yIGludmFsaWQsIGl0IHdpbGwgYmUgY29udmVydGVkIHRvIGNlbnRlclxuXHQkLmVhY2goIFsgXCJteVwiLCBcImF0XCIgXSwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvcyA9ICggb3B0aW9uc1sgdGhpcyBdIHx8IFwiXCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRcdGhvcml6b250YWxPZmZzZXQsXG5cdFx0XHR2ZXJ0aWNhbE9mZnNldDtcblxuXHRcdGlmICggcG9zLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0cG9zID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdHBvcy5jb25jYXQoIFsgXCJjZW50ZXJcIiBdICkgOlxuXHRcdFx0XHRydmVydGljYWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiIF0uY29uY2F0KCBwb3MgKSA6XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiLCBcImNlbnRlclwiIF07XG5cdFx0fVxuXHRcdHBvc1sgMCBdID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/IHBvc1sgMCBdIDogXCJjZW50ZXJcIjtcblx0XHRwb3NbIDEgXSA9IHJ2ZXJ0aWNhbC50ZXN0KCBwb3NbIDEgXSApID8gcG9zWyAxIF0gOiBcImNlbnRlclwiO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIG9mZnNldHNcblx0XHRob3Jpem9udGFsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDAgXSApO1xuXHRcdHZlcnRpY2FsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDEgXSApO1xuXHRcdG9mZnNldHNbIHRoaXMgXSA9IFtcblx0XHRcdGhvcml6b250YWxPZmZzZXQgPyBob3Jpem9udGFsT2Zmc2V0WyAwIF0gOiAwLFxuXHRcdFx0dmVydGljYWxPZmZzZXQgPyB2ZXJ0aWNhbE9mZnNldFsgMCBdIDogMFxuXHRcdF07XG5cblx0XHQvLyByZWR1Y2UgdG8ganVzdCB0aGUgcG9zaXRpb25zIHdpdGhvdXQgdGhlIG9mZnNldHNcblx0XHRvcHRpb25zWyB0aGlzIF0gPSBbXG5cdFx0XHRycG9zaXRpb24uZXhlYyggcG9zWyAwIF0gKVsgMCBdLFxuXHRcdFx0cnBvc2l0aW9uLmV4ZWMoIHBvc1sgMSBdIClbIDAgXVxuXHRcdF07XG5cdH0pO1xuXG5cdC8vIG5vcm1hbGl6ZSBjb2xsaXNpb24gb3B0aW9uXG5cdGlmICggY29sbGlzaW9uLmxlbmd0aCA9PT0gMSApIHtcblx0XHRjb2xsaXNpb25bIDEgXSA9IGNvbGxpc2lvblsgMCBdO1xuXHR9XG5cblx0aWYgKCBvcHRpb25zLmF0WyAwIF0gPT09IFwicmlnaHRcIiApIHtcblx0XHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aDtcblx0fSBlbHNlIGlmICggb3B0aW9ucy5hdFsgMCBdID09PSBcImNlbnRlclwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IHRhcmdldFdpZHRoIC8gMjtcblx0fVxuXG5cdGlmICggb3B0aW9ucy5hdFsgMSBdID09PSBcImJvdHRvbVwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0O1xuXHR9IGVsc2UgaWYgKCBvcHRpb25zLmF0WyAxIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLnRvcCArPSB0YXJnZXRIZWlnaHQgLyAyO1xuXHR9XG5cblx0YXRPZmZzZXQgPSBnZXRPZmZzZXRzKCBvZmZzZXRzLmF0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0ICk7XG5cdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IGF0T2Zmc2V0WyAwIF07XG5cdGJhc2VQb3NpdGlvbi50b3AgKz0gYXRPZmZzZXRbIDEgXTtcblxuXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xsaXNpb25Qb3NpdGlvbiwgdXNpbmcsXG5cdFx0XHRlbGVtID0gJCggdGhpcyApLFxuXHRcdFx0ZWxlbVdpZHRoID0gZWxlbS5vdXRlcldpZHRoKCksXG5cdFx0XHRlbGVtSGVpZ2h0ID0gZWxlbS5vdXRlckhlaWdodCgpLFxuXHRcdFx0bWFyZ2luTGVmdCA9IHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpbkxlZnRcIiApLFxuXHRcdFx0bWFyZ2luVG9wID0gcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luVG9wXCIgKSxcblx0XHRcdGNvbGxpc2lvbldpZHRoID0gZWxlbVdpZHRoICsgbWFyZ2luTGVmdCArIHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpblJpZ2h0XCIgKSArIHNjcm9sbEluZm8ud2lkdGgsXG5cdFx0XHRjb2xsaXNpb25IZWlnaHQgPSBlbGVtSGVpZ2h0ICsgbWFyZ2luVG9wICsgcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luQm90dG9tXCIgKSArIHNjcm9sbEluZm8uaGVpZ2h0LFxuXHRcdFx0cG9zaXRpb24gPSAkLmV4dGVuZCgge30sIGJhc2VQb3NpdGlvbiApLFxuXHRcdFx0bXlPZmZzZXQgPSBnZXRPZmZzZXRzKCBvZmZzZXRzLm15LCBlbGVtLm91dGVyV2lkdGgoKSwgZWxlbS5vdXRlckhlaWdodCgpICk7XG5cblx0XHRpZiAoIG9wdGlvbnMubXlbIDAgXSA9PT0gXCJyaWdodFwiICkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSBlbGVtV2lkdGg7XG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5teVsgMCBdID09PSBcImNlbnRlclwiICkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSBlbGVtV2lkdGggLyAyO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5teVsgMSBdID09PSBcImJvdHRvbVwiICkge1xuXHRcdFx0cG9zaXRpb24udG9wIC09IGVsZW1IZWlnaHQ7XG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5teVsgMSBdID09PSBcImNlbnRlclwiICkge1xuXHRcdFx0cG9zaXRpb24udG9wIC09IGVsZW1IZWlnaHQgLyAyO1xuXHRcdH1cblxuXHRcdHBvc2l0aW9uLmxlZnQgKz0gbXlPZmZzZXRbIDAgXTtcblx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXRbIDEgXTtcblxuXHRcdC8vIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBmcmFjdGlvbnMsIHRoZW4gcm91bmQgZm9yIGNvbnNpc3RlbnQgcmVzdWx0c1xuXHRcdGlmICggISQuc3VwcG9ydC5vZmZzZXRGcmFjdGlvbnMgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0ID0gcm91bmQoIHBvc2l0aW9uLmxlZnQgKTtcblx0XHRcdHBvc2l0aW9uLnRvcCA9IHJvdW5kKCBwb3NpdGlvbi50b3AgKTtcblx0XHR9XG5cblx0XHRjb2xsaXNpb25Qb3NpdGlvbiA9IHtcblx0XHRcdG1hcmdpbkxlZnQ6IG1hcmdpbkxlZnQsXG5cdFx0XHRtYXJnaW5Ub3A6IG1hcmdpblRvcFxuXHRcdH07XG5cblx0XHQkLmVhY2goIFsgXCJsZWZ0XCIsIFwidG9wXCIgXSwgZnVuY3Rpb24oIGksIGRpciApIHtcblx0XHRcdGlmICggJC51aS5wb3NpdGlvblsgY29sbGlzaW9uWyBpIF0gXSApIHtcblx0XHRcdFx0JC51aS5wb3NpdGlvblsgY29sbGlzaW9uWyBpIF0gXVsgZGlyIF0oIHBvc2l0aW9uLCB7XG5cdFx0XHRcdFx0dGFyZ2V0V2lkdGg6IHRhcmdldFdpZHRoLFxuXHRcdFx0XHRcdHRhcmdldEhlaWdodDogdGFyZ2V0SGVpZ2h0LFxuXHRcdFx0XHRcdGVsZW1XaWR0aDogZWxlbVdpZHRoLFxuXHRcdFx0XHRcdGVsZW1IZWlnaHQ6IGVsZW1IZWlnaHQsXG5cdFx0XHRcdFx0Y29sbGlzaW9uUG9zaXRpb246IGNvbGxpc2lvblBvc2l0aW9uLFxuXHRcdFx0XHRcdGNvbGxpc2lvbldpZHRoOiBjb2xsaXNpb25XaWR0aCxcblx0XHRcdFx0XHRjb2xsaXNpb25IZWlnaHQ6IGNvbGxpc2lvbkhlaWdodCxcblx0XHRcdFx0XHRvZmZzZXQ6IFsgYXRPZmZzZXRbIDAgXSArIG15T2Zmc2V0WyAwIF0sIGF0T2Zmc2V0IFsgMSBdICsgbXlPZmZzZXRbIDEgXSBdLFxuXHRcdFx0XHRcdG15OiBvcHRpb25zLm15LFxuXHRcdFx0XHRcdGF0OiBvcHRpb25zLmF0LFxuXHRcdFx0XHRcdHdpdGhpbjogd2l0aGluLFxuXHRcdFx0XHRcdGVsZW0gOiBlbGVtXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCBvcHRpb25zLnVzaW5nICkge1xuXHRcdFx0Ly8gYWRkcyBmZWVkYmFjayBhcyBzZWNvbmQgYXJndW1lbnQgdG8gdXNpbmcgY2FsbGJhY2ssIGlmIHByZXNlbnRcblx0XHRcdHVzaW5nID0gZnVuY3Rpb24oIHByb3BzICkge1xuXHRcdFx0XHR2YXIgbGVmdCA9IHRhcmdldE9mZnNldC5sZWZ0IC0gcG9zaXRpb24ubGVmdCxcblx0XHRcdFx0XHRyaWdodCA9IGxlZnQgKyB0YXJnZXRXaWR0aCAtIGVsZW1XaWR0aCxcblx0XHRcdFx0XHR0b3AgPSB0YXJnZXRPZmZzZXQudG9wIC0gcG9zaXRpb24udG9wLFxuXHRcdFx0XHRcdGJvdHRvbSA9IHRvcCArIHRhcmdldEhlaWdodCAtIGVsZW1IZWlnaHQsXG5cdFx0XHRcdFx0ZmVlZGJhY2sgPSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogdGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiB0YXJnZXRPZmZzZXQubGVmdCxcblx0XHRcdFx0XHRcdFx0dG9wOiB0YXJnZXRPZmZzZXQudG9wLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogdGFyZ2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogdGFyZ2V0SGVpZ2h0XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZWxlbWVudDoge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50OiBlbGVtLFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiBwb3NpdGlvbi5sZWZ0LFxuXHRcdFx0XHRcdFx0XHR0b3A6IHBvc2l0aW9uLnRvcCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IGVsZW1XaWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBlbGVtSGVpZ2h0XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0aG9yaXpvbnRhbDogcmlnaHQgPCAwID8gXCJsZWZ0XCIgOiBsZWZ0ID4gMCA/IFwicmlnaHRcIiA6IFwiY2VudGVyXCIsXG5cdFx0XHRcdFx0XHR2ZXJ0aWNhbDogYm90dG9tIDwgMCA/IFwidG9wXCIgOiB0b3AgPiAwID8gXCJib3R0b21cIiA6IFwibWlkZGxlXCJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIHRhcmdldFdpZHRoIDwgZWxlbVdpZHRoICYmIGFicyggbGVmdCArIHJpZ2h0ICkgPCB0YXJnZXRXaWR0aCApIHtcblx0XHRcdFx0XHRmZWVkYmFjay5ob3Jpem9udGFsID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRhcmdldEhlaWdodCA8IGVsZW1IZWlnaHQgJiYgYWJzKCB0b3AgKyBib3R0b20gKSA8IHRhcmdldEhlaWdodCApIHtcblx0XHRcdFx0XHRmZWVkYmFjay52ZXJ0aWNhbCA9IFwibWlkZGxlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXgoIGFicyggbGVmdCApLCBhYnMoIHJpZ2h0ICkgKSA+IG1heCggYWJzKCB0b3AgKSwgYWJzKCBib3R0b20gKSApICkge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmltcG9ydGFudCA9IFwiaG9yaXpvbnRhbFwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmltcG9ydGFudCA9IFwidmVydGljYWxcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIHRoaXMsIHByb3BzLCBmZWVkYmFjayApO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRlbGVtLm9mZnNldCggJC5leHRlbmQoIHBvc2l0aW9uLCB7IHVzaW5nOiB1c2luZyB9ICkgKTtcblx0fSk7XG59O1xuXG4kLnVpLnBvc2l0aW9uID0ge1xuXHRmaXQ6IHtcblx0XHRsZWZ0OiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxMZWZ0IDogd2l0aGluLm9mZnNldC5sZWZ0LFxuXHRcdFx0XHRvdXRlcldpZHRoID0gd2l0aGluLndpZHRoLFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCxcblx0XHRcdFx0b3ZlckxlZnQgPSB3aXRoaW5PZmZzZXQgLSBjb2xsaXNpb25Qb3NMZWZ0LFxuXHRcdFx0XHRvdmVyUmlnaHQgPSBjb2xsaXNpb25Qb3NMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQsXG5cdFx0XHRcdG5ld092ZXJSaWdodDtcblxuXHRcdFx0Ly8gZWxlbWVudCBpcyB3aWRlciB0aGFuIHdpdGhpblxuXHRcdFx0aWYgKCBkYXRhLmNvbGxpc2lvbldpZHRoID4gb3V0ZXJXaWR0aCApIHtcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciB0aGUgbGVmdCBzaWRlIG9mIHdpdGhpblxuXHRcdFx0XHRpZiAoIG92ZXJMZWZ0ID4gMCAmJiBvdmVyUmlnaHQgPD0gMCApIHtcblx0XHRcdFx0XHRuZXdPdmVyUmlnaHQgPSBwb3NpdGlvbi5sZWZ0ICsgb3ZlckxlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG92ZXJMZWZ0IC0gbmV3T3ZlclJpZ2h0O1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHJpZ2h0IHNpZGUgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgJiYgb3ZlckxlZnQgPD0gMCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggbGVmdCBhbmQgcmlnaHQgc2lkZXMgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyTGVmdCA+IG92ZXJSaWdodCApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQgKyBvdXRlcldpZHRoIC0gZGF0YS5jb2xsaXNpb25XaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdC8vIHRvbyBmYXIgbGVmdCAtPiBhbGlnbiB3aXRoIGxlZnQgZWRnZVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlckxlZnQgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG92ZXJMZWZ0O1xuXHRcdFx0Ly8gdG9vIGZhciByaWdodCAtPiBhbGlnbiB3aXRoIHJpZ2h0IGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gb3ZlclJpZ2h0O1xuXHRcdFx0Ly8gYWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSBtYXgoIHBvc2l0aW9uLmxlZnQgLSBjb2xsaXNpb25Qb3NMZWZ0LCBwb3NpdGlvbi5sZWZ0ICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxuXHRcdFx0XHRvdXRlckhlaWdodCA9IGRhdGEud2l0aGluLmhlaWdodCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG5cdFx0XHRcdG92ZXJUb3AgPSB3aXRoaW5PZmZzZXQgLSBjb2xsaXNpb25Qb3NUb3AsXG5cdFx0XHRcdG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0LFxuXHRcdFx0XHRuZXdPdmVyQm90dG9tO1xuXG5cdFx0XHQvLyBlbGVtZW50IGlzIHRhbGxlciB0aGFuIHdpdGhpblxuXHRcdFx0aWYgKCBkYXRhLmNvbGxpc2lvbkhlaWdodCA+IG91dGVySGVpZ2h0ICkge1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHRoZSB0b3Agb2Ygd2l0aGluXG5cdFx0XHRcdGlmICggb3ZlclRvcCA+IDAgJiYgb3ZlckJvdHRvbSA8PSAwICkge1xuXHRcdFx0XHRcdG5ld092ZXJCb3R0b20gPSBwb3NpdGlvbi50b3AgKyBvdmVyVG9wICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcCAtIG5ld092ZXJCb3R0b207XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90dG9tIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvdmVyQm90dG9tID4gMCAmJiBvdmVyVG9wIDw9IDAgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggdG9wIGFuZCBib3R0b20gb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyVG9wID4gb3ZlckJvdHRvbSApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldCArIG91dGVySGVpZ2h0IC0gZGF0YS5jb2xsaXNpb25IZWlnaHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdC8vIHRvbyBmYXIgdXAgLT4gYWxpZ24gd2l0aCB0b3Bcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJUb3AgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcDtcblx0XHRcdC8vIHRvbyBmYXIgZG93biAtPiBhbGlnbiB3aXRoIGJvdHRvbSBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyQm90dG9tID4gMCApIHtcblx0XHRcdFx0cG9zaXRpb24udG9wIC09IG92ZXJCb3R0b207XG5cdFx0XHQvLyBhZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb24udG9wID0gbWF4KCBwb3NpdGlvbi50b3AgLSBjb2xsaXNpb25Qb3NUb3AsIHBvc2l0aW9uLnRvcCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZmxpcDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC5sZWZ0ICsgd2l0aGluLnNjcm9sbExlZnQsXG5cdFx0XHRcdG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXG5cdFx0XHRcdG9mZnNldExlZnQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXG5cdFx0XHRcdG92ZXJMZWZ0ID0gY29sbGlzaW9uUG9zTGVmdCAtIG9mZnNldExlZnQsXG5cdFx0XHRcdG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIG9mZnNldExlZnQsXG5cdFx0XHRcdG15T2Zmc2V0ID0gZGF0YS5teVsgMCBdID09PSBcImxlZnRcIiA/XG5cdFx0XHRcdFx0LWRhdGEuZWxlbVdpZHRoIDpcblx0XHRcdFx0XHRkYXRhLm15WyAwIF0gPT09IFwicmlnaHRcIiA/XG5cdFx0XHRcdFx0XHRkYXRhLmVsZW1XaWR0aCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRhdE9mZnNldCA9IGRhdGEuYXRbIDAgXSA9PT0gXCJsZWZ0XCIgP1xuXHRcdFx0XHRcdGRhdGEudGFyZ2V0V2lkdGggOlxuXHRcdFx0XHRcdGRhdGEuYXRbIDAgXSA9PT0gXCJyaWdodFwiID9cblx0XHRcdFx0XHRcdC1kYXRhLnRhcmdldFdpZHRoIDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdG9mZnNldCA9IC0yICogZGF0YS5vZmZzZXRbIDAgXSxcblx0XHRcdFx0bmV3T3ZlclJpZ2h0LFxuXHRcdFx0XHRuZXdPdmVyTGVmdDtcblxuXHRcdFx0aWYgKCBvdmVyTGVmdCA8IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJSaWdodCA9IHBvc2l0aW9uLmxlZnQgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdGlmICggbmV3T3ZlclJpZ2h0IDwgMCB8fCBuZXdPdmVyUmlnaHQgPCBhYnMoIG92ZXJMZWZ0ICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggb3ZlclJpZ2h0ID4gMCApIHtcblx0XHRcdFx0bmV3T3ZlckxlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0ICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCAtIG9mZnNldExlZnQ7XG5cdFx0XHRcdGlmICggbmV3T3ZlckxlZnQgPiAwIHx8IGFicyggbmV3T3ZlckxlZnQgKSA8IG92ZXJSaWdodCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4ub2Zmc2V0LnRvcCArIHdpdGhpbi5zY3JvbGxUb3AsXG5cdFx0XHRcdG91dGVySGVpZ2h0ID0gd2l0aGluLmhlaWdodCxcblx0XHRcdFx0b2Zmc2V0VG9wID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCxcblx0XHRcdFx0b3ZlclRvcCA9IGNvbGxpc2lvblBvc1RvcCAtIG9mZnNldFRvcCxcblx0XHRcdFx0b3ZlckJvdHRvbSA9IGNvbGxpc2lvblBvc1RvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSBvZmZzZXRUb3AsXG5cdFx0XHRcdHRvcCA9IGRhdGEubXlbIDEgXSA9PT0gXCJ0b3BcIixcblx0XHRcdFx0bXlPZmZzZXQgPSB0b3AgP1xuXHRcdFx0XHRcdC1kYXRhLmVsZW1IZWlnaHQgOlxuXHRcdFx0XHRcdGRhdGEubXlbIDEgXSA9PT0gXCJib3R0b21cIiA/XG5cdFx0XHRcdFx0XHRkYXRhLmVsZW1IZWlnaHQgOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0YXRPZmZzZXQgPSBkYXRhLmF0WyAxIF0gPT09IFwidG9wXCIgP1xuXHRcdFx0XHRcdGRhdGEudGFyZ2V0SGVpZ2h0IDpcblx0XHRcdFx0XHRkYXRhLmF0WyAxIF0gPT09IFwiYm90dG9tXCIgP1xuXHRcdFx0XHRcdFx0LWRhdGEudGFyZ2V0SGVpZ2h0IDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdG9mZnNldCA9IC0yICogZGF0YS5vZmZzZXRbIDEgXSxcblx0XHRcdFx0bmV3T3ZlclRvcCxcblx0XHRcdFx0bmV3T3ZlckJvdHRvbTtcblx0XHRcdGlmICggb3ZlclRvcCA8IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJCb3R0b20gPSBwb3NpdGlvbi50b3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0ICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0aWYgKCAoIHBvc2l0aW9uLnRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQpID4gb3ZlclRvcCAmJiAoIG5ld092ZXJCb3R0b20gPCAwIHx8IG5ld092ZXJCb3R0b20gPCBhYnMoIG92ZXJUb3AgKSApICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRUb3A7XG5cdFx0XHRcdGlmICggKCBwb3NpdGlvbi50b3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0KSA+IG92ZXJCb3R0b20gJiYgKCBuZXdPdmVyVG9wID4gMCB8fCBhYnMoIG5ld092ZXJUb3AgKSA8IG92ZXJCb3R0b20gKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZmxpcGZpdDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC51aS5wb3NpdGlvbi5mbGlwLmxlZnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0JC51aS5wb3NpdGlvbi5maXQubGVmdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC51aS5wb3NpdGlvbi5mbGlwLnRvcC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZpdC50b3AuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fVxufTtcblxuLy8gZnJhY3Rpb24gc3VwcG9ydCB0ZXN0XG4oZnVuY3Rpb24gKCkge1xuXHR2YXIgdGVzdEVsZW1lbnQsIHRlc3RFbGVtZW50UGFyZW50LCB0ZXN0RWxlbWVudFN0eWxlLCBvZmZzZXRMZWZ0LCBpLFxuXHRcdGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJib2R5XCIgKVsgMCBdLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvL0NyZWF0ZSBhIFwiZmFrZSBib2R5XCIgZm9yIHRlc3RpbmcgYmFzZWQgb24gbWV0aG9kIHVzZWQgaW4galF1ZXJ5LnN1cHBvcnRcblx0dGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBib2R5ID8gXCJkaXZcIiA6IFwiYm9keVwiICk7XG5cdHRlc3RFbGVtZW50U3R5bGUgPSB7XG5cdFx0dmlzaWJpbGl0eTogXCJoaWRkZW5cIixcblx0XHR3aWR0aDogMCxcblx0XHRoZWlnaHQ6IDAsXG5cdFx0Ym9yZGVyOiAwLFxuXHRcdG1hcmdpbjogMCxcblx0XHRiYWNrZ3JvdW5kOiBcIm5vbmVcIlxuXHR9O1xuXHRpZiAoIGJvZHkgKSB7XG5cdFx0JC5leHRlbmQoIHRlc3RFbGVtZW50U3R5bGUsIHtcblx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG5cdFx0XHRsZWZ0OiBcIi0xMDAwcHhcIixcblx0XHRcdHRvcDogXCItMTAwMHB4XCJcblx0XHR9KTtcblx0fVxuXHRmb3IgKCBpIGluIHRlc3RFbGVtZW50U3R5bGUgKSB7XG5cdFx0dGVzdEVsZW1lbnQuc3R5bGVbIGkgXSA9IHRlc3RFbGVtZW50U3R5bGVbIGkgXTtcblx0fVxuXHR0ZXN0RWxlbWVudC5hcHBlbmRDaGlsZCggZGl2ICk7XG5cdHRlc3RFbGVtZW50UGFyZW50ID0gYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdHRlc3RFbGVtZW50UGFyZW50Lmluc2VydEJlZm9yZSggdGVzdEVsZW1lbnQsIHRlc3RFbGVtZW50UGFyZW50LmZpcnN0Q2hpbGQgKTtcblxuXHRkaXYuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAxMC43NDMyMjIycHg7XCI7XG5cblx0b2Zmc2V0TGVmdCA9ICQoIGRpdiApLm9mZnNldCgpLmxlZnQ7XG5cdCQuc3VwcG9ydC5vZmZzZXRGcmFjdGlvbnMgPSBvZmZzZXRMZWZ0ID4gMTAgJiYgb2Zmc2V0TGVmdCA8IDExO1xuXG5cdHRlc3RFbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG5cdHRlc3RFbGVtZW50UGFyZW50LnJlbW92ZUNoaWxkKCB0ZXN0RWxlbWVudCApO1xufSkoKTtcblxufSggalF1ZXJ5ICkgKTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJy4vY29yZScpO1xucmVxdWlyZSgnLi9tb3VzZScpO1xucmVxdWlyZSgnLi93aWRnZXQnKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgU2xpZGVyIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zbGlkZXIvXG4gKlxuICogRGVwZW5kczpcbiAqXHRqcXVlcnkudWkuY29yZS5qc1xuICpcdGpxdWVyeS51aS5tb3VzZS5qc1xuICpcdGpxdWVyeS51aS53aWRnZXQuanNcbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbi8vIG51bWJlciBvZiBwYWdlcyBpbiBhIHNsaWRlclxuLy8gKGhvdyBtYW55IHRpbWVzIGNhbiB5b3UgcGFnZSB1cC9kb3duIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHJhbmdlKVxudmFyIG51bVBhZ2VzID0gNTtcblxuJC53aWRnZXQoIFwidWkuc2xpZGVyXCIsICQudWkubW91c2UsIHtcblx0dmVyc2lvbjogXCIxLjEwLjRcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwic2xpZGVcIixcblxuXHRvcHRpb25zOiB7XG5cdFx0YW5pbWF0ZTogZmFsc2UsXG5cdFx0ZGlzdGFuY2U6IDAsXG5cdFx0bWF4OiAxMDAsXG5cdFx0bWluOiAwLFxuXHRcdG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcblx0XHRyYW5nZTogZmFsc2UsXG5cdFx0c3RlcDogMSxcblx0XHR2YWx1ZTogMCxcblx0XHR2YWx1ZXM6IG51bGwsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRjaGFuZ2U6IG51bGwsXG5cdFx0c2xpZGU6IG51bGwsXG5cdFx0c3RhcnQ6IG51bGwsXG5cdFx0c3RvcDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2tleVNsaWRpbmcgPSBmYWxzZTtcblx0XHR0aGlzLl9tb3VzZVNsaWRpbmcgPSBmYWxzZTtcblx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHR0aGlzLl9oYW5kbGVJbmRleCA9IG51bGw7XG5cdFx0dGhpcy5fZGV0ZWN0T3JpZW50YXRpb24oKTtcblx0XHR0aGlzLl9tb3VzZUluaXQoKTtcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXNsaWRlclwiICtcblx0XHRcdFx0XCIgdWktc2xpZGVyLVwiICsgdGhpcy5vcmllbnRhdGlvbiArXG5cdFx0XHRcdFwiIHVpLXdpZGdldFwiICtcblx0XHRcdFx0XCIgdWktd2lkZ2V0LWNvbnRlbnRcIiArXG5cdFx0XHRcdFwiIHVpLWNvcm5lci1hbGxcIik7XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdFx0dGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApO1xuXG5cdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXHR9LFxuXG5cdF9yZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9jcmVhdGVSYW5nZSgpO1xuXHRcdHRoaXMuX2NyZWF0ZUhhbmRsZXMoKTtcblx0XHR0aGlzLl9zZXR1cEV2ZW50cygpO1xuXHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHR9LFxuXG5cdF9jcmVhdGVIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaSwgaGFuZGxlQ291bnQsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0ZXhpc3RpbmdIYW5kbGVzID0gdGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLXNsaWRlci1oYW5kbGVcIiApLmFkZENsYXNzKCBcInVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFwiICksXG5cdFx0XHRoYW5kbGUgPSBcIjxhIGNsYXNzPSd1aS1zbGlkZXItaGFuZGxlIHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCcgaHJlZj0nIyc+PC9hPlwiLFxuXHRcdFx0aGFuZGxlcyA9IFtdO1xuXG5cdFx0aGFuZGxlQ291bnQgPSAoIG9wdGlvbnMudmFsdWVzICYmIG9wdGlvbnMudmFsdWVzLmxlbmd0aCApIHx8IDE7XG5cblx0XHRpZiAoIGV4aXN0aW5nSGFuZGxlcy5sZW5ndGggPiBoYW5kbGVDb3VudCApIHtcblx0XHRcdGV4aXN0aW5nSGFuZGxlcy5zbGljZSggaGFuZGxlQ291bnQgKS5yZW1vdmUoKTtcblx0XHRcdGV4aXN0aW5nSGFuZGxlcyA9IGV4aXN0aW5nSGFuZGxlcy5zbGljZSggMCwgaGFuZGxlQ291bnQgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gZXhpc3RpbmdIYW5kbGVzLmxlbmd0aDsgaSA8IGhhbmRsZUNvdW50OyBpKysgKSB7XG5cdFx0XHRoYW5kbGVzLnB1c2goIGhhbmRsZSApO1xuXHRcdH1cblxuXHRcdHRoaXMuaGFuZGxlcyA9IGV4aXN0aW5nSGFuZGxlcy5hZGQoICQoIGhhbmRsZXMuam9pbiggXCJcIiApICkuYXBwZW5kVG8oIHRoaXMuZWxlbWVudCApICk7XG5cblx0XHR0aGlzLmhhbmRsZSA9IHRoaXMuaGFuZGxlcy5lcSggMCApO1xuXG5cdFx0dGhpcy5oYW5kbGVzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHQkKCB0aGlzICkuZGF0YSggXCJ1aS1zbGlkZXItaGFuZGxlLWluZGV4XCIsIGkgKTtcblx0XHR9KTtcblx0fSxcblxuXHRfY3JlYXRlUmFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0Y2xhc3NlcyA9IFwiXCI7XG5cblx0XHRpZiAoIG9wdGlvbnMucmFuZ2UgKSB7XG5cdFx0XHRpZiAoIG9wdGlvbnMucmFuZ2UgPT09IHRydWUgKSB7XG5cdFx0XHRcdGlmICggIW9wdGlvbnMudmFsdWVzICkge1xuXHRcdFx0XHRcdG9wdGlvbnMudmFsdWVzID0gWyB0aGlzLl92YWx1ZU1pbigpLCB0aGlzLl92YWx1ZU1pbigpIF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMudmFsdWVzLmxlbmd0aCAmJiBvcHRpb25zLnZhbHVlcy5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy52YWx1ZXMgPSBbIG9wdGlvbnMudmFsdWVzWzBdLCBvcHRpb25zLnZhbHVlc1swXSBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAkLmlzQXJyYXkoIG9wdGlvbnMudmFsdWVzICkgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcy5zbGljZSgwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICF0aGlzLnJhbmdlIHx8ICF0aGlzLnJhbmdlLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5yYW5nZSA9ICQoIFwiPGRpdj48L2Rpdj5cIiApXG5cdFx0XHRcdFx0LmFwcGVuZFRvKCB0aGlzLmVsZW1lbnQgKTtcblxuXHRcdFx0XHRjbGFzc2VzID0gXCJ1aS1zbGlkZXItcmFuZ2VcIiArXG5cdFx0XHRcdC8vIG5vdGU6IHRoaXMgaXNuJ3QgdGhlIG1vc3QgZml0dGluZ2x5IHNlbWFudGljIGZyYW1ld29yayBjbGFzcyBmb3IgdGhpcyBlbGVtZW50LFxuXHRcdFx0XHQvLyBidXQgd29ya2VkIGJlc3QgdmlzdWFsbHkgd2l0aCBhIHZhcmlldHkgb2YgdGhlbWVzXG5cdFx0XHRcdFwiIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbFwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5yYW5nZS5yZW1vdmVDbGFzcyggXCJ1aS1zbGlkZXItcmFuZ2UtbWluIHVpLXNsaWRlci1yYW5nZS1tYXhcIiApXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIHJhbmdlIHN3aXRjaGluZyBmcm9tIHRydWUgdG8gbWluL21heFxuXHRcdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdFx0XCJsZWZ0XCI6IFwiXCIsXG5cdFx0XHRcdFx0XHRcImJvdHRvbVwiOiBcIlwiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucmFuZ2UuYWRkQ2xhc3MoIGNsYXNzZXMgK1xuXHRcdFx0XHQoICggb3B0aW9ucy5yYW5nZSA9PT0gXCJtaW5cIiB8fCBvcHRpb25zLnJhbmdlID09PSBcIm1heFwiICkgPyBcIiB1aS1zbGlkZXItcmFuZ2UtXCIgKyBvcHRpb25zLnJhbmdlIDogXCJcIiApICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdGhpcy5yYW5nZSApIHtcblx0XHRcdFx0dGhpcy5yYW5nZS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmFuZ2UgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0dXBFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtZW50cyA9IHRoaXMuaGFuZGxlcy5hZGQoIHRoaXMucmFuZ2UgKS5maWx0ZXIoIFwiYVwiICk7XG5cdFx0dGhpcy5fb2ZmKCBlbGVtZW50cyApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50cywgdGhpcy5faGFuZGxlRXZlbnRzICk7XG5cdFx0dGhpcy5faG92ZXJhYmxlKCBlbGVtZW50cyApO1xuXHRcdHRoaXMuX2ZvY3VzYWJsZSggZWxlbWVudHMgKTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oYW5kbGVzLnJlbW92ZSgpO1xuXHRcdGlmICggdGhpcy5yYW5nZSApIHtcblx0XHRcdHRoaXMucmFuZ2UucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc2xpZGVyXCIgK1xuXHRcdFx0XHRcIiB1aS1zbGlkZXItaG9yaXpvbnRhbFwiICtcblx0XHRcdFx0XCIgdWktc2xpZGVyLXZlcnRpY2FsXCIgK1xuXHRcdFx0XHRcIiB1aS13aWRnZXRcIiArXG5cdFx0XHRcdFwiIHVpLXdpZGdldC1jb250ZW50XCIgK1xuXHRcdFx0XHRcIiB1aS1jb3JuZXItYWxsXCIgKTtcblxuXHRcdHRoaXMuX21vdXNlRGVzdHJveSgpO1xuXHR9LFxuXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgcG9zaXRpb24sIG5vcm1WYWx1ZSwgZGlzdGFuY2UsIGNsb3Nlc3RIYW5kbGUsIGluZGV4LCBhbGxvd2VkLCBvZmZzZXQsIG1vdXNlT3ZlckhhbmRsZSxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICggby5kaXNhYmxlZCApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnRTaXplID0ge1xuXHRcdFx0d2lkdGg6IHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0XHR0aGlzLmVsZW1lbnRPZmZzZXQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XG5cblx0XHRwb3NpdGlvbiA9IHsgeDogZXZlbnQucGFnZVgsIHk6IGV2ZW50LnBhZ2VZIH07XG5cdFx0bm9ybVZhbHVlID0gdGhpcy5fbm9ybVZhbHVlRnJvbU1vdXNlKCBwb3NpdGlvbiApO1xuXHRcdGRpc3RhbmNlID0gdGhpcy5fdmFsdWVNYXgoKSAtIHRoaXMuX3ZhbHVlTWluKCkgKyAxO1xuXHRcdHRoaXMuaGFuZGxlcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHRoaXNEaXN0YW5jZSA9IE1hdGguYWJzKCBub3JtVmFsdWUgLSB0aGF0LnZhbHVlcyhpKSApO1xuXHRcdFx0aWYgKCggZGlzdGFuY2UgPiB0aGlzRGlzdGFuY2UgKSB8fFxuXHRcdFx0XHQoIGRpc3RhbmNlID09PSB0aGlzRGlzdGFuY2UgJiZcblx0XHRcdFx0XHQoaSA9PT0gdGhhdC5fbGFzdENoYW5nZWRWYWx1ZSB8fCB0aGF0LnZhbHVlcyhpKSA9PT0gby5taW4gKSkpIHtcblx0XHRcdFx0ZGlzdGFuY2UgPSB0aGlzRGlzdGFuY2U7XG5cdFx0XHRcdGNsb3Nlc3RIYW5kbGUgPSAkKCB0aGlzICk7XG5cdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFsbG93ZWQgPSB0aGlzLl9zdGFydCggZXZlbnQsIGluZGV4ICk7XG5cdFx0aWYgKCBhbGxvd2VkID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5fbW91c2VTbGlkaW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2hhbmRsZUluZGV4ID0gaW5kZXg7XG5cblx0XHRjbG9zZXN0SGFuZGxlXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0LmZvY3VzKCk7XG5cblx0XHRvZmZzZXQgPSBjbG9zZXN0SGFuZGxlLm9mZnNldCgpO1xuXHRcdG1vdXNlT3ZlckhhbmRsZSA9ICEkKCBldmVudC50YXJnZXQgKS5wYXJlbnRzKCkuYWRkQmFjaygpLmlzKCBcIi51aS1zbGlkZXItaGFuZGxlXCIgKTtcblx0XHR0aGlzLl9jbGlja09mZnNldCA9IG1vdXNlT3ZlckhhbmRsZSA/IHsgbGVmdDogMCwgdG9wOiAwIH0gOiB7XG5cdFx0XHRsZWZ0OiBldmVudC5wYWdlWCAtIG9mZnNldC5sZWZ0IC0gKCBjbG9zZXN0SGFuZGxlLndpZHRoKCkgLyAyICksXG5cdFx0XHR0b3A6IGV2ZW50LnBhZ2VZIC0gb2Zmc2V0LnRvcCAtXG5cdFx0XHRcdCggY2xvc2VzdEhhbmRsZS5oZWlnaHQoKSAvIDIgKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGNsb3Nlc3RIYW5kbGUuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksIDEwICkgfHwgMCApIC1cblx0XHRcdFx0KCBwYXJzZUludCggY2xvc2VzdEhhbmRsZS5jc3MoXCJib3JkZXJCb3R0b21XaWR0aFwiKSwgMTAgKSB8fCAwKSArXG5cdFx0XHRcdCggcGFyc2VJbnQoIGNsb3Nlc3RIYW5kbGUuY3NzKFwibWFyZ2luVG9wXCIpLCAxMCApIHx8IDApXG5cdFx0fTtcblxuXHRcdGlmICggIXRoaXMuaGFuZGxlcy5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICkgKSB7XG5cdFx0XHR0aGlzLl9zbGlkZSggZXZlbnQsIGluZGV4LCBub3JtVmFsdWUgKTtcblx0XHR9XG5cdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgcG9zaXRpb24gPSB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9LFxuXHRcdFx0bm9ybVZhbHVlID0gdGhpcy5fbm9ybVZhbHVlRnJvbU1vdXNlKCBwb3NpdGlvbiApO1xuXG5cdFx0dGhpcy5fc2xpZGUoIGV2ZW50LCB0aGlzLl9oYW5kbGVJbmRleCwgbm9ybVZhbHVlICk7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHRoaXMuaGFuZGxlcy5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdHRoaXMuX21vdXNlU2xpZGluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fc3RvcCggZXZlbnQsIHRoaXMuX2hhbmRsZUluZGV4ICk7XG5cdFx0dGhpcy5fY2hhbmdlKCBldmVudCwgdGhpcy5faGFuZGxlSW5kZXggKTtcblxuXHRcdHRoaXMuX2hhbmRsZUluZGV4ID0gbnVsbDtcblx0XHR0aGlzLl9jbGlja09mZnNldCA9IG51bGw7XG5cdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9kZXRlY3RPcmllbnRhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5vcmllbnRhdGlvbiA9ICggdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgKSA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiO1xuXHR9LFxuXG5cdF9ub3JtVmFsdWVGcm9tTW91c2U6IGZ1bmN0aW9uKCBwb3NpdGlvbiApIHtcblx0XHR2YXIgcGl4ZWxUb3RhbCxcblx0XHRcdHBpeGVsTW91c2UsXG5cdFx0XHRwZXJjZW50TW91c2UsXG5cdFx0XHR2YWx1ZVRvdGFsLFxuXHRcdFx0dmFsdWVNb3VzZTtcblxuXHRcdGlmICggdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRwaXhlbFRvdGFsID0gdGhpcy5lbGVtZW50U2l6ZS53aWR0aDtcblx0XHRcdHBpeGVsTW91c2UgPSBwb3NpdGlvbi54IC0gdGhpcy5lbGVtZW50T2Zmc2V0LmxlZnQgLSAoIHRoaXMuX2NsaWNrT2Zmc2V0ID8gdGhpcy5fY2xpY2tPZmZzZXQubGVmdCA6IDAgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGl4ZWxUb3RhbCA9IHRoaXMuZWxlbWVudFNpemUuaGVpZ2h0O1xuXHRcdFx0cGl4ZWxNb3VzZSA9IHBvc2l0aW9uLnkgLSB0aGlzLmVsZW1lbnRPZmZzZXQudG9wIC0gKCB0aGlzLl9jbGlja09mZnNldCA/IHRoaXMuX2NsaWNrT2Zmc2V0LnRvcCA6IDAgKTtcblx0XHR9XG5cblx0XHRwZXJjZW50TW91c2UgPSAoIHBpeGVsTW91c2UgLyBwaXhlbFRvdGFsICk7XG5cdFx0aWYgKCBwZXJjZW50TW91c2UgPiAxICkge1xuXHRcdFx0cGVyY2VudE1vdXNlID0gMTtcblx0XHR9XG5cdFx0aWYgKCBwZXJjZW50TW91c2UgPCAwICkge1xuXHRcdFx0cGVyY2VudE1vdXNlID0gMDtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgKSB7XG5cdFx0XHRwZXJjZW50TW91c2UgPSAxIC0gcGVyY2VudE1vdXNlO1xuXHRcdH1cblxuXHRcdHZhbHVlVG90YWwgPSB0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKTtcblx0XHR2YWx1ZU1vdXNlID0gdGhpcy5fdmFsdWVNaW4oKSArIHBlcmNlbnRNb3VzZSAqIHZhbHVlVG90YWw7XG5cblx0XHRyZXR1cm4gdGhpcy5fdHJpbUFsaWduVmFsdWUoIHZhbHVlTW91c2UgKTtcblx0fSxcblxuXHRfc3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgaW5kZXggKSB7XG5cdFx0dmFyIHVpSGFzaCA9IHtcblx0XHRcdGhhbmRsZTogdGhpcy5oYW5kbGVzWyBpbmRleCBdLFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUoKVxuXHRcdH07XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0dWlIYXNoLnZhbHVlID0gdGhpcy52YWx1ZXMoIGluZGV4ICk7XG5cdFx0XHR1aUhhc2gudmFsdWVzID0gdGhpcy52YWx1ZXMoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3RyaWdnZXIoIFwic3RhcnRcIiwgZXZlbnQsIHVpSGFzaCApO1xuXHR9LFxuXG5cdF9zbGlkZTogZnVuY3Rpb24oIGV2ZW50LCBpbmRleCwgbmV3VmFsICkge1xuXHRcdHZhciBvdGhlclZhbCxcblx0XHRcdG5ld1ZhbHVlcyxcblx0XHRcdGFsbG93ZWQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHRvdGhlclZhbCA9IHRoaXMudmFsdWVzKCBpbmRleCA/IDAgOiAxICk7XG5cblx0XHRcdGlmICggKCB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLm9wdGlvbnMucmFuZ2UgPT09IHRydWUgKSAmJlxuXHRcdFx0XHRcdCggKCBpbmRleCA9PT0gMCAmJiBuZXdWYWwgPiBvdGhlclZhbCkgfHwgKCBpbmRleCA9PT0gMSAmJiBuZXdWYWwgPCBvdGhlclZhbCApIClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdG5ld1ZhbCA9IG90aGVyVmFsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5ld1ZhbCAhPT0gdGhpcy52YWx1ZXMoIGluZGV4ICkgKSB7XG5cdFx0XHRcdG5ld1ZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XG5cdFx0XHRcdG5ld1ZhbHVlc1sgaW5kZXggXSA9IG5ld1ZhbDtcblx0XHRcdFx0Ly8gQSBzbGlkZSBjYW4gYmUgY2FuY2VsZWQgYnkgcmV0dXJuaW5nIGZhbHNlIGZyb20gdGhlIHNsaWRlIGNhbGxiYWNrXG5cdFx0XHRcdGFsbG93ZWQgPSB0aGlzLl90cmlnZ2VyKCBcInNsaWRlXCIsIGV2ZW50LCB7XG5cdFx0XHRcdFx0aGFuZGxlOiB0aGlzLmhhbmRsZXNbIGluZGV4IF0sXG5cdFx0XHRcdFx0dmFsdWU6IG5ld1ZhbCxcblx0XHRcdFx0XHR2YWx1ZXM6IG5ld1ZhbHVlc1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG90aGVyVmFsID0gdGhpcy52YWx1ZXMoIGluZGV4ID8gMCA6IDEgKTtcblx0XHRcdFx0aWYgKCBhbGxvd2VkICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlcyggaW5kZXgsIG5ld1ZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggbmV3VmFsICE9PSB0aGlzLnZhbHVlKCkgKSB7XG5cdFx0XHRcdC8vIEEgc2xpZGUgY2FuIGJlIGNhbmNlbGVkIGJ5IHJldHVybmluZyBmYWxzZSBmcm9tIHRoZSBzbGlkZSBjYWxsYmFja1xuXHRcdFx0XHRhbGxvd2VkID0gdGhpcy5fdHJpZ2dlciggXCJzbGlkZVwiLCBldmVudCwge1xuXHRcdFx0XHRcdGhhbmRsZTogdGhpcy5oYW5kbGVzWyBpbmRleCBdLFxuXHRcdFx0XHRcdHZhbHVlOiBuZXdWYWxcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIGFsbG93ZWQgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUoIG5ld1ZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9zdG9wOiBmdW5jdGlvbiggZXZlbnQsIGluZGV4ICkge1xuXHRcdHZhciB1aUhhc2ggPSB7XG5cdFx0XHRoYW5kbGU6IHRoaXMuaGFuZGxlc1sgaW5kZXggXSxcblx0XHRcdHZhbHVlOiB0aGlzLnZhbHVlKClcblx0XHR9O1xuXHRcdGlmICggdGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCApIHtcblx0XHRcdHVpSGFzaC52YWx1ZSA9IHRoaXMudmFsdWVzKCBpbmRleCApO1xuXHRcdFx0dWlIYXNoLnZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJzdG9wXCIsIGV2ZW50LCB1aUhhc2ggKTtcblx0fSxcblxuXHRfY2hhbmdlOiBmdW5jdGlvbiggZXZlbnQsIGluZGV4ICkge1xuXHRcdGlmICggIXRoaXMuX2tleVNsaWRpbmcgJiYgIXRoaXMuX21vdXNlU2xpZGluZyApIHtcblx0XHRcdHZhciB1aUhhc2ggPSB7XG5cdFx0XHRcdGhhbmRsZTogdGhpcy5oYW5kbGVzWyBpbmRleCBdLFxuXHRcdFx0XHR2YWx1ZTogdGhpcy52YWx1ZSgpXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0XHR1aUhhc2gudmFsdWUgPSB0aGlzLnZhbHVlcyggaW5kZXggKTtcblx0XHRcdFx0dWlIYXNoLnZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vc3RvcmUgdGhlIGxhc3QgY2hhbmdlZCB2YWx1ZSBpbmRleCBmb3IgcmVmZXJlbmNlIHdoZW4gaGFuZGxlcyBvdmVybGFwXG5cdFx0XHR0aGlzLl9sYXN0Q2hhbmdlZFZhbHVlID0gaW5kZXg7XG5cblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIsIGV2ZW50LCB1aUhhc2ggKTtcblx0XHR9XG5cdH0sXG5cblx0dmFsdWU6IGZ1bmN0aW9uKCBuZXdWYWx1ZSApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggbmV3VmFsdWUgKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCAwICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlKCk7XG5cdH0sXG5cblx0dmFsdWVzOiBmdW5jdGlvbiggaW5kZXgsIG5ld1ZhbHVlICkge1xuXHRcdHZhciB2YWxzLFxuXHRcdFx0bmV3VmFsdWVzLFxuXHRcdFx0aTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMudmFsdWVzWyBpbmRleCBdID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIG5ld1ZhbHVlICk7XG5cdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgaW5kZXggKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoICQuaXNBcnJheSggYXJndW1lbnRzWyAwIF0gKSApIHtcblx0XHRcdFx0dmFscyA9IHRoaXMub3B0aW9ucy52YWx1ZXM7XG5cdFx0XHRcdG5ld1ZhbHVlcyA9IGFyZ3VtZW50c1sgMCBdO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dmFsc1sgaSBdID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIG5ld1ZhbHVlc1sgaSBdICk7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlcyggaW5kZXggKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZXMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHR2YWxzTGVuZ3RoID0gMDtcblxuXHRcdGlmICgga2V5ID09PSBcInJhbmdlXCIgJiYgdGhpcy5vcHRpb25zLnJhbmdlID09PSB0cnVlICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJtaW5cIiApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fdmFsdWVzKCAwICk7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IFwibWF4XCIgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX3ZhbHVlcyggdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGgtMSApO1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMudmFsdWVzID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICQuaXNBcnJheSggdGhpcy5vcHRpb25zLnZhbHVlcyApICkge1xuXHRcdFx0dmFsc0xlbmd0aCA9IHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoO1xuXHRcdH1cblxuXHRcdCQuV2lkZ2V0LnByb3RvdHlwZS5fc2V0T3B0aW9uLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdHN3aXRjaCAoIGtleSApIHtcblx0XHRcdGNhc2UgXCJvcmllbnRhdGlvblwiOlxuXHRcdFx0XHR0aGlzLl9kZXRlY3RPcmllbnRhdGlvbigpO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc2xpZGVyLWhvcml6b250YWwgdWktc2xpZGVyLXZlcnRpY2FsXCIgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zbGlkZXItXCIgKyB0aGlzLm9yaWVudGF0aW9uICk7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ2YWx1ZVwiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgMCApO1xuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInZhbHVlc1wiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdmFsc0xlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibWluXCI6XG5cdFx0XHRjYXNlIFwibWF4XCI6XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJyYW5nZVwiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSxcblxuXHQvL2ludGVybmFsIHZhbHVlIGdldHRlclxuXHQvLyBfdmFsdWUoKSByZXR1cm5zIHZhbHVlIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxuXHRfdmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2YWwgPSB0aGlzLm9wdGlvbnMudmFsdWU7XG5cdFx0dmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIHZhbCApO1xuXG5cdFx0cmV0dXJuIHZhbDtcblx0fSxcblxuXHQvL2ludGVybmFsIHZhbHVlcyBnZXR0ZXJcblx0Ly8gX3ZhbHVlcygpIHJldHVybnMgYXJyYXkgb2YgdmFsdWVzIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxuXHQvLyBfdmFsdWVzKCBpbmRleCApIHJldHVybnMgc2luZ2xlIHZhbHVlIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxuXHRfdmFsdWVzOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0dmFyIHZhbCxcblx0XHRcdHZhbHMsXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dmFsID0gdGhpcy5vcHRpb25zLnZhbHVlc1sgaW5kZXggXTtcblx0XHRcdHZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCB2YWwgKTtcblxuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0Ly8gLnNsaWNlKCkgY3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFycmF5XG5cdFx0XHQvLyB0aGlzIGNvcHkgZ2V0cyB0cmltbWVkIGJ5IG1pbiBhbmQgbWF4IGFuZCB0aGVuIHJldHVybmVkXG5cdFx0XHR2YWxzID0gdGhpcy5vcHRpb25zLnZhbHVlcy5zbGljZSgpO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSs9IDEpIHtcblx0XHRcdFx0dmFsc1sgaSBdID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIHZhbHNbIGkgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFscztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0fSxcblxuXHQvLyByZXR1cm5zIHRoZSBzdGVwLWFsaWduZWQgdmFsdWUgdGhhdCB2YWwgaXMgY2xvc2VzdCB0bywgYmV0d2VlbiAoaW5jbHVzaXZlKSBtaW4gYW5kIG1heFxuXHRfdHJpbUFsaWduVmFsdWU6IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0aWYgKCB2YWwgPD0gdGhpcy5fdmFsdWVNaW4oKSApIHtcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZU1pbigpO1xuXHRcdH1cblx0XHRpZiAoIHZhbCA+PSB0aGlzLl92YWx1ZU1heCgpICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlTWF4KCk7XG5cdFx0fVxuXHRcdHZhciBzdGVwID0gKCB0aGlzLm9wdGlvbnMuc3RlcCA+IDAgKSA/IHRoaXMub3B0aW9ucy5zdGVwIDogMSxcblx0XHRcdHZhbE1vZFN0ZXAgPSAodmFsIC0gdGhpcy5fdmFsdWVNaW4oKSkgJSBzdGVwLFxuXHRcdFx0YWxpZ25WYWx1ZSA9IHZhbCAtIHZhbE1vZFN0ZXA7XG5cblx0XHRpZiAoIE1hdGguYWJzKHZhbE1vZFN0ZXApICogMiA+PSBzdGVwICkge1xuXHRcdFx0YWxpZ25WYWx1ZSArPSAoIHZhbE1vZFN0ZXAgPiAwICkgPyBzdGVwIDogKCAtc3RlcCApO1xuXHRcdH1cblxuXHRcdC8vIFNpbmNlIEphdmFTY3JpcHQgaGFzIHByb2JsZW1zIHdpdGggbGFyZ2UgZmxvYXRzLCByb3VuZFxuXHRcdC8vIHRoZSBmaW5hbCB2YWx1ZSB0byA1IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCAoc2VlICM0MTI0KVxuXHRcdHJldHVybiBwYXJzZUZsb2F0KCBhbGlnblZhbHVlLnRvRml4ZWQoNSkgKTtcblx0fSxcblxuXHRfdmFsdWVNaW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluO1xuXHR9LFxuXG5cdF92YWx1ZU1heDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXg7XG5cdH0sXG5cblx0X3JlZnJlc2hWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhc3RWYWxQZXJjZW50LCB2YWxQZXJjZW50LCB2YWx1ZSwgdmFsdWVNaW4sIHZhbHVlTWF4LFxuXHRcdFx0b1JhbmdlID0gdGhpcy5vcHRpb25zLnJhbmdlLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0YW5pbWF0ZSA9ICggIXRoaXMuX2FuaW1hdGVPZmYgKSA/IG8uYW5pbWF0ZSA6IGZhbHNlLFxuXHRcdFx0X3NldCA9IHt9O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5oYW5kbGVzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHZhbFBlcmNlbnQgPSAoIHRoYXQudmFsdWVzKGkpIC0gdGhhdC5fdmFsdWVNaW4oKSApIC8gKCB0aGF0Ll92YWx1ZU1heCgpIC0gdGhhdC5fdmFsdWVNaW4oKSApICogMTAwO1xuXHRcdFx0XHRfc2V0WyB0aGF0Lm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwibGVmdFwiIDogXCJib3R0b21cIiBdID0gdmFsUGVyY2VudCArIFwiJVwiO1xuXHRcdFx0XHQkKCB0aGlzICkuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIF9zZXQsIG8uYW5pbWF0ZSApO1xuXHRcdFx0XHRpZiAoIHRoYXQub3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHRoYXQub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IGxlZnQ6IHZhbFBlcmNlbnQgKyBcIiVcIiB9LCBvLmFuaW1hdGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5yYW5nZVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IHdpZHRoOiAoIHZhbFBlcmNlbnQgLSBsYXN0VmFsUGVyY2VudCApICsgXCIlXCIgfSwgeyBxdWV1ZTogZmFsc2UsIGR1cmF0aW9uOiBvLmFuaW1hdGUgfSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoIGkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgYm90dG9tOiAoIHZhbFBlcmNlbnQgKSArIFwiJVwiIH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LnJhbmdlWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgaGVpZ2h0OiAoIHZhbFBlcmNlbnQgLSBsYXN0VmFsUGVyY2VudCApICsgXCIlXCIgfSwgeyBxdWV1ZTogZmFsc2UsIGR1cmF0aW9uOiBvLmFuaW1hdGUgfSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0VmFsUGVyY2VudCA9IHZhbFBlcmNlbnQ7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSB0aGlzLnZhbHVlKCk7XG5cdFx0XHR2YWx1ZU1pbiA9IHRoaXMuX3ZhbHVlTWluKCk7XG5cdFx0XHR2YWx1ZU1heCA9IHRoaXMuX3ZhbHVlTWF4KCk7XG5cdFx0XHR2YWxQZXJjZW50ID0gKCB2YWx1ZU1heCAhPT0gdmFsdWVNaW4gKSA/XG5cdFx0XHRcdFx0KCB2YWx1ZSAtIHZhbHVlTWluICkgLyAoIHZhbHVlTWF4IC0gdmFsdWVNaW4gKSAqIDEwMCA6XG5cdFx0XHRcdFx0MDtcblx0XHRcdF9zZXRbIHRoaXMub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiIF0gPSB2YWxQZXJjZW50ICsgXCIlXCI7XG5cdFx0XHR0aGlzLmhhbmRsZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggX3NldCwgby5hbmltYXRlICk7XG5cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1pblwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IHdpZHRoOiB2YWxQZXJjZW50ICsgXCIlXCIgfSwgby5hbmltYXRlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9SYW5nZSA9PT0gXCJtYXhcIiAmJiB0aGlzLm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiApIHtcblx0XHRcdFx0dGhpcy5yYW5nZVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IHdpZHRoOiAoIDEwMCAtIHZhbFBlcmNlbnQgKSArIFwiJVwiIH0sIHsgcXVldWU6IGZhbHNlLCBkdXJhdGlvbjogby5hbmltYXRlIH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1pblwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdFx0dGhpcy5yYW5nZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggeyBoZWlnaHQ6IHZhbFBlcmNlbnQgKyBcIiVcIiB9LCBvLmFuaW1hdGUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1heFwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdFx0dGhpcy5yYW5nZVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IGhlaWdodDogKCAxMDAgLSB2YWxQZXJjZW50ICkgKyBcIiVcIiB9LCB7IHF1ZXVlOiBmYWxzZSwgZHVyYXRpb246IG8uYW5pbWF0ZSB9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVFdmVudHM6IHtcblx0XHRrZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgYWxsb3dlZCwgY3VyVmFsLCBuZXdWYWwsIHN0ZXAsXG5cdFx0XHRcdGluZGV4ID0gJCggZXZlbnQudGFyZ2V0ICkuZGF0YSggXCJ1aS1zbGlkZXItaGFuZGxlLWluZGV4XCIgKTtcblxuXHRcdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5EOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX1VQOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlVQOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuRE9XTjpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuTEVGVDpcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdGlmICggIXRoaXMuX2tleVNsaWRpbmcgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9rZXlTbGlkaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdCQoIGV2ZW50LnRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdFx0XHRhbGxvd2VkID0gdGhpcy5fc3RhcnQoIGV2ZW50LCBpbmRleCApO1xuXHRcdFx0XHRcdFx0aWYgKCBhbGxvd2VkID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0c3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwO1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0XHRjdXJWYWwgPSBuZXdWYWwgPSB0aGlzLnZhbHVlcyggaW5kZXggKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1clZhbCA9IG5ld1ZhbCA9IHRoaXMudmFsdWUoKTtcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcblx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl92YWx1ZU1pbigpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdmFsdWVNYXgoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggY3VyVmFsICsgKCAodGhpcy5fdmFsdWVNYXgoKSAtIHRoaXMuX3ZhbHVlTWluKCkpIC8gbnVtUGFnZXMgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIGN1clZhbCAtICggKHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpKSAvIG51bVBhZ2VzICkgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxuXHRcdFx0XHRcdGlmICggY3VyVmFsID09PSB0aGlzLl92YWx1ZU1heCgpICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggY3VyVmFsICsgc3RlcCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0XHRcdGlmICggY3VyVmFsID09PSB0aGlzLl92YWx1ZU1pbigpICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggY3VyVmFsIC0gc3RlcCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zbGlkZSggZXZlbnQsIGluZGV4LCBuZXdWYWwgKTtcblx0XHR9LFxuXHRcdGNsaWNrOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH0sXG5cdFx0a2V5dXA6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBpbmRleCA9ICQoIGV2ZW50LnRhcmdldCApLmRhdGEoIFwidWktc2xpZGVyLWhhbmRsZS1pbmRleFwiICk7XG5cblx0XHRcdGlmICggdGhpcy5fa2V5U2xpZGluZyApIHtcblx0XHRcdFx0dGhpcy5fa2V5U2xpZGluZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9zdG9wKCBldmVudCwgaW5kZXggKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlKCBldmVudCwgaW5kZXggKTtcblx0XHRcdFx0JCggZXZlbnQudGFyZ2V0ICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxufSk7XG5cbn0oalF1ZXJ5KSk7XG4iLCJ2YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5yZXF1aXJlKCcuL2NvcmUnKTtcbnJlcXVpcmUoJy4vbW91c2UnKTtcbnJlcXVpcmUoJy4vd2lkZ2V0Jyk7XG5cbi8qIVxuICogalF1ZXJ5IFVJIFNvcnRhYmxlIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zb3J0YWJsZS9cbiAqXG4gKiBEZXBlbmRzOlxuICpcdGpxdWVyeS51aS5jb3JlLmpzXG4gKlx0anF1ZXJ5LnVpLm1vdXNlLmpzXG4gKlx0anF1ZXJ5LnVpLndpZGdldC5qc1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuZnVuY3Rpb24gaXNPdmVyQXhpcyggeCwgcmVmZXJlbmNlLCBzaXplICkge1xuXHRyZXR1cm4gKCB4ID4gcmVmZXJlbmNlICkgJiYgKCB4IDwgKCByZWZlcmVuY2UgKyBzaXplICkgKTtcbn1cblxuZnVuY3Rpb24gaXNGbG9hdGluZyhpdGVtKSB7XG5cdHJldHVybiAoL2xlZnR8cmlnaHQvKS50ZXN0KGl0ZW0uY3NzKFwiZmxvYXRcIikpIHx8ICgvaW5saW5lfHRhYmxlLWNlbGwvKS50ZXN0KGl0ZW0uY3NzKFwiZGlzcGxheVwiKSk7XG59XG5cbiQud2lkZ2V0KFwidWkuc29ydGFibGVcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuNFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJzb3J0XCIsXG5cdHJlYWR5OiBmYWxzZSxcblx0b3B0aW9uczoge1xuXHRcdGFwcGVuZFRvOiBcInBhcmVudFwiLFxuXHRcdGF4aXM6IGZhbHNlLFxuXHRcdGNvbm5lY3RXaXRoOiBmYWxzZSxcblx0XHRjb250YWlubWVudDogZmFsc2UsXG5cdFx0Y3Vyc29yOiBcImF1dG9cIixcblx0XHRjdXJzb3JBdDogZmFsc2UsXG5cdFx0ZHJvcE9uRW1wdHk6IHRydWUsXG5cdFx0Zm9yY2VQbGFjZWhvbGRlclNpemU6IGZhbHNlLFxuXHRcdGZvcmNlSGVscGVyU2l6ZTogZmFsc2UsXG5cdFx0Z3JpZDogZmFsc2UsXG5cdFx0aGFuZGxlOiBmYWxzZSxcblx0XHRoZWxwZXI6IFwib3JpZ2luYWxcIixcblx0XHRpdGVtczogXCI+ICpcIixcblx0XHRvcGFjaXR5OiBmYWxzZSxcblx0XHRwbGFjZWhvbGRlcjogZmFsc2UsXG5cdFx0cmV2ZXJ0OiBmYWxzZSxcblx0XHRzY3JvbGw6IHRydWUsXG5cdFx0c2Nyb2xsU2Vuc2l0aXZpdHk6IDIwLFxuXHRcdHNjcm9sbFNwZWVkOiAyMCxcblx0XHRzY29wZTogXCJkZWZhdWx0XCIsXG5cdFx0dG9sZXJhbmNlOiBcImludGVyc2VjdFwiLFxuXHRcdHpJbmRleDogMTAwMCxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGFjdGl2YXRlOiBudWxsLFxuXHRcdGJlZm9yZVN0b3A6IG51bGwsXG5cdFx0Y2hhbmdlOiBudWxsLFxuXHRcdGRlYWN0aXZhdGU6IG51bGwsXG5cdFx0b3V0OiBudWxsLFxuXHRcdG92ZXI6IG51bGwsXG5cdFx0cmVjZWl2ZTogbnVsbCxcblx0XHRyZW1vdmU6IG51bGwsXG5cdFx0c29ydDogbnVsbCxcblx0XHRzdGFydDogbnVsbCxcblx0XHRzdG9wOiBudWxsLFxuXHRcdHVwZGF0ZTogbnVsbFxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXHRcdHRoaXMuY29udGFpbmVyQ2FjaGUgPSB7fTtcblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1zb3J0YWJsZVwiKTtcblxuXHRcdC8vR2V0IHRoZSBpdGVtc1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXG5cdFx0Ly9MZXQncyBkZXRlcm1pbmUgaWYgdGhlIGl0ZW1zIGFyZSBiZWluZyBkaXNwbGF5ZWQgaG9yaXpvbnRhbGx5XG5cdFx0dGhpcy5mbG9hdGluZyA9IHRoaXMuaXRlbXMubGVuZ3RoID8gby5heGlzID09PSBcInhcIiB8fCBpc0Zsb2F0aW5nKHRoaXMuaXRlbXNbMF0uaXRlbSkgOiBmYWxzZTtcblxuXHRcdC8vTGV0J3MgZGV0ZXJtaW5lIHRoZSBwYXJlbnQncyBvZmZzZXRcblx0XHR0aGlzLm9mZnNldCA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblxuXHRcdC8vSW5pdGlhbGl6ZSBtb3VzZSBldmVudHMgZm9yIGludGVyYWN0aW9uXG5cdFx0dGhpcy5fbW91c2VJbml0KCk7XG5cblx0XHQvL1dlJ3JlIHJlYWR5IHRvIGdvXG5cdFx0dGhpcy5yZWFkeSA9IHRydWU7XG5cblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoXCJ1aS1zb3J0YWJsZSB1aS1zb3J0YWJsZS1kaXNhYmxlZFwiKTtcblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblxuXHRcdGZvciAoIHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblx0XHRcdHRoaXMuaXRlbXNbaV0uaXRlbS5yZW1vdmVEYXRhKHRoaXMud2lkZ2V0TmFtZSArIFwiLWl0ZW1cIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy53aWRnZXQoKS50b2dnbGVDbGFzcyggXCJ1aS1zb3J0YWJsZS1kaXNhYmxlZFwiLCAhIXZhbHVlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERvbid0IGNhbGwgd2lkZ2V0IGJhc2UgX3NldE9wdGlvbiBmb3IgZGlzYWJsZSBhcyBpdCBhZGRzIHVpLXN0YXRlLWRpc2FibGVkIGNsYXNzXG5cdFx0XHQkLldpZGdldC5wcm90b3R5cGUuX3NldE9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fSxcblxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbihldmVudCwgb3ZlcnJpZGVIYW5kbGUpIHtcblx0XHR2YXIgY3VycmVudEl0ZW0gPSBudWxsLFxuXHRcdFx0dmFsaWRIYW5kbGUgPSBmYWxzZSxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXG5cdFx0aWYgKHRoaXMucmV2ZXJ0aW5nKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IHRoaXMub3B0aW9ucy50eXBlID09PSBcInN0YXRpY1wiKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9XZSBoYXZlIHRvIHJlZnJlc2ggdGhlIGl0ZW1zIGRhdGEgb25jZSBmaXJzdFxuXHRcdHRoaXMuX3JlZnJlc2hJdGVtcyhldmVudCk7XG5cblx0XHQvL0ZpbmQgb3V0IGlmIHRoZSBjbGlja2VkIG5vZGUgKG9yIG9uZSBvZiBpdHMgcGFyZW50cykgaXMgYSBhY3R1YWwgaXRlbSBpbiB0aGlzLml0ZW1zXG5cdFx0JChldmVudC50YXJnZXQpLnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoJC5kYXRhKHRoaXMsIHRoYXQud2lkZ2V0TmFtZSArIFwiLWl0ZW1cIikgPT09IHRoYXQpIHtcblx0XHRcdFx0Y3VycmVudEl0ZW0gPSAkKHRoaXMpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aWYoJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgXCItaXRlbVwiKSA9PT0gdGhhdCkge1xuXHRcdFx0Y3VycmVudEl0ZW0gPSAkKGV2ZW50LnRhcmdldCk7XG5cdFx0fVxuXG5cdFx0aWYoIWN1cnJlbnRJdGVtKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgIW92ZXJyaWRlSGFuZGxlKSB7XG5cdFx0XHQkKHRoaXMub3B0aW9ucy5oYW5kbGUsIGN1cnJlbnRJdGVtKS5maW5kKFwiKlwiKS5hZGRCYWNrKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYodGhpcyA9PT0gZXZlbnQudGFyZ2V0KSB7XG5cdFx0XHRcdFx0dmFsaWRIYW5kbGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGlmKCF2YWxpZEhhbmRsZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5jdXJyZW50SXRlbSA9IGN1cnJlbnRJdGVtO1xuXHRcdHRoaXMuX3JlbW92ZUN1cnJlbnRzRnJvbUl0ZW1zKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oZXZlbnQsIG92ZXJyaWRlSGFuZGxlLCBub0FjdGl2YXRpb24pIHtcblxuXHRcdHZhciBpLCBib2R5LFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuY3VycmVudENvbnRhaW5lciA9IHRoaXM7XG5cblx0XHQvL1dlIG9ubHkgbmVlZCB0byBjYWxsIHJlZnJlc2hQb3NpdGlvbnMsIGJlY2F1c2UgdGhlIHJlZnJlc2hJdGVtcyBjYWxsIGhhcyBiZWVuIG1vdmVkIHRvIG1vdXNlQ2FwdHVyZVxuXHRcdHRoaXMucmVmcmVzaFBvc2l0aW9ucygpO1xuXG5cdFx0Ly9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcblx0XHR0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlcihldmVudCk7XG5cblx0XHQvL0NhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXHRcdC8qXG5cdFx0ICogLSBQb3NpdGlvbiBnZW5lcmF0aW9uIC1cblx0XHQgKiBUaGlzIGJsb2NrIGdlbmVyYXRlcyBldmVyeXRoaW5nIHBvc2l0aW9uIHJlbGF0ZWQgLSBpdCdzIHRoZSBjb3JlIG9mIGRyYWdnYWJsZXMuXG5cdFx0ICovXG5cblx0XHQvL0NhY2hlIHRoZSBtYXJnaW5zIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50XG5cdFx0dGhpcy5fY2FjaGVNYXJnaW5zKCk7XG5cblx0XHQvL0dldCB0aGUgbmV4dCBzY3JvbGxpbmcgcGFyZW50XG5cdFx0dGhpcy5zY3JvbGxQYXJlbnQgPSB0aGlzLmhlbHBlci5zY3JvbGxQYXJlbnQoKTtcblxuXHRcdC8vVGhlIGVsZW1lbnQncyBhYnNvbHV0ZSBwb3NpdGlvbiBvbiB0aGUgcGFnZSBtaW51cyBtYXJnaW5zXG5cdFx0dGhpcy5vZmZzZXQgPSB0aGlzLmN1cnJlbnRJdGVtLm9mZnNldCgpO1xuXHRcdHRoaXMub2Zmc2V0ID0ge1xuXHRcdFx0dG9wOiB0aGlzLm9mZnNldC50b3AgLSB0aGlzLm1hcmdpbnMudG9wLFxuXHRcdFx0bGVmdDogdGhpcy5vZmZzZXQubGVmdCAtIHRoaXMubWFyZ2lucy5sZWZ0XG5cdFx0fTtcblxuXHRcdCQuZXh0ZW5kKHRoaXMub2Zmc2V0LCB7XG5cdFx0XHRjbGljazogeyAvL1doZXJlIHRoZSBjbGljayBoYXBwZW5lZCwgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0bGVmdDogZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5sZWZ0LFxuXHRcdFx0XHR0b3A6IGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQudG9wXG5cdFx0XHR9LFxuXHRcdFx0cGFyZW50OiB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKSxcblx0XHRcdHJlbGF0aXZlOiB0aGlzLl9nZXRSZWxhdGl2ZU9mZnNldCgpIC8vVGhpcyBpcyBhIHJlbGF0aXZlIHRvIGFic29sdXRlIHBvc2l0aW9uIG1pbnVzIHRoZSBhY3R1YWwgcG9zaXRpb24gY2FsY3VsYXRpb24gLSBvbmx5IHVzZWQgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgaGVscGVyXG5cdFx0fSk7XG5cblx0XHQvLyBPbmx5IGFmdGVyIHdlIGdvdCB0aGUgb2Zmc2V0LCB3ZSBjYW4gY2hhbmdlIHRoZSBoZWxwZXIncyBwb3NpdGlvbiB0byBhYnNvbHV0ZVxuXHRcdC8vIFRPRE86IFN0aWxsIG5lZWQgdG8gZmlndXJlIG91dCBhIHdheSB0byBtYWtlIHJlbGF0aXZlIHNvcnRpbmcgcG9zc2libGVcblx0XHR0aGlzLmhlbHBlci5jc3MoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpO1xuXHRcdHRoaXMuY3NzUG9zaXRpb24gPSB0aGlzLmhlbHBlci5jc3MoXCJwb3NpdGlvblwiKTtcblxuXHRcdC8vR2VuZXJhdGUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0dGhpcy5vcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5fZ2VuZXJhdGVQb3NpdGlvbihldmVudCk7XG5cdFx0dGhpcy5vcmlnaW5hbFBhZ2VYID0gZXZlbnQucGFnZVg7XG5cdFx0dGhpcy5vcmlnaW5hbFBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvL0FkanVzdCB0aGUgbW91c2Ugb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBoZWxwZXIgaWYgXCJjdXJzb3JBdFwiIGlzIHN1cHBsaWVkXG5cdFx0KG8uY3Vyc29yQXQgJiYgdGhpcy5fYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcihvLmN1cnNvckF0KSk7XG5cblx0XHQvL0NhY2hlIHRoZSBmb3JtZXIgRE9NIHBvc2l0aW9uXG5cdFx0dGhpcy5kb21Qb3NpdGlvbiA9IHsgcHJldjogdGhpcy5jdXJyZW50SXRlbS5wcmV2KClbMF0sIHBhcmVudDogdGhpcy5jdXJyZW50SXRlbS5wYXJlbnQoKVswXSB9O1xuXG5cdFx0Ly9JZiB0aGUgaGVscGVyIGlzIG5vdCB0aGUgb3JpZ2luYWwsIGhpZGUgdGhlIG9yaWdpbmFsIHNvIGl0J3Mgbm90IHBsYXlpbmcgYW55IHJvbGUgZHVyaW5nIHRoZSBkcmFnLCB3b24ndCBjYXVzZSBhbnl0aGluZyBiYWQgdGhpcyB3YXlcblx0XHRpZih0aGlzLmhlbHBlclswXSAhPT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xuXHRcdFx0dGhpcy5jdXJyZW50SXRlbS5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0Ly9DcmVhdGUgdGhlIHBsYWNlaG9sZGVyXG5cdFx0dGhpcy5fY3JlYXRlUGxhY2Vob2xkZXIoKTtcblxuXHRcdC8vU2V0IGEgY29udGFpbm1lbnQgaWYgZ2l2ZW4gaW4gdGhlIG9wdGlvbnNcblx0XHRpZihvLmNvbnRhaW5tZW50KSB7XG5cdFx0XHR0aGlzLl9zZXRDb250YWlubWVudCgpO1xuXHRcdH1cblxuXHRcdGlmKCBvLmN1cnNvciAmJiBvLmN1cnNvciAhPT0gXCJhdXRvXCIgKSB7IC8vIGN1cnNvciBvcHRpb25cblx0XHRcdGJvZHkgPSB0aGlzLmRvY3VtZW50LmZpbmQoIFwiYm9keVwiICk7XG5cblx0XHRcdC8vIHN1cHBvcnQ6IElFXG5cdFx0XHR0aGlzLnN0b3JlZEN1cnNvciA9IGJvZHkuY3NzKCBcImN1cnNvclwiICk7XG5cdFx0XHRib2R5LmNzcyggXCJjdXJzb3JcIiwgby5jdXJzb3IgKTtcblxuXHRcdFx0dGhpcy5zdG9yZWRTdHlsZXNoZWV0ID0gJCggXCI8c3R5bGU+KnsgY3Vyc29yOiBcIitvLmN1cnNvcitcIiAhaW1wb3J0YW50OyB9PC9zdHlsZT5cIiApLmFwcGVuZFRvKCBib2R5ICk7XG5cdFx0fVxuXG5cdFx0aWYoby5vcGFjaXR5KSB7IC8vIG9wYWNpdHkgb3B0aW9uXG5cdFx0XHRpZiAodGhpcy5oZWxwZXIuY3NzKFwib3BhY2l0eVwiKSkge1xuXHRcdFx0XHR0aGlzLl9zdG9yZWRPcGFjaXR5ID0gdGhpcy5oZWxwZXIuY3NzKFwib3BhY2l0eVwiKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGVscGVyLmNzcyhcIm9wYWNpdHlcIiwgby5vcGFjaXR5KTtcblx0XHR9XG5cblx0XHRpZihvLnpJbmRleCkgeyAvLyB6SW5kZXggb3B0aW9uXG5cdFx0XHRpZiAodGhpcy5oZWxwZXIuY3NzKFwiekluZGV4XCIpKSB7XG5cdFx0XHRcdHRoaXMuX3N0b3JlZFpJbmRleCA9IHRoaXMuaGVscGVyLmNzcyhcInpJbmRleFwiKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGVscGVyLmNzcyhcInpJbmRleFwiLCBvLnpJbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly9QcmVwYXJlIHNjcm9sbGluZ1xuXHRcdGlmKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSBkb2N1bWVudCAmJiB0aGlzLnNjcm9sbFBhcmVudFswXS50YWdOYW1lICE9PSBcIkhUTUxcIikge1xuXHRcdFx0dGhpcy5vdmVyZmxvd09mZnNldCA9IHRoaXMuc2Nyb2xsUGFyZW50Lm9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8vQ2FsbCBjYWxsYmFja3Ncblx0XHR0aGlzLl90cmlnZ2VyKFwic3RhcnRcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblxuXHRcdC8vUmVjYWNoZSB0aGUgaGVscGVyIHNpemVcblx0XHRpZighdGhpcy5fcHJlc2VydmVIZWxwZXJQcm9wb3J0aW9ucykge1xuXHRcdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXHRcdH1cblxuXG5cdFx0Ly9Qb3N0IFwiYWN0aXZhdGVcIiBldmVudHMgdG8gcG9zc2libGUgY29udGFpbmVyc1xuXHRcdGlmKCAhbm9BY3RpdmF0aW9uICkge1xuXHRcdFx0Zm9yICggaSA9IHRoaXMuY29udGFpbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzWyBpIF0uX3RyaWdnZXIoIFwiYWN0aXZhdGVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCggdGhpcyApICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9QcmVwYXJlIHBvc3NpYmxlIGRyb3BwYWJsZXNcblx0XHRpZigkLnVpLmRkbWFuYWdlcikge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIuY3VycmVudCA9IHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHR0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuaGVscGVyLmFkZENsYXNzKFwidWktc29ydGFibGUtaGVscGVyXCIpO1xuXHRcdHRoaXMuX21vdXNlRHJhZyhldmVudCk7IC8vRXhlY3V0ZSB0aGUgZHJhZyBvbmNlIC0gdGhpcyBjYXVzZXMgdGhlIGhlbHBlciBub3QgdG8gYmUgdmlzaWJsZSBiZWZvcmUgZ2V0dGluZyBpdHMgY29ycmVjdCBwb3NpdGlvblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0X21vdXNlRHJhZzogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgaSwgaXRlbSwgaXRlbUVsZW1lbnQsIGludGVyc2VjdGlvbixcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRzY3JvbGxlZCA9IGZhbHNlO1xuXG5cdFx0Ly9Db21wdXRlIHRoZSBoZWxwZXJzIHBvc2l0aW9uXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xuXHRcdHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyhcImFic29sdXRlXCIpO1xuXG5cdFx0aWYgKCF0aGlzLmxhc3RQb3NpdGlvbkFicykge1xuXHRcdFx0dGhpcy5sYXN0UG9zaXRpb25BYnMgPSB0aGlzLnBvc2l0aW9uQWJzO1xuXHRcdH1cblxuXHRcdC8vRG8gc2Nyb2xsaW5nXG5cdFx0aWYodGhpcy5vcHRpb25zLnNjcm9sbCkge1xuXHRcdFx0aWYodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT09IGRvY3VtZW50ICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUgIT09IFwiSFRNTFwiKSB7XG5cblx0XHRcdFx0aWYoKHRoaXMub3ZlcmZsb3dPZmZzZXQudG9wICsgdGhpcy5zY3JvbGxQYXJlbnRbMF0ub2Zmc2V0SGVpZ2h0KSAtIGV2ZW50LnBhZ2VZIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wICsgby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0fSBlbHNlIGlmKGV2ZW50LnBhZ2VZIC0gdGhpcy5vdmVyZmxvd09mZnNldC50b3AgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0dGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSB0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgLSBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoKHRoaXMub3ZlcmZsb3dPZmZzZXQubGVmdCArIHRoaXMuc2Nyb2xsUGFyZW50WzBdLm9mZnNldFdpZHRoKSAtIGV2ZW50LnBhZ2VYIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgKyBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9IGVsc2UgaWYoZXZlbnQucGFnZVggLSB0aGlzLm92ZXJmbG93T2Zmc2V0LmxlZnQgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0dGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCAtIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIC0gby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH0gZWxzZSBpZigkKHdpbmRvdykuaGVpZ2h0KCkgLSAoZXZlbnQucGFnZVkgLSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgKyBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgLSBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0fSBlbHNlIGlmKCQod2luZG93KS53aWR0aCgpIC0gKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpICsgby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZihzY3JvbGxlZCAhPT0gZmFsc2UgJiYgJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cikge1xuXHRcdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyh0aGlzLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9SZWdlbmVyYXRlIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiB1c2VkIGZvciBwb3NpdGlvbiBjaGVja3Ncblx0XHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXCJhYnNvbHV0ZVwiKTtcblxuXHRcdC8vU2V0IHRoZSBoZWxwZXIgcG9zaXRpb25cblx0XHRpZighdGhpcy5vcHRpb25zLmF4aXMgfHwgdGhpcy5vcHRpb25zLmF4aXMgIT09IFwieVwiKSB7XG5cdFx0XHR0aGlzLmhlbHBlclswXS5zdHlsZS5sZWZ0ID0gdGhpcy5wb3NpdGlvbi5sZWZ0K1wicHhcIjtcblx0XHR9XG5cdFx0aWYoIXRoaXMub3B0aW9ucy5heGlzIHx8IHRoaXMub3B0aW9ucy5heGlzICE9PSBcInhcIikge1xuXHRcdFx0dGhpcy5oZWxwZXJbMF0uc3R5bGUudG9wID0gdGhpcy5wb3NpdGlvbi50b3ArXCJweFwiO1xuXHRcdH1cblxuXHRcdC8vUmVhcnJhbmdlXG5cdFx0Zm9yIChpID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXG5cdFx0XHQvL0NhY2hlIHZhcmlhYmxlcyBhbmQgaW50ZXJzZWN0aW9uLCBjb250aW51ZSBpZiBubyBpbnRlcnNlY3Rpb25cblx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXHRcdFx0aXRlbUVsZW1lbnQgPSBpdGVtLml0ZW1bMF07XG5cdFx0XHRpbnRlcnNlY3Rpb24gPSB0aGlzLl9pbnRlcnNlY3RzV2l0aFBvaW50ZXIoaXRlbSk7XG5cdFx0XHRpZiAoIWludGVyc2VjdGlvbikge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBwdXQgdGhlIHBsYWNlaG9sZGVyIGluc2lkZSB0aGUgY3VycmVudCBDb250YWluZXIsIHNraXAgYWxsXG5cdFx0XHQvLyBpdGVtcyBmcm9tIG90aGVyIGNvbnRhaW5lcnMuIFRoaXMgd29ya3MgYmVjYXVzZSB3aGVuIG1vdmluZ1xuXHRcdFx0Ly8gYW4gaXRlbSBmcm9tIG9uZSBjb250YWluZXIgdG8gYW5vdGhlciB0aGVcblx0XHRcdC8vIGN1cnJlbnRDb250YWluZXIgaXMgc3dpdGNoZWQgYmVmb3JlIHRoZSBwbGFjZWhvbGRlciBpcyBtb3ZlZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBXaXRob3V0IHRoaXMsIG1vdmluZyBpdGVtcyBpbiBcInN1Yi1zb3J0YWJsZXNcIiBjYW4gY2F1c2Vcblx0XHRcdC8vIHRoZSBwbGFjZWhvbGRlciB0byBqaXR0ZXIgYmVldHdlZW4gdGhlIG91dGVyIGFuZCBpbm5lciBjb250YWluZXIuXG5cdFx0XHRpZiAoaXRlbS5pbnN0YW5jZSAhPT0gdGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYW5ub3QgaW50ZXJzZWN0IHdpdGggaXRzZWxmXG5cdFx0XHQvLyBubyB1c2VsZXNzIGFjdGlvbnMgdGhhdCBoYXZlIGJlZW4gZG9uZSBiZWZvcmVcblx0XHRcdC8vIG5vIGFjdGlvbiBpZiB0aGUgaXRlbSBtb3ZlZCBpcyB0aGUgcGFyZW50IG9mIHRoZSBpdGVtIGNoZWNrZWRcblx0XHRcdGlmIChpdGVtRWxlbWVudCAhPT0gdGhpcy5jdXJyZW50SXRlbVswXSAmJlxuXHRcdFx0XHR0aGlzLnBsYWNlaG9sZGVyW2ludGVyc2VjdGlvbiA9PT0gMSA/IFwibmV4dFwiIDogXCJwcmV2XCJdKClbMF0gIT09IGl0ZW1FbGVtZW50ICYmXG5cdFx0XHRcdCEkLmNvbnRhaW5zKHRoaXMucGxhY2Vob2xkZXJbMF0sIGl0ZW1FbGVtZW50KSAmJlxuXHRcdFx0XHQodGhpcy5vcHRpb25zLnR5cGUgPT09IFwic2VtaS1keW5hbWljXCIgPyAhJC5jb250YWlucyh0aGlzLmVsZW1lbnRbMF0sIGl0ZW1FbGVtZW50KSA6IHRydWUpXG5cdFx0XHQpIHtcblxuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbiA9IGludGVyc2VjdGlvbiA9PT0gMSA/IFwiZG93blwiIDogXCJ1cFwiO1xuXG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG9sZXJhbmNlID09PSBcInBvaW50ZXJcIiB8fCB0aGlzLl9pbnRlcnNlY3RzV2l0aFNpZGVzKGl0ZW0pKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVhcnJhbmdlKGV2ZW50LCBpdGVtKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoXCJjaGFuZ2VcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9Qb3N0IGV2ZW50cyB0byBjb250YWluZXJzXG5cdFx0dGhpcy5fY29udGFjdENvbnRhaW5lcnMoZXZlbnQpO1xuXG5cdFx0Ly9JbnRlcmNvbm5lY3Qgd2l0aCBkcm9wcGFibGVzXG5cdFx0aWYoJC51aS5kZG1hbmFnZXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyYWcodGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdC8vQ2FsbCBjYWxsYmFja3Ncblx0XHR0aGlzLl90cmlnZ2VyKFwic29ydFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXG5cdFx0dGhpcy5sYXN0UG9zaXRpb25BYnMgPSB0aGlzLnBvc2l0aW9uQWJzO1xuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKGV2ZW50LCBub1Byb3BhZ2F0aW9uKSB7XG5cblx0XHRpZighZXZlbnQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL0lmIHdlIGFyZSB1c2luZyBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgYWJvdXQgdGhlIGRyb3Bcblx0XHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIXRoaXMub3B0aW9ucy5kcm9wQmVoYXZpb3VyKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcm9wKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRpZih0aGlzLm9wdGlvbnMucmV2ZXJ0KSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdGN1ciA9IHRoaXMucGxhY2Vob2xkZXIub2Zmc2V0KCksXG5cdFx0XHRcdGF4aXMgPSB0aGlzLm9wdGlvbnMuYXhpcyxcblx0XHRcdFx0YW5pbWF0aW9uID0ge307XG5cblx0XHRcdGlmICggIWF4aXMgfHwgYXhpcyA9PT0gXCJ4XCIgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi5sZWZ0ID0gY3VyLmxlZnQgLSB0aGlzLm9mZnNldC5wYXJlbnQubGVmdCAtIHRoaXMubWFyZ2lucy5sZWZ0ICsgKHRoaXMub2Zmc2V0UGFyZW50WzBdID09PSBkb2N1bWVudC5ib2R5ID8gMCA6IHRoaXMub2Zmc2V0UGFyZW50WzBdLnNjcm9sbExlZnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhYXhpcyB8fCBheGlzID09PSBcInlcIiApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnRvcCA9IGN1ci50b3AgLSB0aGlzLm9mZnNldC5wYXJlbnQudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCArICh0aGlzLm9mZnNldFBhcmVudFswXSA9PT0gZG9jdW1lbnQuYm9keSA/IDAgOiB0aGlzLm9mZnNldFBhcmVudFswXS5zY3JvbGxUb3ApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZXZlcnRpbmcgPSB0cnVlO1xuXHRcdFx0JCh0aGlzLmhlbHBlcikuYW5pbWF0ZSggYW5pbWF0aW9uLCBwYXJzZUludCh0aGlzLm9wdGlvbnMucmV2ZXJ0LCAxMCkgfHwgNTAwLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5fY2xlYXIoZXZlbnQpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NsZWFyKGV2ZW50LCBub1Byb3BhZ2F0aW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSxcblxuXHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYodGhpcy5kcmFnZ2luZykge1xuXG5cdFx0XHR0aGlzLl9tb3VzZVVwKHsgdGFyZ2V0OiBudWxsIH0pO1xuXG5cdFx0XHRpZih0aGlzLm9wdGlvbnMuaGVscGVyID09PSBcIm9yaWdpbmFsXCIpIHtcblx0XHRcdFx0dGhpcy5jdXJyZW50SXRlbS5jc3ModGhpcy5fc3RvcmVkQ1NTKS5yZW1vdmVDbGFzcyhcInVpLXNvcnRhYmxlLWhlbHBlclwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuY3VycmVudEl0ZW0uc2hvdygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1Bvc3QgZGVhY3RpdmF0aW5nIGV2ZW50cyB0byBjb250YWluZXJzXG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLl90cmlnZ2VyKFwiZGVhY3RpdmF0ZVwiLCBudWxsLCB0aGlzLl91aUhhc2godGhpcykpO1xuXHRcdFx0XHRpZih0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUub3Zlcikge1xuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpXS5fdHJpZ2dlcihcIm91dFwiLCBudWxsLCB0aGlzLl91aUhhc2godGhpcykpO1xuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcblx0XHRcdC8vJCh0aGlzLnBsYWNlaG9sZGVyWzBdKS5yZW1vdmUoKTsgd291bGQgaGF2ZSBiZWVuIHRoZSBqUXVlcnkgd2F5IC0gdW5mb3J0dW5hdGVseSwgaXQgdW5iaW5kcyBBTEwgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIG5vZGUhXG5cdFx0XHRpZih0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0dGhpcy5wbGFjZWhvbGRlclswXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucGxhY2Vob2xkZXJbMF0pO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5vcHRpb25zLmhlbHBlciAhPT0gXCJvcmlnaW5hbFwiICYmIHRoaXMuaGVscGVyICYmIHRoaXMuaGVscGVyWzBdLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0dGhpcy5oZWxwZXIucmVtb3ZlKCk7XG5cdFx0XHR9XG5cblx0XHRcdCQuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdFx0aGVscGVyOiBudWxsLFxuXHRcdFx0XHRkcmFnZ2luZzogZmFsc2UsXG5cdFx0XHRcdHJldmVydGluZzogZmFsc2UsXG5cdFx0XHRcdF9ub0ZpbmFsU29ydDogbnVsbFxuXHRcdFx0fSk7XG5cblx0XHRcdGlmKHRoaXMuZG9tUG9zaXRpb24ucHJldikge1xuXHRcdFx0XHQkKHRoaXMuZG9tUG9zaXRpb24ucHJldikuYWZ0ZXIodGhpcy5jdXJyZW50SXRlbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKHRoaXMuZG9tUG9zaXRpb24ucGFyZW50KS5wcmVwZW5kKHRoaXMuY3VycmVudEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2VyaWFsaXplOiBmdW5jdGlvbihvKSB7XG5cblx0XHR2YXIgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0FzalF1ZXJ5KG8gJiYgby5jb25uZWN0ZWQpLFxuXHRcdFx0c3RyID0gW107XG5cdFx0byA9IG8gfHwge307XG5cblx0XHQkKGl0ZW1zKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlcyA9ICgkKG8uaXRlbSB8fCB0aGlzKS5hdHRyKG8uYXR0cmlidXRlIHx8IFwiaWRcIikgfHwgXCJcIikubWF0Y2goby5leHByZXNzaW9uIHx8ICgvKC4rKVtcXC09X10oLispLykpO1xuXHRcdFx0aWYgKHJlcykge1xuXHRcdFx0XHRzdHIucHVzaCgoby5rZXkgfHwgcmVzWzFdK1wiW11cIikrXCI9XCIrKG8ua2V5ICYmIG8uZXhwcmVzc2lvbiA/IHJlc1sxXSA6IHJlc1syXSkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYoIXN0ci5sZW5ndGggJiYgby5rZXkpIHtcblx0XHRcdHN0ci5wdXNoKG8ua2V5ICsgXCI9XCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHIuam9pbihcIiZcIik7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbihvKSB7XG5cblx0XHR2YXIgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0FzalF1ZXJ5KG8gJiYgby5jb25uZWN0ZWQpLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHRvID0gbyB8fCB7fTtcblxuXHRcdGl0ZW1zLmVhY2goZnVuY3Rpb24oKSB7IHJldC5wdXNoKCQoby5pdGVtIHx8IHRoaXMpLmF0dHIoby5hdHRyaWJ1dGUgfHwgXCJpZFwiKSB8fCBcIlwiKTsgfSk7XG5cdFx0cmV0dXJuIHJldDtcblxuXHR9LFxuXG5cdC8qIEJlIGNhcmVmdWwgd2l0aCB0aGUgZm9sbG93aW5nIGNvcmUgZnVuY3Rpb25zICovXG5cdF9pbnRlcnNlY3RzV2l0aDogZnVuY3Rpb24oaXRlbSkge1xuXG5cdFx0dmFyIHgxID0gdGhpcy5wb3NpdGlvbkFicy5sZWZ0LFxuXHRcdFx0eDIgPSB4MSArIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsXG5cdFx0XHR5MSA9IHRoaXMucG9zaXRpb25BYnMudG9wLFxuXHRcdFx0eTIgPSB5MSArIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LFxuXHRcdFx0bCA9IGl0ZW0ubGVmdCxcblx0XHRcdHIgPSBsICsgaXRlbS53aWR0aCxcblx0XHRcdHQgPSBpdGVtLnRvcCxcblx0XHRcdGIgPSB0ICsgaXRlbS5oZWlnaHQsXG5cdFx0XHRkeUNsaWNrID0gdGhpcy5vZmZzZXQuY2xpY2sudG9wLFxuXHRcdFx0ZHhDbGljayA9IHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQsXG5cdFx0XHRpc092ZXJFbGVtZW50SGVpZ2h0ID0gKCB0aGlzLm9wdGlvbnMuYXhpcyA9PT0gXCJ4XCIgKSB8fCAoICggeTEgKyBkeUNsaWNrICkgPiB0ICYmICggeTEgKyBkeUNsaWNrICkgPCBiICksXG5cdFx0XHRpc092ZXJFbGVtZW50V2lkdGggPSAoIHRoaXMub3B0aW9ucy5heGlzID09PSBcInlcIiApIHx8ICggKCB4MSArIGR4Q2xpY2sgKSA+IGwgJiYgKCB4MSArIGR4Q2xpY2sgKSA8IHIgKSxcblx0XHRcdGlzT3ZlckVsZW1lbnQgPSBpc092ZXJFbGVtZW50SGVpZ2h0ICYmIGlzT3ZlckVsZW1lbnRXaWR0aDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnRvbGVyYW5jZSA9PT0gXCJwb2ludGVyXCIgfHxcblx0XHRcdHRoaXMub3B0aW9ucy5mb3JjZVBvaW50ZXJGb3JDb250YWluZXJzIHx8XG5cdFx0XHQodGhpcy5vcHRpb25zLnRvbGVyYW5jZSAhPT0gXCJwb2ludGVyXCIgJiYgdGhpcy5oZWxwZXJQcm9wb3J0aW9uc1t0aGlzLmZsb2F0aW5nID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPiBpdGVtW3RoaXMuZmxvYXRpbmcgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSlcblx0XHQpIHtcblx0XHRcdHJldHVybiBpc092ZXJFbGVtZW50O1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiAobCA8IHgxICsgKHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyKSAmJiAvLyBSaWdodCBIYWxmXG5cdFx0XHRcdHgyIC0gKHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyKSA8IHIgJiYgLy8gTGVmdCBIYWxmXG5cdFx0XHRcdHQgPCB5MSArICh0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAvIDIpICYmIC8vIEJvdHRvbSBIYWxmXG5cdFx0XHRcdHkyIC0gKHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC8gMikgPCBiICk7IC8vIFRvcCBIYWxmXG5cblx0XHR9XG5cdH0sXG5cblx0X2ludGVyc2VjdHNXaXRoUG9pbnRlcjogZnVuY3Rpb24oaXRlbSkge1xuXG5cdFx0dmFyIGlzT3ZlckVsZW1lbnRIZWlnaHQgPSAodGhpcy5vcHRpb25zLmF4aXMgPT09IFwieFwiKSB8fCBpc092ZXJBeGlzKHRoaXMucG9zaXRpb25BYnMudG9wICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wLCBpdGVtLnRvcCwgaXRlbS5oZWlnaHQpLFxuXHRcdFx0aXNPdmVyRWxlbWVudFdpZHRoID0gKHRoaXMub3B0aW9ucy5heGlzID09PSBcInlcIikgfHwgaXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLmxlZnQgKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0LCBpdGVtLmxlZnQsIGl0ZW0ud2lkdGgpLFxuXHRcdFx0aXNPdmVyRWxlbWVudCA9IGlzT3ZlckVsZW1lbnRIZWlnaHQgJiYgaXNPdmVyRWxlbWVudFdpZHRoLFxuXHRcdFx0dmVydGljYWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnVmVydGljYWxEaXJlY3Rpb24oKSxcblx0XHRcdGhvcml6b250YWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbigpO1xuXG5cdFx0aWYgKCFpc092ZXJFbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZmxvYXRpbmcgP1xuXHRcdFx0KCAoKGhvcml6b250YWxEaXJlY3Rpb24gJiYgaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gXCJyaWdodFwiKSB8fCB2ZXJ0aWNhbERpcmVjdGlvbiA9PT0gXCJkb3duXCIpID8gMiA6IDEgKVxuXHRcdFx0OiAoIHZlcnRpY2FsRGlyZWN0aW9uICYmICh2ZXJ0aWNhbERpcmVjdGlvbiA9PT0gXCJkb3duXCIgPyAyIDogMSkgKTtcblxuXHR9LFxuXG5cdF9pbnRlcnNlY3RzV2l0aFNpZGVzOiBmdW5jdGlvbihpdGVtKSB7XG5cblx0XHR2YXIgaXNPdmVyQm90dG9tSGFsZiA9IGlzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy50b3AgKyB0aGlzLm9mZnNldC5jbGljay50b3AsIGl0ZW0udG9wICsgKGl0ZW0uaGVpZ2h0LzIpLCBpdGVtLmhlaWdodCksXG5cdFx0XHRpc092ZXJSaWdodEhhbGYgPSBpc092ZXJBeGlzKHRoaXMucG9zaXRpb25BYnMubGVmdCArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQsIGl0ZW0ubGVmdCArIChpdGVtLndpZHRoLzIpLCBpdGVtLndpZHRoKSxcblx0XHRcdHZlcnRpY2FsRGlyZWN0aW9uID0gdGhpcy5fZ2V0RHJhZ1ZlcnRpY2FsRGlyZWN0aW9uKCksXG5cdFx0XHRob3Jpem9udGFsRGlyZWN0aW9uID0gdGhpcy5fZ2V0RHJhZ0hvcml6b250YWxEaXJlY3Rpb24oKTtcblxuXHRcdGlmICh0aGlzLmZsb2F0aW5nICYmIGhvcml6b250YWxEaXJlY3Rpb24pIHtcblx0XHRcdHJldHVybiAoKGhvcml6b250YWxEaXJlY3Rpb24gPT09IFwicmlnaHRcIiAmJiBpc092ZXJSaWdodEhhbGYpIHx8IChob3Jpem9udGFsRGlyZWN0aW9uID09PSBcImxlZnRcIiAmJiAhaXNPdmVyUmlnaHRIYWxmKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2ZXJ0aWNhbERpcmVjdGlvbiAmJiAoKHZlcnRpY2FsRGlyZWN0aW9uID09PSBcImRvd25cIiAmJiBpc092ZXJCb3R0b21IYWxmKSB8fCAodmVydGljYWxEaXJlY3Rpb24gPT09IFwidXBcIiAmJiAhaXNPdmVyQm90dG9tSGFsZikpO1xuXHRcdH1cblxuXHR9LFxuXG5cdF9nZXREcmFnVmVydGljYWxEaXJlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWx0YSA9IHRoaXMucG9zaXRpb25BYnMudG9wIC0gdGhpcy5sYXN0UG9zaXRpb25BYnMudG9wO1xuXHRcdHJldHVybiBkZWx0YSAhPT0gMCAmJiAoZGVsdGEgPiAwID8gXCJkb3duXCIgOiBcInVwXCIpO1xuXHR9LFxuXG5cdF9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlbHRhID0gdGhpcy5wb3NpdGlvbkFicy5sZWZ0IC0gdGhpcy5sYXN0UG9zaXRpb25BYnMubGVmdDtcblx0XHRyZXR1cm4gZGVsdGEgIT09IDAgJiYgKGRlbHRhID4gMCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHRoaXMuX3JlZnJlc2hJdGVtcyhldmVudCk7XG5cdFx0dGhpcy5yZWZyZXNoUG9zaXRpb25zKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2Nvbm5lY3RXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRyZXR1cm4gb3B0aW9ucy5jb25uZWN0V2l0aC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID8gW29wdGlvbnMuY29ubmVjdFdpdGhdIDogb3B0aW9ucy5jb25uZWN0V2l0aDtcblx0fSxcblxuXHRfZ2V0SXRlbXNBc2pRdWVyeTogZnVuY3Rpb24oY29ubmVjdGVkKSB7XG5cblx0XHR2YXIgaSwgaiwgY3VyLCBpbnN0LFxuXHRcdFx0aXRlbXMgPSBbXSxcblx0XHRcdHF1ZXJpZXMgPSBbXSxcblx0XHRcdGNvbm5lY3RXaXRoID0gdGhpcy5fY29ubmVjdFdpdGgoKTtcblxuXHRcdGlmKGNvbm5lY3RXaXRoICYmIGNvbm5lY3RlZCkge1xuXHRcdFx0Zm9yIChpID0gY29ubmVjdFdpdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0XHRjdXIgPSAkKGNvbm5lY3RXaXRoW2ldKTtcblx0XHRcdFx0Zm9yICggaiA9IGN1ci5sZW5ndGggLSAxOyBqID49IDA7IGotLSl7XG5cdFx0XHRcdFx0aW5zdCA9ICQuZGF0YShjdXJbal0sIHRoaXMud2lkZ2V0RnVsbE5hbWUpO1xuXHRcdFx0XHRcdGlmKGluc3QgJiYgaW5zdCAhPT0gdGhpcyAmJiAhaW5zdC5vcHRpb25zLmRpc2FibGVkKSB7XG5cdFx0XHRcdFx0XHRxdWVyaWVzLnB1c2goWyQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMuaXRlbXMpID8gaW5zdC5vcHRpb25zLml0ZW1zLmNhbGwoaW5zdC5lbGVtZW50KSA6ICQoaW5zdC5vcHRpb25zLml0ZW1zLCBpbnN0LmVsZW1lbnQpLm5vdChcIi51aS1zb3J0YWJsZS1oZWxwZXJcIikubm90KFwiLnVpLXNvcnRhYmxlLXBsYWNlaG9sZGVyXCIpLCBpbnN0XSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cXVlcmllcy5wdXNoKFskLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLml0ZW1zKSA/IHRoaXMub3B0aW9ucy5pdGVtcy5jYWxsKHRoaXMuZWxlbWVudCwgbnVsbCwgeyBvcHRpb25zOiB0aGlzLm9wdGlvbnMsIGl0ZW06IHRoaXMuY3VycmVudEl0ZW0gfSkgOiAkKHRoaXMub3B0aW9ucy5pdGVtcywgdGhpcy5lbGVtZW50KS5ub3QoXCIudWktc29ydGFibGUtaGVscGVyXCIpLm5vdChcIi51aS1zb3J0YWJsZS1wbGFjZWhvbGRlclwiKSwgdGhpc10pO1xuXG5cdFx0ZnVuY3Rpb24gYWRkSXRlbXMoKSB7XG5cdFx0XHRpdGVtcy5wdXNoKCB0aGlzICk7XG5cdFx0fVxuXHRcdGZvciAoaSA9IHF1ZXJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0cXVlcmllc1tpXVswXS5lYWNoKCBhZGRJdGVtcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiAkKGl0ZW1zKTtcblxuXHR9LFxuXG5cdF9yZW1vdmVDdXJyZW50c0Zyb21JdGVtczogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbGlzdCA9IHRoaXMuY3VycmVudEl0ZW0uZmluZChcIjpkYXRhKFwiICsgdGhpcy53aWRnZXROYW1lICsgXCItaXRlbSlcIik7XG5cblx0XHR0aGlzLml0ZW1zID0gJC5ncmVwKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRmb3IgKHZhciBqPTA7IGogPCBsaXN0Lmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmKGxpc3Rbal0gPT09IGl0ZW0uaXRlbVswXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cblx0fSxcblxuXHRfcmVmcmVzaEl0ZW1zOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dGhpcy5pdGVtcyA9IFtdO1xuXHRcdHRoaXMuY29udGFpbmVycyA9IFt0aGlzXTtcblxuXHRcdHZhciBpLCBqLCBjdXIsIGluc3QsIHRhcmdldERhdGEsIF9xdWVyaWVzLCBpdGVtLCBxdWVyaWVzTGVuZ3RoLFxuXHRcdFx0aXRlbXMgPSB0aGlzLml0ZW1zLFxuXHRcdFx0cXVlcmllcyA9IFtbJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5pdGVtcykgPyB0aGlzLm9wdGlvbnMuaXRlbXMuY2FsbCh0aGlzLmVsZW1lbnRbMF0sIGV2ZW50LCB7IGl0ZW06IHRoaXMuY3VycmVudEl0ZW0gfSkgOiAkKHRoaXMub3B0aW9ucy5pdGVtcywgdGhpcy5lbGVtZW50KSwgdGhpc11dLFxuXHRcdFx0Y29ubmVjdFdpdGggPSB0aGlzLl9jb25uZWN0V2l0aCgpO1xuXG5cdFx0aWYoY29ubmVjdFdpdGggJiYgdGhpcy5yZWFkeSkgeyAvL1Nob3VsZG4ndCBiZSBydW4gdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCBkdWUgdG8gbWFzc2l2ZSBzbG93LWRvd25cblx0XHRcdGZvciAoaSA9IGNvbm5lY3RXaXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0Y3VyID0gJChjb25uZWN0V2l0aFtpXSk7XG5cdFx0XHRcdGZvciAoaiA9IGN1ci5sZW5ndGggLSAxOyBqID49IDA7IGotLSl7XG5cdFx0XHRcdFx0aW5zdCA9ICQuZGF0YShjdXJbal0sIHRoaXMud2lkZ2V0RnVsbE5hbWUpO1xuXHRcdFx0XHRcdGlmKGluc3QgJiYgaW5zdCAhPT0gdGhpcyAmJiAhaW5zdC5vcHRpb25zLmRpc2FibGVkKSB7XG5cdFx0XHRcdFx0XHRxdWVyaWVzLnB1c2goWyQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMuaXRlbXMpID8gaW5zdC5vcHRpb25zLml0ZW1zLmNhbGwoaW5zdC5lbGVtZW50WzBdLCBldmVudCwgeyBpdGVtOiB0aGlzLmN1cnJlbnRJdGVtIH0pIDogJChpbnN0Lm9wdGlvbnMuaXRlbXMsIGluc3QuZWxlbWVudCksIGluc3RdKTtcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbmVycy5wdXNoKGluc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IHF1ZXJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHRhcmdldERhdGEgPSBxdWVyaWVzW2ldWzFdO1xuXHRcdFx0X3F1ZXJpZXMgPSBxdWVyaWVzW2ldWzBdO1xuXG5cdFx0XHRmb3IgKGo9MCwgcXVlcmllc0xlbmd0aCA9IF9xdWVyaWVzLmxlbmd0aDsgaiA8IHF1ZXJpZXNMZW5ndGg7IGorKykge1xuXHRcdFx0XHRpdGVtID0gJChfcXVlcmllc1tqXSk7XG5cblx0XHRcdFx0aXRlbS5kYXRhKHRoaXMud2lkZ2V0TmFtZSArIFwiLWl0ZW1cIiwgdGFyZ2V0RGF0YSk7IC8vIERhdGEgZm9yIHRhcmdldCBjaGVja2luZyAobW91c2UgbWFuYWdlcilcblxuXHRcdFx0XHRpdGVtcy5wdXNoKHtcblx0XHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHRcdGluc3RhbmNlOiB0YXJnZXREYXRhLFxuXHRcdFx0XHRcdHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG5cdFx0XHRcdFx0bGVmdDogMCwgdG9wOiAwXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9LFxuXG5cdHJlZnJlc2hQb3NpdGlvbnM6IGZ1bmN0aW9uKGZhc3QpIHtcblxuXHRcdC8vVGhpcyBoYXMgdG8gYmUgcmVkb25lIGJlY2F1c2UgZHVlIHRvIHRoZSBpdGVtIGJlaW5nIG1vdmVkIG91dC9pbnRvIHRoZSBvZmZzZXRQYXJlbnQsIHRoZSBvZmZzZXRQYXJlbnQncyBwb3NpdGlvbiB3aWxsIGNoYW5nZVxuXHRcdGlmKHRoaXMub2Zmc2V0UGFyZW50ICYmIHRoaXMuaGVscGVyKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaXRlbSwgdCwgcDtcblxuXHRcdGZvciAoaSA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cblx0XHRcdC8vV2UgaWdub3JlIGNhbGN1bGF0aW5nIHBvc2l0aW9ucyBvZiBhbGwgY29ubmVjdGVkIGNvbnRhaW5lcnMgd2hlbiB3ZSdyZSBub3Qgb3ZlciB0aGVtXG5cdFx0XHRpZihpdGVtLmluc3RhbmNlICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIgJiYgdGhpcy5jdXJyZW50Q29udGFpbmVyICYmIGl0ZW0uaXRlbVswXSAhPT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dCA9IHRoaXMub3B0aW9ucy50b2xlcmFuY2VFbGVtZW50ID8gJCh0aGlzLm9wdGlvbnMudG9sZXJhbmNlRWxlbWVudCwgaXRlbS5pdGVtKSA6IGl0ZW0uaXRlbTtcblxuXHRcdFx0aWYgKCFmYXN0KSB7XG5cdFx0XHRcdGl0ZW0ud2lkdGggPSB0Lm91dGVyV2lkdGgoKTtcblx0XHRcdFx0aXRlbS5oZWlnaHQgPSB0Lm91dGVySGVpZ2h0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHAgPSB0Lm9mZnNldCgpO1xuXHRcdFx0aXRlbS5sZWZ0ID0gcC5sZWZ0O1xuXHRcdFx0aXRlbS50b3AgPSBwLnRvcDtcblx0XHR9XG5cblx0XHRpZih0aGlzLm9wdGlvbnMuY3VzdG9tICYmIHRoaXMub3B0aW9ucy5jdXN0b20ucmVmcmVzaENvbnRhaW5lcnMpIHtcblx0XHRcdHRoaXMub3B0aW9ucy5jdXN0b20ucmVmcmVzaENvbnRhaW5lcnMuY2FsbCh0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0cCA9IHRoaXMuY29udGFpbmVyc1tpXS5lbGVtZW50Lm9mZnNldCgpO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUubGVmdCA9IHAubGVmdDtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLnRvcCA9IHAudG9wO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUud2lkdGhcdD0gdGhpcy5jb250YWluZXJzW2ldLmVsZW1lbnQub3V0ZXJXaWR0aCgpO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXJzW2ldLmVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfY3JlYXRlUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKHRoYXQpIHtcblx0XHR0aGF0ID0gdGhhdCB8fCB0aGlzO1xuXHRcdHZhciBjbGFzc05hbWUsXG5cdFx0XHRvID0gdGhhdC5vcHRpb25zO1xuXG5cdFx0aWYoIW8ucGxhY2Vob2xkZXIgfHwgby5wbGFjZWhvbGRlci5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG5cdFx0XHRjbGFzc05hbWUgPSBvLnBsYWNlaG9sZGVyO1xuXHRcdFx0by5wbGFjZWhvbGRlciA9IHtcblx0XHRcdFx0ZWxlbWVudDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHR2YXIgbm9kZU5hbWUgPSB0aGF0LmN1cnJlbnRJdGVtWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHRlbGVtZW50ID0gJCggXCI8XCIgKyBub2RlTmFtZSArIFwiPlwiLCB0aGF0LmRvY3VtZW50WzBdIClcblx0XHRcdFx0XHRcdFx0LmFkZENsYXNzKGNsYXNzTmFtZSB8fCB0aGF0LmN1cnJlbnRJdGVtWzBdLmNsYXNzTmFtZStcIiB1aS1zb3J0YWJsZS1wbGFjZWhvbGRlclwiKVxuXHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXCJ1aS1zb3J0YWJsZS1oZWxwZXJcIik7XG5cblx0XHRcdFx0XHRpZiAoIG5vZGVOYW1lID09PSBcInRyXCIgKSB7XG5cdFx0XHRcdFx0XHR0aGF0LmN1cnJlbnRJdGVtLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0JCggXCI8dGQ+JiMxNjA7PC90ZD5cIiwgdGhhdC5kb2N1bWVudFswXSApXG5cdFx0XHRcdFx0XHRcdFx0LmF0dHIoIFwiY29sc3BhblwiLCAkKCB0aGlzICkuYXR0ciggXCJjb2xzcGFuXCIgKSB8fCAxIClcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oIGVsZW1lbnQgKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImltZ1wiICkge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5hdHRyKCBcInNyY1wiLCB0aGF0LmN1cnJlbnRJdGVtLmF0dHIoIFwic3JjXCIgKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggIWNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHRcdGVsZW1lbnQuY3NzKCBcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgcCkge1xuXG5cdFx0XHRcdFx0Ly8gMS4gSWYgYSBjbGFzc05hbWUgaXMgc2V0IGFzICdwbGFjZWhvbGRlciBvcHRpb24sIHdlIGRvbid0IGZvcmNlIHNpemVzIC0gdGhlIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGF0XG5cdFx0XHRcdFx0Ly8gMi4gVGhlIG9wdGlvbiAnZm9yY2VQbGFjZWhvbGRlclNpemUgY2FuIGJlIGVuYWJsZWQgdG8gZm9yY2UgaXQgZXZlbiBpZiBhIGNsYXNzIG5hbWUgaXMgc3BlY2lmaWVkXG5cdFx0XHRcdFx0aWYoY2xhc3NOYW1lICYmICFvLmZvcmNlUGxhY2Vob2xkZXJTaXplKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9JZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBhY3R1YWwgaGVpZ2h0IGJ5IGl0c2VsZiAod2l0aG91dCBzdHlsZXMgY29taW5nIGZyb20gYSBzdHlsZXNoZWV0KSwgaXQgcmVjZWl2ZXMgdGhlIGlubGluZSBoZWlnaHQgZnJvbSB0aGUgZHJhZ2dlZCBpdGVtXG5cdFx0XHRcdFx0aWYoIXAuaGVpZ2h0KCkpIHsgcC5oZWlnaHQodGhhdC5jdXJyZW50SXRlbS5pbm5lckhlaWdodCgpIC0gcGFyc2VJbnQodGhhdC5jdXJyZW50SXRlbS5jc3MoXCJwYWRkaW5nVG9wXCIpfHwwLCAxMCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcyhcInBhZGRpbmdCb3R0b21cIil8fDAsIDEwKSk7IH1cblx0XHRcdFx0XHRpZighcC53aWR0aCgpKSB7IHAud2lkdGgodGhhdC5jdXJyZW50SXRlbS5pbm5lcldpZHRoKCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcyhcInBhZGRpbmdMZWZ0XCIpfHwwLCAxMCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcyhcInBhZGRpbmdSaWdodFwiKXx8MCwgMTApKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vQ3JlYXRlIHRoZSBwbGFjZWhvbGRlclxuXHRcdHRoYXQucGxhY2Vob2xkZXIgPSAkKG8ucGxhY2Vob2xkZXIuZWxlbWVudC5jYWxsKHRoYXQuZWxlbWVudCwgdGhhdC5jdXJyZW50SXRlbSkpO1xuXG5cdFx0Ly9BcHBlbmQgaXQgYWZ0ZXIgdGhlIGFjdHVhbCBjdXJyZW50IGl0ZW1cblx0XHR0aGF0LmN1cnJlbnRJdGVtLmFmdGVyKHRoYXQucGxhY2Vob2xkZXIpO1xuXG5cdFx0Ly9VcGRhdGUgdGhlIHNpemUgb2YgdGhlIHBsYWNlaG9sZGVyIChUT0RPOiBMb2dpYyB0byBmdXp6eSwgc2VlIGxpbmUgMzE2LzMxNylcblx0XHRvLnBsYWNlaG9sZGVyLnVwZGF0ZSh0aGF0LCB0aGF0LnBsYWNlaG9sZGVyKTtcblxuXHR9LFxuXG5cdF9jb250YWN0Q29udGFpbmVyczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgaSwgaiwgZGlzdCwgaXRlbVdpdGhMZWFzdERpc3RhbmNlLCBwb3NQcm9wZXJ0eSwgc2l6ZVByb3BlcnR5LCBiYXNlLCBjdXIsIG5lYXJCb3R0b20sIGZsb2F0aW5nLFxuXHRcdFx0aW5uZXJtb3N0Q29udGFpbmVyID0gbnVsbCxcblx0XHRcdGlubmVybW9zdEluZGV4ID0gbnVsbDtcblxuXHRcdC8vIGdldCBpbm5lcm1vc3QgY29udGFpbmVyIHRoYXQgaW50ZXJzZWN0cyB3aXRoIGl0ZW1cblx0XHRmb3IgKGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblxuXHRcdFx0Ly8gbmV2ZXIgY29uc2lkZXIgYSBjb250YWluZXIgdGhhdCdzIGxvY2F0ZWQgd2l0aGluIHRoZSBpdGVtIGl0c2VsZlxuXHRcdFx0aWYoJC5jb250YWlucyh0aGlzLmN1cnJlbnRJdGVtWzBdLCB0aGlzLmNvbnRhaW5lcnNbaV0uZWxlbWVudFswXSkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuX2ludGVyc2VjdHNXaXRoKHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZSkpIHtcblxuXHRcdFx0XHQvLyBpZiB3ZSd2ZSBhbHJlYWR5IGZvdW5kIGEgY29udGFpbmVyIGFuZCBpdCdzIG1vcmUgXCJpbm5lclwiIHRoYW4gdGhpcywgdGhlbiBjb250aW51ZVxuXHRcdFx0XHRpZihpbm5lcm1vc3RDb250YWluZXIgJiYgJC5jb250YWlucyh0aGlzLmNvbnRhaW5lcnNbaV0uZWxlbWVudFswXSwgaW5uZXJtb3N0Q29udGFpbmVyLmVsZW1lbnRbMF0pKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbm5lcm1vc3RDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcnNbaV07XG5cdFx0XHRcdGlubmVybW9zdEluZGV4ID0gaTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY29udGFpbmVyIGRvZXNuJ3QgaW50ZXJzZWN0LiB0cmlnZ2VyIFwib3V0XCIgZXZlbnQgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdGlmKHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyKSB7XG5cdFx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLl90cmlnZ2VyKFwib3V0XCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpO1xuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaWYgbm8gaW50ZXJzZWN0aW5nIGNvbnRhaW5lcnMgZm91bmQsIHJldHVyblxuXHRcdGlmKCFpbm5lcm1vc3RDb250YWluZXIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBtb3ZlIHRoZSBpdGVtIGludG8gdGhlIGNvbnRhaW5lciBpZiBpdCdzIG5vdCB0aGVyZSBhbHJlYWR5XG5cdFx0aWYodGhpcy5jb250YWluZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0aWYgKCF0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmNvbnRhaW5lckNhY2hlLm92ZXIpIHtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5fdHJpZ2dlcihcIm92ZXJcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uY29udGFpbmVyQ2FjaGUub3ZlciA9IDE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly9XaGVuIGVudGVyaW5nIGEgbmV3IGNvbnRhaW5lciwgd2Ugd2lsbCBmaW5kIHRoZSBpdGVtIHdpdGggdGhlIGxlYXN0IGRpc3RhbmNlIGFuZCBhcHBlbmQgb3VyIGl0ZW0gbmVhciBpdFxuXHRcdFx0ZGlzdCA9IDEwMDAwO1xuXHRcdFx0aXRlbVdpdGhMZWFzdERpc3RhbmNlID0gbnVsbDtcblx0XHRcdGZsb2F0aW5nID0gaW5uZXJtb3N0Q29udGFpbmVyLmZsb2F0aW5nIHx8IGlzRmxvYXRpbmcodGhpcy5jdXJyZW50SXRlbSk7XG5cdFx0XHRwb3NQcm9wZXJ0eSA9IGZsb2F0aW5nID8gXCJsZWZ0XCIgOiBcInRvcFwiO1xuXHRcdFx0c2l6ZVByb3BlcnR5ID0gZmxvYXRpbmcgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiO1xuXHRcdFx0YmFzZSA9IHRoaXMucG9zaXRpb25BYnNbcG9zUHJvcGVydHldICsgdGhpcy5vZmZzZXQuY2xpY2tbcG9zUHJvcGVydHldO1xuXHRcdFx0Zm9yIChqID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRpZighJC5jb250YWlucyh0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmVsZW1lbnRbMF0sIHRoaXMuaXRlbXNbal0uaXRlbVswXSkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0aGlzLml0ZW1zW2pdLml0ZW1bMF0gPT09IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZmxvYXRpbmcgJiYgIWlzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy50b3AgKyB0aGlzLm9mZnNldC5jbGljay50b3AsIHRoaXMuaXRlbXNbal0udG9wLCB0aGlzLml0ZW1zW2pdLmhlaWdodCkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXIgPSB0aGlzLml0ZW1zW2pdLml0ZW0ub2Zmc2V0KClbcG9zUHJvcGVydHldO1xuXHRcdFx0XHRuZWFyQm90dG9tID0gZmFsc2U7XG5cdFx0XHRcdGlmKE1hdGguYWJzKGN1ciAtIGJhc2UpID4gTWF0aC5hYnMoY3VyICsgdGhpcy5pdGVtc1tqXVtzaXplUHJvcGVydHldIC0gYmFzZSkpe1xuXHRcdFx0XHRcdG5lYXJCb3R0b20gPSB0cnVlO1xuXHRcdFx0XHRcdGN1ciArPSB0aGlzLml0ZW1zW2pdW3NpemVQcm9wZXJ0eV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihNYXRoLmFicyhjdXIgLSBiYXNlKSA8IGRpc3QpIHtcblx0XHRcdFx0XHRkaXN0ID0gTWF0aC5hYnMoY3VyIC0gYmFzZSk7IGl0ZW1XaXRoTGVhc3REaXN0YW5jZSA9IHRoaXMuaXRlbXNbal07XG5cdFx0XHRcdFx0dGhpcy5kaXJlY3Rpb24gPSBuZWFyQm90dG9tID8gXCJ1cFwiOiBcImRvd25cIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL0NoZWNrIGlmIGRyb3BPbkVtcHR5IGlzIGVuYWJsZWRcblx0XHRcdGlmKCFpdGVtV2l0aExlYXN0RGlzdGFuY2UgJiYgIXRoaXMub3B0aW9ucy5kcm9wT25FbXB0eSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuY3VycmVudENvbnRhaW5lciA9PT0gdGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGl0ZW1XaXRoTGVhc3REaXN0YW5jZSA/IHRoaXMuX3JlYXJyYW5nZShldmVudCwgaXRlbVdpdGhMZWFzdERpc3RhbmNlLCBudWxsLCB0cnVlKSA6IHRoaXMuX3JlYXJyYW5nZShldmVudCwgbnVsbCwgdGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5lbGVtZW50LCB0cnVlKTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoXCJjaGFuZ2VcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblx0XHRcdHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uX3RyaWdnZXIoXCJjaGFuZ2VcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XG5cdFx0XHR0aGlzLmN1cnJlbnRDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdO1xuXG5cdFx0XHQvL1VwZGF0ZSB0aGUgcGxhY2Vob2xkZXJcblx0XHRcdHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlci51cGRhdGUodGhpcy5jdXJyZW50Q29udGFpbmVyLCB0aGlzLnBsYWNlaG9sZGVyKTtcblxuXHRcdFx0dGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5fdHJpZ2dlcihcIm92ZXJcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XG5cdFx0XHR0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAxO1xuXHRcdH1cblxuXG5cdH0sXG5cblx0X2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0aGVscGVyID0gJC5pc0Z1bmN0aW9uKG8uaGVscGVyKSA/ICQoby5oZWxwZXIuYXBwbHkodGhpcy5lbGVtZW50WzBdLCBbZXZlbnQsIHRoaXMuY3VycmVudEl0ZW1dKSkgOiAoby5oZWxwZXIgPT09IFwiY2xvbmVcIiA/IHRoaXMuY3VycmVudEl0ZW0uY2xvbmUoKSA6IHRoaXMuY3VycmVudEl0ZW0pO1xuXG5cdFx0Ly9BZGQgdGhlIGhlbHBlciB0byB0aGUgRE9NIGlmIHRoYXQgZGlkbid0IGhhcHBlbiBhbHJlYWR5XG5cdFx0aWYoIWhlbHBlci5wYXJlbnRzKFwiYm9keVwiKS5sZW5ndGgpIHtcblx0XHRcdCQoby5hcHBlbmRUbyAhPT0gXCJwYXJlbnRcIiA/IG8uYXBwZW5kVG8gOiB0aGlzLmN1cnJlbnRJdGVtWzBdLnBhcmVudE5vZGUpWzBdLmFwcGVuZENoaWxkKGhlbHBlclswXSk7XG5cdFx0fVxuXG5cdFx0aWYoaGVscGVyWzBdID09PSB0aGlzLmN1cnJlbnRJdGVtWzBdKSB7XG5cdFx0XHR0aGlzLl9zdG9yZWRDU1MgPSB7IHdpZHRoOiB0aGlzLmN1cnJlbnRJdGVtWzBdLnN0eWxlLndpZHRoLCBoZWlnaHQ6IHRoaXMuY3VycmVudEl0ZW1bMF0uc3R5bGUuaGVpZ2h0LCBwb3NpdGlvbjogdGhpcy5jdXJyZW50SXRlbS5jc3MoXCJwb3NpdGlvblwiKSwgdG9wOiB0aGlzLmN1cnJlbnRJdGVtLmNzcyhcInRvcFwiKSwgbGVmdDogdGhpcy5jdXJyZW50SXRlbS5jc3MoXCJsZWZ0XCIpIH07XG5cdFx0fVxuXG5cdFx0aWYoIWhlbHBlclswXS5zdHlsZS53aWR0aCB8fCBvLmZvcmNlSGVscGVyU2l6ZSkge1xuXHRcdFx0aGVscGVyLndpZHRoKHRoaXMuY3VycmVudEl0ZW0ud2lkdGgoKSk7XG5cdFx0fVxuXHRcdGlmKCFoZWxwZXJbMF0uc3R5bGUuaGVpZ2h0IHx8IG8uZm9yY2VIZWxwZXJTaXplKSB7XG5cdFx0XHRoZWxwZXIuaGVpZ2h0KHRoaXMuY3VycmVudEl0ZW0uaGVpZ2h0KCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBoZWxwZXI7XG5cblx0fSxcblxuXHRfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0aWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdG9iaiA9IG9iai5zcGxpdChcIiBcIik7XG5cdFx0fVxuXHRcdGlmICgkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0b2JqID0ge2xlZnQ6ICtvYmpbMF0sIHRvcDogK29ialsxXSB8fCAwfTtcblx0XHR9XG5cdFx0aWYgKFwibGVmdFwiIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IG9iai5sZWZ0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XG5cdFx0fVxuXHRcdGlmIChcInJpZ2h0XCIgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIG9iai5yaWdodCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoXCJ0b3BcIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IG9iai50b3AgKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0XHRpZiAoXCJib3R0b21cIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gb2JqLmJvdHRvbSArIHRoaXMubWFyZ2lucy50b3A7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRQYXJlbnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXG5cblx0XHQvL0dldCB0aGUgb2Zmc2V0UGFyZW50IGFuZCBjYWNoZSBpdHMgcG9zaXRpb25cblx0XHR0aGlzLm9mZnNldFBhcmVudCA9IHRoaXMuaGVscGVyLm9mZnNldFBhcmVudCgpO1xuXHRcdHZhciBwbyA9IHRoaXMub2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIG1vZGlmeSBhIG9mZnNldCBjYWxjdWxhdGVkIG9uIHN0YXJ0LCBzaW5jZSB0aGUgZm9sbG93aW5nIGhhcHBlbmVkOlxuXHRcdC8vIDEuIFRoZSBwb3NpdGlvbiBvZiB0aGUgaGVscGVyIGlzIGFic29sdXRlLCBzbyBpdCdzIHBvc2l0aW9uIGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIG5leHQgcG9zaXRpb25lZCBwYXJlbnRcblx0XHQvLyAyLiBUaGUgYWN0dWFsIG9mZnNldCBwYXJlbnQgaXMgYSBjaGlsZCBvZiB0aGUgc2Nyb2xsIHBhcmVudCwgYW5kIHRoZSBzY3JvbGwgcGFyZW50IGlzbid0IHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhhdFxuXHRcdC8vICAgIHRoZSBzY3JvbGwgaXMgaW5jbHVkZWQgaW4gdGhlIGluaXRpYWwgY2FsY3VsYXRpb24gb2YgdGhlIG9mZnNldCBvZiB0aGUgcGFyZW50LCBhbmQgbmV2ZXIgcmVjYWxjdWxhdGVkIHVwb24gZHJhZ1xuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiB0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XG5cdFx0XHRwby5sZWZ0ICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTtcblx0XHRcdHBvLnRvcCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTtcblx0XHR9XG5cblx0XHQvLyBUaGlzIG5lZWRzIHRvIGJlIGFjdHVhbGx5IGRvbmUgZm9yIGFsbCBicm93c2Vycywgc2luY2UgcGFnZVgvcGFnZVkgaW5jbHVkZXMgdGhpcyBpbmZvcm1hdGlvblxuXHRcdC8vIHdpdGggYW4gdWdseSBJRSBmaXhcblx0XHRpZiggdGhpcy5vZmZzZXRQYXJlbnRbMF0gPT09IGRvY3VtZW50LmJvZHkgfHwgKHRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUgJiYgdGhpcy5vZmZzZXRQYXJlbnRbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImh0bWxcIiAmJiAkLnVpLmllKSkge1xuXHRcdFx0cG8gPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHBvLnRvcCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCkgfHwgMCksXG5cdFx0XHRsZWZ0OiBwby5sZWZ0ICsgKHBhcnNlSW50KHRoaXMub2Zmc2V0UGFyZW50LmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSwxMCkgfHwgMClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2dldFJlbGF0aXZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT09IFwicmVsYXRpdmVcIikge1xuXHRcdFx0dmFyIHAgPSB0aGlzLmN1cnJlbnRJdGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IHAudG9wIC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcInRvcFwiKSwxMCkgfHwgMCkgKyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSxcblx0XHRcdFx0bGVmdDogcC5sZWZ0IC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcImxlZnRcIiksMTApIHx8IDApICsgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0fSxcblxuXHRfY2FjaGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm1hcmdpbnMgPSB7XG5cdFx0XHRsZWZ0OiAocGFyc2VJbnQodGhpcy5jdXJyZW50SXRlbS5jc3MoXCJtYXJnaW5MZWZ0XCIpLDEwKSB8fCAwKSxcblx0XHRcdHRvcDogKHBhcnNlSW50KHRoaXMuY3VycmVudEl0ZW0uY3NzKFwibWFyZ2luVG9wXCIpLDEwKSB8fCAwKVxuXHRcdH07XG5cdH0sXG5cblx0X2NhY2hlSGVscGVyUHJvcG9ydGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMgPSB7XG5cdFx0XHR3aWR0aDogdGhpcy5oZWxwZXIub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmhlbHBlci5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fSxcblxuXHRfc2V0Q29udGFpbm1lbnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGNlLCBjbywgb3Zlcixcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0aWYoby5jb250YWlubWVudCA9PT0gXCJwYXJlbnRcIikge1xuXHRcdFx0by5jb250YWlubWVudCA9IHRoaXMuaGVscGVyWzBdLnBhcmVudE5vZGU7XG5cdFx0fVxuXHRcdGlmKG8uY29udGFpbm1lbnQgPT09IFwiZG9jdW1lbnRcIiB8fCBvLmNvbnRhaW5tZW50ID09PSBcIndpbmRvd1wiKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHQwIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0LFxuXHRcdFx0XHQwIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCxcblx0XHRcdFx0JChvLmNvbnRhaW5tZW50ID09PSBcImRvY3VtZW50XCIgPyBkb2N1bWVudCA6IHdpbmRvdykud2lkdGgoKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0KCQoby5jb250YWlubWVudCA9PT0gXCJkb2N1bWVudFwiID8gZG9jdW1lbnQgOiB3aW5kb3cpLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdH1cblxuXHRcdGlmKCEoL14oZG9jdW1lbnR8d2luZG93fHBhcmVudCkkLykudGVzdChvLmNvbnRhaW5tZW50KSkge1xuXHRcdFx0Y2UgPSAkKG8uY29udGFpbm1lbnQpWzBdO1xuXHRcdFx0Y28gPSAkKG8uY29udGFpbm1lbnQpLm9mZnNldCgpO1xuXHRcdFx0b3ZlciA9ICgkKGNlKS5jc3MoXCJvdmVyZmxvd1wiKSAhPT0gXCJoaWRkZW5cIik7XG5cblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdGNvLmxlZnQgKyAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpLDEwKSB8fCAwKSArIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nTGVmdFwiKSwxMCkgfHwgMCkgLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0Y28udG9wICsgKHBhcnNlSW50KCQoY2UpLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpLDEwKSB8fCAwKSArIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nVG9wXCIpLDEwKSB8fCAwKSAtIHRoaXMubWFyZ2lucy50b3AsXG5cdFx0XHRcdGNvLmxlZnQrKG92ZXIgPyBNYXRoLm1heChjZS5zY3JvbGxXaWR0aCxjZS5vZmZzZXRXaWR0aCkgOiBjZS5vZmZzZXRXaWR0aCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpLDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nUmlnaHRcIiksMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHRjby50b3ArKG92ZXIgPyBNYXRoLm1heChjZS5zY3JvbGxIZWlnaHQsY2Uub2Zmc2V0SGVpZ2h0KSA6IGNlLm9mZnNldEhlaWdodCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApIHx8IDApIC0gKHBhcnNlSW50KCQoY2UpLmNzcyhcInBhZGRpbmdCb3R0b21cIiksMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdH1cblxuXHR9LFxuXG5cdF9jb252ZXJ0UG9zaXRpb25UbzogZnVuY3Rpb24oZCwgcG9zKSB7XG5cblx0XHRpZighcG9zKSB7XG5cdFx0XHRwb3MgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdH1cblx0XHR2YXIgbW9kID0gZCA9PT0gXCJhYnNvbHV0ZVwiID8gMSA6IC0xLFxuXHRcdFx0c2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmICEodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT09IGRvY3VtZW50ICYmICQuY29udGFpbnModGhpcy5zY3JvbGxQYXJlbnRbMF0sIHRoaXMub2Zmc2V0UGFyZW50WzBdKSkgPyB0aGlzLm9mZnNldFBhcmVudCA6IHRoaXMuc2Nyb2xsUGFyZW50LFxuXHRcdFx0c2Nyb2xsSXNSb290Tm9kZSA9ICgvKGh0bWx8Ym9keSkvaSkudGVzdChzY3JvbGxbMF0udGFnTmFtZSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiAoXG5cdFx0XHRcdHBvcy50b3BcdCtcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgKiBtb2QgK1x0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC50b3AgKiBtb2QgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogKCBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxUb3AoKSApICkgKiBtb2QpXG5cdFx0XHQpLFxuXHRcdFx0bGVmdDogKFxuXHRcdFx0XHRwb3MubGVmdCArXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAqIG1vZCArXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LmxlZnQgKiBtb2RcdC1cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpIDogc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsTGVmdCgpICkgKiBtb2QpXG5cdFx0XHQpXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9nZW5lcmF0ZVBvc2l0aW9uOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIHRvcCwgbGVmdCxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRwYWdlWCA9IGV2ZW50LnBhZ2VYLFxuXHRcdFx0cGFnZVkgPSBldmVudC5wYWdlWSxcblx0XHRcdHNjcm9sbCA9IHRoaXMuY3NzUG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiAhKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLCB0aGlzLm9mZnNldFBhcmVudFswXSkpID8gdGhpcy5vZmZzZXRQYXJlbnQgOiB0aGlzLnNjcm9sbFBhcmVudCwgc2Nyb2xsSXNSb290Tm9kZSA9ICgvKGh0bWx8Ym9keSkvaSkudGVzdChzY3JvbGxbMF0udGFnTmFtZSk7XG5cblx0XHQvLyBUaGlzIGlzIGFub3RoZXIgdmVyeSB3ZWlyZCBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGhhcHBlbnMgZm9yIHJlbGF0aXZlIGVsZW1lbnRzOlxuXHRcdC8vIDEuIElmIHRoZSBjc3MgcG9zaXRpb24gaXMgcmVsYXRpdmVcblx0XHQvLyAyLiBhbmQgdGhlIHNjcm9sbCBwYXJlbnQgaXMgdGhlIGRvY3VtZW50IG9yIHNpbWlsYXIgdG8gdGhlIG9mZnNldCBwYXJlbnRcblx0XHQvLyB3ZSBoYXZlIHRvIHJlZnJlc2ggdGhlIHJlbGF0aXZlIG9mZnNldCBkdXJpbmcgdGhlIHNjcm9sbCBzbyB0aGVyZSBhcmUgbm8ganVtcHNcblx0XHRpZih0aGlzLmNzc1Bvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgJiYgISh0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgdGhpcy5zY3JvbGxQYXJlbnRbMF0gIT09IHRoaXMub2Zmc2V0UGFyZW50WzBdKSkge1xuXHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUgPSB0aGlzLl9nZXRSZWxhdGl2ZU9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0ICogLSBQb3NpdGlvbiBjb25zdHJhaW5pbmcgLVxuXHRcdCAqIENvbnN0cmFpbiB0aGUgcG9zaXRpb24gdG8gYSBtaXggb2YgZ3JpZCwgY29udGFpbm1lbnQuXG5cdFx0ICovXG5cblx0XHRpZih0aGlzLm9yaWdpbmFsUG9zaXRpb24pIHsgLy9JZiB3ZSBhcmUgbm90IGRyYWdnaW5nIHlldCwgd2Ugd29uJ3QgY2hlY2sgZm9yIG9wdGlvbnNcblxuXHRcdFx0aWYodGhpcy5jb250YWlubWVudCkge1xuXHRcdFx0XHRpZihldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPCB0aGlzLmNvbnRhaW5tZW50WzBdKSB7XG5cdFx0XHRcdFx0cGFnZVggPSB0aGlzLmNvbnRhaW5tZW50WzBdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IHRoaXMuY29udGFpbm1lbnRbMV0pIHtcblx0XHRcdFx0XHRwYWdlWSA9IHRoaXMuY29udGFpbm1lbnRbMV0gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID4gdGhpcy5jb250YWlubWVudFsyXSkge1xuXHRcdFx0XHRcdHBhZ2VYID0gdGhpcy5jb250YWlubWVudFsyXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPiB0aGlzLmNvbnRhaW5tZW50WzNdKSB7XG5cdFx0XHRcdFx0cGFnZVkgPSB0aGlzLmNvbnRhaW5tZW50WzNdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKG8uZ3JpZCkge1xuXHRcdFx0XHR0b3AgPSB0aGlzLm9yaWdpbmFsUGFnZVkgKyBNYXRoLnJvdW5kKChwYWdlWSAtIHRoaXMub3JpZ2luYWxQYWdlWSkgLyBvLmdyaWRbMV0pICogby5ncmlkWzFdO1xuXHRcdFx0XHRwYWdlWSA9IHRoaXMuY29udGFpbm1lbnQgPyAoICh0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPj0gdGhpcy5jb250YWlubWVudFsxXSAmJiB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPD0gdGhpcy5jb250YWlubWVudFszXSkgPyB0b3AgOiAoKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSB0aGlzLmNvbnRhaW5tZW50WzFdKSA/IHRvcCAtIG8uZ3JpZFsxXSA6IHRvcCArIG8uZ3JpZFsxXSkpIDogdG9wO1xuXG5cdFx0XHRcdGxlZnQgPSB0aGlzLm9yaWdpbmFsUGFnZVggKyBNYXRoLnJvdW5kKChwYWdlWCAtIHRoaXMub3JpZ2luYWxQYWdlWCkgLyBvLmdyaWRbMF0pICogby5ncmlkWzBdO1xuXHRcdFx0XHRwYWdlWCA9IHRoaXMuY29udGFpbm1lbnQgPyAoIChsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSB0aGlzLmNvbnRhaW5tZW50WzBdICYmIGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDw9IHRoaXMuY29udGFpbm1lbnRbMl0pID8gbGVmdCA6ICgobGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPj0gdGhpcy5jb250YWlubWVudFswXSkgPyBsZWZ0IC0gby5ncmlkWzBdIDogbGVmdCArIG8uZ3JpZFswXSkpIDogbGVmdDtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblx0XHRcdFx0cGFnZVkgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCAtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3BcdC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC50b3AgK1x0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCkgOiAoIHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbFRvcCgpICkgKSlcblx0XHRcdCksXG5cdFx0XHRsZWZ0OiAoXG5cdFx0XHRcdHBhZ2VYIC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0IC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0XHQtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCArXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KCAoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxMZWZ0KCkgKSlcblx0XHRcdClcblx0XHR9O1xuXG5cdH0sXG5cblx0X3JlYXJyYW5nZTogZnVuY3Rpb24oZXZlbnQsIGksIGEsIGhhcmRSZWZyZXNoKSB7XG5cblx0XHRhID8gYVswXS5hcHBlbmRDaGlsZCh0aGlzLnBsYWNlaG9sZGVyWzBdKSA6IGkuaXRlbVswXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnBsYWNlaG9sZGVyWzBdLCAodGhpcy5kaXJlY3Rpb24gPT09IFwiZG93blwiID8gaS5pdGVtWzBdIDogaS5pdGVtWzBdLm5leHRTaWJsaW5nKSk7XG5cblx0XHQvL1ZhcmlvdXMgdGhpbmdzIGRvbmUgaGVyZSB0byBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZTpcblx0XHQvLyAxLiB3ZSBjcmVhdGUgYSBzZXRUaW1lb3V0LCB0aGF0IGNhbGxzIHJlZnJlc2hQb3NpdGlvbnNcblx0XHQvLyAyLiBvbiB0aGUgaW5zdGFuY2UsIHdlIGhhdmUgYSBjb3VudGVyIHZhcmlhYmxlLCB0aGF0IGdldCdzIGhpZ2hlciBhZnRlciBldmVyeSBhcHBlbmRcblx0XHQvLyAzLiBvbiB0aGUgbG9jYWwgc2NvcGUsIHdlIGNvcHkgdGhlIGNvdW50ZXIgdmFyaWFibGUsIGFuZCBjaGVjayBpbiB0aGUgdGltZW91dCwgaWYgaXQncyBzdGlsbCB0aGUgc2FtZVxuXHRcdC8vIDQuIHRoaXMgbGV0cyBvbmx5IHRoZSBsYXN0IGFkZGl0aW9uIHRvIHRoZSB0aW1lb3V0IHN0YWNrIHRocm91Z2hcblx0XHR0aGlzLmNvdW50ZXIgPSB0aGlzLmNvdW50ZXIgPyArK3RoaXMuY291bnRlciA6IDE7XG5cdFx0dmFyIGNvdW50ZXIgPSB0aGlzLmNvdW50ZXI7XG5cblx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdGlmKGNvdW50ZXIgPT09IHRoaXMuY291bnRlcikge1xuXHRcdFx0XHR0aGlzLnJlZnJlc2hQb3NpdGlvbnMoIWhhcmRSZWZyZXNoKTsgLy9QcmVjb21wdXRlIGFmdGVyIGVhY2ggRE9NIGluc2VydGlvbiwgTk9UIG9uIG1vdXNlbW92ZVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbihldmVudCwgbm9Qcm9wYWdhdGlvbikge1xuXG5cdFx0dGhpcy5yZXZlcnRpbmcgPSBmYWxzZTtcblx0XHQvLyBXZSBkZWxheSBhbGwgZXZlbnRzIHRoYXQgaGF2ZSB0byBiZSB0cmlnZ2VyZWQgdG8gYWZ0ZXIgdGhlIHBvaW50IHdoZXJlIHRoZSBwbGFjZWhvbGRlciBoYXMgYmVlbiByZW1vdmVkIGFuZFxuXHRcdC8vIGV2ZXJ5dGhpbmcgZWxzZSBub3JtYWxpemVkIGFnYWluXG5cdFx0dmFyIGksXG5cdFx0XHRkZWxheWVkVHJpZ2dlcnMgPSBbXTtcblxuXHRcdC8vIFdlIGZpcnN0IGhhdmUgdG8gdXBkYXRlIHRoZSBkb20gcG9zaXRpb24gb2YgdGhlIGFjdHVhbCBjdXJyZW50SXRlbVxuXHRcdC8vIE5vdGU6IGRvbid0IGRvIGl0IGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYWxyZWFkeSByZW1vdmVkIChieSBhIHVzZXIpLCBvciBpdCBnZXRzIHJlYXBwZW5kZWQgKHNlZSAjNDA4OClcblx0XHRpZighdGhpcy5fbm9GaW5hbFNvcnQgJiYgdGhpcy5jdXJyZW50SXRlbS5wYXJlbnQoKS5sZW5ndGgpIHtcblx0XHRcdHRoaXMucGxhY2Vob2xkZXIuYmVmb3JlKHRoaXMuY3VycmVudEl0ZW0pO1xuXHRcdH1cblx0XHR0aGlzLl9ub0ZpbmFsU29ydCA9IG51bGw7XG5cblx0XHRpZih0aGlzLmhlbHBlclswXSA9PT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xuXHRcdFx0Zm9yKGkgaW4gdGhpcy5fc3RvcmVkQ1NTKSB7XG5cdFx0XHRcdGlmKHRoaXMuX3N0b3JlZENTU1tpXSA9PT0gXCJhdXRvXCIgfHwgdGhpcy5fc3RvcmVkQ1NTW2ldID09PSBcInN0YXRpY1wiKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RvcmVkQ1NTW2ldID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5jdXJyZW50SXRlbS5jc3ModGhpcy5fc3RvcmVkQ1NTKS5yZW1vdmVDbGFzcyhcInVpLXNvcnRhYmxlLWhlbHBlclwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jdXJyZW50SXRlbS5zaG93KCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5mcm9tT3V0c2lkZSAmJiAhbm9Qcm9wYWdhdGlvbikge1xuXHRcdFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goZnVuY3Rpb24oZXZlbnQpIHsgdGhpcy5fdHJpZ2dlcihcInJlY2VpdmVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzLmZyb21PdXRzaWRlKSk7IH0pO1xuXHRcdH1cblx0XHRpZigodGhpcy5mcm9tT3V0c2lkZSB8fCB0aGlzLmRvbVBvc2l0aW9uLnByZXYgIT09IHRoaXMuY3VycmVudEl0ZW0ucHJldigpLm5vdChcIi51aS1zb3J0YWJsZS1oZWxwZXJcIilbMF0gfHwgdGhpcy5kb21Qb3NpdGlvbi5wYXJlbnQgIT09IHRoaXMuY3VycmVudEl0ZW0ucGFyZW50KClbMF0pICYmICFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHRkZWxheWVkVHJpZ2dlcnMucHVzaChmdW5jdGlvbihldmVudCkgeyB0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7IH0pOyAvL1RyaWdnZXIgdXBkYXRlIGNhbGxiYWNrIGlmIHRoZSBET00gcG9zaXRpb24gaGFzIGNoYW5nZWRcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgaXRlbXMgQ29udGFpbmVyIGhhcyBDaGFuZ2VkIGFuZCB0cmlnZ2VyIGFwcHJvcHJpYXRlXG5cdFx0Ly8gZXZlbnRzLlxuXHRcdGlmICh0aGlzICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcblx0XHRcdGlmKCFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKGZ1bmN0aW9uKGV2ZW50KSB7IHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTsgfSk7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKChmdW5jdGlvbihjKSB7IHJldHVybiBmdW5jdGlvbihldmVudCkgeyBjLl90cmlnZ2VyKFwicmVjZWl2ZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTsgfTsgIH0pLmNhbGwodGhpcywgdGhpcy5jdXJyZW50Q29udGFpbmVyKSk7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKChmdW5jdGlvbihjKSB7IHJldHVybiBmdW5jdGlvbihldmVudCkgeyBjLl90cmlnZ2VyKFwidXBkYXRlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpOyAgfTsgfSkuY2FsbCh0aGlzLCB0aGlzLmN1cnJlbnRDb250YWluZXIpKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdC8vUG9zdCBldmVudHMgdG8gY29udGFpbmVyc1xuXHRcdGZ1bmN0aW9uIGRlbGF5RXZlbnQoIHR5cGUsIGluc3RhbmNlLCBjb250YWluZXIgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRjb250YWluZXIuX3RyaWdnZXIoIHR5cGUsIGV2ZW50LCBpbnN0YW5jZS5fdWlIYXNoKCBpbnN0YW5jZSApICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRmb3IgKGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0aWYgKCFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKCBkZWxheUV2ZW50KCBcImRlYWN0aXZhdGVcIiwgdGhpcywgdGhpcy5jb250YWluZXJzWyBpIF0gKSApO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIpIHtcblx0XHRcdFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goIGRlbGF5RXZlbnQoIFwib3V0XCIsIHRoaXMsIHRoaXMuY29udGFpbmVyc1sgaSBdICkgKTtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vRG8gd2hhdCB3YXMgb3JpZ2luYWxseSBpbiBwbHVnaW5zXG5cdFx0aWYgKCB0aGlzLnN0b3JlZEN1cnNvciApIHtcblx0XHRcdHRoaXMuZG9jdW1lbnQuZmluZCggXCJib2R5XCIgKS5jc3MoIFwiY3Vyc29yXCIsIHRoaXMuc3RvcmVkQ3Vyc29yICk7XG5cdFx0XHR0aGlzLnN0b3JlZFN0eWxlc2hlZXQucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdGlmKHRoaXMuX3N0b3JlZE9wYWNpdHkpIHtcblx0XHRcdHRoaXMuaGVscGVyLmNzcyhcIm9wYWNpdHlcIiwgdGhpcy5fc3RvcmVkT3BhY2l0eSk7XG5cdFx0fVxuXHRcdGlmKHRoaXMuX3N0b3JlZFpJbmRleCkge1xuXHRcdFx0dGhpcy5oZWxwZXIuY3NzKFwiekluZGV4XCIsIHRoaXMuX3N0b3JlZFpJbmRleCA9PT0gXCJhdXRvXCIgPyBcIlwiIDogdGhpcy5fc3RvcmVkWkluZGV4KTtcblx0XHR9XG5cblx0XHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cdFx0aWYodGhpcy5jYW5jZWxIZWxwZXJSZW1vdmFsKSB7XG5cdFx0XHRpZighbm9Qcm9wYWdhdGlvbikge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKFwiYmVmb3JlU3RvcFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXHRcdFx0XHRmb3IgKGk9MDsgaSA8IGRlbGF5ZWRUcmlnZ2Vycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdFx0fSAvL1RyaWdnZXIgYWxsIGRlbGF5ZWQgZXZlbnRzXG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoXCJzdG9wXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZnJvbU91dHNpZGUgPSBmYWxzZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZighbm9Qcm9wYWdhdGlvbikge1xuXHRcdFx0dGhpcy5fdHJpZ2dlcihcImJlZm9yZVN0b3BcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblx0XHR9XG5cblx0XHQvLyQodGhpcy5wbGFjZWhvbGRlclswXSkucmVtb3ZlKCk7IHdvdWxkIGhhdmUgYmVlbiB0aGUgalF1ZXJ5IHdheSAtIHVuZm9ydHVuYXRlbHksIGl0IHVuYmluZHMgQUxMIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBub2RlIVxuXHRcdHRoaXMucGxhY2Vob2xkZXJbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBsYWNlaG9sZGVyWzBdKTtcblxuXHRcdGlmKHRoaXMuaGVscGVyWzBdICE9PSB0aGlzLmN1cnJlbnRJdGVtWzBdKSB7XG5cdFx0XHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dGhpcy5oZWxwZXIgPSBudWxsO1xuXG5cdFx0aWYoIW5vUHJvcGFnYXRpb24pIHtcblx0XHRcdGZvciAoaT0wOyBpIDwgZGVsYXllZFRyaWdnZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH0gLy9UcmlnZ2VyIGFsbCBkZWxheWVkIGV2ZW50c1xuXHRcdFx0dGhpcy5fdHJpZ2dlcihcInN0b3BcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblx0XHR9XG5cblx0XHR0aGlzLmZyb21PdXRzaWRlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCQuV2lkZ2V0LnByb3RvdHlwZS5fdHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5jYW5jZWwoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VpSGFzaDogZnVuY3Rpb24oX2luc3QpIHtcblx0XHR2YXIgaW5zdCA9IF9pbnN0IHx8IHRoaXM7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlbHBlcjogaW5zdC5oZWxwZXIsXG5cdFx0XHRwbGFjZWhvbGRlcjogaW5zdC5wbGFjZWhvbGRlciB8fCAkKFtdKSxcblx0XHRcdHBvc2l0aW9uOiBpbnN0LnBvc2l0aW9uLFxuXHRcdFx0b3JpZ2luYWxQb3NpdGlvbjogaW5zdC5vcmlnaW5hbFBvc2l0aW9uLFxuXHRcdFx0b2Zmc2V0OiBpbnN0LnBvc2l0aW9uQWJzLFxuXHRcdFx0aXRlbTogaW5zdC5jdXJyZW50SXRlbSxcblx0XHRcdHNlbmRlcjogX2luc3QgPyBfaW5zdC5lbGVtZW50IDogbnVsbFxuXHRcdH07XG5cdH1cblxufSk7XG5cbn0pKGpRdWVyeSk7XG4iLCJ2YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5yZXF1aXJlKCcuL2NvcmUnKTtcbnJlcXVpcmUoJy4vd2lkZ2V0Jyk7XG5yZXF1aXJlKCcuL2J1dHRvbicpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBTcGlubmVyIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zcGlubmVyL1xuICpcbiAqIERlcGVuZHM6XG4gKiAganF1ZXJ5LnVpLmNvcmUuanNcbiAqICBqcXVlcnkudWkud2lkZ2V0LmpzXG4gKiAganF1ZXJ5LnVpLmJ1dHRvbi5qc1xuICovXG4oZnVuY3Rpb24oICQgKSB7XG5cbmZ1bmN0aW9uIG1vZGlmaWVyKCBmbiApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcmV2aW91cyA9IHRoaXMuZWxlbWVudC52YWwoKTtcblx0XHRmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHRcdGlmICggcHJldmlvdXMgIT09IHRoaXMuZWxlbWVudC52YWwoKSApIHtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIgKTtcblx0XHR9XG5cdH07XG59XG5cbiQud2lkZ2V0KCBcInVpLnNwaW5uZXJcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuNFwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8aW5wdXQ+XCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcInNwaW5cIixcblx0b3B0aW9uczoge1xuXHRcdGN1bHR1cmU6IG51bGwsXG5cdFx0aWNvbnM6IHtcblx0XHRcdGRvd246IFwidWktaWNvbi10cmlhbmdsZS0xLXNcIixcblx0XHRcdHVwOiBcInVpLWljb24tdHJpYW5nbGUtMS1uXCJcblx0XHR9LFxuXHRcdGluY3JlbWVudGFsOiB0cnVlLFxuXHRcdG1heDogbnVsbCxcblx0XHRtaW46IG51bGwsXG5cdFx0bnVtYmVyRm9ybWF0OiBudWxsLFxuXHRcdHBhZ2U6IDEwLFxuXHRcdHN0ZXA6IDEsXG5cblx0XHRjaGFuZ2U6IG51bGwsXG5cdFx0c3BpbjogbnVsbCxcblx0XHRzdGFydDogbnVsbCxcblx0XHRzdG9wOiBudWxsXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gaGFuZGxlIHN0cmluZyB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHBhcnNlZFxuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJtYXhcIiwgdGhpcy5vcHRpb25zLm1heCApO1xuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJtaW5cIiwgdGhpcy5vcHRpb25zLm1pbiApO1xuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJzdGVwXCIsIHRoaXMub3B0aW9ucy5zdGVwICk7XG5cblx0XHQvLyBPbmx5IGZvcm1hdCBpZiB0aGVyZSBpcyBhIHZhbHVlLCBwcmV2ZW50cyB0aGUgZmllbGQgZnJvbSBiZWluZyBtYXJrZWRcblx0XHQvLyBhcyBpbnZhbGlkIGluIEZpcmVmb3gsIHNlZSAjOTU3My5cblx0XHRpZiAoIHRoaXMudmFsdWUoKSAhPT0gXCJcIiApIHtcblx0XHRcdC8vIEZvcm1hdCB0aGUgdmFsdWUsIGJ1dCBkb24ndCBjb25zdHJhaW4uXG5cdFx0XHR0aGlzLl92YWx1ZSggdGhpcy5lbGVtZW50LnZhbCgpLCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhdygpO1xuXHRcdHRoaXMuX29uKCB0aGlzLl9ldmVudHMgKTtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cblx0XHQvLyB0dXJuaW5nIG9mZiBhdXRvY29tcGxldGUgcHJldmVudHMgdGhlIGJyb3dzZXIgZnJvbSByZW1lbWJlcmluZyB0aGVcblx0XHQvLyB2YWx1ZSB3aGVuIG5hdmlnYXRpbmcgdGhyb3VnaCBoaXN0b3J5LCBzbyB3ZSByZS1lbmFibGUgYXV0b2NvbXBsZXRlXG5cdFx0Ly8gaWYgdGhlIHBhZ2UgaXMgdW5sb2FkZWQgYmVmb3JlIHRoZSB3aWRnZXQgaXMgZGVzdHJveWVkLiAjNzc5MFxuXHRcdHRoaXMuX29uKCB0aGlzLndpbmRvdywge1xuXHRcdFx0YmVmb3JldW5sb2FkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoIFwiYXV0b2NvbXBsZXRlXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB7fSxcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cblx0XHQkLmVhY2goIFsgXCJtaW5cIiwgXCJtYXhcIiwgXCJzdGVwXCIgXSwgZnVuY3Rpb24oIGksIG9wdGlvbiApIHtcblx0XHRcdHZhciB2YWx1ZSA9IGVsZW1lbnQuYXR0ciggb3B0aW9uICk7XG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoICkge1xuXHRcdFx0XHRvcHRpb25zWyBvcHRpb24gXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH0sXG5cblx0X2V2ZW50czoge1xuXHRcdGtleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGlmICggdGhpcy5fc3RhcnQoIGV2ZW50ICkgJiYgdGhpcy5fa2V5ZG93biggZXZlbnQgKSApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGtleXVwOiBcIl9zdG9wXCIsXG5cdFx0Zm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5wcmV2aW91cyA9IHRoaXMuZWxlbWVudC52YWwoKTtcblx0XHR9LFxuXHRcdGJsdXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGlmICggdGhpcy5jYW5jZWxCbHVyICkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3N0b3AoKTtcblx0XHRcdHRoaXMuX3JlZnJlc2goKTtcblx0XHRcdGlmICggdGhpcy5wcmV2aW91cyAhPT0gdGhpcy5lbGVtZW50LnZhbCgpICkge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCBcImNoYW5nZVwiLCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bW91c2V3aGVlbDogZnVuY3Rpb24oIGV2ZW50LCBkZWx0YSApIHtcblx0XHRcdGlmICggIWRlbHRhICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF0aGlzLnNwaW5uaW5nICYmICF0aGlzLl9zdGFydCggZXZlbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zcGluKCAoZGVsdGEgPiAwID8gMSA6IC0xKSAqIHRoaXMub3B0aW9ucy5zdGVwLCBldmVudCApO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLm1vdXNld2hlZWxUaW1lciApO1xuXHRcdFx0dGhpcy5tb3VzZXdoZWVsVGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnNwaW5uaW5nICkge1xuXHRcdFx0XHRcdHRoaXMuX3N0b3AoIGV2ZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDEwMCApO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9LFxuXHRcdFwibW91c2Vkb3duIC51aS1zcGlubmVyLWJ1dHRvblwiOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcHJldmlvdXM7XG5cblx0XHRcdC8vIFdlIG5ldmVyIHdhbnQgdGhlIGJ1dHRvbnMgdG8gaGF2ZSBmb2N1czsgd2hlbmV2ZXIgdGhlIHVzZXIgaXNcblx0XHRcdC8vIGludGVyYWN0aW5nIHdpdGggdGhlIHNwaW5uZXIsIHRoZSBmb2N1cyBzaG91bGQgYmUgb24gdGhlIGlucHV0LlxuXHRcdFx0Ly8gSWYgdGhlIGlucHV0IGlzIGZvY3VzZWQgdGhlbiB0aGlzLnByZXZpb3VzIGlzIHByb3Blcmx5IHNldCBmcm9tXG5cdFx0XHQvLyB3aGVuIHRoZSBpbnB1dCBmaXJzdCByZWNlaXZlZCBmb2N1cy4gSWYgdGhlIGlucHV0IGlzIG5vdCBmb2N1c2VkXG5cdFx0XHQvLyB0aGVuIHdlIG5lZWQgdG8gc2V0IHRoaXMucHJldmlvdXMgYmFzZWQgb24gdGhlIHZhbHVlIGJlZm9yZSBzcGlubmluZy5cblx0XHRcdHByZXZpb3VzID0gdGhpcy5lbGVtZW50WzBdID09PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgP1xuXHRcdFx0XHR0aGlzLnByZXZpb3VzIDogdGhpcy5lbGVtZW50LnZhbCgpO1xuXHRcdFx0ZnVuY3Rpb24gY2hlY2tGb2N1cygpIHtcblx0XHRcdFx0dmFyIGlzQWN0aXZlID0gdGhpcy5lbGVtZW50WzBdID09PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQ7XG5cdFx0XHRcdGlmICggIWlzQWN0aXZlICkge1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudC5mb2N1cygpO1xuXHRcdFx0XHRcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcblx0XHRcdFx0XHQvLyBzdXBwb3J0OiBJRVxuXHRcdFx0XHRcdC8vIElFIHNldHMgZm9jdXMgYXN5bmNocm9ub3VzbHksIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgZm9jdXNcblx0XHRcdFx0XHQvLyBtb3ZlZCBvZmYgb2YgdGhlIGlucHV0IGJlY2F1c2UgdGhlIHVzZXIgY2xpY2tlZCBvbiB0aGUgYnV0dG9uLlxuXHRcdFx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGVuc3VyZSBmb2N1cyBpcyBvbiAob3Igc3RheXMgb24pIHRoZSB0ZXh0IGZpZWxkXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Y2hlY2tGb2N1cy5jYWxsKCB0aGlzICk7XG5cblx0XHRcdC8vIHN1cHBvcnQ6IElFXG5cdFx0XHQvLyBJRSBkb2Vzbid0IHByZXZlbnQgbW92aW5nIGZvY3VzIGV2ZW4gd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHQvLyBzbyB3ZSBzZXQgYSBmbGFnIHRvIGtub3cgd2hlbiB3ZSBzaG91bGQgaWdub3JlIHRoZSBibHVyIGV2ZW50XG5cdFx0XHQvLyBhbmQgY2hlY2sgKGFnYWluKSBpZiBmb2N1cyBtb3ZlZCBvZmYgb2YgdGhlIGlucHV0LlxuXHRcdFx0dGhpcy5jYW5jZWxCbHVyID0gdHJ1ZTtcblx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xuXHRcdFx0XHRjaGVja0ZvY3VzLmNhbGwoIHRoaXMgKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIHRoaXMuX3N0YXJ0KCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZXBlYXQoIG51bGwsICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5oYXNDbGFzcyggXCJ1aS1zcGlubmVyLXVwXCIgKSA/IDEgOiAtMSwgZXZlbnQgKTtcblx0XHR9LFxuXHRcdFwibW91c2V1cCAudWktc3Bpbm5lci1idXR0b25cIjogXCJfc3RvcFwiLFxuXHRcdFwibW91c2VlbnRlciAudWktc3Bpbm5lci1idXR0b25cIjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0Ly8gYnV0dG9uIHdpbGwgYWRkIHVpLXN0YXRlLWFjdGl2ZSBpZiBtb3VzZSB3YXMgZG93biB3aGlsZSBtb3VzZWxlYXZlIGFuZCBrZXB0IGRvd25cblx0XHRcdGlmICggISQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5fc3RhcnQoIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXQoIG51bGwsICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5oYXNDbGFzcyggXCJ1aS1zcGlubmVyLXVwXCIgKSA/IDEgOiAtMSwgZXZlbnQgKTtcblx0XHR9LFxuXHRcdC8vIFRPRE86IGRvIHdlIHJlYWxseSB3YW50IHRvIGNvbnNpZGVyIHRoaXMgYSBzdG9wP1xuXHRcdC8vIHNob3VsZG4ndCB3ZSBqdXN0IHN0b3AgdGhlIHJlcGVhdGVyIGFuZCB3YWl0IHVudGlsIG1vdXNldXAgYmVmb3JlXG5cdFx0Ly8gd2UgdHJpZ2dlciB0aGUgc3RvcCBldmVudD9cblx0XHRcIm1vdXNlbGVhdmUgLnVpLXNwaW5uZXItYnV0dG9uXCI6IFwiX3N0b3BcIlxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdWlTcGlubmVyID0gdGhpcy51aVNwaW5uZXIgPSB0aGlzLmVsZW1lbnRcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zcGlubmVyLWlucHV0XCIgKVxuXHRcdFx0LmF0dHIoIFwiYXV0b2NvbXBsZXRlXCIsIFwib2ZmXCIgKVxuXHRcdFx0LndyYXAoIHRoaXMuX3VpU3Bpbm5lckh0bWwoKSApXG5cdFx0XHQucGFyZW50KClcblx0XHRcdFx0Ly8gYWRkIGJ1dHRvbnNcblx0XHRcdFx0LmFwcGVuZCggdGhpcy5fYnV0dG9uSHRtbCgpICk7XG5cblx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJyb2xlXCIsIFwic3BpbmJ1dHRvblwiICk7XG5cblx0XHQvLyBidXR0b24gYmluZGluZ3Ncblx0XHR0aGlzLmJ1dHRvbnMgPSB1aVNwaW5uZXIuZmluZCggXCIudWktc3Bpbm5lci1idXR0b25cIiApXG5cdFx0XHQuYXR0ciggXCJ0YWJJbmRleFwiLCAtMSApXG5cdFx0XHQuYnV0dG9uKClcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1jb3JuZXItYWxsXCIgKTtcblxuXHRcdC8vIElFIDYgZG9lc24ndCB1bmRlcnN0YW5kIGhlaWdodDogNTAlIGZvciB0aGUgYnV0dG9uc1xuXHRcdC8vIHVubGVzcyB0aGUgd3JhcHBlciBoYXMgYW4gZXhwbGljaXQgaGVpZ2h0XG5cdFx0aWYgKCB0aGlzLmJ1dHRvbnMuaGVpZ2h0KCkgPiBNYXRoLmNlaWwoIHVpU3Bpbm5lci5oZWlnaHQoKSAqIDAuNSApICYmXG5cdFx0XHRcdHVpU3Bpbm5lci5oZWlnaHQoKSA+IDAgKSB7XG5cdFx0XHR1aVNwaW5uZXIuaGVpZ2h0KCB1aVNwaW5uZXIuaGVpZ2h0KCkgKTtcblx0XHR9XG5cblx0XHQvLyBkaXNhYmxlIHNwaW5uZXIgaWYgZWxlbWVudCB3YXMgYWxyZWFkeSBkaXNhYmxlZFxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9rZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRrZXlDb2RlID0gJC51aS5rZXlDb2RlO1xuXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRjYXNlIGtleUNvZGUuVVA6XG5cdFx0XHR0aGlzLl9yZXBlYXQoIG51bGwsIDEsIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRjYXNlIGtleUNvZGUuRE9XTjpcblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgLTEsIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgb3B0aW9ucy5wYWdlLCBldmVudCApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSBrZXlDb2RlLlBBR0VfRE9XTjpcblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgLW9wdGlvbnMucGFnZSwgZXZlbnQgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfdWlTcGlubmVySHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiPHNwYW4gY2xhc3M9J3VpLXNwaW5uZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnPjwvc3Bhbj5cIjtcblx0fSxcblxuXHRfYnV0dG9uSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiXCIgK1xuXHRcdFx0XCI8YSBjbGFzcz0ndWktc3Bpbm5lci1idXR0b24gdWktc3Bpbm5lci11cCB1aS1jb3JuZXItdHInPlwiICtcblx0XHRcdFx0XCI8c3BhbiBjbGFzcz0ndWktaWNvbiBcIiArIHRoaXMub3B0aW9ucy5pY29ucy51cCArIFwiJz4mIzk2NTA7PC9zcGFuPlwiICtcblx0XHRcdFwiPC9hPlwiICtcblx0XHRcdFwiPGEgY2xhc3M9J3VpLXNwaW5uZXItYnV0dG9uIHVpLXNwaW5uZXItZG93biB1aS1jb3JuZXItYnInPlwiICtcblx0XHRcdFx0XCI8c3BhbiBjbGFzcz0ndWktaWNvbiBcIiArIHRoaXMub3B0aW9ucy5pY29ucy5kb3duICsgXCInPiYjOTY2MDs8L3NwYW4+XCIgK1xuXHRcdFx0XCI8L2E+XCI7XG5cdH0sXG5cblx0X3N0YXJ0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCAhdGhpcy5zcGlubmluZyAmJiB0aGlzLl90cmlnZ2VyKCBcInN0YXJ0XCIsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuY291bnRlciApIHtcblx0XHRcdHRoaXMuY291bnRlciA9IDE7XG5cdFx0fVxuXHRcdHRoaXMuc3Bpbm5pbmcgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9yZXBlYXQ6IGZ1bmN0aW9uKCBpLCBzdGVwcywgZXZlbnQgKSB7XG5cdFx0aSA9IGkgfHwgNTAwO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cdFx0dGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fcmVwZWF0KCA0MCwgc3RlcHMsIGV2ZW50ICk7XG5cdFx0fSwgaSApO1xuXG5cdFx0dGhpcy5fc3Bpbiggc3RlcHMgKiB0aGlzLm9wdGlvbnMuc3RlcCwgZXZlbnQgKTtcblx0fSxcblxuXHRfc3BpbjogZnVuY3Rpb24oIHN0ZXAsIGV2ZW50ICkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKSB8fCAwO1xuXG5cdFx0aWYgKCAhdGhpcy5jb3VudGVyICkge1xuXHRcdFx0dGhpcy5jb3VudGVyID0gMTtcblx0XHR9XG5cblx0XHR2YWx1ZSA9IHRoaXMuX2FkanVzdFZhbHVlKCB2YWx1ZSArIHN0ZXAgKiB0aGlzLl9pbmNyZW1lbnQoIHRoaXMuY291bnRlciApICk7XG5cblx0XHRpZiAoICF0aGlzLnNwaW5uaW5nIHx8IHRoaXMuX3RyaWdnZXIoIFwic3BpblwiLCBldmVudCwgeyB2YWx1ZTogdmFsdWUgfSApICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5fdmFsdWUoIHZhbHVlICk7XG5cdFx0XHR0aGlzLmNvdW50ZXIrKztcblx0XHR9XG5cdH0sXG5cblx0X2luY3JlbWVudDogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGluY3JlbWVudGFsID0gdGhpcy5vcHRpb25zLmluY3JlbWVudGFsO1xuXG5cdFx0aWYgKCBpbmNyZW1lbnRhbCApIHtcblx0XHRcdHJldHVybiAkLmlzRnVuY3Rpb24oIGluY3JlbWVudGFsICkgP1xuXHRcdFx0XHRpbmNyZW1lbnRhbCggaSApIDpcblx0XHRcdFx0TWF0aC5mbG9vciggaSppKmkvNTAwMDAgLSBpKmkvNTAwICsgMTcqaS8yMDAgKyAxICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDE7XG5cdH0sXG5cblx0X3ByZWNpc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZWNpc2lvbiA9IHRoaXMuX3ByZWNpc2lvbk9mKCB0aGlzLm9wdGlvbnMuc3RlcCApO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLm1pbiAhPT0gbnVsbCApIHtcblx0XHRcdHByZWNpc2lvbiA9IE1hdGgubWF4KCBwcmVjaXNpb24sIHRoaXMuX3ByZWNpc2lvbk9mKCB0aGlzLm9wdGlvbnMubWluICkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByZWNpc2lvbjtcblx0fSxcblxuXHRfcHJlY2lzaW9uT2Y6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0dmFyIHN0ciA9IG51bS50b1N0cmluZygpLFxuXHRcdFx0ZGVjaW1hbCA9IHN0ci5pbmRleE9mKCBcIi5cIiApO1xuXHRcdHJldHVybiBkZWNpbWFsID09PSAtMSA/IDAgOiBzdHIubGVuZ3RoIC0gZGVjaW1hbCAtIDE7XG5cdH0sXG5cblx0X2FkanVzdFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGJhc2UsIGFib3ZlTWluLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vIG1ha2Ugc3VyZSB3ZSdyZSBhdCBhIHZhbGlkIHN0ZXBcblx0XHQvLyAtIGZpbmQgb3V0IHdoZXJlIHdlIGFyZSByZWxhdGl2ZSB0byB0aGUgYmFzZSAobWluIG9yIDApXG5cdFx0YmFzZSA9IG9wdGlvbnMubWluICE9PSBudWxsID8gb3B0aW9ucy5taW4gOiAwO1xuXHRcdGFib3ZlTWluID0gdmFsdWUgLSBiYXNlO1xuXHRcdC8vIC0gcm91bmQgdG8gdGhlIG5lYXJlc3Qgc3RlcFxuXHRcdGFib3ZlTWluID0gTWF0aC5yb3VuZChhYm92ZU1pbiAvIG9wdGlvbnMuc3RlcCkgKiBvcHRpb25zLnN0ZXA7XG5cdFx0Ly8gLSByb3VuZGluZyBpcyBiYXNlZCBvbiAwLCBzbyBhZGp1c3QgYmFjayB0byBvdXIgYmFzZVxuXHRcdHZhbHVlID0gYmFzZSArIGFib3ZlTWluO1xuXG5cdFx0Ly8gZml4IHByZWNpc2lvbiBmcm9tIGJhZCBKUyBmbG9hdGluZyBwb2ludCBtYXRoXG5cdFx0dmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZS50b0ZpeGVkKCB0aGlzLl9wcmVjaXNpb24oKSApICk7XG5cblx0XHQvLyBjbGFtcCB0aGUgdmFsdWVcblx0XHRpZiAoIG9wdGlvbnMubWF4ICE9PSBudWxsICYmIHZhbHVlID4gb3B0aW9ucy5tYXgpIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLm1pbiAhPT0gbnVsbCAmJiB2YWx1ZSA8IG9wdGlvbnMubWluICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWluO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblxuXHRfc3RvcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggIXRoaXMuc3Bpbm5pbmcgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLm1vdXNld2hlZWxUaW1lciApO1xuXHRcdHRoaXMuY291bnRlciA9IDA7XG5cdFx0dGhpcy5zcGlubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwic3RvcFwiLCBldmVudCApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcImN1bHR1cmVcIiB8fCBrZXkgPT09IFwibnVtYmVyRm9ybWF0XCIgKSB7XG5cdFx0XHR2YXIgcHJldlZhbHVlID0gdGhpcy5fcGFyc2UoIHRoaXMuZWxlbWVudC52YWwoKSApO1xuXHRcdFx0dGhpcy5vcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5lbGVtZW50LnZhbCggdGhpcy5fZm9ybWF0KCBwcmV2VmFsdWUgKSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcIm1heFwiIHx8IGtleSA9PT0gXCJtaW5cIiB8fCBrZXkgPT09IFwic3RlcFwiICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fcGFyc2UoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICgga2V5ID09PSBcImljb25zXCIgKSB7XG5cdFx0XHR0aGlzLmJ1dHRvbnMuZmlyc3QoKS5maW5kKCBcIi51aS1pY29uXCIgKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHRoaXMub3B0aW9ucy5pY29ucy51cCApXG5cdFx0XHRcdC5hZGRDbGFzcyggdmFsdWUudXAgKTtcblx0XHRcdHRoaXMuYnV0dG9ucy5sYXN0KCkuZmluZCggXCIudWktaWNvblwiIClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLm9wdGlvbnMuaWNvbnMuZG93biApXG5cdFx0XHRcdC5hZGRDbGFzcyggdmFsdWUuZG93biApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgdHJ1ZSApO1xuXHRcdFx0XHR0aGlzLmJ1dHRvbnMuYnV0dG9uKCBcImRpc2FibGVcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgZmFsc2UgKTtcblx0XHRcdFx0dGhpcy5idXR0b25zLmJ1dHRvbiggXCJlbmFibGVcIiApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uczogbW9kaWZpZXIoZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblx0XHR0aGlzLl92YWx1ZSggdGhpcy5lbGVtZW50LnZhbCgpICk7XG5cdH0pLFxuXG5cdF9wYXJzZTogZnVuY3Rpb24oIHZhbCApIHtcblx0XHRpZiAoIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgJiYgdmFsICE9PSBcIlwiICkge1xuXHRcdFx0dmFsID0gd2luZG93Lkdsb2JhbGl6ZSAmJiB0aGlzLm9wdGlvbnMubnVtYmVyRm9ybWF0ID9cblx0XHRcdFx0R2xvYmFsaXplLnBhcnNlRmxvYXQoIHZhbCwgMTAsIHRoaXMub3B0aW9ucy5jdWx0dXJlICkgOiArdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsID09PSBcIlwiIHx8IGlzTmFOKCB2YWwgKSA/IG51bGwgOiB2YWw7XG5cdH0sXG5cblx0X2Zvcm1hdDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHdpbmRvdy5HbG9iYWxpemUgJiYgdGhpcy5vcHRpb25zLm51bWJlckZvcm1hdCA/XG5cdFx0XHRHbG9iYWxpemUuZm9ybWF0KCB2YWx1ZSwgdGhpcy5vcHRpb25zLm51bWJlckZvcm1hdCwgdGhpcy5vcHRpb25zLmN1bHR1cmUgKSA6XG5cdFx0XHR2YWx1ZTtcblx0fSxcblxuXHRfcmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoe1xuXHRcdFx0XCJhcmlhLXZhbHVlbWluXCI6IHRoaXMub3B0aW9ucy5taW4sXG5cdFx0XHRcImFyaWEtdmFsdWVtYXhcIjogdGhpcy5vcHRpb25zLm1heCxcblx0XHRcdC8vIFRPRE86IHdoYXQgc2hvdWxkIHdlIGRvIHdpdGggdmFsdWVzIHRoYXQgY2FuJ3QgYmUgcGFyc2VkP1xuXHRcdFx0XCJhcmlhLXZhbHVlbm93XCI6IHRoaXMuX3BhcnNlKCB0aGlzLmVsZW1lbnQudmFsKCkgKVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8vIHVwZGF0ZSB0aGUgdmFsdWUgd2l0aG91dCB0cmlnZ2VyaW5nIGNoYW5nZVxuXHRfdmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSwgYWxsb3dBbnkgKSB7XG5cdFx0dmFyIHBhcnNlZDtcblx0XHRpZiAoIHZhbHVlICE9PSBcIlwiICkge1xuXHRcdFx0cGFyc2VkID0gdGhpcy5fcGFyc2UoIHZhbHVlICk7XG5cdFx0XHRpZiAoIHBhcnNlZCAhPT0gbnVsbCApIHtcblx0XHRcdFx0aWYgKCAhYWxsb3dBbnkgKSB7XG5cdFx0XHRcdFx0cGFyc2VkID0gdGhpcy5fYWRqdXN0VmFsdWUoIHBhcnNlZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fZm9ybWF0KCBwYXJzZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5lbGVtZW50LnZhbCggdmFsdWUgKTtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXNwaW5uZXItaW5wdXRcIiApXG5cdFx0XHQucHJvcCggXCJkaXNhYmxlZFwiLCBmYWxzZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhdXRvY29tcGxldGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS12YWx1ZW1pblwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtdmFsdWVtYXhcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXZhbHVlbm93XCIgKTtcblx0XHR0aGlzLnVpU3Bpbm5lci5yZXBsYWNlV2l0aCggdGhpcy5lbGVtZW50ICk7XG5cdH0sXG5cblx0c3RlcFVwOiBtb2RpZmllcihmdW5jdGlvbiggc3RlcHMgKSB7XG5cdFx0dGhpcy5fc3RlcFVwKCBzdGVwcyApO1xuXHR9KSxcblx0X3N0ZXBVcDogZnVuY3Rpb24oIHN0ZXBzICkge1xuXHRcdGlmICggdGhpcy5fc3RhcnQoKSApIHtcblx0XHRcdHRoaXMuX3NwaW4oIChzdGVwcyB8fCAxKSAqIHRoaXMub3B0aW9ucy5zdGVwICk7XG5cdFx0XHR0aGlzLl9zdG9wKCk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0ZXBEb3duOiBtb2RpZmllcihmdW5jdGlvbiggc3RlcHMgKSB7XG5cdFx0dGhpcy5fc3RlcERvd24oIHN0ZXBzICk7XG5cdH0pLFxuXHRfc3RlcERvd246IGZ1bmN0aW9uKCBzdGVwcyApIHtcblx0XHRpZiAoIHRoaXMuX3N0YXJ0KCkgKSB7XG5cdFx0XHR0aGlzLl9zcGluKCAoc3RlcHMgfHwgMSkgKiAtdGhpcy5vcHRpb25zLnN0ZXAgKTtcblx0XHRcdHRoaXMuX3N0b3AoKTtcblx0XHR9XG5cdH0sXG5cblx0cGFnZVVwOiBtb2RpZmllcihmdW5jdGlvbiggcGFnZXMgKSB7XG5cdFx0dGhpcy5fc3RlcFVwKCAocGFnZXMgfHwgMSkgKiB0aGlzLm9wdGlvbnMucGFnZSApO1xuXHR9KSxcblxuXHRwYWdlRG93bjogbW9kaWZpZXIoZnVuY3Rpb24oIHBhZ2VzICkge1xuXHRcdHRoaXMuX3N0ZXBEb3duKCAocGFnZXMgfHwgMSkgKiB0aGlzLm9wdGlvbnMucGFnZSApO1xuXHR9KSxcblxuXHR2YWx1ZTogZnVuY3Rpb24oIG5ld1ZhbCApIHtcblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BhcnNlKCB0aGlzLmVsZW1lbnQudmFsKCkgKTtcblx0XHR9XG5cdFx0bW9kaWZpZXIoIHRoaXMuX3ZhbHVlICkuY2FsbCggdGhpcywgbmV3VmFsICk7XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy51aVNwaW5uZXI7XG5cdH1cbn0pO1xuXG59KCBqUXVlcnkgKSApO1xuIiwidmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBXaWRnZXQgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2pRdWVyeS53aWRnZXQvXG4gKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRfY2xlYW5EYXRhID0gJC5jbGVhbkRhdGE7XG4kLmNsZWFuRGF0YSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdCQoIGVsZW0gKS50cmlnZ2VySGFuZGxlciggXCJyZW1vdmVcIiApO1xuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzgyMzVcblx0XHR9IGNhdGNoKCBlICkge31cblx0fVxuXHRfY2xlYW5EYXRhKCBlbGVtcyApO1xufTtcblxuJC53aWRnZXQgPSBmdW5jdGlvbiggbmFtZSwgYmFzZSwgcHJvdG90eXBlICkge1xuXHR2YXIgZnVsbE5hbWUsIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlLFxuXHRcdC8vIHByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcblx0XHQvLyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGFzIGEgbWl4aW4gZm9yIG11bHRpcGxlIHdpZGdldHMgKCM4ODc2KVxuXHRcdHByb3hpZWRQcm90b3R5cGUgPSB7fSxcblx0XHRuYW1lc3BhY2UgPSBuYW1lLnNwbGl0KCBcIi5cIiApWyAwIF07XG5cblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcblx0ZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0Ly8gY3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXHRcdC8vIGFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcblx0XHRpZiAoICF0aGlzLl9jcmVhdGVXaWRnZXQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlV2lkZ2V0KCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXHR9O1xuXHQvLyBleHRlbmQgd2l0aCB0aGUgZXhpc3RpbmcgY29uc3RydWN0b3IgdG8gY2Fycnkgb3ZlciBhbnkgc3RhdGljIHByb3BlcnRpZXNcblx0JC5leHRlbmQoIGNvbnN0cnVjdG9yLCBleGlzdGluZ0NvbnN0cnVjdG9yLCB7XG5cdFx0dmVyc2lvbjogcHJvdG90eXBlLnZlcnNpb24sXG5cdFx0Ly8gY29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblx0XHQvLyB0cmFjayB3aWRnZXRzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgd2lkZ2V0IGluIGNhc2UgdGhpcyB3aWRnZXQgaXNcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxuXHRcdF9jaGlsZENvbnN0cnVjdG9yczogW11cblx0fSk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cdC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxuXHQvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXG5cdC8vIGluaGVyaXRpbmcgZnJvbVxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcblx0JC5lYWNoKCBwcm90b3R5cGUsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIF9zdXBlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBiYXNlLnByb3RvdHlwZVsgcHJvcCBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0X3N1cGVyQXBwbHkgPSBmdW5jdGlvbiggYXJncyApIHtcblx0XHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdF9fc3VwZXJBcHBseSA9IHRoaXMuX3N1cGVyQXBwbHksXG5cdFx0XHRcdFx0cmV0dXJuVmFsdWU7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbHVlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHR9KTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cdFx0Ly8gVE9ETzogcmVtb3ZlIHN1cHBvcnQgZm9yIHdpZGdldEV2ZW50UHJlZml4XG5cdFx0Ly8gYWx3YXlzIHVzZSB0aGUgbmFtZSArIGEgY29sb24gYXMgdGhlIHByZWZpeCwgZS5nLiwgZHJhZ2dhYmxlOnN0YXJ0XG5cdFx0Ly8gZG9uJ3QgcHJlZml4IGZvciB3aWRnZXRzIHRoYXQgYXJlbid0IERPTS1iYXNlZFxuXHRcdHdpZGdldEV2ZW50UHJlZml4OiBleGlzdGluZ0NvbnN0cnVjdG9yID8gKGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSkgOiBuYW1lXG5cdH0sIHByb3hpZWRQcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG5cdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0d2lkZ2V0TmFtZTogbmFtZSxcblx0XHR3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcblx0fSk7XG5cblx0Ly8gSWYgdGhpcyB3aWRnZXQgaXMgYmVpbmcgcmVkZWZpbmVkIHRoZW4gd2UgbmVlZCB0byBmaW5kIGFsbCB3aWRnZXRzIHRoYXRcblx0Ly8gYXJlIGluaGVyaXRpbmcgZnJvbSBpdCBhbmQgcmVkZWZpbmUgYWxsIG9mIHRoZW0gc28gdGhhdCB0aGV5IGluaGVyaXQgZnJvbVxuXHQvLyB0aGUgbmV3IHZlcnNpb24gb2YgdGhpcyB3aWRnZXQuIFdlJ3JlIGVzc2VudGlhbGx5IHRyeWluZyB0byByZXBsYWNlIG9uZVxuXHQvLyBsZXZlbCBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuXHRpZiAoIGV4aXN0aW5nQ29uc3RydWN0b3IgKSB7XG5cdFx0JC5lYWNoKCBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycywgZnVuY3Rpb24oIGksIGNoaWxkICkge1xuXHRcdFx0dmFyIGNoaWxkUHJvdG90eXBlID0gY2hpbGQucHJvdG90eXBlO1xuXG5cdFx0XHQvLyByZWRlZmluZSB0aGUgY2hpbGQgd2lkZ2V0IHVzaW5nIHRoZSBzYW1lIHByb3RvdHlwZSB0aGF0IHdhc1xuXHRcdFx0Ly8gb3JpZ2luYWxseSB1c2VkLCBidXQgaW5oZXJpdCBmcm9tIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGUgYmFzZVxuXHRcdFx0JC53aWRnZXQoIGNoaWxkUHJvdG90eXBlLm5hbWVzcGFjZSArIFwiLlwiICsgY2hpbGRQcm90b3R5cGUud2lkZ2V0TmFtZSwgY29uc3RydWN0b3IsIGNoaWxkLl9wcm90byApO1xuXHRcdH0pO1xuXHRcdC8vIHJlbW92ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjaGlsZCBjb25zdHJ1Y3RvcnMgZnJvbSB0aGUgb2xkIGNvbnN0cnVjdG9yXG5cdFx0Ly8gc28gdGhlIG9sZCBjaGlsZCBjb25zdHJ1Y3RvcnMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0ZGVsZXRlIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzO1xuXHR9IGVsc2Uge1xuXHRcdGJhc2UuX2NoaWxkQ29uc3RydWN0b3JzLnB1c2goIGNvbnN0cnVjdG9yICk7XG5cdH1cblxuXHQkLndpZGdldC5icmlkZ2UoIG5hbWUsIGNvbnN0cnVjdG9yICk7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSxcblx0XHRpbnB1dEluZGV4ID0gMCxcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHRrZXksXG5cdFx0dmFsdWU7XG5cdGZvciAoIDsgaW5wdXRJbmRleCA8IGlucHV0TGVuZ3RoOyBpbnB1dEluZGV4KysgKSB7XG5cdFx0Zm9yICgga2V5IGluIGlucHV0WyBpbnB1dEluZGV4IF0gKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0WyBpbnB1dEluZGV4IF1bIGtleSBdO1xuXHRcdFx0aWYgKCBpbnB1dFsgaW5wdXRJbmRleCBdLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBDbG9uZSBvYmplY3RzXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSAkLmlzUGxhaW5PYmplY3QoIHRhcmdldFsga2V5IF0gKSA/XG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB0YXJnZXRbIGtleSBdLCB2YWx1ZSApIDpcblx0XHRcdFx0XHRcdC8vIERvbid0IGV4dGVuZCBzdHJpbmdzLCBhcnJheXMsIGV0Yy4gd2l0aCBvYmplY3RzXG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB2YWx1ZSApO1xuXHRcdFx0XHQvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbiQud2lkZ2V0LmJyaWRnZSA9IGZ1bmN0aW9uKCBuYW1lLCBvYmplY3QgKSB7XG5cdHZhciBmdWxsTmFtZSA9IG9iamVjdC5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgbmFtZTtcblx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGlzTWV0aG9kQ2FsbCA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLFxuXHRcdFx0cmV0dXJuVmFsdWUgPSB0aGlzO1xuXG5cdFx0Ly8gYWxsb3cgbXVsdGlwbGUgaGFzaGVzIHRvIGJlIHBhc3NlZCBvbiBpbml0XG5cdFx0b3B0aW9ucyA9ICFpc01ldGhvZENhbGwgJiYgYXJncy5sZW5ndGggP1xuXHRcdFx0JC53aWRnZXQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIG9wdGlvbnMgXS5jb25jYXQoYXJncykgKSA6XG5cdFx0XHRvcHRpb25zO1xuXG5cdFx0aWYgKCBpc01ldGhvZENhbGwgKSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBtZXRob2RWYWx1ZSxcblx0XHRcdFx0XHRpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwiY2Fubm90IGNhbGwgbWV0aG9kcyBvbiBcIiArIG5hbWUgKyBcIiBwcmlvciB0byBpbml0aWFsaXphdGlvbjsgXCIgK1xuXHRcdFx0XHRcdFx0XCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJ1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCBpbnN0YW5jZVtvcHRpb25zXSApIHx8IG9wdGlvbnMuY2hhckF0KCAwICkgPT09IFwiX1wiICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcIm5vIHN1Y2ggbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIicgZm9yIFwiICsgbmFtZSArIFwiIHdpZGdldCBpbnN0YW5jZVwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWV0aG9kVmFsdWUgPSBpbnN0YW5jZVsgb3B0aW9ucyBdLmFwcGx5KCBpbnN0YW5jZSwgYXJncyApO1xuXHRcdFx0XHRpZiAoIG1ldGhvZFZhbHVlICE9PSBpbnN0YW5jZSAmJiBtZXRob2RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gbWV0aG9kVmFsdWUgJiYgbWV0aG9kVmFsdWUuanF1ZXJ5ID9cblx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XG5cdFx0XHRcdFx0XHRtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgfHwge30gKS5faW5pdCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQuZGF0YSggdGhpcywgZnVsbE5hbWUsIG5ldyBvYmplY3QoIG9wdGlvbnMsIHRoaXMgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG4kLldpZGdldCA9IGZ1bmN0aW9uKCAvKiBvcHRpb25zLCBlbGVtZW50ICovICkge307XG4kLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcblxuJC5XaWRnZXQucHJvdG90eXBlID0ge1xuXHR3aWRnZXROYW1lOiBcIndpZGdldFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGRpdj5cIixcblx0b3B0aW9uczoge1xuXHRcdGRpc2FibGVkOiBmYWxzZSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGNyZWF0ZTogbnVsbFxuXHR9LFxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB1dWlkKys7XG5cdFx0dGhpcy5ldmVudE5hbWVzcGFjZSA9IFwiLlwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xuXHRcdHRoaXMub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sXG5cdFx0XHR0aGlzLm9wdGlvbnMsXG5cdFx0XHR0aGlzLl9nZXRDcmVhdGVPcHRpb25zKCksXG5cdFx0XHRvcHRpb25zICk7XG5cblx0XHR0aGlzLmJpbmRpbmdzID0gJCgpO1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gJCgpO1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gJCgpO1xuXG5cdFx0aWYgKCBlbGVtZW50ICE9PSB0aGlzICkge1xuXHRcdFx0JC5kYXRhKCBlbGVtZW50LCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzICk7XG5cdFx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cblx0XHRcdFx0Ly8gZWxlbWVudCB3aXRoaW4gdGhlIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQub3duZXJEb2N1bWVudCA6XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgd2luZG93IG9yIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQuZG9jdW1lbnQgfHwgZWxlbWVudCApO1xuXHRcdFx0dGhpcy53aW5kb3cgPSAkKCB0aGlzLmRvY3VtZW50WzBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbMF0ucGFyZW50V2luZG93ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkgKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdH0sXG5cdF9nZXRDcmVhdGVPcHRpb25zOiAkLm5vb3AsXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblx0X2NyZWF0ZTogJC5ub29wLFxuXHRfaW5pdDogJC5ub29wLFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2Rlc3Ryb3koKTtcblx0XHQvLyB3ZSBjYW4gcHJvYmFibHkgcmVtb3ZlIHRoZSB1bmJpbmQgY2FsbHMgaW4gMi4wXG5cdFx0Ly8gYWxsIGV2ZW50IGJpbmRpbmdzIHNob3VsZCBnbyB0aHJvdWdoIHRoaXMuX29uKClcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0Ly8gMS45IEJDIGZvciAjNzgxMFxuXHRcdFx0Ly8gVE9ETyByZW1vdmUgZHVhbCBzdG9yYWdlXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXROYW1lIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lIClcblx0XHRcdC8vIHN1cHBvcnQ6IGpxdWVyeSA8MS42LjNcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTNcblx0XHRcdC5yZW1vdmVEYXRhKCAkLmNhbWVsQ2FzZSggdGhpcy53aWRnZXRGdWxsTmFtZSApICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0LnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKVxuXHRcdFx0LnJlbW92ZUNsYXNzKFxuXHRcdFx0XHR0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgXCIgK1xuXHRcdFx0XHRcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIGNsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0XHR0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHR9LFxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5LFxuXHRcdFx0cGFydHMsXG5cdFx0XHRjdXJPcHRpb24sXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0Ly8gZG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Ly8gaGFuZGxlIG5lc3RlZCBrZXlzLCBlLmcuLCBcImZvby5iYXJcIiA9PiB7IGZvbzogeyBiYXI6IF9fXyB9IH1cblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHBhcnRzID0ga2V5LnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0a2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdGlmICggcGFydHMubGVuZ3RoICkge1xuXHRcdFx0XHRjdXJPcHRpb24gPSBvcHRpb25zWyBrZXkgXSA9ICQud2lkZ2V0LmV4dGVuZCgge30sIHRoaXMub3B0aW9uc1sga2V5IF0gKTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKysgKSB7XG5cdFx0XHRcdFx0Y3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSB8fCB7fTtcblx0XHRcdFx0XHRjdXJPcHRpb24gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXkgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiBjdXJPcHRpb25bIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogY3VyT3B0aW9uWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJPcHRpb25bIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1sga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0aGlzLm9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0T3B0aW9ucyggb3B0aW9ucyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5vcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgdWktc3RhdGUtZGlzYWJsZWRcIiwgISF2YWx1ZSApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgdmFsdWUgKTtcblx0XHRcdHRoaXMuaG92ZXJhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgZmFsc2UgKTtcblx0fSxcblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbiggXCJkaXNhYmxlZFwiLCB0cnVlICk7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50LFxuXHRcdFx0aW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Ly8gbm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0aWYgKCB0eXBlb2Ygc3VwcHJlc3NEaXNhYmxlZENoZWNrICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XG5cdFx0XHRzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBubyBlbGVtZW50IGFyZ3VtZW50LCBzaHVmZmxlIGFuZCB1c2UgdGhpcy5lbGVtZW50XG5cdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYWNjZXB0IHNlbGVjdG9ycywgRE9NIGVsZW1lbnRzXG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFxcdyspXFxzKiguKikkLyApLFxuXHRcdFx0XHRldmVudE5hbWUgPSBtYXRjaFsxXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlLFxuXHRcdFx0XHRzZWxlY3RvciA9IG1hdGNoWzJdO1xuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0ZGVsZWdhdGVFbGVtZW50LmRlbGVnYXRlKCBzZWxlY3RvciwgZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQuYmluZCggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfb2ZmOiBmdW5jdGlvbiggZWxlbWVudCwgZXZlbnROYW1lICkge1xuXHRcdGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgXCJcIikuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgKyB0aGlzLmV2ZW50TmFtZXNwYWNlO1xuXHRcdGVsZW1lbnQudW5iaW5kKCBldmVudE5hbWUgKS51bmRlbGVnYXRlKCBldmVudE5hbWUgKTtcblx0fSxcblxuXHRfZGVsYXk6IGZ1bmN0aW9uKCBoYW5kbGVyLCBkZWxheSApIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XG5cdFx0XHRyZXR1cm4gKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJzdHJpbmdcIiA/IGluc3RhbmNlWyBoYW5kbGVyIF0gOiBoYW5kbGVyIClcblx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0fVxuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHNldFRpbWVvdXQoIGhhbmRsZXJQcm94eSwgZGVsYXkgfHwgMCApO1xuXHR9LFxuXG5cdF9ob3ZlcmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2ZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSB0aGlzLmZvY3VzYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0Zm9jdXNpbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X3RyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgZGF0YSApIHtcblx0XHR2YXIgcHJvcCwgb3JpZyxcblx0XHRcdGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHQvLyB0aGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBjb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFswXSwgWyBldmVudCBdLmNvbmNhdCggZGF0YSApICkgPT09IGZhbHNlIHx8XG5cdFx0XHRldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApO1xuXHR9XG59O1xuXG4kLmVhY2goIHsgc2hvdzogXCJmYWRlSW5cIiwgaGlkZTogXCJmYWRlT3V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgZGVmYXVsdEVmZmVjdCApIHtcblx0JC5XaWRnZXQucHJvdG90eXBlWyBcIl9cIiArIG1ldGhvZCBdID0gZnVuY3Rpb24oIGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBlZmZlY3Q6IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0dmFyIGhhc09wdGlvbnMsXG5cdFx0XHRlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0XHRtZXRob2QgOlxuXHRcdFx0XHRvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID9cblx0XHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblx0XHRoYXNPcHRpb25zID0gISQuaXNFbXB0eU9iamVjdCggb3B0aW9ucyApO1xuXHRcdG9wdGlvbnMuY29tcGxldGUgPSBjYWxsYmFjaztcblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgbWV0aG9kIF0oIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCBlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5xdWV1ZShmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdFx0JCggdGhpcyApWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn0pO1xuXG59KSggalF1ZXJ5ICk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiogQm9vdHN0cmFwOiBidXR0b24uanMgdjMuMS4xXG4qIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2J1dHRvbnNcbiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4qIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBCVVRUT04gUFVCTElDIENMQVNTIERFRklOSVRJT05cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG52YXIgQnV0dG9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gIHRoaXMub3B0aW9ucyAgID0gJC5leHRlbmQoe30sIEJ1dHRvbi5ERUZBVUxUUywgb3B0aW9ucylcbiAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZVxufVxuXG5CdXR0b24uREVGQVVMVFMgPSB7XG4gIGxvYWRpbmdUZXh0OiAnbG9hZGluZy4uLidcbn1cblxuQnV0dG9uLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgZCAgICA9ICdiay1icy1kaXNhYmxlZCdcbiAgdmFyICRlbCAgPSB0aGlzLiRlbGVtZW50XG4gIHZhciB2YWwgID0gJGVsLmlzKCdpbnB1dCcpID8gJ3ZhbCcgOiAnaHRtbCdcbiAgdmFyIGRhdGEgPSAkZWwuZGF0YSgpXG5cbiAgc3RhdGUgPSBzdGF0ZSArICdUZXh0J1xuXG4gIGlmICghZGF0YS5yZXNldFRleHQpICRlbC5kYXRhKCdyZXNldFRleHQnLCAkZWxbdmFsXSgpKVxuXG4gICRlbFt2YWxdKGRhdGFbc3RhdGVdIHx8IHRoaXMub3B0aW9uc1tzdGF0ZV0pXG5cbiAgLy8gcHVzaCB0byBldmVudCBsb29wIHRvIGFsbG93IGZvcm1zIHRvIHN1Ym1pdFxuICBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdGF0ZSA9PSAnbG9hZGluZ1RleHQnKSB7XG4gICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWVcbiAgICAgICRlbC5hZGRDbGFzcyhkKS5hdHRyKGQsIGQpXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzTG9hZGluZykge1xuICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZVxuICAgICAgJGVsLnJlbW92ZUNsYXNzKGQpLnJlbW92ZUF0dHIoZClcbiAgICB9XG4gIH0sIHRoaXMpLCAwKVxufVxuXG5CdXR0b24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoYW5nZWQgPSB0cnVlXG4gIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS1iay1icy10b2dnbGU9XCJidXR0b25zXCJdJylcblxuICBpZiAoJHBhcmVudC5sZW5ndGgpIHtcbiAgICB2YXIgJGlucHV0ID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbnB1dCcpXG4gICAgaWYgKCRpbnB1dC5wcm9wKCd0eXBlJykgPT0gJ3JhZGlvJykge1xuICAgICAgaWYgKCRpbnB1dC5wcm9wKCdjaGVja2VkJykgJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYmstYnMtYWN0aXZlJykpIGNoYW5nZWQgPSBmYWxzZVxuICAgICAgZWxzZSAkcGFyZW50LmZpbmQoJy5iay1icy1hY3RpdmUnKS5yZW1vdmVDbGFzcygnYmstYnMtYWN0aXZlJylcbiAgICB9XG4gICAgaWYgKGNoYW5nZWQpICRpbnB1dC5wcm9wKCdjaGVja2VkJywgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2JrLWJzLWFjdGl2ZScpKS50cmlnZ2VyKCdjaGFuZ2UnKVxuICB9XG5cbiAgaWYgKGNoYW5nZWQpIHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ2JrLWJzLWFjdGl2ZScpXG59XG5cblxuLy8gQlVUVE9OIFBMVUdJTiBERUZJTklUSU9OXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT1cblxudmFyIG9sZCA9ICQuZm4uYnV0dG9uXG5cbiQuZm4uYnV0dG9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JrLWJzLmJ1dHRvbicpXG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdiay1icy5idXR0b24nLCAoZGF0YSA9IG5ldyBCdXR0b24odGhpcywgb3B0aW9ucykpKVxuXG4gICAgaWYgKG9wdGlvbiA9PSAndG9nZ2xlJykgZGF0YS50b2dnbGUoKVxuICAgIGVsc2UgaWYgKG9wdGlvbikgZGF0YS5zZXRTdGF0ZShvcHRpb24pXG4gIH0pXG59XG5cbiQuZm4uYnV0dG9uLkNvbnN0cnVjdG9yID0gQnV0dG9uXG5cblxuLy8gQlVUVE9OIE5PIENPTkZMSUNUXG4vLyA9PT09PT09PT09PT09PT09PT1cblxuJC5mbi5idXR0b24ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgJC5mbi5idXR0b24gPSBvbGRcbiAgcmV0dXJuIHRoaXNcbn1cblxuXG4vLyBCVVRUT04gREFUQS1BUElcbi8vID09PT09PT09PT09PT09PVxuXG4kKGRvY3VtZW50KS5vbignY2xpY2suYmstYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLWJrLWJzLXRvZ2dsZV49YnV0dG9uXScsIGZ1bmN0aW9uIChlKSB7XG4gIHZhciAkYnRuID0gJChlLnRhcmdldClcbiAgaWYgKCEkYnRuLmhhc0NsYXNzKCdiay1icy1idG4nKSkgJGJ0biA9ICRidG4uY2xvc2VzdCgnLmJrLWJzLWJ0bicpXG4gICRidG4uYnV0dG9uKCd0b2dnbGUnKVxuICBlLnByZXZlbnREZWZhdWx0KClcbn0pXG4iLCJ2YXIgJCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBkcm9wZG93bi5qcyB2My4xLjFcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Ryb3Bkb3duc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBEUk9QRE9XTiBDTEFTUyBERUZJTklUSU9OXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnZhciBiYWNrZHJvcCA9ICcuYmstYnMtZHJvcGRvd24tYmFja2Ryb3AnXG52YXIgdG9nZ2xlICAgPSAnW2RhdGEtYmstYnMtdG9nZ2xlPWRyb3Bkb3duXSdcbnZhciBEcm9wZG93biA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICQoZWxlbWVudCkub24oJ2NsaWNrLmJrLWJzLmRyb3Bkb3duJywgdGhpcy50b2dnbGUpXG59XG5cbkRyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgaWYgKCR0aGlzLmlzKCcuYmstYnMtZGlzYWJsZWQsIDpkaXNhYmxlZCcpKSByZXR1cm5cblxuICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gIHZhciBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ2JrLWJzLW9wZW4nKVxuXG4gIGNsZWFyTWVudXMoKVxuXG4gIGlmICghaXNBY3RpdmUpIHtcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICEkcGFyZW50LmNsb3Nlc3QoJy5iay1icy1uYXZiYXItbmF2JykubGVuZ3RoKSB7XG4gICAgICAvLyBpZiBtb2JpbGUgd2UgdXNlIGEgYmFja2Ryb3AgYmVjYXVzZSBjbGljayBldmVudHMgZG9uJ3QgZGVsZWdhdGVcbiAgICAgICQoJzxkaXYgY2xhc3M9XCJiay1icy1kcm9wZG93bi1iYWNrZHJvcFwiLz4nKS5pbnNlcnRBZnRlcigkKHRoaXMpKS5vbignY2xpY2snLCBjbGVhck1lbnVzKVxuICAgIH1cblxuICAgIHZhciByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiB0aGlzIH1cbiAgICAkcGFyZW50LnRyaWdnZXIoZSA9ICQuRXZlbnQoJ3Nob3cuYmstYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KSlcblxuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICRwYXJlbnRcbiAgICAgIC50b2dnbGVDbGFzcygnYmstYnMtb3BlbicpXG4gICAgICAudHJpZ2dlcignc2hvd24uYmstYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KVxuXG4gICAgJHRoaXMuZm9jdXMoKVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbkRyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgaWYgKCEvKDM4fDQwfDI3KS8udGVzdChlLmtleUNvZGUpKSByZXR1cm5cblxuICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICBpZiAoJHRoaXMuaXMoJy5iay1icy1kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gIHZhciAkcGFyZW50ICA9IGdldFBhcmVudCgkdGhpcylcbiAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnYmstYnMtb3BlbicpXG5cbiAgaWYgKCFpc0FjdGl2ZSB8fCAoaXNBY3RpdmUgJiYgZS5rZXlDb2RlID09IDI3KSkge1xuICAgIGlmIChlLndoaWNoID09IDI3KSAkcGFyZW50LmZpbmQodG9nZ2xlKS5mb2N1cygpXG4gICAgcmV0dXJuICR0aGlzLmNsaWNrKClcbiAgfVxuXG4gIHZhciBkZXNjID0gJyBsaTpub3QoLmJrLWJzLWRpdmlkZXIpOnZpc2libGUgYSdcbiAgdmFyICRpdGVtcyA9ICRwYXJlbnQuZmluZCgnW3JvbGU9bWVudV0nICsgZGVzYyArICcsIFtyb2xlPWxpc3Rib3hdJyArIGRlc2MpXG5cbiAgaWYgKCEkaXRlbXMubGVuZ3RoKSByZXR1cm5cblxuICB2YXIgaW5kZXggPSAkaXRlbXMuaW5kZXgoJGl0ZW1zLmZpbHRlcignOmZvY3VzJykpXG5cbiAgaWYgKGUua2V5Q29kZSA9PSAzOCAmJiBpbmRleCA+IDApICAgICAgICAgICAgICAgICBpbmRleC0tICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBcbiAgaWYgKGUua2V5Q29kZSA9PSA0MCAmJiBpbmRleCA8ICRpdGVtcy5sZW5ndGggLSAxKSBpbmRleCsrICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG93blxuICBpZiAoIX5pbmRleCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMFxuXG4gICRpdGVtcy5lcShpbmRleCkuZm9jdXMoKVxufVxuXG5mdW5jdGlvbiBjbGVhck1lbnVzKGUpIHtcbiAgJChiYWNrZHJvcCkucmVtb3ZlKClcbiAgJCh0b2dnbGUpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIHZhciAkcGFyZW50ID0gZ2V0UGFyZW50KCQodGhpcykpXG4gICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfVxuICAgIGlmICghJHBhcmVudC5oYXNDbGFzcygnYmstYnMtb3BlbicpKSByZXR1cm5cbiAgICAkcGFyZW50LnRyaWdnZXIoZSA9ICQuRXZlbnQoJ2hpZGUuYmstYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KSlcbiAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG4gICAgJHBhcmVudC5yZW1vdmVDbGFzcygnYmstYnMtb3BlbicpLnRyaWdnZXIoJ2hpZGRlbi5iay1icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudCgkdGhpcykge1xuICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLWJrLWJzLXRhcmdldCcpXG5cbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiAvI1tBLVphLXpdLy50ZXN0KHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy9zdHJpcCBmb3IgaWU3XG4gIH1cblxuICB2YXIgJHBhcmVudCA9IHNlbGVjdG9yICYmICQoc2VsZWN0b3IpXG5cbiAgcmV0dXJuICRwYXJlbnQgJiYgJHBhcmVudC5sZW5ndGggPyAkcGFyZW50IDogJHRoaXMucGFyZW50KClcbn1cblxuXG4vLyBEUk9QRE9XTiBQTFVHSU4gREVGSU5JVElPTlxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudmFyIG9sZCA9ICQuZm4uZHJvcGRvd25cblxuJC5mbi5kcm9wZG93biA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JrLWJzLmRyb3Bkb3duJylcblxuICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYmstYnMuZHJvcGRvd24nLCAoZGF0YSA9IG5ldyBEcm9wZG93bih0aGlzKSkpXG4gICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICB9KVxufVxuXG4kLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yID0gRHJvcGRvd25cblxuXG4vLyBEUk9QRE9XTiBOTyBDT05GTElDVFxuLy8gPT09PT09PT09PT09PT09PT09PT1cblxuJC5mbi5kcm9wZG93bi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAkLmZuLmRyb3Bkb3duID0gb2xkXG4gIHJldHVybiB0aGlzXG59XG5cblxuLy8gQVBQTFkgVE8gU1RBTkRBUkQgRFJPUERPV04gRUxFTUVOVFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiQoZG9jdW1lbnQpXG4gIC5vbignY2xpY2suYmstYnMuZHJvcGRvd24uZGF0YS1hcGknLCBjbGVhck1lbnVzKVxuICAub24oJ2NsaWNrLmJrLWJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJy5iay1icy1kcm9wZG93biBmb3JtJywgZnVuY3Rpb24gKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKSB9KVxuICAub24oJ2NsaWNrLmJrLWJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlKVxuICAub24oJ2tleWRvd24uYmstYnMuZHJvcGRvd24uZGF0YS1hcGknLCB0b2dnbGUgKyAnLCBbcm9sZT1tZW51XSwgW3JvbGU9bGlzdGJveF0nLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcbiIsInZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0YWIuanMgdjMuMS4xXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0YWJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRBQiBDTEFTUyBERUZJTklUSU9OXG4vLyA9PT09PT09PT09PT09PT09PT09PVxuXG52YXIgVGFiID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdGhpcy5lbGVtZW50ID0gJChlbGVtZW50KVxufVxuXG5UYWIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciAkdGhpcyAgICA9IHRoaXMuZWxlbWVudFxuICB2YXIgJHVsICAgICAgPSAkdGhpcy5jbG9zZXN0KCd1bDpub3QoLmJrLWJzLWRyb3Bkb3duLW1lbnUpJylcbiAgdmFyIHNlbGVjdG9yID0gJHRoaXMuZGF0YSgnYmstYnMtdGFyZ2V0JylcblxuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvL3N0cmlwIGZvciBpZTdcbiAgfVxuXG4gIGlmICgkdGhpcy5wYXJlbnQoJ2xpJykuaGFzQ2xhc3MoJ2JrLWJzLWFjdGl2ZScpKSByZXR1cm5cblxuICB2YXIgcHJldmlvdXMgPSAkdWwuZmluZCgnLmJrLWJzLWFjdGl2ZTpsYXN0IGEnKVswXVxuICB2YXIgZSAgICAgICAgPSAkLkV2ZW50KCdzaG93LmJrLWJzLnRhYicsIHtcbiAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICB9KVxuXG4gICR0aGlzLnRyaWdnZXIoZSlcblxuICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgdmFyICR0YXJnZXQgPSAkKHNlbGVjdG9yKVxuXG4gIHRoaXMuYWN0aXZhdGUoJHRoaXMucGFyZW50KCdsaScpLCAkdWwpXG4gIHRoaXMuYWN0aXZhdGUoJHRhcmdldCwgJHRhcmdldC5wYXJlbnQoKSwgZnVuY3Rpb24gKCkge1xuICAgICR0aGlzLnRyaWdnZXIoe1xuICAgICAgdHlwZTogJ3Nob3duLmJrLWJzLnRhYicsXG4gICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgIH0pXG4gIH0pXG59XG5cblRhYi5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICB2YXIgJGFjdGl2ZSAgICA9IGNvbnRhaW5lci5maW5kKCc+IC5iay1icy1hY3RpdmUnKVxuICB2YXIgdHJhbnNpdGlvbiA9IGNhbGxiYWNrXG4gICAgJiYgJC5zdXBwb3J0LnRyYW5zaXRpb25cbiAgICAmJiAkYWN0aXZlLmhhc0NsYXNzKCdiay1icy1mYWRlJylcblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICRhY3RpdmVcbiAgICAgIC5yZW1vdmVDbGFzcygnYmstYnMtYWN0aXZlJylcbiAgICAgIC5maW5kKCc+IC5iay1icy1kcm9wZG93bi1tZW51ID4gLmJrLWJzLWFjdGl2ZScpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2JrLWJzLWFjdGl2ZScpXG5cbiAgICBlbGVtZW50LmFkZENsYXNzKCdiay1icy1hY3RpdmUnKVxuXG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gcmVmbG93IGZvciB0cmFuc2l0aW9uXG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdiay1icy1pbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2JrLWJzLWZhZGUnKVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnBhcmVudCgnLmJrLWJzLWRyb3Bkb3duLW1lbnUnKSkge1xuICAgICAgZWxlbWVudC5jbG9zZXN0KCdsaS5iay1icy1kcm9wZG93bicpLmFkZENsYXNzKCdiay1icy1hY3RpdmUnKVxuICAgIH1cblxuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgfVxuXG4gIHRyYW5zaXRpb24gP1xuICAgICRhY3RpdmVcbiAgICAgIC5vbmUoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLCBuZXh0KVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKDE1MCkgOlxuICAgIG5leHQoKVxuXG4gICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2JrLWJzLWluJylcbn1cblxuXG4vLyBUQUIgUExVR0lOIERFRklOSVRJT05cbi8vID09PT09PT09PT09PT09PT09PT09PVxuXG52YXIgb2xkID0gJC5mbi50YWJcblxuJC5mbi50YWIgPSBmdW5jdGlvbiAoIG9wdGlvbiApIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JrLWJzLnRhYicpXG5cbiAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JrLWJzLnRhYicsIChkYXRhID0gbmV3IFRhYih0aGlzKSkpXG4gICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gIH0pXG59XG5cbiQuZm4udGFiLkNvbnN0cnVjdG9yID0gVGFiXG5cblxuLy8gVEFCIE5PIENPTkZMSUNUXG4vLyA9PT09PT09PT09PT09PT1cblxuJC5mbi50YWIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgJC5mbi50YWIgPSBvbGRcbiAgcmV0dXJuIHRoaXNcbn1cblxuXG4vLyBUQUIgREFUQS1BUElcbi8vID09PT09PT09PT09PVxuXG4kKGRvY3VtZW50KS5vbignY2xpY2suYmstYnMudGFiLmRhdGEtYXBpJywgJ1tkYXRhLWJrLWJzLXRvZ2dsZT1cInRhYlwiXSwgW2RhdGEtYmstYnMtdG9nZ2xlPVwicGlsbFwiXScsIGZ1bmN0aW9uIChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKVxuICAkKHRoaXMpLnRhYignc2hvdycpXG59KVxuIiwiLyoqXG4gKiBqUVJhbmdlU2xpZGVyXG4gKiBBIGphdmFzY3JpcHQgc2xpZGVyIHNlbGVjdG9yIHRoYXQgc3VwcG9ydHMgZGF0ZXNcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIEd1aWxsYXVtZSBHYXV0cmVhdSAyMDEyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiAqXG4gKi9cblxudmFyICQgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xucmVxdWlyZShcIi4valFSYW5nZVNsaWRlclwiKTtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICQud2lkZ2V0KFwidWkuZGF0ZVJhbmdlU2xpZGVyXCIsICQudWkucmFuZ2VTbGlkZXIsIHtcblx0b3B0aW9uczoge1xuXHRcdGJvdW5kczoge21pbjogbmV3IERhdGUoMjAxMCwwLDEpLnZhbHVlT2YoKSwgbWF4OiBuZXcgRGF0ZSgyMDEyLDAsMSkudmFsdWVPZigpfSxcblx0XHRkZWZhdWx0VmFsdWVzOiB7bWluOiBuZXcgRGF0ZSgyMDEwLDEsMTEpLnZhbHVlT2YoKSwgbWF4OiBuZXcgRGF0ZSgyMDExLDEsMTEpLnZhbHVlT2YoKX1cblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpe1xuXHRcdCQudWkucmFuZ2VTbGlkZXIucHJvdG90eXBlLl9jcmVhdGUuYXBwbHkodGhpcyk7XG5cblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJiay11aS1kYXRlUmFuZ2VTbGlkZXJcIik7XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKXtcblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJiay11aS1kYXRlUmFuZ2VTbGlkZXJcIik7XG5cdFx0JC51aS5yYW5nZVNsaWRlci5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzKTtcblx0fSxcblxuXHRfc2V0RGVmYXVsdFZhbHVlczogZnVuY3Rpb24oKXtcblx0XHR0aGlzLl92YWx1ZXMgPSB7XG5cdFx0XHRtaW46IHRoaXMub3B0aW9ucy5kZWZhdWx0VmFsdWVzLm1pbi52YWx1ZU9mKCksXG5cdFx0XHRtYXg6IHRoaXMub3B0aW9ucy5kZWZhdWx0VmFsdWVzLm1heC52YWx1ZU9mKClcblx0XHR9O1xuXHR9LFxuXG5cdF9zZXRSdWxlclBhcmFtZXRlcnM6IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5ydWxlci5ydWxlcih7XG5cdFx0XHRtaW46IG5ldyBEYXRlKHRoaXMub3B0aW9ucy5ib3VuZHMubWluKSxcblx0XHRcdG1heDogbmV3IERhdGUodGhpcy5vcHRpb25zLmJvdW5kcy5tYXgpLFxuXHRcdFx0c2NhbGVzOiB0aGlzLm9wdGlvbnMuc2NhbGVzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG5cdFx0aWYgKChrZXkgPT09IFwiZGVmYXVsdFZhbHVlc1wiIHx8IGtleSA9PT0gXCJib3VuZHNcIikgJiYgdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlICE9PSBudWxsICYmIHRoaXMuX2lzVmFsaWREYXRlKHZhbHVlLm1pbikgJiYgdGhpcy5faXNWYWxpZERhdGUodmFsdWUubWF4KSl7XG5cdFx0XHQkLnVpLnJhbmdlU2xpZGVyLnByb3RvdHlwZS5fc2V0T3B0aW9uLmFwcGx5KHRoaXMsIFtrZXksIHttaW46dmFsdWUubWluLnZhbHVlT2YoKSwgbWF4OnZhbHVlLm1heC52YWx1ZU9mKCl9XSk7XG5cdFx0fWVsc2V7XG5cdFx0XHQkLnVpLnJhbmdlU2xpZGVyLnByb3RvdHlwZS5fc2V0T3B0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX3RvQXJyYXkoYXJndW1lbnRzKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVUeXBlOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBcImRhdGVSYW5nZVNsaWRlckhhbmRsZVwiO1xuXHR9LFxuXG5cdG9wdGlvbjogZnVuY3Rpb24oa2V5KXtcblx0XHRpZiAoa2V5ID09PSBcImJvdW5kc1wiIHx8IGtleSA9PT0gXCJkZWZhdWx0VmFsdWVzXCIpe1xuXHRcdFx0dmFyIHJlc3VsdCA9ICQudWkucmFuZ2VTbGlkZXIucHJvdG90eXBlLm9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRyZXR1cm4ge21pbjpuZXcgRGF0ZShyZXN1bHQubWluKSwgbWF4Om5ldyBEYXRlKHJlc3VsdC5tYXgpfTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJC51aS5yYW5nZVNsaWRlci5wcm90b3R5cGUub3B0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX3RvQXJyYXkoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2RlZmF1bHRGb3JtYXR0ZXI6IGZ1bmN0aW9uKHZhbHVlKXtcblx0XHR2YXIgbW9udGggPSB2YWx1ZS5nZXRNb250aCgpICsgMSxcblx0XHRcdGRheSA9IHZhbHVlLmdldERhdGUoKTtcblxuXHRcdHJldHVybiBcIlwiICsgdmFsdWUuZ2V0RnVsbFllYXIoKSArIFwiLVwiICsgKG1vbnRoIDwgMTAgPyBcIjBcIiArIG1vbnRoIDogbW9udGgpICsgXCItXCIgKyAoZGF5IDwgMTAgPyBcIjBcIiArIGRheSA6IGRheSk7XG5cdH0sXG5cblx0X2dldEZvcm1hdHRlcjogZnVuY3Rpb24oKXtcblx0XHR2YXIgZm9ybWF0dGVyID0gdGhpcy5vcHRpb25zLmZvcm1hdHRlcjtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZm9ybWF0dGVyID09PSBmYWxzZSB8fCB0aGlzLm9wdGlvbnMuZm9ybWF0dGVyID09PSBudWxsKXtcblx0XHRcdGZvcm1hdHRlciA9IHRoaXMuX2RlZmF1bHRGb3JtYXR0ZXI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChmdW5jdGlvbihmb3JtYXR0ZXIpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdFx0cmV0dXJuIGZvcm1hdHRlcihuZXcgRGF0ZSh2YWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH0oZm9ybWF0dGVyKSk7XG5cdH0sXG5cblx0dmFsdWVzOiBmdW5jdGlvbihtaW4sIG1heCl7XG5cdFx0dmFyIHZhbHVlcyA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5faXNWYWxpZERhdGUobWluKSAmJiB0aGlzLl9pc1ZhbGlkRGF0ZShtYXgpKVxuXHRcdHtcblx0XHRcdHZhbHVlcyA9ICQudWkucmFuZ2VTbGlkZXIucHJvdG90eXBlLnZhbHVlcy5hcHBseSh0aGlzLCBbbWluLnZhbHVlT2YoKSwgbWF4LnZhbHVlT2YoKV0pO1xuXHRcdH1lbHNle1xuXHRcdFx0dmFsdWVzID0gJC51aS5yYW5nZVNsaWRlci5wcm90b3R5cGUudmFsdWVzLmFwcGx5KHRoaXMsIHRoaXMuX3RvQXJyYXkoYXJndW1lbnRzKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHttaW46IG5ldyBEYXRlKHZhbHVlcy5taW4pLCBtYXg6IG5ldyBEYXRlKHZhbHVlcy5tYXgpfTtcblx0fSxcblxuXHRtaW46IGZ1bmN0aW9uKG1pbil7XG5cdFx0aWYgKHRoaXMuX2lzVmFsaWREYXRlKG1pbikpe1xuXHRcdFx0cmV0dXJuIG5ldyBEYXRlKCQudWkucmFuZ2VTbGlkZXIucHJvdG90eXBlLm1pbi5hcHBseSh0aGlzLCBbbWluLnZhbHVlT2YoKV0pKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IERhdGUoJC51aS5yYW5nZVNsaWRlci5wcm90b3R5cGUubWluLmFwcGx5KHRoaXMpKTtcblx0fSxcblxuXHRtYXg6IGZ1bmN0aW9uKG1heCl7XG5cdFx0aWYgKHRoaXMuX2lzVmFsaWREYXRlKG1heCkpe1xuXHRcdFx0cmV0dXJuIG5ldyBEYXRlKCQudWkucmFuZ2VTbGlkZXIucHJvdG90eXBlLm1heC5hcHBseSh0aGlzLCBbbWF4LnZhbHVlT2YoKV0pKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IERhdGUoJC51aS5yYW5nZVNsaWRlci5wcm90b3R5cGUubWF4LmFwcGx5KHRoaXMpKTtcblx0fSxcblxuXHRib3VuZHM6IGZ1bmN0aW9uKG1pbiwgbWF4KXtcblx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0aWYgKHRoaXMuX2lzVmFsaWREYXRlKG1pbikgJiYgdGhpcy5faXNWYWxpZERhdGUobWF4KSkge1xuXHRcdFx0cmVzdWx0ID0gJC51aS5yYW5nZVNsaWRlci5wcm90b3R5cGUuYm91bmRzLmFwcGx5KHRoaXMsIFttaW4udmFsdWVPZigpLCBtYXgudmFsdWVPZigpXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9ICQudWkucmFuZ2VTbGlkZXIucHJvdG90eXBlLmJvdW5kcy5hcHBseSh0aGlzLCB0aGlzLl90b0FycmF5KGFyZ3VtZW50cykpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7bWluOiBuZXcgRGF0ZShyZXN1bHQubWluKSwgbWF4OiBuZXcgRGF0ZShyZXN1bHQubWF4KX07XG5cdH0sXG5cblx0X2lzVmFsaWREYXRlOiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG5cdH0sXG5cblx0X3RvQXJyYXk6IGZ1bmN0aW9uKGFyZ3NPYmplY3Qpe1xuXHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzT2JqZWN0KTtcblx0fVxufSk7XG4iLCIvKipcbiAqIGpRUmFuZ2VTbGlkZXJcbiAqIEEgamF2YXNjcmlwdCBzbGlkZXIgc2VsZWN0b3IgdGhhdCBzdXBwb3J0cyBkYXRlc1xuICpcbiAqIENvcHlyaWdodCAoQykgR3VpbGxhdW1lIEdhdXRyZWF1IDIwMTJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuICpcbiAqL1xuXG52YXIgJCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XG5yZXF1aXJlKFwianF1ZXJ5LXVpL2NvcmVcIik7XG5yZXF1aXJlKFwianF1ZXJ5LXVpL3dpZGdldFwiKTtcbnJlcXVpcmUoXCJqcXVlcnktdWkvbW91c2VcIik7XG5yZXF1aXJlKFwianF1ZXJ5LW1vdXNld2hlZWxcIik7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSAkLndpZGdldChcInVpLnJhbmdlU2xpZGVyXCIsIHtcblx0b3B0aW9uczoge1xuXHRcdGJvdW5kczoge21pbjowLCBtYXg6MTAwfSxcblx0XHRkZWZhdWx0VmFsdWVzOiB7bWluOjIwLCBtYXg6NTB9LFxuXHRcdHdoZWVsTW9kZTogbnVsbCxcblx0XHR3aGVlbFNwZWVkOiA0LFxuXHRcdGFycm93czogdHJ1ZSxcblx0XHR2YWx1ZUxhYmVsczogXCJzaG93XCIsXG5cdFx0Zm9ybWF0dGVyOiBudWxsLFxuXHRcdGR1cmF0aW9uSW46IDAsXG5cdFx0ZHVyYXRpb25PdXQ6IDQwMCxcblx0XHRkZWxheU91dDogMjAwLFxuXHRcdHJhbmdlOiB7bWluOiBmYWxzZSwgbWF4OiBmYWxzZX0sXG5cdFx0c3RlcDogZmFsc2UsXG5cdFx0c2NhbGVzOiBmYWxzZSxcblx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdHN5bW1ldHJpY1Bvc2l0aW9ubmluZzogZmFsc2Vcblx0fSxcblxuXHRfdmFsdWVzOiBudWxsLFxuXHRfdmFsdWVzQ2hhbmdlZDogZmFsc2UsXG5cdF9pbml0aWFsaXplZDogZmFsc2UsXG5cblx0Ly8gQ3JlYXRlZCBlbGVtZW50c1xuXHRiYXI6IG51bGwsXG5cdGxlZnRIYW5kbGU6IG51bGwsXG5cdHJpZ2h0SGFuZGxlOiBudWxsLFxuXHRpbm5lckJhcjogbnVsbCxcblx0Y29udGFpbmVyOiBudWxsLFxuXHRhcnJvd3M6IG51bGwsXG5cdGxhYmVsczogbnVsbCxcblx0Y2hhbmdpbmc6IHttaW46ZmFsc2UsIG1heDpmYWxzZX0sXG5cdGNoYW5nZWQ6IHttaW46ZmFsc2UsIG1heDpmYWxzZX0sXG5cdHJ1bGVyOiBudWxsLFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5fc2V0RGVmYXVsdFZhbHVlcygpO1xuXG5cdFx0dGhpcy5sYWJlbHMgPSB7bGVmdDogbnVsbCwgcmlnaHQ6bnVsbCwgbGVmdERpc3BsYXllZDp0cnVlLCByaWdodERpc3BsYXllZDp0cnVlfTtcblx0XHR0aGlzLmFycm93cyA9IHtsZWZ0Om51bGwsIHJpZ2h0Om51bGx9O1xuXHRcdHRoaXMuY2hhbmdpbmcgPSB7bWluOmZhbHNlLCBtYXg6ZmFsc2V9O1xuXHRcdHRoaXMuY2hhbmdlZCA9IHttaW46ZmFsc2UsIG1heDpmYWxzZX07XG5cblx0XHR0aGlzLl9jcmVhdGVFbGVtZW50cygpO1xuXG5cdFx0dGhpcy5fYmluZFJlc2l6ZSgpO1xuXG5cdFx0c2V0VGltZW91dCgkLnByb3h5KHRoaXMucmVzaXplLCB0aGlzKSwgMSk7XG5cdFx0c2V0VGltZW91dCgkLnByb3h5KHRoaXMuX2luaXRWYWx1ZXMsIHRoaXMpLCAxKTtcblx0fSxcblxuXHRfc2V0RGVmYXVsdFZhbHVlczogZnVuY3Rpb24oKXtcblx0XHR0aGlzLl92YWx1ZXMgPSB7XG5cdFx0XHRtaW46IHRoaXMub3B0aW9ucy5kZWZhdWx0VmFsdWVzLm1pbixcblx0XHRcdG1heDogdGhpcy5vcHRpb25zLmRlZmF1bHRWYWx1ZXMubWF4XG5cdFx0fTtcblx0fSxcblxuXHRfYmluZFJlc2l6ZTogZnVuY3Rpb24oKXtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLl9yZXNpemVQcm94eSA9IGZ1bmN0aW9uKGUpe1xuXHRcdFx0dGhhdC5yZXNpemUoZSk7XG5cdFx0fTtcblxuXHRcdCQod2luZG93KS5yZXNpemUodGhpcy5fcmVzaXplUHJveHkpO1xuXHR9LFxuXG5cdF9pbml0V2lkdGg6IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5jb250YWluZXIuY3NzKFwid2lkdGhcIiwgdGhpcy5lbGVtZW50LndpZHRoKCkgLSB0aGlzLmNvbnRhaW5lci5vdXRlcldpZHRoKHRydWUpICsgdGhpcy5jb250YWluZXIud2lkdGgoKSk7XG5cdFx0dGhpcy5pbm5lckJhci5jc3MoXCJ3aWR0aFwiLCB0aGlzLmNvbnRhaW5lci53aWR0aCgpIC0gdGhpcy5pbm5lckJhci5vdXRlcldpZHRoKHRydWUpICsgdGhpcy5pbm5lckJhci53aWR0aCgpKTtcblx0fSxcblxuXHRfaW5pdFZhbHVlczogZnVuY3Rpb24oKXtcblx0XHR0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG5cdFx0dGhpcy52YWx1ZXModGhpcy5fdmFsdWVzLm1pbiwgdGhpcy5fdmFsdWVzLm1heCk7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdHRoaXMuX3NldFdoZWVsT3B0aW9uKGtleSwgdmFsdWUpO1xuXHRcdHRoaXMuX3NldEFycm93c09wdGlvbihrZXksIHZhbHVlKTtcblx0XHR0aGlzLl9zZXRMYWJlbHNPcHRpb24oa2V5LCB2YWx1ZSk7XG5cdFx0dGhpcy5fc2V0TGFiZWxzRHVyYXRpb25zKGtleSwgdmFsdWUpO1xuXHRcdHRoaXMuX3NldEZvcm1hdHRlck9wdGlvbihrZXksIHZhbHVlKTtcblx0XHR0aGlzLl9zZXRCb3VuZHNPcHRpb24oa2V5LCB2YWx1ZSk7XG5cdFx0dGhpcy5fc2V0UmFuZ2VPcHRpb24oa2V5LCB2YWx1ZSk7XG5cdFx0dGhpcy5fc2V0U3RlcE9wdGlvbihrZXksIHZhbHVlKTtcblx0XHR0aGlzLl9zZXRTY2FsZXNPcHRpb24oa2V5LCB2YWx1ZSk7XG5cdFx0dGhpcy5fc2V0RW5hYmxlZE9wdGlvbihrZXksIHZhbHVlKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbm5pbmdPcHRpb24oa2V5LCB2YWx1ZSk7XG5cdH0sXG5cblx0X3ZhbGlkUHJvcGVydHk6IGZ1bmN0aW9uKG9iamVjdCwgbmFtZSwgZGVmYXVsdFZhbHVlKXtcblx0XHRpZiAob2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBvYmplY3RbbmFtZV0gPT09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqZWN0W25hbWVdO1xuXHR9LFxuXG5cdF9zZXRTdGVwT3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKXtcblx0XHRpZiAoa2V5ID09PSBcInN0ZXBcIil7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcCA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fbGVmdEhhbmRsZShcIm9wdGlvblwiLCBcInN0ZXBcIiwgdmFsdWUpO1xuXHRcdFx0dGhpcy5fcmlnaHRIYW5kbGUoXCJvcHRpb25cIiwgXCJzdGVwXCIsIHZhbHVlKTtcblx0XHRcdHRoaXMuX2NoYW5nZWQodHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRTY2FsZXNPcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuXHRcdGlmIChrZXkgPT09IFwic2NhbGVzXCIpe1xuXHRcdFx0aWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCl7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5zY2FsZXMgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fZGVzdHJveVJ1bGVyKCk7XG5cdFx0XHR9ZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSl7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5zY2FsZXMgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlUnVsZXIoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3NldFJhbmdlT3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKXtcblx0XHRpZiAoa2V5ID09PSBcInJhbmdlXCIpe1xuXHRcdFx0dGhpcy5fYmFyKFwib3B0aW9uXCIsIFwicmFuZ2VcIiwgdmFsdWUpO1xuXHRcdFx0dGhpcy5vcHRpb25zLnJhbmdlID0gdGhpcy5fYmFyKFwib3B0aW9uXCIsIFwicmFuZ2VcIik7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Qm91bmRzT3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKXtcblx0XHRpZiAoa2V5ID09PSBcImJvdW5kc1wiICYmIHR5cGVvZiB2YWx1ZS5taW4gIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHZhbHVlLm1heCAhPT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHR0aGlzLmJvdW5kcyh2YWx1ZS5taW4sIHZhbHVlLm1heCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRXaGVlbE9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG5cdFx0aWYgKGtleSA9PT0gXCJ3aGVlbE1vZGVcIiB8fCBrZXkgPT09IFwid2hlZWxTcGVlZFwiKXtcblx0XHRcdHRoaXMuX2JhcihcIm9wdGlvblwiLCBrZXksIHZhbHVlKTtcblx0XHRcdHRoaXMub3B0aW9uc1trZXldID0gdGhpcy5fYmFyKFwib3B0aW9uXCIsIGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRMYWJlbHNPcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuXHRcdGlmIChrZXkgPT09IFwidmFsdWVMYWJlbHNcIil7XG5cdFx0XHRpZiAodmFsdWUgIT09IFwiaGlkZVwiICYmIHZhbHVlICE9PSBcInNob3dcIiAmJiB2YWx1ZSAhPT0gXCJjaGFuZ2VcIil7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5vcHRpb25zLnZhbHVlTGFiZWxzID0gdmFsdWU7XG5cblx0XHRcdGlmICh2YWx1ZSAhPT0gXCJoaWRlXCIpe1xuXHRcdFx0XHR0aGlzLl9jcmVhdGVMYWJlbHMoKTtcblx0XHRcdFx0dGhpcy5fbGVmdExhYmVsKFwidXBkYXRlXCIpO1xuXHRcdFx0XHR0aGlzLl9yaWdodExhYmVsKFwidXBkYXRlXCIpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHRoaXMuX2Rlc3Ryb3lMYWJlbHMoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3NldEZvcm1hdHRlck9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG5cdFx0aWYgKGtleSA9PT0gXCJmb3JtYXR0ZXJcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnZhbHVlTGFiZWxzICE9PSBcImhpZGVcIil7XG5cdFx0XHRcdHRoaXMuX2xlZnRMYWJlbChcIm9wdGlvblwiLCBcImZvcm1hdHRlclwiLCB2YWx1ZSk7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5mb3JtYXR0ZXIgPSB0aGlzLl9yaWdodExhYmVsKFwib3B0aW9uXCIsIFwiZm9ybWF0dGVyXCIsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3NldEFycm93c09wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG5cdFx0aWYgKGtleSA9PT0gXCJhcnJvd3NcIiAmJiAodmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlKSAmJiB2YWx1ZSAhPT0gdGhpcy5vcHRpb25zLmFycm93cyl7XG5cdFx0XHRpZiAodmFsdWUgPT09IHRydWUpe1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXCJiay11aS1yYW5nZVNsaWRlci1ub0Fycm93XCIpXG5cdFx0XHRcdFx0LmFkZENsYXNzKFwiYmstdWktcmFuZ2VTbGlkZXItd2l0aEFycm93c1wiKTtcblx0XHRcdFx0dGhpcy5hcnJvd3MubGVmdC5jc3MoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cdFx0XHRcdHRoaXMuYXJyb3dzLnJpZ2h0LmNzcyhcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblx0XHRcdFx0dGhpcy5vcHRpb25zLmFycm93cyA9IHRydWU7XG5cdFx0XHR9ZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKXtcblx0XHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0LmFkZENsYXNzKFwiYmstdWktcmFuZ2VTbGlkZXItbm9BcnJvd1wiKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcImJrLXVpLXJhbmdlU2xpZGVyLXdpdGhBcnJvd3NcIik7XG5cdFx0XHRcdHRoaXMuYXJyb3dzLmxlZnQuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG5cdFx0XHRcdHRoaXMuYXJyb3dzLnJpZ2h0LmNzcyhcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMuYXJyb3dzID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2luaXRXaWR0aCgpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0TGFiZWxzRHVyYXRpb25zOiBmdW5jdGlvbihrZXksIHZhbHVlKXtcblx0XHRpZiAoa2V5ID09PSBcImR1cmF0aW9uSW5cIiB8fCBrZXkgPT09IFwiZHVyYXRpb25PdXRcIiB8fCBrZXkgPT09IFwiZGVsYXlPdXRcIil7XG5cdFx0XHRpZiAocGFyc2VJbnQodmFsdWUsIDEwKSAhPT0gdmFsdWUpIHJldHVybjtcblxuXHRcdFx0aWYgKHRoaXMubGFiZWxzLmxlZnQgIT09IG51bGwpe1xuXHRcdFx0XHR0aGlzLl9sZWZ0TGFiZWwoXCJvcHRpb25cIiwga2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmxhYmVscy5yaWdodCAhPT0gbnVsbCl7XG5cdFx0XHRcdHRoaXMuX3JpZ2h0TGFiZWwoXCJvcHRpb25cIiwga2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRFbmFibGVkT3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKXtcblx0XHRpZiAoa2V5ID09PSBcImVuYWJsZWRcIil7XG5cdFx0XHR0aGlzLnRvZ2dsZSh2YWx1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRQb3NpdGlvbm5pbmdPcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuXHRcdGlmIChrZXkgPT09IFwic3ltbWV0cmljUG9zaXRpb25uaW5nXCIpe1xuXHRcdFx0dGhpcy5fcmlnaHRIYW5kbGUoXCJvcHRpb25cIiwga2V5LCB2YWx1ZSk7XG5cdFx0XHR0aGlzLm9wdGlvbnNba2V5XSA9IHRoaXMuX2xlZnRIYW5kbGUoXCJvcHRpb25cIiwga2V5LCB2YWx1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jcmVhdGVFbGVtZW50czogZnVuY3Rpb24oKXtcblx0XHRpZiAodGhpcy5lbGVtZW50LmNzcyhcInBvc2l0aW9uXCIpICE9PSBcImFic29sdXRlXCIpe1xuXHRcdFx0dGhpcy5lbGVtZW50LmNzcyhcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIik7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFwiYmstdWktcmFuZ2VTbGlkZXJcIik7XG5cblx0XHR0aGlzLmNvbnRhaW5lciA9ICQoXCI8ZGl2IGNsYXNzPSdiay11aS1yYW5nZVNsaWRlci1jb250YWluZXInIC8+XCIpXG5cdFx0XHQuY3NzKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKVxuXHRcdFx0LmFwcGVuZFRvKHRoaXMuZWxlbWVudCk7XG5cblx0XHR0aGlzLmlubmVyQmFyID0gJChcIjxkaXYgY2xhc3M9J2JrLXVpLXJhbmdlU2xpZGVyLWlubmVyQmFyJyAvPlwiKVxuXHRcdFx0LmNzcyhcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIilcblx0XHRcdC5jc3MoXCJ0b3BcIiwgMClcblx0XHRcdC5jc3MoXCJsZWZ0XCIsIDApO1xuXG5cdFx0dGhpcy5fY3JlYXRlSGFuZGxlcygpO1xuXHRcdHRoaXMuX2NyZWF0ZUJhcigpO1xuXHRcdHRoaXMuY29udGFpbmVyLnByZXBlbmQodGhpcy5pbm5lckJhcik7XG5cdFx0dGhpcy5fY3JlYXRlQXJyb3dzKCk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnZhbHVlTGFiZWxzICE9PSBcImhpZGVcIil7XG5cdFx0XHR0aGlzLl9jcmVhdGVMYWJlbHMoKTtcblx0XHR9ZWxzZXtcblx0XHRcdHRoaXMuX2Rlc3Ryb3lMYWJlbHMoKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVSdWxlcigpO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlZCkgdGhpcy5fdG9nZ2xlKHRoaXMub3B0aW9ucy5lbmFibGVkKTtcblx0fSxcblxuXHRfY3JlYXRlSGFuZGxlOiBmdW5jdGlvbihvcHRpb25zKXtcblx0XHRyZXR1cm4gJChcIjxkaXYgLz5cIilcblx0XHRcdFt0aGlzLl9oYW5kbGVUeXBlKCldKG9wdGlvbnMpXG5cdFx0XHQuYmluZChcInNsaWRlckRyYWdcIiwgJC5wcm94eSh0aGlzLl9jaGFuZ2luZywgdGhpcykpXG5cdFx0XHQuYmluZChcInN0b3BcIiwgJC5wcm94eSh0aGlzLl9jaGFuZ2VkLCB0aGlzKSk7XG5cdH0sXG5cblx0X2NyZWF0ZUhhbmRsZXM6IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5sZWZ0SGFuZGxlID0gdGhpcy5fY3JlYXRlSGFuZGxlKHtcblx0XHRcdFx0aXNMZWZ0OiB0cnVlLFxuXHRcdFx0XHRib3VuZHM6IHRoaXMub3B0aW9ucy5ib3VuZHMsXG5cdFx0XHRcdHZhbHVlOiB0aGlzLl92YWx1ZXMubWluLFxuXHRcdFx0XHRzdGVwOiB0aGlzLm9wdGlvbnMuc3RlcCxcblx0XHRcdFx0c3ltbWV0cmljUG9zaXRpb25uaW5nOiB0aGlzLm9wdGlvbnMuc3ltbWV0cmljUG9zaXRpb25uaW5nXG5cdFx0fSkuYXBwZW5kVG8odGhpcy5jb250YWluZXIpO1xuXG5cdFx0dGhpcy5yaWdodEhhbmRsZSA9IHRoaXMuX2NyZWF0ZUhhbmRsZSh7XG5cdFx0XHRpc0xlZnQ6IGZhbHNlLFxuXHRcdFx0Ym91bmRzOiB0aGlzLm9wdGlvbnMuYm91bmRzLFxuXHRcdFx0dmFsdWU6IHRoaXMuX3ZhbHVlcy5tYXgsXG5cdFx0XHRzdGVwOiB0aGlzLm9wdGlvbnMuc3RlcCxcblx0XHRcdHN5bW1ldHJpY1Bvc2l0aW9ubmluZzogdGhpcy5vcHRpb25zLnN5bW1ldHJpY1Bvc2l0aW9ubmluZ1xuXHRcdH0pLmFwcGVuZFRvKHRoaXMuY29udGFpbmVyKTtcblx0fSxcblxuXHRfY3JlYXRlQmFyOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMuYmFyID0gJChcIjxkaXYgLz5cIilcblx0XHRcdC5wcmVwZW5kVG8odGhpcy5jb250YWluZXIpXG5cdFx0XHQuYmluZChcInNsaWRlckRyYWcgc2Nyb2xsIHpvb21cIiwgJC5wcm94eSh0aGlzLl9jaGFuZ2luZywgdGhpcykpXG5cdFx0XHQuYmluZChcInN0b3BcIiwgJC5wcm94eSh0aGlzLl9jaGFuZ2VkLCB0aGlzKSk7XG5cblx0XHR0aGlzLl9iYXIoe1xuXHRcdFx0XHRsZWZ0SGFuZGxlOiB0aGlzLmxlZnRIYW5kbGUsXG5cdFx0XHRcdHJpZ2h0SGFuZGxlOiB0aGlzLnJpZ2h0SGFuZGxlLFxuXHRcdFx0XHR2YWx1ZXM6IHttaW46IHRoaXMuX3ZhbHVlcy5taW4sIG1heDogdGhpcy5fdmFsdWVzLm1heH0sXG5cdFx0XHRcdHR5cGU6IHRoaXMuX2hhbmRsZVR5cGUoKSxcblx0XHRcdFx0cmFuZ2U6IHRoaXMub3B0aW9ucy5yYW5nZSxcblx0XHRcdFx0d2hlZWxNb2RlOiB0aGlzLm9wdGlvbnMud2hlZWxNb2RlLFxuXHRcdFx0XHR3aGVlbFNwZWVkOiB0aGlzLm9wdGlvbnMud2hlZWxTcGVlZFxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLm9wdGlvbnMucmFuZ2UgPSB0aGlzLl9iYXIoXCJvcHRpb25cIiwgXCJyYW5nZVwiKTtcblx0XHR0aGlzLm9wdGlvbnMud2hlZWxNb2RlID0gdGhpcy5fYmFyKFwib3B0aW9uXCIsIFwid2hlZWxNb2RlXCIpO1xuXHRcdHRoaXMub3B0aW9ucy53aGVlbFNwZWVkID0gdGhpcy5fYmFyKFwib3B0aW9uXCIsIFwid2hlZWxTcGVlZFwiKTtcblx0fSxcblxuXHRfY3JlYXRlQXJyb3dzOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMuYXJyb3dzLmxlZnQgPSB0aGlzLl9jcmVhdGVBcnJvdyhcImxlZnRcIik7XG5cdFx0dGhpcy5hcnJvd3MucmlnaHQgPSB0aGlzLl9jcmVhdGVBcnJvdyhcInJpZ2h0XCIpO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXJyb3dzKXtcblx0XHRcdHRoaXMuYXJyb3dzLmxlZnQuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG5cdFx0XHR0aGlzLmFycm93cy5yaWdodC5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcblx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcImJrLXVpLXJhbmdlU2xpZGVyLW5vQXJyb3dcIik7XG5cdFx0fWVsc2V7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJiay11aS1yYW5nZVNsaWRlci13aXRoQXJyb3dzXCIpO1xuXHRcdH1cblx0fSxcblxuXHRfY3JlYXRlQXJyb3c6IGZ1bmN0aW9uKHdoaWNoT25lKXtcblx0XHR2YXIgYXJyb3cgPSAkKFwiPGRpdiBjbGFzcz0nYmstdWktcmFuZ2VTbGlkZXItYXJyb3cnIC8+XCIpXG5cdFx0XHQuYXBwZW5kKFwiPGRpdiBjbGFzcz0nYmstdWktcmFuZ2VTbGlkZXItYXJyb3ctaW5uZXInIC8+XCIpXG5cdFx0XHQuYWRkQ2xhc3MoXCJiay11aS1yYW5nZVNsaWRlci1cIiArIHdoaWNoT25lICsgXCJBcnJvd1wiKVxuXHRcdFx0LmNzcyhcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIilcblx0XHRcdC5jc3Mod2hpY2hPbmUsIDApXG5cdFx0XHQuYXBwZW5kVG8odGhpcy5lbGVtZW50KSxcblx0XHRcdHRhcmdldDtcblxuXHRcdGlmICh3aGljaE9uZSA9PT0gXCJyaWdodFwiKXtcblx0XHRcdHRhcmdldCA9ICQucHJveHkodGhpcy5fc2Nyb2xsUmlnaHRDbGljaywgdGhpcyk7XG5cdFx0fWVsc2V7XG5cdFx0XHR0YXJnZXQgPSAkLnByb3h5KHRoaXMuX3Njcm9sbExlZnRDbGljaywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0YXJyb3cuYmluZChcIm1vdXNlZG93biB0b3VjaHN0YXJ0XCIsIHRhcmdldCk7XG5cblx0XHRyZXR1cm4gYXJyb3c7XG5cdH0sXG5cblx0X3Byb3h5OiBmdW5jdGlvbihlbGVtZW50LCB0eXBlLCBhcmdzKXtcblx0XHR2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcblxuXHRcdGlmIChlbGVtZW50ICYmIGVsZW1lbnRbdHlwZV0pe1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRbdHlwZV0uYXBwbHkoZWxlbWVudCwgYXJyYXkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdF9oYW5kbGVUeXBlOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBcInJhbmdlU2xpZGVySGFuZGxlXCI7XG5cdH0sXG5cblx0X2JhclR5cGU6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIFwicmFuZ2VTbGlkZXJCYXJcIjtcblx0fSxcblxuXHRfYmFyOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLl9wcm94eSh0aGlzLmJhciwgdGhpcy5fYmFyVHlwZSgpLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9sYWJlbFR5cGU6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIFwicmFuZ2VTbGlkZXJMYWJlbFwiO1xuXHR9LFxuXG5cdF9sZWZ0TGFiZWw6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb3h5KHRoaXMubGFiZWxzLmxlZnQsIHRoaXMuX2xhYmVsVHlwZSgpLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9yaWdodExhYmVsOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLl9wcm94eSh0aGlzLmxhYmVscy5yaWdodCwgdGhpcy5fbGFiZWxUeXBlKCksIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0X2xlZnRIYW5kbGU6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb3h5KHRoaXMubGVmdEhhbmRsZSwgdGhpcy5faGFuZGxlVHlwZSgpLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9yaWdodEhhbmRsZTogZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5fcHJveHkodGhpcy5yaWdodEhhbmRsZSwgdGhpcy5faGFuZGxlVHlwZSgpLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9nZXRWYWx1ZTogZnVuY3Rpb24ocG9zaXRpb24sIGhhbmRsZSl7XG5cdFx0aWYgKGhhbmRsZSA9PT0gdGhpcy5yaWdodEhhbmRsZSl7XG5cdFx0XHRwb3NpdGlvbiA9IHBvc2l0aW9uIC0gaGFuZGxlLm91dGVyV2lkdGgoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcG9zaXRpb24gKiAodGhpcy5vcHRpb25zLmJvdW5kcy5tYXggLSB0aGlzLm9wdGlvbnMuYm91bmRzLm1pbikgLyAodGhpcy5jb250YWluZXIuaW5uZXJXaWR0aCgpIC0gaGFuZGxlLm91dGVyV2lkdGgodHJ1ZSkpICsgdGhpcy5vcHRpb25zLmJvdW5kcy5taW47XG5cdH0sXG5cblx0X3RyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSl7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0dGhhdC5lbGVtZW50LnRyaWdnZXIoZXZlbnROYW1lLCB7XG5cdFx0XHRcdFx0bGFiZWw6IHRoYXQuZWxlbWVudCxcblx0XHRcdFx0XHR2YWx1ZXM6IHRoYXQudmFsdWVzKClcblx0XHRcdFx0fSk7XG5cdFx0fSwgMSk7XG5cdH0sXG5cblx0X2NoYW5naW5nOiBmdW5jdGlvbigpe1xuXHRcdGlmKHRoaXMuX3VwZGF0ZVZhbHVlcygpKXtcblx0XHRcdHRoaXMuX3RyaWdnZXIoXCJ2YWx1ZXNDaGFuZ2luZ1wiKTtcblx0XHRcdHRoaXMuX3ZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRfZGVhY3RpdmF0ZUxhYmVsczogZnVuY3Rpb24oKXtcblx0XHRpZiAodGhpcy5vcHRpb25zLnZhbHVlTGFiZWxzID09PSBcImNoYW5nZVwiKXtcblx0XHRcdHRoaXMuX2xlZnRMYWJlbChcIm9wdGlvblwiLCBcInNob3dcIiwgXCJoaWRlXCIpO1xuXHRcdFx0dGhpcy5fcmlnaHRMYWJlbChcIm9wdGlvblwiLCBcInNob3dcIiwgXCJoaWRlXCIpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVhY3RpdmF0ZUxhYmVsczogZnVuY3Rpb24oKXtcblx0XHRpZiAodGhpcy5vcHRpb25zLnZhbHVlTGFiZWxzID09PSBcImNoYW5nZVwiKXtcblx0XHRcdHRoaXMuX2xlZnRMYWJlbChcIm9wdGlvblwiLCBcInNob3dcIiwgXCJjaGFuZ2VcIik7XG5cdFx0XHR0aGlzLl9yaWdodExhYmVsKFwib3B0aW9uXCIsIFwic2hvd1wiLCBcImNoYW5nZVwiKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGlzQXV0b21hdGljKXtcblx0XHRpZiAoaXNBdXRvbWF0aWMgPT09IHRydWUpe1xuXHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUxhYmVscygpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl91cGRhdGVWYWx1ZXMoKSB8fCB0aGlzLl92YWx1ZXNDaGFuZ2VkKXtcblx0XHRcdHRoaXMuX3RyaWdnZXIoXCJ2YWx1ZXNDaGFuZ2VkXCIpO1xuXG5cdFx0XHRpZiAoaXNBdXRvbWF0aWMgIT09IHRydWUpe1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKFwidXNlclZhbHVlc0NoYW5nZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3ZhbHVlc0NoYW5nZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoaXNBdXRvbWF0aWMgPT09IHRydWUpe1xuXHRcdFx0dGhpcy5fcmVhY3RpdmF0ZUxhYmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlVmFsdWVzOiBmdW5jdGlvbigpe1xuXHRcdHZhciBsZWZ0ID0gdGhpcy5fbGVmdEhhbmRsZShcInZhbHVlXCIpLFxuXHRcdFx0cmlnaHQgPSB0aGlzLl9yaWdodEhhbmRsZShcInZhbHVlXCIpLFxuXHRcdFx0bWluID0gdGhpcy5fbWluKGxlZnQsIHJpZ2h0KSxcblx0XHRcdG1heCA9IHRoaXMuX21heChsZWZ0LCByaWdodCksXG5cdFx0XHRjaGFuZ2luZyA9IChtaW4gIT09IHRoaXMuX3ZhbHVlcy5taW4gfHwgbWF4ICE9PSB0aGlzLl92YWx1ZXMubWF4KTtcblxuXHRcdHRoaXMuX3ZhbHVlcy5taW4gPSB0aGlzLl9taW4obGVmdCwgcmlnaHQpO1xuXHRcdHRoaXMuX3ZhbHVlcy5tYXggPSB0aGlzLl9tYXgobGVmdCwgcmlnaHQpO1xuXG5cdFx0cmV0dXJuIGNoYW5naW5nO1xuXHR9LFxuXG5cdF9taW46IGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKXtcblx0XHRyZXR1cm4gTWF0aC5taW4odmFsdWUxLCB2YWx1ZTIpO1xuXHR9LFxuXG5cdF9tYXg6IGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKXtcblx0XHRyZXR1cm4gTWF0aC5tYXgodmFsdWUxLCB2YWx1ZTIpO1xuXHR9LFxuXG5cdC8qXG5cdCAqIFZhbHVlIGxhYmVsc1xuXHQgKi9cblx0X2NyZWF0ZUxhYmVsOiBmdW5jdGlvbihsYWJlbCwgaGFuZGxlKXtcblx0XHR2YXIgcGFyYW1zO1xuXG5cdFx0aWYgKGxhYmVsID09PSBudWxsKXtcblx0XHRcdHBhcmFtcyA9IHRoaXMuX2dldExhYmVsQ29uc3RydWN0b3JQYXJhbWV0ZXJzKGxhYmVsLCBoYW5kbGUpO1xuXHRcdFx0bGFiZWwgPSAkKFwiPGRpdiAvPlwiKVxuXHRcdFx0XHQuYXBwZW5kVG8odGhpcy5lbGVtZW50KVxuXHRcdFx0XHRbdGhpcy5fbGFiZWxUeXBlKCldKHBhcmFtcyk7XG5cdFx0fWVsc2V7XG5cdFx0XHRwYXJhbXMgPSB0aGlzLl9nZXRMYWJlbFJlZnJlc2hQYXJhbWV0ZXJzKGxhYmVsLCBoYW5kbGUpO1xuXG5cdFx0XHRsYWJlbFt0aGlzLl9sYWJlbFR5cGUoKV0ocGFyYW1zKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGFiZWw7XG5cdH0sXG5cblx0X2dldExhYmVsQ29uc3RydWN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbihsYWJlbCwgaGFuZGxlKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aGFuZGxlOiBoYW5kbGUsXG5cdFx0XHRoYW5kbGVUeXBlOiB0aGlzLl9oYW5kbGVUeXBlKCksXG5cdFx0XHRmb3JtYXR0ZXI6IHRoaXMuX2dldEZvcm1hdHRlcigpLFxuXHRcdFx0c2hvdzogdGhpcy5vcHRpb25zLnZhbHVlTGFiZWxzLFxuXHRcdFx0ZHVyYXRpb25JbjogdGhpcy5vcHRpb25zLmR1cmF0aW9uSW4sXG5cdFx0XHRkdXJhdGlvbk91dDogdGhpcy5vcHRpb25zLmR1cmF0aW9uT3V0LFxuXHRcdFx0ZGVsYXlPdXQ6IHRoaXMub3B0aW9ucy5kZWxheU91dFxuXHRcdH07XG5cdH0sXG5cblx0X2dldExhYmVsUmVmcmVzaFBhcmFtZXRlcnM6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGZvcm1hdHRlcjogdGhpcy5fZ2V0Rm9ybWF0dGVyKCksXG5cdFx0XHRzaG93OiB0aGlzLm9wdGlvbnMudmFsdWVMYWJlbHMsXG5cdFx0XHRkdXJhdGlvbkluOiB0aGlzLm9wdGlvbnMuZHVyYXRpb25Jbixcblx0XHRcdGR1cmF0aW9uT3V0OiB0aGlzLm9wdGlvbnMuZHVyYXRpb25PdXQsXG5cdFx0XHRkZWxheU91dDogdGhpcy5vcHRpb25zLmRlbGF5T3V0XG5cdFx0fTtcblx0fSxcblxuXHRfZ2V0Rm9ybWF0dGVyOiBmdW5jdGlvbigpe1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuZm9ybWF0dGVyID09PSBmYWxzZSB8fCB0aGlzLm9wdGlvbnMuZm9ybWF0dGVyID09PSBudWxsKXtcblx0XHRcdHJldHVybiB0aGlzLl9kZWZhdWx0Rm9ybWF0dGVyO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuZm9ybWF0dGVyO1xuXHR9LFxuXG5cdF9kZWZhdWx0Rm9ybWF0dGVyOiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuXHR9LFxuXG5cdF9kZXN0cm95TGFiZWw6IGZ1bmN0aW9uKGxhYmVsKXtcblx0XHRpZiAobGFiZWwgIT09IG51bGwpe1xuXHRcdFx0bGFiZWxbdGhpcy5fbGFiZWxUeXBlKCldKFwiZGVzdHJveVwiKTtcblx0XHRcdGxhYmVsLnJlbW92ZSgpO1xuXHRcdFx0bGFiZWwgPSBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBsYWJlbDtcblx0fSxcblxuXHRfY3JlYXRlTGFiZWxzOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMubGFiZWxzLmxlZnQgPSB0aGlzLl9jcmVhdGVMYWJlbCh0aGlzLmxhYmVscy5sZWZ0LCB0aGlzLmxlZnRIYW5kbGUpO1xuXHRcdHRoaXMubGFiZWxzLnJpZ2h0ID0gdGhpcy5fY3JlYXRlTGFiZWwodGhpcy5sYWJlbHMucmlnaHQsIHRoaXMucmlnaHRIYW5kbGUpO1xuXG5cdFx0dGhpcy5fbGVmdExhYmVsKFwicGFpclwiLCB0aGlzLmxhYmVscy5yaWdodCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lMYWJlbHM6IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5sYWJlbHMubGVmdCA9IHRoaXMuX2Rlc3Ryb3lMYWJlbCh0aGlzLmxhYmVscy5sZWZ0KTtcblx0XHR0aGlzLmxhYmVscy5yaWdodCA9IHRoaXMuX2Rlc3Ryb3lMYWJlbCh0aGlzLmxhYmVscy5yaWdodCk7XG5cdH0sXG5cblx0Lypcblx0ICogU2Nyb2xsaW5nXG5cdCAqL1xuXHRfc3RlcFJhdGlvOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLl9sZWZ0SGFuZGxlKFwic3RlcFJhdGlvXCIpO1xuXHR9LFxuXG5cdF9zY3JvbGxSaWdodENsaWNrOiBmdW5jdGlvbihlKXtcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVkKSByZXR1cm4gZmFsc2U7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0dGhpcy5fYmFyKFwic3RhcnRTY3JvbGxcIik7XG5cdFx0dGhpcy5fYmluZFN0b3BTY3JvbGwoKTtcblxuXHRcdHRoaXMuX2NvbnRpbnVlU2Nyb2xsaW5nKFwic2Nyb2xsUmlnaHRcIiwgNCAqIHRoaXMuX3N0ZXBSYXRpbygpLCAxKTtcblx0fSxcblxuXHRfY29udGludWVTY3JvbGxpbmc6IGZ1bmN0aW9uKGFjdGlvbiwgdGltZW91dCwgcXVhbnRpdHksIHRpbWVzQmVmb3JlU3BlZWRpbmdVcCl7XG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dGhpcy5fYmFyKGFjdGlvbiwgcXVhbnRpdHkpO1xuXHRcdHRpbWVzQmVmb3JlU3BlZWRpbmdVcCA9IHRpbWVzQmVmb3JlU3BlZWRpbmdVcCB8fCA1O1xuXHRcdHRpbWVzQmVmb3JlU3BlZWRpbmdVcC0tO1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0bWluVGltZW91dCA9IDE2LFxuXHRcdFx0bWF4UXVhbnRpdHkgPSBNYXRoLm1heCgxLCA0IC8gdGhpcy5fc3RlcFJhdGlvKCkpO1xuXG5cdFx0dGhpcy5fc2Nyb2xsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdGlmICh0aW1lc0JlZm9yZVNwZWVkaW5nVXAgPT09IDApe1xuXHRcdFx0XHRpZiAodGltZW91dCA+IG1pblRpbWVvdXQpe1xuXHRcdFx0XHRcdHRpbWVvdXQgPSBNYXRoLm1heChtaW5UaW1lb3V0LCB0aW1lb3V0IC8gMS41KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWFudGl0eSA9IE1hdGgubWluKG1heFF1YW50aXR5LCBxdWFudGl0eSAqIDIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGltZXNCZWZvcmVTcGVlZGluZ1VwID0gNTtcblx0XHRcdH1cblxuXHRcdFx0dGhhdC5fY29udGludWVTY3JvbGxpbmcoYWN0aW9uLCB0aW1lb3V0LCBxdWFudGl0eSwgdGltZXNCZWZvcmVTcGVlZGluZ1VwKTtcblx0XHR9LCB0aW1lb3V0KTtcblx0fSxcblxuXHRfc2Nyb2xsTGVmdENsaWNrOiBmdW5jdGlvbihlKXtcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVkKSByZXR1cm4gZmFsc2U7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR0aGlzLl9iYXIoXCJzdGFydFNjcm9sbFwiKTtcblx0XHR0aGlzLl9iaW5kU3RvcFNjcm9sbCgpO1xuXG5cdFx0dGhpcy5fY29udGludWVTY3JvbGxpbmcoXCJzY3JvbGxMZWZ0XCIsIDQgKiB0aGlzLl9zdGVwUmF0aW8oKSwgMSk7XG5cdH0sXG5cblx0X2JpbmRTdG9wU2Nyb2xsOiBmdW5jdGlvbigpe1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR0aGlzLl9zdG9wU2Nyb2xsSGFuZGxlID0gZnVuY3Rpb24oZSl7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGF0Ll9zdG9wU2Nyb2xsKCk7XG5cdFx0fTtcblxuXHRcdCQoZG9jdW1lbnQpLmJpbmQoXCJtb3VzZXVwIHRvdWNoZW5kXCIsIHRoaXMuX3N0b3BTY3JvbGxIYW5kbGUpO1xuXHR9LFxuXG5cdF9zdG9wU2Nyb2xsOiBmdW5jdGlvbigpe1xuXHRcdCQoZG9jdW1lbnQpLnVuYmluZChcIm1vdXNldXAgdG91Y2hlbmRcIiwgdGhpcy5fc3RvcFNjcm9sbEhhbmRsZSk7XG5cdFx0dGhpcy5fc3RvcFNjcm9sbEhhbmRsZSA9IG51bGw7XG5cdFx0dGhpcy5fYmFyKFwic3RvcFNjcm9sbFwiKTtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2Nyb2xsVGltZW91dCk7XG5cdH0sXG5cblx0Lypcblx0ICogUnVsZXJcblx0ICovXG5cdF9jcmVhdGVSdWxlcjogZnVuY3Rpb24oKXtcblx0XHR0aGlzLnJ1bGVyID0gJChcIjxkaXYgY2xhc3M9J2JrLXVpLXJhbmdlU2xpZGVyLXJ1bGVyJyAvPlwiKS5hcHBlbmRUbyh0aGlzLmlubmVyQmFyKTtcblx0fSxcblxuXHRfc2V0UnVsZXJQYXJhbWV0ZXJzOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMucnVsZXIucnVsZXIoe1xuXHRcdFx0bWluOiB0aGlzLm9wdGlvbnMuYm91bmRzLm1pbixcblx0XHRcdG1heDogdGhpcy5vcHRpb25zLmJvdW5kcy5tYXgsXG5cdFx0XHRzY2FsZXM6IHRoaXMub3B0aW9ucy5zY2FsZXNcblx0XHR9KTtcblx0fSxcblxuXHRfZGVzdHJveVJ1bGVyOiBmdW5jdGlvbigpe1xuXHRcdGlmICh0aGlzLnJ1bGVyICE9PSBudWxsICYmICQuZm4ucnVsZXIpe1xuXHRcdFx0dGhpcy5ydWxlci5ydWxlcihcImRlc3Ryb3lcIik7XG5cdFx0XHR0aGlzLnJ1bGVyLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5ydWxlciA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVSdWxlcjogZnVuY3Rpb24oKXtcblx0XHR0aGlzLl9kZXN0cm95UnVsZXIoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2NhbGVzID09PSBmYWxzZSB8fCAhJC5mbi5ydWxlcil7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fY3JlYXRlUnVsZXIoKTtcblx0XHR0aGlzLl9zZXRSdWxlclBhcmFtZXRlcnMoKTtcblx0fSxcblxuXHQvKlxuXHQgKiBQdWJsaWMgbWV0aG9kc1xuXHQgKi9cblx0dmFsdWVzOiBmdW5jdGlvbihtaW4sIG1heCl7XG5cdFx0dmFyIHZhbDtcblxuXHRcdGlmICh0eXBlb2YgbWluICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBtYXggIT09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplZCl7XG5cdFx0XHRcdHRoaXMuX3ZhbHVlcy5taW4gPSBtaW47XG5cdFx0XHRcdHRoaXMuX3ZhbHVlcy5tYXggPSBtYXg7XG5cdFx0XHRcdHJldHVybiB0aGlzLl92YWx1ZXM7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2RlYWN0aXZhdGVMYWJlbHMoKTtcblx0XHRcdHZhbCA9IHRoaXMuX2JhcihcInZhbHVlc1wiLCBtaW4sIG1heCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKHRydWUpO1xuXHRcdFx0dGhpcy5fcmVhY3RpdmF0ZUxhYmVscygpO1xuXHRcdH1lbHNle1xuXHRcdFx0dmFsID0gdGhpcy5fYmFyKFwidmFsdWVzXCIsIG1pbiwgbWF4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9LFxuXG5cdG1pbjogZnVuY3Rpb24obWluKXtcblx0XHR0aGlzLl92YWx1ZXMubWluID0gdGhpcy52YWx1ZXMobWluLCB0aGlzLl92YWx1ZXMubWF4KS5taW47XG5cblx0XHRyZXR1cm4gdGhpcy5fdmFsdWVzLm1pbjtcblx0fSxcblxuXHRtYXg6IGZ1bmN0aW9uKG1heCl7XG5cdFx0dGhpcy5fdmFsdWVzLm1heCA9IHRoaXMudmFsdWVzKHRoaXMuX3ZhbHVlcy5taW4sIG1heCkubWF4O1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlcy5tYXg7XG5cdH0sXG5cblx0Ym91bmRzOiBmdW5jdGlvbihtaW4sIG1heCl7XG5cdFx0aWYgKHRoaXMuX2lzVmFsaWRWYWx1ZShtaW4pICYmIHRoaXMuX2lzVmFsaWRWYWx1ZShtYXgpICYmIG1pbiA8IG1heCl7XG5cblx0XHRcdHRoaXMuX3NldEJvdW5kcyhtaW4sIG1heCk7XG5cdFx0XHR0aGlzLl91cGRhdGVSdWxlcigpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCh0cnVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmJvdW5kcztcblx0fSxcblxuXHRfaXNWYWxpZFZhbHVlOiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwYXJzZUZsb2F0KHZhbHVlKSA9PT0gdmFsdWU7XG5cdH0sXG5cblx0X3NldEJvdW5kczogZnVuY3Rpb24obWluLCBtYXgpe1xuXHRcdHRoaXMub3B0aW9ucy5ib3VuZHMgPSB7bWluOiBtaW4sIG1heDogbWF4fTtcblx0XHR0aGlzLl9sZWZ0SGFuZGxlKFwib3B0aW9uXCIsIFwiYm91bmRzXCIsIHRoaXMub3B0aW9ucy5ib3VuZHMpO1xuXHRcdHRoaXMuX3JpZ2h0SGFuZGxlKFwib3B0aW9uXCIsIFwiYm91bmRzXCIsIHRoaXMub3B0aW9ucy5ib3VuZHMpO1xuXHRcdHRoaXMuX2JhcihcIm9wdGlvblwiLCBcImJvdW5kc1wiLCB0aGlzLm9wdGlvbnMuYm91bmRzKTtcblx0fSxcblxuXHR6b29tSW46IGZ1bmN0aW9uKHF1YW50aXR5KXtcblx0XHR0aGlzLl9iYXIoXCJ6b29tSW5cIiwgcXVhbnRpdHkpXG5cdH0sXG5cblx0em9vbU91dDogZnVuY3Rpb24ocXVhbnRpdHkpe1xuXHRcdHRoaXMuX2JhcihcInpvb21PdXRcIiwgcXVhbnRpdHkpO1xuXHR9LFxuXG5cdHNjcm9sbExlZnQ6IGZ1bmN0aW9uKHF1YW50aXR5KXtcblx0XHR0aGlzLl9iYXIoXCJzdGFydFNjcm9sbFwiKTtcblx0XHR0aGlzLl9iYXIoXCJzY3JvbGxMZWZ0XCIsIHF1YW50aXR5KTtcblx0XHR0aGlzLl9iYXIoXCJzdG9wU2Nyb2xsXCIpO1xuXHR9LFxuXG5cdHNjcm9sbFJpZ2h0OiBmdW5jdGlvbihxdWFudGl0eSl7XG5cdFx0dGhpcy5fYmFyKFwic3RhcnRTY3JvbGxcIik7XG5cdFx0dGhpcy5fYmFyKFwic2Nyb2xsUmlnaHRcIiwgcXVhbnRpdHkpO1xuXHRcdHRoaXMuX2JhcihcInN0b3BTY3JvbGxcIik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlc2l6ZVxuXHQgKi9cblx0cmVzaXplOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMuX2luaXRXaWR0aCgpO1xuXHRcdHRoaXMuX2xlZnRIYW5kbGUoXCJ1cGRhdGVcIik7XG5cdFx0dGhpcy5fcmlnaHRIYW5kbGUoXCJ1cGRhdGVcIik7XG5cdFx0dGhpcy5fYmFyKFwidXBkYXRlXCIpO1xuXHR9LFxuXG5cdC8qXG5cdCAqIEVuYWJsZSAvIGRpc2FibGVcblx0ICovXG5cdGVuYWJsZTogZnVuY3Rpb24oKXtcblx0XHR0aGlzLnRvZ2dsZSh0cnVlKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMudG9nZ2xlKGZhbHNlKTtcblx0fSxcblxuXHR0b2dnbGU6IGZ1bmN0aW9uKGVuYWJsZWQpe1xuXHRcdGlmIChlbmFibGVkID09PSB1bmRlZmluZWQpIGVuYWJsZWQgPSAhdGhpcy5vcHRpb25zLmVuYWJsZWQ7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgIT09IGVuYWJsZWQpe1xuXHRcdFx0dGhpcy5fdG9nZ2xlKGVuYWJsZWQpO1xuXHRcdH1cblx0fSxcblxuXHRfdG9nZ2xlOiBmdW5jdGlvbihlbmFibGVkKXtcblx0XHR0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdFx0dGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKFwiYmstdWktcmFuZ2VTbGlkZXItZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuXG5cdFx0dmFyIGFjdGlvbiA9IGVuYWJsZWQgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCI7XG5cblx0XHR0aGlzLl9iYXIoYWN0aW9uKTtcblx0XHR0aGlzLl9sZWZ0SGFuZGxlKGFjdGlvbik7XG5cdFx0dGhpcy5fcmlnaHRIYW5kbGUoYWN0aW9uKTtcblx0XHR0aGlzLl9sZWZ0TGFiZWwoYWN0aW9uKTtcblx0XHR0aGlzLl9yaWdodExhYmVsKGFjdGlvbik7XG5cdH0sXG5cblx0Lypcblx0ICogRGVzdHJveVxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24oKXtcblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJiay11aS1yYW5nZVNsaWRlci13aXRoQXJyb3dzIGJrLXVpLXJhbmdlU2xpZGVyLW5vQXJyb3cgYmstdWktcmFuZ2VTbGlkZXItZGlzYWJsZWRcIik7XG5cblx0XHR0aGlzLl9kZXN0cm95V2lkZ2V0cygpO1xuXHRcdHRoaXMuX2Rlc3Ryb3lFbGVtZW50cygpO1xuXG5cdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFwiYmstdWktcmFuZ2VTbGlkZXJcIik7XG5cdFx0dGhpcy5vcHRpb25zID0gbnVsbDtcblxuXHRcdCQod2luZG93KS51bmJpbmQoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplUHJveHkpO1xuXHRcdHRoaXMuX3Jlc2l6ZVByb3h5ID0gbnVsbDtcblx0XHR0aGlzLl9iaW5kUmVzaXplID0gbnVsbDtcblxuXHRcdCQuV2lkZ2V0LnByb3RvdHlwZS5kZXN0cm95LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lXaWRnZXQ6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHRoaXNbXCJfXCIgKyBuYW1lXShcImRlc3Ryb3lcIik7XG5cdFx0dGhpc1tuYW1lXS5yZW1vdmUoKTtcblx0XHR0aGlzW25hbWVdID0gbnVsbDtcblx0fSxcblxuXHRfZGVzdHJveVdpZGdldHM6IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5fZGVzdHJveVdpZGdldChcImJhclwiKTtcblx0XHR0aGlzLl9kZXN0cm95V2lkZ2V0KFwibGVmdEhhbmRsZVwiKTtcblx0XHR0aGlzLl9kZXN0cm95V2lkZ2V0KFwicmlnaHRIYW5kbGVcIik7XG5cblx0XHR0aGlzLl9kZXN0cm95UnVsZXIoKTtcblx0XHR0aGlzLl9kZXN0cm95TGFiZWxzKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lFbGVtZW50czogZnVuY3Rpb24oKXtcblx0XHR0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcblx0XHR0aGlzLmNvbnRhaW5lciA9IG51bGw7XG5cblx0XHR0aGlzLmlubmVyQmFyLnJlbW92ZSgpO1xuXHRcdHRoaXMuaW5uZXJCYXIgPSBudWxsO1xuXG5cdFx0dGhpcy5hcnJvd3MubGVmdC5yZW1vdmUoKTtcblx0XHR0aGlzLmFycm93cy5yaWdodC5yZW1vdmUoKTtcblx0XHR0aGlzLmFycm93cyA9IG51bGw7XG5cdH1cbn0pO1xuIiwiLyohXG4gKiBqcXVlcnkuZXZlbnQuZHJhZyAtIHYgMi4yXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgVGhyZWUgRHViIE1lZGlhIC0gaHR0cDovL3RocmVlZHVibWVkaWEuY29tXG4gKiBPcGVuIFNvdXJjZSBNSVQgTGljZW5zZSAtIGh0dHA6Ly90aHJlZWR1Ym1lZGlhLmNvbS9jb2RlL2xpY2Vuc2VcbiAqL1xuLy8gQ3JlYXRlZDogMjAwOC0wNi0wNFxuLy8gVXBkYXRlZDogMjAxMi0wNS0yMVxuLy8gUkVRVUlSRVM6IGpxdWVyeSAxLjcueFxuXG52YXIgJCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XG5cbi8vIGFkZCB0aGUganF1ZXJ5IGluc3RhbmNlIG1ldGhvZFxuJC5mbi5kcmFnID0gZnVuY3Rpb24oIHN0ciwgYXJnLCBvcHRzICl7XG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGV2ZW50IHR5cGVcblx0dmFyIHR5cGUgPSB0eXBlb2Ygc3RyID09IFwic3RyaW5nXCIgPyBzdHIgOiBcIlwiLFxuXHQvLyBmaWd1cmUgb3V0IHRoZSBldmVudCBoYW5kbGVyLi4uXG5cdGZuID0gJC5pc0Z1bmN0aW9uKCBzdHIgKSA/IHN0ciA6ICQuaXNGdW5jdGlvbiggYXJnICkgPyBhcmcgOiBudWxsO1xuXHQvLyBmaXggdGhlIGV2ZW50IHR5cGVcblx0aWYgKCB0eXBlLmluZGV4T2YoXCJkcmFnXCIpICE9PSAwIClcblx0XHR0eXBlID0gXCJkcmFnXCIrIHR5cGU7XG5cdC8vIHdlcmUgb3B0aW9ucyBwYXNzZWRcblx0b3B0cyA9ICggc3RyID09IGZuID8gYXJnIDogb3B0cyApIHx8IHt9O1xuXHQvLyB0cmlnZ2VyIG9yIGJpbmQgZXZlbnQgaGFuZGxlclxuXHRyZXR1cm4gZm4gPyB0aGlzLmJpbmQoIHR5cGUsIG9wdHMsIGZuICkgOiB0aGlzLnRyaWdnZXIoIHR5cGUgKTtcbn07XG5cbi8vIGxvY2FsIHJlZnMgKGluY3JlYXNlIGNvbXByZXNzaW9uKVxudmFyICRldmVudCA9ICQuZXZlbnQsXG4kc3BlY2lhbCA9ICRldmVudC5zcGVjaWFsLFxuLy8gY29uZmlndXJlIHRoZSBkcmFnIHNwZWNpYWwgZXZlbnRcbmRyYWcgPSAkc3BlY2lhbC5kcmFnID0ge1xuXG5cdC8vIHRoZXNlIGFyZSB0aGUgZGVmYXVsdCBzZXR0aW5nc1xuXHRkZWZhdWx0czoge1xuXHRcdHdoaWNoOiAxLCAvLyBtb3VzZSBidXR0b24gcHJlc3NlZCB0byBzdGFydCBkcmFnIHNlcXVlbmNlXG5cdFx0ZGlzdGFuY2U6IDAsIC8vIGRpc3RhbmNlIGRyYWdnZWQgYmVmb3JlIGRyYWdzdGFydFxuXHRcdG5vdDogJzppbnB1dCcsIC8vIHNlbGVjdG9yIHRvIHN1cHByZXNzIGRyYWdnaW5nIG9uIHRhcmdldCBlbGVtZW50c1xuXHRcdGhhbmRsZTogbnVsbCwgLy8gc2VsZWN0b3IgdG8gbWF0Y2ggaGFuZGxlIHRhcmdldCBlbGVtZW50c1xuXHRcdHJlbGF0aXZlOiBmYWxzZSwgLy8gdHJ1ZSB0byB1c2UgXCJwb3NpdGlvblwiLCBmYWxzZSB0byB1c2UgXCJvZmZzZXRcIlxuXHRcdGRyb3A6IHRydWUsIC8vIGZhbHNlIHRvIHN1cHByZXNzIGRyb3AgZXZlbnRzLCB0cnVlIG9yIHNlbGVjdG9yIHRvIGFsbG93XG5cdFx0Y2xpY2s6IGZhbHNlIC8vIGZhbHNlIHRvIHN1cHByZXNzIGNsaWNrIGV2ZW50cyBhZnRlciBkcmFnZW5kIChubyBwcm94eSlcblx0fSxcblxuXHQvLyB0aGUga2V5IG5hbWUgZm9yIHN0b3JlZCBkcmFnIGRhdGFcblx0ZGF0YWtleTogXCJkcmFnZGF0YVwiLFxuXG5cdC8vIHByZXZlbnQgYnViYmxpbmcgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXHRub0J1YmJsZTogdHJ1ZSxcblxuXHQvLyBjb3VudCBib3VuZCByZWxhdGVkIGV2ZW50c1xuXHRhZGQ6IGZ1bmN0aW9uKCBvYmogKXtcblx0XHQvLyByZWFkIHRoZSBpbnRlcmFjdGlvbiBkYXRhXG5cdFx0dmFyIGRhdGEgPSAkLmRhdGEoIHRoaXMsIGRyYWcuZGF0YWtleSApLFxuXHRcdC8vIHJlYWQgYW55IHBhc3NlZCBvcHRpb25zXG5cdFx0b3B0cyA9IG9iai5kYXRhIHx8IHt9O1xuXHRcdC8vIGNvdW50IGFub3RoZXIgcmVhbHRlZCBldmVudFxuXHRcdGRhdGEucmVsYXRlZCArPSAxO1xuXHRcdC8vIGV4dGVuZCBkYXRhIG9wdGlvbnMgYm91bmQgd2l0aCB0aGlzIGV2ZW50XG5cdFx0Ly8gZG9uJ3QgaXRlcmF0ZSBcIm9wdHNcIiBpbiBjYXNlIGl0IGlzIGEgbm9kZVxuXHRcdCQuZWFjaCggZHJhZy5kZWZhdWx0cywgZnVuY3Rpb24oIGtleSwgZGVmICl7XG5cdFx0XHRpZiAoIG9wdHNbIGtleSBdICE9PSB1bmRlZmluZWQgKVxuXHRcdFx0XHRkYXRhWyBrZXkgXSA9IG9wdHNbIGtleSBdO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8vIGZvcmdldCB1bmJvdW5kIHJlbGF0ZWQgZXZlbnRzXG5cdHJlbW92ZTogZnVuY3Rpb24oKXtcblx0XHQkLmRhdGEoIHRoaXMsIGRyYWcuZGF0YWtleSApLnJlbGF0ZWQgLT0gMTtcblx0fSxcblxuXHQvLyBjb25maWd1cmUgaW50ZXJhY3Rpb24sIGNhcHR1cmUgc2V0dGluZ3Ncblx0c2V0dXA6IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gY2hlY2sgZm9yIHJlbGF0ZWQgZXZlbnRzXG5cdFx0aWYgKCAkLmRhdGEoIHRoaXMsIGRyYWcuZGF0YWtleSApIClcblx0XHRcdHJldHVybjtcblx0XHQvLyBpbml0aWFsaXplIHRoZSBkcmFnIGRhdGEgd2l0aCBjb3BpZWQgZGVmYXVsdHNcblx0XHR2YXIgZGF0YSA9ICQuZXh0ZW5kKHsgcmVsYXRlZDowIH0sIGRyYWcuZGVmYXVsdHMgKTtcblx0XHQvLyBzdG9yZSB0aGUgaW50ZXJhY3Rpb24gZGF0YVxuXHRcdCQuZGF0YSggdGhpcywgZHJhZy5kYXRha2V5LCBkYXRhICk7XG5cdFx0Ly8gYmluZCB0aGUgbW91c2Vkb3duIGV2ZW50LCB3aGljaCBzdGFydHMgZHJhZyBpbnRlcmFjdGlvbnNcblx0XHQkZXZlbnQuYWRkKCB0aGlzLCBcInRvdWNoc3RhcnQgbW91c2Vkb3duXCIsIGRyYWcuaW5pdCwgZGF0YSApO1xuXHRcdC8vIHByZXZlbnQgaW1hZ2UgZHJhZ2dpbmcgaW4gSUUuLi5cblx0XHRpZiAoIHRoaXMuYXR0YWNoRXZlbnQgKVxuXHRcdFx0dGhpcy5hdHRhY2hFdmVudChcIm9uZHJhZ3N0YXJ0XCIsIGRyYWcuZG9udHN0YXJ0ICk7XG5cdH0sXG5cblx0Ly8gZGVzdHJveSBjb25maWd1cmVkIGludGVyYWN0aW9uXG5cdHRlYXJkb3duOiBmdW5jdGlvbigpe1xuXHRcdHZhciBkYXRhID0gJC5kYXRhKCB0aGlzLCBkcmFnLmRhdGFrZXkgKSB8fCB7fTtcblx0XHQvLyBjaGVjayBmb3IgcmVsYXRlZCBldmVudHNcblx0XHRpZiAoIGRhdGEucmVsYXRlZCApXG5cdFx0XHRyZXR1cm47XG5cdFx0Ly8gcmVtb3ZlIHRoZSBzdG9yZWQgZGF0YVxuXHRcdCQucmVtb3ZlRGF0YSggdGhpcywgZHJhZy5kYXRha2V5ICk7XG5cdFx0Ly8gcmVtb3ZlIHRoZSBtb3VzZWRvd24gZXZlbnRcblx0XHQkZXZlbnQucmVtb3ZlKCB0aGlzLCBcInRvdWNoc3RhcnQgbW91c2Vkb3duXCIsIGRyYWcuaW5pdCApO1xuXHRcdC8vIGVuYWJsZSB0ZXh0IHNlbGVjdGlvblxuXHRcdGRyYWcudGV4dHNlbGVjdCggdHJ1ZSApO1xuXHRcdC8vIHVuLXByZXZlbnQgaW1hZ2UgZHJhZ2dpbmcgaW4gSUUuLi5cblx0XHRpZiAoIHRoaXMuZGV0YWNoRXZlbnQgKVxuXHRcdFx0dGhpcy5kZXRhY2hFdmVudChcIm9uZHJhZ3N0YXJ0XCIsIGRyYWcuZG9udHN0YXJ0ICk7XG5cdH0sXG5cblx0Ly8gaW5pdGlhbGl6ZSB0aGUgaW50ZXJhY3Rpb25cblx0aW5pdDogZnVuY3Rpb24oIGV2ZW50ICl7XG5cdFx0Ly8gc29ycnksIG9ubHkgb25lIHRvdWNoIGF0IGEgdGltZVxuXHRcdGlmICggZHJhZy50b3VjaGVkIClcblx0XHRcdHJldHVybjtcblx0XHQvLyB0aGUgZHJhZy9kcm9wIGludGVyYWN0aW9uIGRhdGFcblx0XHR2YXIgZGQgPSBldmVudC5kYXRhLCByZXN1bHRzO1xuXHRcdC8vIGNoZWNrIHRoZSB3aGljaCBkaXJlY3RpdmVcblx0XHRpZiAoIGV2ZW50LndoaWNoICE9IDAgJiYgZGQud2hpY2ggPiAwICYmIGV2ZW50LndoaWNoICE9IGRkLndoaWNoIClcblx0XHRcdHJldHVybjtcblx0XHQvLyBjaGVjayBmb3Igc3VwcHJlc3NlZCBzZWxlY3RvclxuXHRcdGlmICggJCggZXZlbnQudGFyZ2V0ICkuaXMoIGRkLm5vdCApIClcblx0XHRcdHJldHVybjtcblx0XHQvLyBjaGVjayBmb3IgaGFuZGxlIHNlbGVjdG9yXG5cdFx0aWYgKCBkZC5oYW5kbGUgJiYgISQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIGRkLmhhbmRsZSwgZXZlbnQuY3VycmVudFRhcmdldCApLmxlbmd0aCApXG5cdFx0XHRyZXR1cm47XG5cblx0XHRkcmFnLnRvdWNoZWQgPSBldmVudC50eXBlID09ICd0b3VjaHN0YXJ0JyA/IHRoaXMgOiBudWxsO1xuXHRcdGRkLnByb3BhZ2F0ZXMgPSAxO1xuXHRcdGRkLm1vdXNlZG93biA9IHRoaXM7XG5cdFx0ZGQuaW50ZXJhY3Rpb25zID0gWyBkcmFnLmludGVyYWN0aW9uKCB0aGlzLCBkZCApIF07XG5cdFx0ZGQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdGRkLnBhZ2VYID0gZXZlbnQucGFnZVg7XG5cdFx0ZGQucGFnZVkgPSBldmVudC5wYWdlWTtcblx0XHRkZC5kcmFnZ2luZyA9IG51bGw7XG5cdFx0Ly8gaGFuZGxlIGRyYWdpbml0IGV2ZW50Li4uXG5cdFx0cmVzdWx0cyA9IGRyYWcuaGlqYWNrKCBldmVudCwgXCJkcmFnaW5pdFwiLCBkZCApO1xuXHRcdC8vIGVhcmx5IGNhbmNlbFxuXHRcdGlmICggIWRkLnByb3BhZ2F0ZXMgKVxuXHRcdFx0cmV0dXJuO1xuXHRcdC8vIGZsYXR0ZW4gdGhlIHJlc3VsdCBzZXRcblx0XHRyZXN1bHRzID0gZHJhZy5mbGF0dGVuKCByZXN1bHRzICk7XG5cdFx0Ly8gaW5zZXJ0IG5ldyBpbnRlcmFjdGlvbiBlbGVtZW50c1xuXHRcdGlmICggcmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCApe1xuXHRcdFx0ZGQuaW50ZXJhY3Rpb25zID0gW107XG5cdFx0XHQkLmVhY2goIHJlc3VsdHMsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGRkLmludGVyYWN0aW9ucy5wdXNoKCBkcmFnLmludGVyYWN0aW9uKCB0aGlzLCBkZCApICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0Ly8gcmVtZW1iZXIgaG93IG1hbnkgaW50ZXJhY3Rpb25zIGFyZSBwcm9wYWdhdGluZ1xuXHRcdGRkLnByb3BhZ2F0ZXMgPSBkZC5pbnRlcmFjdGlvbnMubGVuZ3RoO1xuXHRcdC8vIGxvY2F0ZSBhbmQgaW5pdCB0aGUgZHJvcCB0YXJnZXRzXG5cdFx0aWYgKCBkZC5kcm9wICE9PSBmYWxzZSAmJiAkc3BlY2lhbC5kcm9wIClcblx0XHRcdCRzcGVjaWFsLmRyb3AuaGFuZGxlciggZXZlbnQsIGRkICk7XG5cdFx0Ly8gZGlzYWJsZSB0ZXh0IHNlbGVjdGlvblxuXHRcdGRyYWcudGV4dHNlbGVjdCggZmFsc2UgKTtcblx0XHQvLyBiaW5kIGFkZGl0aW9uYWwgZXZlbnRzLi4uXG5cdFx0aWYgKCBkcmFnLnRvdWNoZWQgKVxuXHRcdFx0JGV2ZW50LmFkZCggZHJhZy50b3VjaGVkLCBcInRvdWNobW92ZSB0b3VjaGVuZFwiLCBkcmFnLmhhbmRsZXIsIGRkICk7XG5cdFx0ZWxzZVxuXHRcdFx0JGV2ZW50LmFkZCggZG9jdW1lbnQsIFwibW91c2Vtb3ZlIG1vdXNldXBcIiwgZHJhZy5oYW5kbGVyLCBkZCApO1xuXHRcdC8vIGhlbHBzIHByZXZlbnQgdGV4dCBzZWxlY3Rpb24gb3Igc2Nyb2xsaW5nXG5cdFx0aWYgKCAhZHJhZy50b3VjaGVkIHx8IGRkLmxpdmUgKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8vIHJldHVybnMgYW4gaW50ZXJhY3Rpb24gb2JqZWN0XG5cdGludGVyYWN0aW9uOiBmdW5jdGlvbiggZWxlbSwgZGQgKXtcblx0XHR2YXIgb2Zmc2V0ID0gJCggZWxlbSApWyBkZC5yZWxhdGl2ZSA/IFwicG9zaXRpb25cIiA6IFwib2Zmc2V0XCIgXSgpIHx8IHsgdG9wOjAsIGxlZnQ6MCB9O1xuXHRcdHJldHVybiB7XG5cdFx0XHRkcmFnOiBlbGVtLFxuXHRcdFx0Y2FsbGJhY2s6IG5ldyBkcmFnLmNhbGxiYWNrKCksXG5cdFx0XHRkcm9wcGFibGU6IFtdLFxuXHRcdFx0b2Zmc2V0OiBvZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIGhhbmRsZSBkcmFnLXJlbGVhdGQgRE9NIGV2ZW50c1xuXHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKXtcblx0XHQvLyByZWFkIHRoZSBkYXRhIGJlZm9yZSBoaWphY2tpbmcgYW55dGhpbmdcblx0XHR2YXIgZGQgPSBldmVudC5kYXRhO1xuXHRcdC8vIGhhbmRsZSB2YXJpb3VzIGV2ZW50c1xuXHRcdHN3aXRjaCAoIGV2ZW50LnR5cGUgKXtcblx0XHRcdC8vIG1vdXNlbW92ZSwgY2hlY2sgZGlzdGFuY2UsIHN0YXJ0IGRyYWdnaW5nXG5cdFx0XHRjYXNlICFkZC5kcmFnZ2luZyAmJiAndG91Y2htb3ZlJzpcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGNhc2UgIWRkLmRyYWdnaW5nICYmICdtb3VzZW1vdmUnOlxuXHRcdFx0XHQvLyAgZHJhZyB0b2xlcmFuY2UsIHjiiaQgKyB54omkID0gZGlzdGFuY2XiiaRcblx0XHRcdFx0aWYgKCBNYXRoLnBvdyggIGV2ZW50LnBhZ2VYLWRkLnBhZ2VYLCAyICkgKyBNYXRoLnBvdyggIGV2ZW50LnBhZ2VZLWRkLnBhZ2VZLCAyICkgPCBNYXRoLnBvdyggZGQuZGlzdGFuY2UsIDIgKSApXG5cdFx0XHRcdFx0YnJlYWs7IC8vIGRpc3RhbmNlIHRvbGVyYW5jZSBub3QgcmVhY2hlZFxuXHRcdFx0XHRldmVudC50YXJnZXQgPSBkZC50YXJnZXQ7IC8vIGZvcmNlIHRhcmdldCBmcm9tIFwibW91c2Vkb3duXCIgZXZlbnQgKGZpeCBkaXN0YW5jZSBpc3N1ZSlcblx0XHRcdFx0ZHJhZy5oaWphY2soIGV2ZW50LCBcImRyYWdzdGFydFwiLCBkZCApOyAvLyB0cmlnZ2VyIFwiZHJhZ3N0YXJ0XCJcblx0XHRcdFx0aWYgKCBkZC5wcm9wYWdhdGVzICkgLy8gXCJkcmFnc3RhcnRcIiBub3QgcmVqZWN0ZWRcblx0XHRcdFx0XHRkZC5kcmFnZ2luZyA9IHRydWU7IC8vIGFjdGl2YXRlIGludGVyYWN0aW9uXG5cdFx0XHQvLyBtb3VzZW1vdmUsIGRyYWdnaW5nXG5cdFx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0aWYgKCBkZC5kcmFnZ2luZyApe1xuXHRcdFx0XHRcdC8vIHRyaWdnZXIgXCJkcmFnXCJcblx0XHRcdFx0XHRkcmFnLmhpamFjayggZXZlbnQsIFwiZHJhZ1wiLCBkZCApO1xuXHRcdFx0XHRcdGlmICggZGQucHJvcGFnYXRlcyApe1xuXHRcdFx0XHRcdFx0Ly8gbWFuYWdlIGRyb3AgZXZlbnRzXG5cdFx0XHRcdFx0XHRpZiAoIGRkLmRyb3AgIT09IGZhbHNlICYmICRzcGVjaWFsLmRyb3AgKVxuXHRcdFx0XHRcdFx0XHQkc3BlY2lhbC5kcm9wLmhhbmRsZXIoIGV2ZW50LCBkZCApOyAvLyBcImRyb3BzdGFydFwiLCBcImRyb3BlbmRcIlxuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIFwiZHJhZ1wiIG5vdCByZWplY3RlZCwgc3RvcFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRldmVudC50eXBlID0gXCJtb3VzZXVwXCI7IC8vIGhlbHBzIFwiZHJvcFwiIGhhbmRsZXIgYmVoYXZlXG5cdFx0XHRcdH1cblx0XHRcdC8vIG1vdXNldXAsIHN0b3AgZHJhZ2dpbmdcblx0XHRcdGNhc2UgJ3RvdWNoZW5kJzpcblx0XHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0aWYgKCBkcmFnLnRvdWNoZWQgKVxuXHRcdFx0XHRcdCRldmVudC5yZW1vdmUoIGRyYWcudG91Y2hlZCwgXCJ0b3VjaG1vdmUgdG91Y2hlbmRcIiwgZHJhZy5oYW5kbGVyICk7IC8vIHJlbW92ZSB0b3VjaCBldmVudHNcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdCRldmVudC5yZW1vdmUoIGRvY3VtZW50LCBcIm1vdXNlbW92ZSBtb3VzZXVwXCIsIGRyYWcuaGFuZGxlciApOyAvLyByZW1vdmUgcGFnZSBldmVudHNcblx0XHRcdFx0aWYgKCBkZC5kcmFnZ2luZyApe1xuXHRcdFx0XHRcdGlmICggZGQuZHJvcCAhPT0gZmFsc2UgJiYgJHNwZWNpYWwuZHJvcCApXG5cdFx0XHRcdFx0XHQkc3BlY2lhbC5kcm9wLmhhbmRsZXIoIGV2ZW50LCBkZCApOyAvLyBcImRyb3BcIlxuXHRcdFx0XHRcdGRyYWcuaGlqYWNrKCBldmVudCwgXCJkcmFnZW5kXCIsIGRkICk7IC8vIHRyaWdnZXIgXCJkcmFnZW5kXCJcblx0XHRcdFx0fVxuXHRcdFx0XHRkcmFnLnRleHRzZWxlY3QoIHRydWUgKTsgLy8gZW5hYmxlIHRleHQgc2VsZWN0aW9uXG5cdFx0XHRcdC8vIGlmIHN1cHByZXNzaW5nIGNsaWNrIGV2ZW50cy4uLlxuXHRcdFx0XHRpZiAoIGRkLmNsaWNrID09PSBmYWxzZSAmJiBkZC5kcmFnZ2luZyApXG5cdFx0XHRcdFx0JC5kYXRhKCBkZC5tb3VzZWRvd24sIFwic3VwcHJlc3MuY2xpY2tcIiwgbmV3IERhdGUoKS5nZXRUaW1lKCkgKyA1ICk7XG5cdFx0XHRcdGRkLmRyYWdnaW5nID0gZHJhZy50b3VjaGVkID0gZmFsc2U7IC8vIGRlYWN0aXZhdGUgZWxlbWVudFxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0Ly8gcmUtdXNlIGV2ZW50IG9iamVjdCBmb3IgY3VzdG9tIGV2ZW50c1xuXHRoaWphY2s6IGZ1bmN0aW9uKCBldmVudCwgdHlwZSwgZGQsIHgsIGVsZW0gKXtcblx0XHQvLyBub3QgY29uZmlndXJlZFxuXHRcdGlmICggIWRkIClcblx0XHRcdHJldHVybjtcblx0XHQvLyByZW1lbWJlciB0aGUgb3JpZ2luYWwgZXZlbnQgYW5kIHR5cGVcblx0XHR2YXIgb3JpZyA9IHsgZXZlbnQ6ZXZlbnQub3JpZ2luYWxFdmVudCwgdHlwZTpldmVudC50eXBlIH0sXG5cdFx0Ly8gaXMgdGhlIGV2ZW50IGRyYWcgcmVsYXRlZCBvciBkcm9nIHJlbGF0ZWQ/XG5cdFx0bW9kZSA9IHR5cGUuaW5kZXhPZihcImRyb3BcIikgPyBcImRyYWdcIiA6IFwiZHJvcFwiLFxuXHRcdC8vIGl0ZXJhdGlvbiB2YXJzXG5cdFx0cmVzdWx0LCBpID0geCB8fCAwLCBpYSwgJGVsZW1zLCBjYWxsYmFjayxcblx0XHRsZW4gPSAhaXNOYU4oIHggKSA/IHggOiBkZC5pbnRlcmFjdGlvbnMubGVuZ3RoO1xuXHRcdC8vIG1vZGlmeSB0aGUgZXZlbnQgdHlwZVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXHRcdC8vIHJlbW92ZSB0aGUgb3JpZ2luYWwgZXZlbnRcblx0XHRldmVudC5vcmlnaW5hbEV2ZW50ID0gbnVsbDtcblx0XHQvLyBpbml0aWFsaXplIHRoZSByZXN1bHRzXG5cdFx0ZGQucmVzdWx0cyA9IFtdO1xuXHRcdC8vIGhhbmRsZSBlYWNoIGludGVyYWN0ZWQgZWxlbWVudFxuXHRcdGRvIGlmICggaWEgPSBkZC5pbnRlcmFjdGlvbnNbIGkgXSApe1xuXHRcdFx0Ly8gdmFsaWRhdGUgdGhlIGludGVyYWN0aW9uXG5cdFx0XHRpZiAoIHR5cGUgIT09IFwiZHJhZ2VuZFwiICYmIGlhLmNhbmNlbGxlZCApXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0Ly8gc2V0IHRoZSBkcmFnZHJvcCBwcm9wZXJ0aWVzIG9uIHRoZSBldmVudCBvYmplY3Rcblx0XHRcdGNhbGxiYWNrID0gZHJhZy5wcm9wZXJ0aWVzKCBldmVudCwgZGQsIGlhICk7XG5cdFx0XHQvLyBwcmVwYXJlIGZvciBtb3JlIHJlc3VsdHNcblx0XHRcdGlhLnJlc3VsdHMgPSBbXTtcblx0XHRcdC8vIGhhbmRsZSBlYWNoIGVsZW1lbnRcblx0XHRcdCQoIGVsZW0gfHwgaWFbIG1vZGUgXSB8fCBkZC5kcm9wcGFibGUgKS5lYWNoKGZ1bmN0aW9uKCBwLCBzdWJqZWN0ICl7XG5cdFx0XHRcdC8vIGlkZW50aWZ5IGRyYWcgb3IgZHJvcCB0YXJnZXRzIGluZGl2aWR1YWxseVxuXHRcdFx0XHRjYWxsYmFjay50YXJnZXQgPSBzdWJqZWN0O1xuXHRcdFx0XHQvLyBmb3JjZSBwcm9wYWd0aW9uIG9mIHRoZSBjdXN0b20gZXZlbnRcblx0XHRcdFx0ZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvbigpeyByZXR1cm4gZmFsc2U7IH07XG5cdFx0XHRcdC8vIGhhbmRsZSB0aGUgZXZlbnRcblx0XHRcdFx0cmVzdWx0ID0gc3ViamVjdCA/ICRldmVudC5kaXNwYXRjaC5jYWxsKCBzdWJqZWN0LCBldmVudCwgY2FsbGJhY2sgKSA6IG51bGw7XG5cdFx0XHRcdC8vIHN0b3AgdGhlIGRyYWcgaW50ZXJhY3Rpb24gZm9yIHRoaXMgZWxlbWVudFxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PT0gZmFsc2UgKXtcblx0XHRcdFx0XHRpZiAoIG1vZGUgPT0gXCJkcmFnXCIgKXtcblx0XHRcdFx0XHRcdGlhLmNhbmNlbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRkZC5wcm9wYWdhdGVzIC09IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdHlwZSA9PSBcImRyb3BcIiApe1xuXHRcdFx0XHRcdFx0aWFbIG1vZGUgXVtwXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGFzc2lnbiBhbnkgZHJvcGluaXQgZWxlbWVudHNcblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT0gXCJkcm9waW5pdFwiIClcblx0XHRcdFx0XHRpYS5kcm9wcGFibGUucHVzaCggZHJhZy5lbGVtZW50KCByZXN1bHQgKSB8fCBzdWJqZWN0ICk7XG5cdFx0XHRcdC8vIGFjY2VwdCBhIHJldHVybmVkIHByb3h5IGVsZW1lbnRcblx0XHRcdFx0aWYgKCB0eXBlID09IFwiZHJhZ3N0YXJ0XCIgKVxuXHRcdFx0XHRcdGlhLnByb3h5ID0gJCggZHJhZy5lbGVtZW50KCByZXN1bHQgKSB8fCBpYS5kcmFnIClbMF07XG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoaXMgcmVzdWx0XG5cdFx0XHRcdGlhLnJlc3VsdHMucHVzaCggcmVzdWx0ICk7XG5cdFx0XHRcdC8vIGZvcmdldCB0aGUgZXZlbnQgcmVzdWx0LCBmb3IgcmVjeWNsaW5nXG5cdFx0XHRcdGRlbGV0ZSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdC8vIGJyZWFrIG9uIGNhbmNlbGxlZCBoYW5kbGVyXG5cdFx0XHRcdGlmICggdHlwZSAhPT0gXCJkcm9waW5pdFwiIClcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fSk7XG5cdFx0XHQvLyBmbGF0dGVuIHRoZSByZXN1bHRzXG5cdFx0XHRkZC5yZXN1bHRzWyBpIF0gPSBkcmFnLmZsYXR0ZW4oIGlhLnJlc3VsdHMgKTtcblx0XHRcdC8vIGFjY2VwdCBhIHNldCBvZiB2YWxpZCBkcm9wIHRhcmdldHNcblx0XHRcdGlmICggdHlwZSA9PSBcImRyb3Bpbml0XCIgKVxuXHRcdFx0XHRpYS5kcm9wcGFibGUgPSBkcmFnLmZsYXR0ZW4oIGlhLmRyb3BwYWJsZSApO1xuXHRcdFx0Ly8gbG9jYXRlIGRyb3AgdGFyZ2V0c1xuXHRcdFx0aWYgKCB0eXBlID09IFwiZHJhZ3N0YXJ0XCIgJiYgIWlhLmNhbmNlbGxlZCApXG5cdFx0XHRcdGNhbGxiYWNrLnVwZGF0ZSgpO1xuXHRcdH1cblx0XHR3aGlsZSAoICsraSA8IGxlbiApXG5cdFx0Ly8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgZXZlbnQgJiB0eXBlXG5cdFx0ZXZlbnQudHlwZSA9IG9yaWcudHlwZTtcblx0XHRldmVudC5vcmlnaW5hbEV2ZW50ID0gb3JpZy5ldmVudDtcblx0XHQvLyByZXR1cm4gYWxsIGhhbmRsZXIgcmVzdWx0c1xuXHRcdHJldHVybiBkcmFnLmZsYXR0ZW4oIGRkLnJlc3VsdHMgKTtcblx0fSxcblxuXHQvLyBleHRlbmQgdGhlIGNhbGxiYWNrIG9iamVjdCB3aXRoIGRyYWcvZHJvcCBwcm9wZXJ0aWVzLi4uXG5cdHByb3BlcnRpZXM6IGZ1bmN0aW9uKCBldmVudCwgZGQsIGlhICl7XG5cdFx0dmFyIG9iaiA9IGlhLmNhbGxiYWNrO1xuXHRcdC8vIGVsZW1lbnRzXG5cdFx0b2JqLmRyYWcgPSBpYS5kcmFnO1xuXHRcdG9iai5wcm94eSA9IGlhLnByb3h5IHx8IGlhLmRyYWc7XG5cdFx0Ly8gc3RhcnRpbmcgbW91c2UgcG9zaXRpb25cblx0XHRvYmouc3RhcnRYID0gZGQucGFnZVg7XG5cdFx0b2JqLnN0YXJ0WSA9IGRkLnBhZ2VZO1xuXHRcdC8vIGN1cnJlbnQgZGlzdGFuY2UgZHJhZ2dlZFxuXHRcdG9iai5kZWx0YVggPSBldmVudC5wYWdlWCAtIGRkLnBhZ2VYO1xuXHRcdG9iai5kZWx0YVkgPSBldmVudC5wYWdlWSAtIGRkLnBhZ2VZO1xuXHRcdC8vIG9yaWdpbmFsIGVsZW1lbnQgcG9zaXRpb25cblx0XHRvYmoub3JpZ2luYWxYID0gaWEub2Zmc2V0LmxlZnQ7XG5cdFx0b2JqLm9yaWdpbmFsWSA9IGlhLm9mZnNldC50b3A7XG5cdFx0Ly8gYWRqdXN0ZWQgZWxlbWVudCBwb3NpdGlvblxuXHRcdG9iai5vZmZzZXRYID0gb2JqLm9yaWdpbmFsWCArIG9iai5kZWx0YVg7XG5cdFx0b2JqLm9mZnNldFkgPSBvYmoub3JpZ2luYWxZICsgb2JqLmRlbHRhWTtcblx0XHQvLyBhc3NpZ24gdGhlIGRyb3AgdGFyZ2V0cyBpbmZvcm1hdGlvblxuXHRcdG9iai5kcm9wID0gZHJhZy5mbGF0dGVuKCAoIGlhLmRyb3AgfHwgW10gKS5zbGljZSgpICk7XG5cdFx0b2JqLmF2YWlsYWJsZSA9IGRyYWcuZmxhdHRlbiggKCBpYS5kcm9wcGFibGUgfHwgW10gKS5zbGljZSgpICk7XG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBkZXRlcm1pbmUgaXMgdGhlIGFyZ3VtZW50IGlzIGFuIGVsZW1lbnQgb3IganF1ZXJ5IGluc3RhbmNlXG5cdGVsZW1lbnQ6IGZ1bmN0aW9uKCBhcmcgKXtcblx0XHRpZiAoIGFyZyAmJiAoIGFyZy5qcXVlcnkgfHwgYXJnLm5vZGVUeXBlID09IDEgKSApXG5cdFx0XHRyZXR1cm4gYXJnO1xuXHR9LFxuXG5cdC8vIGZsYXR0ZW4gbmVzdGVkIGpxdWVyeSBvYmplY3RzIGFuZCBhcnJheXMgaW50byBhIHNpbmdsZSBkaW1lbnNpb24gYXJyYXlcblx0ZmxhdHRlbjogZnVuY3Rpb24oIGFyciApe1xuXHRcdHJldHVybiAkLm1hcCggYXJyLCBmdW5jdGlvbiggbWVtYmVyICl7XG5cdFx0XHRyZXR1cm4gbWVtYmVyICYmIG1lbWJlci5qcXVlcnkgPyAkLm1ha2VBcnJheSggbWVtYmVyICkgOlxuXHRcdFx0XHRtZW1iZXIgJiYgbWVtYmVyLmxlbmd0aCA/IGRyYWcuZmxhdHRlbiggbWVtYmVyICkgOiBtZW1iZXI7XG5cdFx0fSk7XG5cdH0sXG5cblx0Ly8gdG9nZ2xlcyB0ZXh0IHNlbGVjdGlvbiBhdHRyaWJ1dGVzIE9OICh0cnVlKSBvciBPRkYgKGZhbHNlKVxuXHR0ZXh0c2VsZWN0OiBmdW5jdGlvbiggYm9vbCApe1xuXHRcdCQoIGRvY3VtZW50IClbIGJvb2wgPyBcInVuYmluZFwiIDogXCJiaW5kXCIgXShcInNlbGVjdHN0YXJ0XCIsIGRyYWcuZG9udHN0YXJ0IClcblx0XHRcdC5jc3MoXCJNb3pVc2VyU2VsZWN0XCIsIGJvb2wgPyBcIlwiIDogXCJub25lXCIgKTtcblx0XHQvLyAuYXR0cihcInVuc2VsZWN0YWJsZVwiLCBib29sID8gXCJvZmZcIiA6IFwib25cIiApXG5cdFx0ZG9jdW1lbnQudW5zZWxlY3RhYmxlID0gYm9vbCA/IFwib2ZmXCIgOiBcIm9uXCI7XG5cdH0sXG5cblx0Ly8gc3VwcHJlc3MgXCJzZWxlY3RzdGFydFwiIGFuZCBcIm9uZHJhZ3N0YXJ0XCIgZXZlbnRzXG5cdGRvbnRzdGFydDogZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Ly8gYSBjYWxsYmFjayBpbnN0YW5jZSBjb250cnVjdG9yXG5cdGNhbGxiYWNrOiBmdW5jdGlvbigpe31cblxufTtcblxuLy8gY2FsbGJhY2sgbWV0aG9kc1xuZHJhZy5jYWxsYmFjay5wcm90b3R5cGUgPSB7XG5cdHVwZGF0ZTogZnVuY3Rpb24oKXtcblx0XHRpZiAoICRzcGVjaWFsLmRyb3AgJiYgdGhpcy5hdmFpbGFibGUubGVuZ3RoIClcblx0XHRcdCQuZWFjaCggdGhpcy5hdmFpbGFibGUsIGZ1bmN0aW9uKCBpICl7XG5cdFx0XHRcdCRzcGVjaWFsLmRyb3AubG9jYXRlKCB0aGlzLCBpICk7XG5cdFx0XHR9KTtcblx0fVxufTtcblxuLy8gcGF0Y2ggJC5ldmVudC4kZGlzcGF0Y2ggdG8gYWxsb3cgc3VwcHJlc3NpbmcgY2xpY2tzXG52YXIgJGRpc3BhdGNoID0gJGV2ZW50LmRpc3BhdGNoO1xuJGV2ZW50LmRpc3BhdGNoID0gZnVuY3Rpb24oIGV2ZW50ICl7XG5cdGlmICggJC5kYXRhKCB0aGlzLCBcInN1cHByZXNzLlwiKyBldmVudC50eXBlICkgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IDAgKXtcblx0XHQkLnJlbW92ZURhdGEoIHRoaXMsIFwic3VwcHJlc3MuXCIrIGV2ZW50LnR5cGUgKTtcblx0XHRyZXR1cm47XG5cdH1cblx0cmV0dXJuICRkaXNwYXRjaC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG59O1xuXG4vLyBldmVudCBmaXggaG9va3MgZm9yIHRvdWNoIGV2ZW50cy4uLlxudmFyIHRvdWNoSG9va3MgPVxuJGV2ZW50LmZpeEhvb2tzLnRvdWNoc3RhcnQgPVxuJGV2ZW50LmZpeEhvb2tzLnRvdWNobW92ZSA9XG4kZXZlbnQuZml4SG9va3MudG91Y2hlbmQgPVxuJGV2ZW50LmZpeEhvb2tzLnRvdWNoY2FuY2VsID0ge1xuXHRwcm9wczogXCJjbGllbnRYIGNsaWVudFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZXCIuc3BsaXQoIFwiIFwiICksXG5cdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnICkge1xuXHRcdGlmICggb3JpZyApe1xuXHRcdFx0dmFyIHRvdWNoZWQgPSAoIG9yaWcudG91Y2hlcyAmJiBvcmlnLnRvdWNoZXNbMF0gKVxuXHRcdFx0XHR8fCAoIG9yaWcuY2hhbmdlZFRvdWNoZXMgJiYgb3JpZy5jaGFuZ2VkVG91Y2hlc1swXSApXG5cdFx0XHRcdHx8IG51bGw7XG5cdFx0XHQvLyBpT1Mgd2Via2l0OiB0b3VjaHN0YXJ0LCB0b3VjaG1vdmUsIHRvdWNoZW5kXG5cdFx0XHRpZiAoIHRvdWNoZWQgKVxuXHRcdFx0XHQkLmVhY2goIHRvdWNoSG9va3MucHJvcHMsIGZ1bmN0aW9uKCBpLCBwcm9wICl7XG5cdFx0XHRcdFx0ZXZlbnRbIHByb3AgXSA9IHRvdWNoZWRbIHByb3AgXTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBldmVudDtcblx0fVxufTtcblxuLy8gc2hhcmUgdGhlIHNhbWUgc3BlY2lhbCBldmVudCBjb25maWd1cmF0aW9uIHdpdGggcmVsYXRlZCBldmVudHMuLi5cbiRzcGVjaWFsLmRyYWdpbml0ID0gJHNwZWNpYWwuZHJhZ3N0YXJ0ID0gJHNwZWNpYWwuZHJhZ2VuZCA9IGRyYWc7XG4iLCIvKiFcbiAqIGpxdWVyeS5ldmVudC5kcm9wIC0gdiAyLjJcbiAqIENvcHlyaWdodCAoYykgMjAxMCBUaHJlZSBEdWIgTWVkaWEgLSBodHRwOi8vdGhyZWVkdWJtZWRpYS5jb21cbiAqIE9wZW4gU291cmNlIE1JVCBMaWNlbnNlIC0gaHR0cDovL3RocmVlZHVibWVkaWEuY29tL2NvZGUvbGljZW5zZVxuICovXG4vLyBDcmVhdGVkOiAyMDA4LTA2LTA0XG4vLyBVcGRhdGVkOiAyMDEyLTA1LTIxXG4vLyBSRVFVSVJFUzoganF1ZXJ5IDEuNy54LCBldmVudC5kcmFnIDIuMlxuXG52YXIgJCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XG52YXIgJDEgPSByZXF1aXJlKFwianF1ZXJ5X2V2ZW50X2RyYWdcIik7XG5cbi8vIEV2ZW50czogZHJvcCwgZHJvcHN0YXJ0LCBkcm9wZW5kXG5cbi8vIGFkZCB0aGUganF1ZXJ5IGluc3RhbmNlIG1ldGhvZFxuJC5mbi5kcm9wID0gZnVuY3Rpb24oIHN0ciwgYXJnLCBvcHRzICl7XG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGV2ZW50IHR5cGVcblx0dmFyIHR5cGUgPSB0eXBlb2Ygc3RyID09IFwic3RyaW5nXCIgPyBzdHIgOiBcIlwiLFxuXHQvLyBmaWd1cmUgb3V0IHRoZSBldmVudCBoYW5kbGVyLi4uXG5cdGZuID0gJC5pc0Z1bmN0aW9uKCBzdHIgKSA/IHN0ciA6ICQuaXNGdW5jdGlvbiggYXJnICkgPyBhcmcgOiBudWxsO1xuXHQvLyBmaXggdGhlIGV2ZW50IHR5cGVcblx0aWYgKCB0eXBlLmluZGV4T2YoXCJkcm9wXCIpICE9PSAwIClcblx0XHR0eXBlID0gXCJkcm9wXCIrIHR5cGU7XG5cdC8vIHdlcmUgb3B0aW9ucyBwYXNzZWRcblx0b3B0cyA9ICggc3RyID09IGZuID8gYXJnIDogb3B0cyApIHx8IHt9O1xuXHQvLyB0cmlnZ2VyIG9yIGJpbmQgZXZlbnQgaGFuZGxlclxuXHRyZXR1cm4gZm4gPyB0aGlzLmJpbmQoIHR5cGUsIG9wdHMsIGZuICkgOiB0aGlzLnRyaWdnZXIoIHR5cGUgKTtcbn07XG5cbi8vIERST1AgTUFOQUdFTUVOVCBVVElMSVRZXG4vLyByZXR1cm5zIGZpbHRlcmVkIGRyb3AgdGFyZ2V0IGVsZW1lbnRzLCBjYWNoZXMgdGhlaXIgcG9zaXRpb25zXG4kLmRyb3AgPSBmdW5jdGlvbiggb3B0cyApe1xuXHRvcHRzID0gb3B0cyB8fCB7fTtcblx0Ly8gc2FmZWx5IHNldCBuZXcgb3B0aW9ucy4uLlxuXHRkcm9wLm11bHRpID0gb3B0cy5tdWx0aSA9PT0gdHJ1ZSA/IEluZmluaXR5IDpcblx0XHRvcHRzLm11bHRpID09PSBmYWxzZSA/IDEgOiAhaXNOYU4oIG9wdHMubXVsdGkgKSA/IG9wdHMubXVsdGkgOiBkcm9wLm11bHRpO1xuXHRkcm9wLmRlbGF5ID0gb3B0cy5kZWxheSB8fCBkcm9wLmRlbGF5O1xuXHRkcm9wLnRvbGVyYW5jZSA9ICQuaXNGdW5jdGlvbiggb3B0cy50b2xlcmFuY2UgKSA/IG9wdHMudG9sZXJhbmNlIDpcblx0XHRvcHRzLnRvbGVyYW5jZSA9PT0gbnVsbCA/IG51bGwgOiBkcm9wLnRvbGVyYW5jZTtcblx0ZHJvcC5tb2RlID0gb3B0cy5tb2RlIHx8IGRyb3AubW9kZSB8fCAnaW50ZXJzZWN0Jztcbn07XG5cbi8vIGxvY2FsIHJlZnMgKGluY3JlYXNlIGNvbXByZXNzaW9uKVxudmFyICRldmVudCA9ICQuZXZlbnQsXG4kc3BlY2lhbCA9ICRldmVudC5zcGVjaWFsLFxuLy8gY29uZmlndXJlIHRoZSBkcm9wIHNwZWNpYWwgZXZlbnRcbmRyb3AgPSAkLmV2ZW50LnNwZWNpYWwuZHJvcCA9IHtcblxuXHQvLyB0aGVzZSBhcmUgdGhlIGRlZmF1bHQgc2V0dGluZ3Ncblx0bXVsdGk6IDEsIC8vIGFsbG93IG11bHRpcGxlIGRyb3Agd2lubmVycyBwZXIgZHJhZ2dlZCBlbGVtZW50XG5cdGRlbGF5OiAyMCwgLy8gYXN5bmMgdGltZW91dCBkZWxheVxuXHRtb2RlOiAnb3ZlcmxhcCcsIC8vIGRyb3AgdG9sZXJhbmNlIG1vZGVcblxuXHQvLyBpbnRlcm5hbCBjYWNoZVxuXHR0YXJnZXRzOiBbXSxcblxuXHQvLyB0aGUga2V5IG5hbWUgZm9yIHN0b3JlZCBkcm9wIGRhdGFcblx0ZGF0YWtleTogXCJkcm9wZGF0YVwiLFxuXG5cdC8vIHByZXZlbnQgYnViYmxpbmcgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXHRub0J1YmJsZTogdHJ1ZSxcblxuXHQvLyBjb3VudCBib3VuZCByZWxhdGVkIGV2ZW50c1xuXHRhZGQ6IGZ1bmN0aW9uKCBvYmogKXtcblx0XHQvLyByZWFkIHRoZSBpbnRlcmFjdGlvbiBkYXRhXG5cdFx0dmFyIGRhdGEgPSAkLmRhdGEoIHRoaXMsIGRyb3AuZGF0YWtleSApO1xuXHRcdC8vIGNvdW50IGFub3RoZXIgcmVhbHRlZCBldmVudFxuXHRcdGRhdGEucmVsYXRlZCArPSAxO1xuXHR9LFxuXG5cdC8vIGZvcmdldCB1bmJvdW5kIHJlbGF0ZWQgZXZlbnRzXG5cdHJlbW92ZTogZnVuY3Rpb24oKXtcblx0XHQkLmRhdGEoIHRoaXMsIGRyb3AuZGF0YWtleSApLnJlbGF0ZWQgLT0gMTtcblx0fSxcblxuXHQvLyBjb25maWd1cmUgdGhlIGludGVyYWN0aW9uc1xuXHRzZXR1cDogZnVuY3Rpb24oKXtcblx0XHQvLyBjaGVjayBmb3IgcmVsYXRlZCBldmVudHNcblx0XHRpZiAoICQuZGF0YSggdGhpcywgZHJvcC5kYXRha2V5ICkgKVxuXHRcdFx0cmV0dXJuO1xuXHRcdC8vIGluaXRpYWxpemUgdGhlIGRyb3AgZWxlbWVudCBkYXRhXG5cdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRyZWxhdGVkOiAwLFxuXHRcdFx0YWN0aXZlOiBbXSxcblx0XHRcdGFueWFjdGl2ZTogMCxcblx0XHRcdHdpbm5lcjogMCxcblx0XHRcdGxvY2F0aW9uOiB7fVxuXHRcdH07XG5cdFx0Ly8gc3RvcmUgdGhlIGRyb3AgZGF0YSBvbiB0aGUgZWxlbWVudFxuXHRcdCQuZGF0YSggdGhpcywgZHJvcC5kYXRha2V5LCBkYXRhICk7XG5cdFx0Ly8gc3RvcmUgdGhlIGRyb3AgdGFyZ2V0IGluIGludGVybmFsIGNhY2hlXG5cdFx0ZHJvcC50YXJnZXRzLnB1c2goIHRoaXMgKTtcblx0fSxcblxuXHQvLyBkZXN0cm95IHRoZSBjb25maWd1cmUgaW50ZXJhY3Rpb25cblx0dGVhcmRvd246IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGRhdGEgPSAkLmRhdGEoIHRoaXMsIGRyb3AuZGF0YWtleSApIHx8IHt9O1xuXHRcdC8vIGNoZWNrIGZvciByZWxhdGVkIGV2ZW50c1xuXHRcdGlmICggZGF0YS5yZWxhdGVkIClcblx0XHRcdHJldHVybjtcblx0XHQvLyByZW1vdmUgdGhlIHN0b3JlZCBkYXRhXG5cdFx0JC5yZW1vdmVEYXRhKCB0aGlzLCBkcm9wLmRhdGFrZXkgKTtcblx0XHQvLyByZWZlcmVuY2UgdGhlIHRhcmdldGVkIGVsZW1lbnRcblx0XHR2YXIgZWxlbWVudCA9IHRoaXM7XG5cdFx0Ly8gcmVtb3ZlIGZyb20gdGhlIGludGVybmFsIGNhY2hlXG5cdFx0ZHJvcC50YXJnZXRzID0gJC5ncmVwKCBkcm9wLnRhcmdldHMsIGZ1bmN0aW9uKCB0YXJnZXQgKXtcblx0XHRcdHJldHVybiAoIHRhcmdldCAhPT0gZWxlbWVudCApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8vIHNoYXJlZCBldmVudCBoYW5kbGVyXG5cdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCwgZGQgKXtcblx0XHQvLyBsb2NhbCB2YXJzXG5cdFx0dmFyIHJlc3VsdHMsICR0YXJnZXRzO1xuXHRcdC8vIG1ha2Ugc3VyZSB0aGUgcmlnaHQgZGF0YSBpcyBhdmFpbGFibGVcblx0XHRpZiAoICFkZCApXG5cdFx0XHRyZXR1cm47XG5cdFx0Ly8gaGFuZGxlIHZhcmlvdXMgZXZlbnRzXG5cdFx0c3dpdGNoICggZXZlbnQudHlwZSApe1xuXHRcdFx0Ly8gZHJhZ2luaXQsIGZyb20gJC5ldmVudC5zcGVjaWFsLmRyYWdcblx0XHRcdGNhc2UgJ21vdXNlZG93bic6IC8vIERST1BJTklUID4+XG5cdFx0XHRjYXNlICd0b3VjaHN0YXJ0JzogLy8gRFJPUElOSVQgPj5cblx0XHRcdFx0Ly8gY29sbGVjdCBhbmQgYXNzaWduIHRoZSBkcm9wIHRhcmdldHNcblx0XHRcdFx0JHRhcmdldHMgPSAgJCggZHJvcC50YXJnZXRzICk7XG5cdFx0XHRcdGlmICggdHlwZW9mIGRkLmRyb3AgPT0gXCJzdHJpbmdcIiApXG5cdFx0XHRcdFx0JHRhcmdldHMgPSAkdGFyZ2V0cy5maWx0ZXIoIGRkLmRyb3AgKTtcblx0XHRcdFx0Ly8gcmVzZXQgZHJvcCBkYXRhIHdpbm5lciBwcm9wZXJ0aWVzXG5cdFx0XHRcdCR0YXJnZXRzLmVhY2goZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgZGF0YSA9ICQuZGF0YSggdGhpcywgZHJvcC5kYXRha2V5ICk7XG5cdFx0XHRcdFx0ZGF0YS5hY3RpdmUgPSBbXTtcblx0XHRcdFx0XHRkYXRhLmFueWFjdGl2ZSA9IDA7XG5cdFx0XHRcdFx0ZGF0YS53aW5uZXIgPSAwO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gc2V0IGF2YWlsYWJsZSB0YXJnZXQgZWxlbWVudHNcblx0XHRcdFx0ZGQuZHJvcHBhYmxlID0gJHRhcmdldHM7XG5cdFx0XHRcdC8vIGFjdGl2YXRlIGRyb3AgdGFyZ2V0cyBmb3IgdGhlIGluaXRpYWwgZWxlbWVudCBiZWluZyBkcmFnZ2VkXG5cdFx0XHRcdCRzcGVjaWFsLmRyYWcuaGlqYWNrKCBldmVudCwgXCJkcm9waW5pdFwiLCBkZCApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdC8vIGRyYWcsIGZyb20gJC5ldmVudC5zcGVjaWFsLmRyYWdcblx0XHRcdGNhc2UgJ21vdXNlbW92ZSc6IC8vIFRPTEVSQVRFID4+XG5cdFx0XHRjYXNlICd0b3VjaG1vdmUnOiAvLyBUT0xFUkFURSA+PlxuXHRcdFx0XHRkcm9wLmV2ZW50ID0gZXZlbnQ7IC8vIHN0b3JlIHRoZSBtb3VzZW1vdmUgZXZlbnRcblx0XHRcdFx0aWYgKCAhZHJvcC50aW1lciApXG5cdFx0XHRcdFx0Ly8gbW9uaXRvciBkcm9wIHRhcmdldHNcblx0XHRcdFx0XHRkcm9wLnRvbGVyYXRlKCBkZCApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdC8vIGRyYWdlbmQsIGZyb20gJC5ldmVudC5zcGVjaWFsLmRyYWdcblx0XHRcdGNhc2UgJ21vdXNldXAnOiAvLyBEUk9QID4+IERST1BFTkQgPj5cblx0XHRcdGNhc2UgJ3RvdWNoZW5kJzogLy8gRFJPUCA+PiBEUk9QRU5EID4+XG5cdFx0XHRcdGRyb3AudGltZXIgPSBjbGVhclRpbWVvdXQoIGRyb3AudGltZXIgKTsgLy8gZGVsZXRlIHRpbWVyXG5cdFx0XHRcdGlmICggZGQucHJvcGFnYXRlcyApe1xuXHRcdFx0XHRcdCRzcGVjaWFsLmRyYWcuaGlqYWNrKCBldmVudCwgXCJkcm9wXCIsIGRkICk7XG5cdFx0XHRcdFx0JHNwZWNpYWwuZHJhZy5oaWphY2soIGV2ZW50LCBcImRyb3BlbmRcIiwgZGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblx0fSxcblxuXHQvLyByZXR1cm5zIHRoZSBsb2NhdGlvbiBwb3NpdGlvbnMgb2YgYW4gZWxlbWVudFxuXHRsb2NhdGU6IGZ1bmN0aW9uKCBlbGVtLCBpbmRleCApe1xuXHRcdHZhciBkYXRhID0gJC5kYXRhKCBlbGVtLCBkcm9wLmRhdGFrZXkgKSxcblx0XHQkZWxlbSA9ICQoIGVsZW0gKSxcblx0XHRwb3NpID0gJGVsZW0ub2Zmc2V0KCkgfHwge30sXG5cdFx0aGVpZ2h0ID0gJGVsZW0ub3V0ZXJIZWlnaHQoKSxcblx0XHR3aWR0aCA9ICRlbGVtLm91dGVyV2lkdGgoKSxcblx0XHRsb2NhdGlvbiA9IHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHRvcDogcG9zaS50b3AsXG5cdFx0XHRsZWZ0OiBwb3NpLmxlZnQsXG5cdFx0XHRyaWdodDogcG9zaS5sZWZ0ICsgd2lkdGgsXG5cdFx0XHRib3R0b206IHBvc2kudG9wICsgaGVpZ2h0XG5cdFx0fTtcblx0XHQvLyBkcmFnIGVsZW1lbnRzIG1pZ2h0IG5vdCBoYXZlIGRyb3BkYXRhXG5cdFx0aWYgKCBkYXRhICl7XG5cdFx0XHRkYXRhLmxvY2F0aW9uID0gbG9jYXRpb247XG5cdFx0XHRkYXRhLmluZGV4ID0gaW5kZXg7XG5cdFx0XHRkYXRhLmVsZW0gPSBlbGVtO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9jYXRpb247XG5cdH0sXG5cblx0Ly8gdGVzdCB0aGUgbG9jYXRpb24gcG9zaXRpb25zIG9mIGFuIGVsZW1lbnQgYWdhaW5zdCBhbm90aGVyIE9SIGFuIFgsWSBjb29yZFxuXHRjb250YWluczogZnVuY3Rpb24oIHRhcmdldCwgdGVzdCApeyAvLyB0YXJnZXQgeyBsb2NhdGlvbiB9IGNvbnRhaW5zIHRlc3QgW3gseV0gb3IgeyBsb2NhdGlvbiB9XG5cdFx0cmV0dXJuICggKCB0ZXN0WzBdIHx8IHRlc3QubGVmdCApID49IHRhcmdldC5sZWZ0ICYmICggdGVzdFswXSB8fCB0ZXN0LnJpZ2h0ICkgPD0gdGFyZ2V0LnJpZ2h0XG5cdFx0XHQmJiAoIHRlc3RbMV0gfHwgdGVzdC50b3AgKSA+PSB0YXJnZXQudG9wICYmICggdGVzdFsxXSB8fCB0ZXN0LmJvdHRvbSApIDw9IHRhcmdldC5ib3R0b20gKTtcblx0fSxcblxuXHQvLyBzdG9yZWQgdG9sZXJhbmNlIG1vZGVzXG5cdG1vZGVzOiB7IC8vIGZuIHNjb3BlOiBcIiQuZXZlbnQuc3BlY2lhbC5kcm9wXCIgb2JqZWN0XG5cdFx0Ly8gdGFyZ2V0IHdpdGggbW91c2Ugd2lucywgZWxzZSB0YXJnZXQgd2l0aCBtb3N0IG92ZXJsYXAgd2luc1xuXHRcdCdpbnRlcnNlY3QnOiBmdW5jdGlvbiggZXZlbnQsIHByb3h5LCB0YXJnZXQgKXtcblx0XHRcdHJldHVybiB0aGlzLmNvbnRhaW5zKCB0YXJnZXQsIFsgZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZIF0gKSA/IC8vIGNoZWNrIGN1cnNvclxuXHRcdFx0XHQxZTkgOiB0aGlzLm1vZGVzLm92ZXJsYXAuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApOyAvLyBjaGVjayBvdmVybGFwXG5cdFx0fSxcblx0XHQvLyB0YXJnZXQgd2l0aCBtb3N0IG92ZXJsYXAgd2luc1xuXHRcdCdvdmVybGFwJzogZnVuY3Rpb24oIGV2ZW50LCBwcm94eSwgdGFyZ2V0ICl7XG5cdFx0XHQvLyBjYWxjdWxhdGUgdGhlIGFyZWEgb2Ygb3ZlcmxhcC4uLlxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCAwLCBNYXRoLm1pbiggdGFyZ2V0LmJvdHRvbSwgcHJveHkuYm90dG9tICkgLSBNYXRoLm1heCggdGFyZ2V0LnRvcCwgcHJveHkudG9wICkgKVxuXHRcdFx0XHQqIE1hdGgubWF4KCAwLCBNYXRoLm1pbiggdGFyZ2V0LnJpZ2h0LCBwcm94eS5yaWdodCApIC0gTWF0aC5tYXgoIHRhcmdldC5sZWZ0LCBwcm94eS5sZWZ0ICkgKTtcblx0XHR9LFxuXHRcdC8vIHByb3h5IGlzIGNvbXBsZXRlbHkgY29udGFpbmVkIHdpdGhpbiB0YXJnZXQgYm91bmRzXG5cdFx0J2ZpdCc6IGZ1bmN0aW9uKCBldmVudCwgcHJveHksIHRhcmdldCApe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29udGFpbnMoIHRhcmdldCwgcHJveHkgKSA/IDEgOiAwO1xuXHRcdH0sXG5cdFx0Ly8gY2VudGVyIG9mIHRoZSBwcm94eSBpcyBjb250YWluZWQgd2l0aGluIHRhcmdldCBib3VuZHNcblx0XHQnbWlkZGxlJzogZnVuY3Rpb24oIGV2ZW50LCBwcm94eSwgdGFyZ2V0ICl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb250YWlucyggdGFyZ2V0LCBbIHByb3h5LmxlZnQgKyBwcm94eS53aWR0aCAqIC41LCBwcm94eS50b3AgKyBwcm94eS5oZWlnaHQgKiAuNSBdICkgPyAxIDogMDtcblx0XHR9XG5cdH0sXG5cblx0Ly8gc29ydCBkcm9wIHRhcmdldCBjYWNoZSBieSBieSB3aW5uZXIgKGRzYyksIHRoZW4gaW5kZXggKGFzYylcblx0c29ydDogZnVuY3Rpb24oIGEsIGIgKXtcblx0XHRyZXR1cm4gKCBiLndpbm5lciAtIGEud2lubmVyICkgfHwgKCBhLmluZGV4IC0gYi5pbmRleCApO1xuXHR9LFxuXG5cdC8vIGFzeW5jLCByZWN1cnNpdmUgdG9sZXJhbmNlIGV4ZWN1dGlvblxuXHR0b2xlcmF0ZTogZnVuY3Rpb24oIGRkICl7XG5cdFx0Ly8gZGVjbGFyZSBsb2NhbCByZWZzXG5cdFx0dmFyIGksIGRycCwgZHJnLCBkYXRhLCBhcnIsIGxlbiwgZWxlbSxcblx0XHQvLyBpbnRlcmFjdGlvbiBpdGVyYXRpb24gdmFyaWFibGVzXG5cdFx0eCA9IDAsIGlhLCBlbmQgPSBkZC5pbnRlcmFjdGlvbnMubGVuZ3RoLFxuXHRcdC8vIGRldGVybWluZSB0aGUgbW91c2UgY29vcmRzXG5cdFx0eHkgPSBbIGRyb3AuZXZlbnQucGFnZVgsIGRyb3AuZXZlbnQucGFnZVkgXSxcblx0XHQvLyBjdXN0b20gb3Igc3RvcmVkIHRvbGVyYW5jZSBmblxuXHRcdHRvbGVyYW5jZSA9IGRyb3AudG9sZXJhbmNlIHx8IGRyb3AubW9kZXNbIGRyb3AubW9kZSBdO1xuXHRcdC8vIGdvIHRocm91Z2ggZWFjaCBwYXNzZWQgaW50ZXJhY3Rpb24uLi5cblx0XHRkbyBpZiAoIGlhID0gZGQuaW50ZXJhY3Rpb25zW3hdICl7XG5cdFx0XHQvLyBjaGVjayB2YWxpZCBpbnRlcmFjdGlvblxuXHRcdFx0aWYgKCAhaWEgKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHQvLyBpbml0aWFsaXplIG9yIGNsZWFyIHRoZSBkcm9wIGRhdGFcblx0XHRcdGlhLmRyb3AgPSBbXTtcblx0XHRcdC8vIGhvbGRzIHRoZSBkcm9wIGVsZW1lbnRzXG5cdFx0XHRhcnIgPSBbXTtcblx0XHRcdGxlbiA9IGlhLmRyb3BwYWJsZS5sZW5ndGg7XG5cdFx0XHQvLyBkZXRlcm1pbmUgdGhlIHByb3h5IGxvY2F0aW9uLCBpZiBuZWVkZWRcblx0XHRcdGlmICggdG9sZXJhbmNlIClcblx0XHRcdFx0ZHJnID0gZHJvcC5sb2NhdGUoIGlhLnByb3h5ICk7XG5cdFx0XHQvLyByZXNldCB0aGUgbG9vcFxuXHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBsb29wIGVhY2ggc3RvcmVkIGRyb3AgdGFyZ2V0XG5cdFx0XHRkbyBpZiAoIGVsZW0gPSBpYS5kcm9wcGFibGVbaV0gKXtcblx0XHRcdFx0ZGF0YSA9ICQuZGF0YSggZWxlbSwgZHJvcC5kYXRha2V5ICk7XG5cdFx0XHRcdGRycCA9IGRhdGEubG9jYXRpb247XG5cdFx0XHRcdGlmICggIWRycCApIGNvbnRpbnVlO1xuXHRcdFx0XHQvLyBmaW5kIGEgd2lubmVyOiB0b2xlcmFuY2UgZnVuY3Rpb24gaXMgZGVmaW5lZCwgY2FsbCBpdFxuXHRcdFx0XHRkYXRhLndpbm5lciA9IHRvbGVyYW5jZSA/IHRvbGVyYW5jZS5jYWxsKCBkcm9wLCBkcm9wLmV2ZW50LCBkcmcsIGRycCApXG5cdFx0XHRcdFx0Ly8gbW91c2UgcG9zaXRpb24gaXMgYWx3YXlzIHRoZSBmYWxsYmFja1xuXHRcdFx0XHRcdDogZHJvcC5jb250YWlucyggZHJwLCB4eSApID8gMSA6IDA7XG5cdFx0XHRcdGFyci5wdXNoKCBkYXRhICk7XG5cdFx0XHR9IHdoaWxlICggKytpIDwgbGVuICk7IC8vIGxvb3Bcblx0XHRcdC8vIHNvcnQgdGhlIGRyb3AgdGFyZ2V0c1xuXHRcdFx0YXJyLnNvcnQoIGRyb3Auc29ydCApO1xuXHRcdFx0Ly8gcmVzZXQgdGhlIGxvb3Bcblx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIGFsbCBvZiB0aGUgdGFyZ2V0cyBhZ2FpblxuXHRcdFx0ZG8gaWYgKCBkYXRhID0gYXJyWyBpIF0gKXtcblx0XHRcdFx0Ly8gd2lubmVycy4uLlxuXHRcdFx0XHRpZiAoIGRhdGEud2lubmVyICYmIGlhLmRyb3AubGVuZ3RoIDwgZHJvcC5tdWx0aSApe1xuXHRcdFx0XHRcdC8vIG5ldyB3aW5uZXIuLi4gZHJvcHN0YXJ0XG5cdFx0XHRcdFx0aWYgKCAhZGF0YS5hY3RpdmVbeF0gJiYgIWRhdGEuYW55YWN0aXZlICl7XG5cdFx0XHRcdFx0XHQvLyBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIGlzIG5vdCBwcmV2ZW50ZWRcblx0XHRcdFx0XHRcdGlmICggJHNwZWNpYWwuZHJhZy5oaWphY2soIGRyb3AuZXZlbnQsIFwiZHJvcHN0YXJ0XCIsIGRkLCB4LCBkYXRhLmVsZW0gKVswXSAhPT0gZmFsc2UgKXtcblx0XHRcdFx0XHRcdFx0ZGF0YS5hY3RpdmVbeF0gPSAxO1xuXHRcdFx0XHRcdFx0XHRkYXRhLmFueWFjdGl2ZSArPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gaWYgZmFsc2UsIGl0IGlzIG5vdCBhIHdpbm5lclxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRkYXRhLndpbm5lciA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGlmIGl0IGlzIHN0aWxsIGEgd2lubmVyXG5cdFx0XHRcdFx0aWYgKCBkYXRhLndpbm5lciApXG5cdFx0XHRcdFx0XHRpYS5kcm9wLnB1c2goIGRhdGEuZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGxvc2Vycy4uLlxuXHRcdFx0XHRlbHNlIGlmICggZGF0YS5hY3RpdmVbeF0gJiYgZGF0YS5hbnlhY3RpdmUgPT0gMSApe1xuXHRcdFx0XHRcdC8vIGZvcm1lciB3aW5uZXIuLi4gZHJvcGVuZFxuXHRcdFx0XHRcdCRzcGVjaWFsLmRyYWcuaGlqYWNrKCBkcm9wLmV2ZW50LCBcImRyb3BlbmRcIiwgZGQsIHgsIGRhdGEuZWxlbSApO1xuXHRcdFx0XHRcdGRhdGEuYWN0aXZlW3hdID0gMDtcblx0XHRcdFx0XHRkYXRhLmFueWFjdGl2ZSAtPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICggKytpIDwgbGVuICk7IC8vIGxvb3Bcblx0XHR9IHdoaWxlICggKyt4IDwgZW5kICkgLy8gbG9vcFxuXHRcdC8vIGNoZWNrIGlmIHRoZSBtb3VzZSBpcyBzdGlsbCBtb3Zpbmcgb3IgaXMgaWRsZVxuXHRcdGlmICggZHJvcC5sYXN0ICYmIHh5WzBdID09IGRyb3AubGFzdC5wYWdlWCAmJiB4eVsxXSA9PSBkcm9wLmxhc3QucGFnZVkgKVxuXHRcdFx0ZGVsZXRlIGRyb3AudGltZXI7IC8vIGlkbGUsIGRvbid0IHJlY3Vyc2Vcblx0XHRlbHNlICAvLyByZWN1cnNlXG5cdFx0XHRkcm9wLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRkcm9wLnRvbGVyYXRlKCBkZCApO1xuXHRcdFx0fSwgZHJvcC5kZWxheSApO1xuXHRcdC8vIHJlbWVtYmVyIGV2ZW50LCB0byBjb21wYXJlIGlkbGVuZXNzXG5cdFx0ZHJvcC5sYXN0ID0gZHJvcC5ldmVudDtcblx0fVxuXG59O1xuXG4vLyBzaGFyZSB0aGUgc2FtZSBzcGVjaWFsIGV2ZW50IGNvbmZpZ3VyYXRpb24gd2l0aCByZWxhdGVkIGV2ZW50cy4uLlxuJHNwZWNpYWwuZHJvcGluaXQgPSAkc3BlY2lhbC5kcm9wc3RhcnQgPSAkc3BlY2lhbC5kcm9wZW5kID0gZHJvcDtcbiIsInZhciAkID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbnZhciBTbGljayA9IHJlcXVpcmUoXCIuLi9zbGljay5jb3JlXCIpO1xuXG5mdW5jdGlvbiBDaGVja2JveFNlbGVjdENvbHVtbihvcHRpb25zKSB7XG4gIHZhciBfZ3JpZDtcbiAgdmFyIF9zZWxmID0gdGhpcztcbiAgdmFyIF9oYW5kbGVyID0gbmV3IFNsaWNrLkV2ZW50SGFuZGxlcigpO1xuICB2YXIgX3NlbGVjdGVkUm93c0xvb2t1cCA9IHt9O1xuICB2YXIgX2RlZmF1bHRzID0ge1xuICAgIGNvbHVtbklkOiBcIl9jaGVja2JveF9zZWxlY3RvclwiLFxuICAgIGNzc0NsYXNzOiBudWxsLFxuICAgIHRvb2xUaXA6IFwiU2VsZWN0L0Rlc2VsZWN0IEFsbFwiLFxuICAgIHdpZHRoOiAzMFxuICB9O1xuXG4gIHZhciBfb3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBfZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIGluaXQoZ3JpZCkge1xuICAgIF9ncmlkID0gZ3JpZDtcbiAgICBfaGFuZGxlclxuICAgICAgLnN1YnNjcmliZShfZ3JpZC5vblNlbGVjdGVkUm93c0NoYW5nZWQsIGhhbmRsZVNlbGVjdGVkUm93c0NoYW5nZWQpXG4gICAgICAuc3Vic2NyaWJlKF9ncmlkLm9uQ2xpY2ssIGhhbmRsZUNsaWNrKVxuICAgICAgLnN1YnNjcmliZShfZ3JpZC5vbkhlYWRlckNsaWNrLCBoYW5kbGVIZWFkZXJDbGljaylcbiAgICAgIC5zdWJzY3JpYmUoX2dyaWQub25LZXlEb3duLCBoYW5kbGVLZXlEb3duKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgX2hhbmRsZXIudW5zdWJzY3JpYmVBbGwoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVNlbGVjdGVkUm93c0NoYW5nZWQoZSwgYXJncykge1xuICAgIHZhciBzZWxlY3RlZFJvd3MgPSBfZ3JpZC5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICB2YXIgbG9va3VwID0ge30sIHJvdywgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0ZWRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByb3cgPSBzZWxlY3RlZFJvd3NbaV07XG4gICAgICBsb29rdXBbcm93XSA9IHRydWU7XG4gICAgICBpZiAobG9va3VwW3Jvd10gIT09IF9zZWxlY3RlZFJvd3NMb29rdXBbcm93XSkge1xuICAgICAgICBfZ3JpZC5pbnZhbGlkYXRlUm93KHJvdyk7XG4gICAgICAgIGRlbGV0ZSBfc2VsZWN0ZWRSb3dzTG9va3VwW3Jvd107XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSBpbiBfc2VsZWN0ZWRSb3dzTG9va3VwKSB7XG4gICAgICBfZ3JpZC5pbnZhbGlkYXRlUm93KGkpO1xuICAgIH1cbiAgICBfc2VsZWN0ZWRSb3dzTG9va3VwID0gbG9va3VwO1xuICAgIF9ncmlkLnJlbmRlcigpO1xuXG4gICAgaWYgKHNlbGVjdGVkUm93cy5sZW5ndGggJiYgc2VsZWN0ZWRSb3dzLmxlbmd0aCA9PSBfZ3JpZC5nZXREYXRhTGVuZ3RoKCkpIHtcbiAgICAgIF9ncmlkLnVwZGF0ZUNvbHVtbkhlYWRlcihfb3B0aW9ucy5jb2x1bW5JZCwgXCI8aW5wdXQgdHlwZT0nY2hlY2tib3gnIGNoZWNrZWQ9J2NoZWNrZWQnPlwiLCBfb3B0aW9ucy50b29sVGlwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2dyaWQudXBkYXRlQ29sdW1uSGVhZGVyKF9vcHRpb25zLmNvbHVtbklkLCBcIjxpbnB1dCB0eXBlPSdjaGVja2JveCc+XCIsIF9vcHRpb25zLnRvb2xUaXApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZSwgYXJncykge1xuICAgIGlmIChlLndoaWNoID09IDMyKSB7XG4gICAgICBpZiAoX2dyaWQuZ2V0Q29sdW1ucygpW2FyZ3MuY2VsbF0uaWQgPT09IF9vcHRpb25zLmNvbHVtbklkKSB7XG4gICAgICAgIC8vIGlmIGVkaXRpbmcsIHRyeSB0byBjb21taXRcbiAgICAgICAgaWYgKCFfZ3JpZC5nZXRFZGl0b3JMb2NrKCkuaXNBY3RpdmUoKSB8fCBfZ3JpZC5nZXRFZGl0b3JMb2NrKCkuY29tbWl0Q3VycmVudEVkaXQoKSkge1xuICAgICAgICAgIHRvZ2dsZVJvd1NlbGVjdGlvbihhcmdzLnJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGUsIGFyZ3MpIHtcbiAgICAvLyBjbGlja2luZyBvbiBhIHJvdyBzZWxlY3QgY2hlY2tib3hcbiAgICBpZiAoX2dyaWQuZ2V0Q29sdW1ucygpW2FyZ3MuY2VsbF0uaWQgPT09IF9vcHRpb25zLmNvbHVtbklkICYmICQoZS50YXJnZXQpLmlzKFwiOmNoZWNrYm94XCIpKSB7XG4gICAgICAvLyBpZiBlZGl0aW5nLCB0cnkgdG8gY29tbWl0XG4gICAgICBpZiAoX2dyaWQuZ2V0RWRpdG9yTG9jaygpLmlzQWN0aXZlKCkgJiYgIV9ncmlkLmdldEVkaXRvckxvY2soKS5jb21taXRDdXJyZW50RWRpdCgpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2dnbGVSb3dTZWxlY3Rpb24oYXJncy5yb3cpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9nZ2xlUm93U2VsZWN0aW9uKHJvdykge1xuICAgIGlmIChfc2VsZWN0ZWRSb3dzTG9va3VwW3Jvd10pIHtcbiAgICAgIF9ncmlkLnNldFNlbGVjdGVkUm93cygkLmdyZXAoX2dyaWQuZ2V0U2VsZWN0ZWRSb3dzKCksIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuICE9IHJvd1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZ3JpZC5zZXRTZWxlY3RlZFJvd3MoX2dyaWQuZ2V0U2VsZWN0ZWRSb3dzKCkuY29uY2F0KHJvdykpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUhlYWRlckNsaWNrKGUsIGFyZ3MpIHtcbiAgICBpZiAoYXJncy5jb2x1bW4uaWQgPT0gX29wdGlvbnMuY29sdW1uSWQgJiYgJChlLnRhcmdldCkuaXMoXCI6Y2hlY2tib3hcIikpIHtcbiAgICAgIC8vIGlmIGVkaXRpbmcsIHRyeSB0byBjb21taXRcbiAgICAgIGlmIChfZ3JpZC5nZXRFZGl0b3JMb2NrKCkuaXNBY3RpdmUoKSAmJiAhX2dyaWQuZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyhcIjpjaGVja2VkXCIpKSB7XG4gICAgICAgIHZhciByb3dzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2dyaWQuZ2V0RGF0YUxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICByb3dzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKHJvd3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dyaWQuc2V0U2VsZWN0ZWRSb3dzKFtdKTtcbiAgICAgIH1cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbHVtbkRlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBfb3B0aW9ucy5jb2x1bW5JZCxcbiAgICAgIG5hbWU6IFwiPGlucHV0IHR5cGU9J2NoZWNrYm94Jz5cIixcbiAgICAgIHRvb2xUaXA6IF9vcHRpb25zLnRvb2xUaXAsXG4gICAgICBmaWVsZDogXCJzZWxcIixcbiAgICAgIHdpZHRoOiBfb3B0aW9ucy53aWR0aCxcbiAgICAgIHJlc2l6YWJsZTogZmFsc2UsXG4gICAgICBzb3J0YWJsZTogZmFsc2UsXG4gICAgICBjc3NDbGFzczogX29wdGlvbnMuY3NzQ2xhc3MsXG4gICAgICBmb3JtYXR0ZXI6IGNoZWNrYm94U2VsZWN0aW9uRm9ybWF0dGVyXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrYm94U2VsZWN0aW9uRm9ybWF0dGVyKHJvdywgY2VsbCwgdmFsdWUsIGNvbHVtbkRlZiwgZGF0YUNvbnRleHQpIHtcbiAgICBpZiAoZGF0YUNvbnRleHQpIHtcbiAgICAgIHJldHVybiBfc2VsZWN0ZWRSb3dzTG9va3VwW3Jvd11cbiAgICAgICAgICA/IFwiPGlucHV0IHR5cGU9J2NoZWNrYm94JyBjaGVja2VkPSdjaGVja2VkJz5cIlxuICAgICAgICAgIDogXCI8aW5wdXQgdHlwZT0nY2hlY2tib3gnPlwiO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gICQuZXh0ZW5kKHRoaXMsIHtcbiAgICBcImluaXRcIjogaW5pdCxcbiAgICBcImRlc3Ryb3lcIjogZGVzdHJveSxcblxuICAgIFwiZ2V0Q29sdW1uRGVmaW5pdGlvblwiOiBnZXRDb2x1bW5EZWZpbml0aW9uXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENoZWNrYm94U2VsZWN0Q29sdW1uO1xuIiwidmFyICQgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xudmFyIFNsaWNrID0gcmVxdWlyZShcIi4uL3NsaWNrLmNvcmVcIik7XG5cbmZ1bmN0aW9uIFJvd1NlbGVjdGlvbk1vZGVsKG9wdGlvbnMpIHtcbiAgdmFyIF9ncmlkO1xuICB2YXIgX3JhbmdlcyA9IFtdO1xuICB2YXIgX3NlbGYgPSB0aGlzO1xuICB2YXIgX2hhbmRsZXIgPSBuZXcgU2xpY2suRXZlbnRIYW5kbGVyKCk7XG4gIHZhciBfaW5IYW5kbGVyO1xuICB2YXIgX29wdGlvbnM7XG4gIHZhciBfZGVmYXVsdHMgPSB7XG4gICAgc2VsZWN0QWN0aXZlUm93OiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdChncmlkKSB7XG4gICAgX29wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgX2RlZmF1bHRzLCBvcHRpb25zKTtcbiAgICBfZ3JpZCA9IGdyaWQ7XG4gICAgX2hhbmRsZXIuc3Vic2NyaWJlKF9ncmlkLm9uQWN0aXZlQ2VsbENoYW5nZWQsXG4gICAgICAgIHdyYXBIYW5kbGVyKGhhbmRsZUFjdGl2ZUNlbGxDaGFuZ2UpKTtcbiAgICBfaGFuZGxlci5zdWJzY3JpYmUoX2dyaWQub25LZXlEb3duLFxuICAgICAgICB3cmFwSGFuZGxlcihoYW5kbGVLZXlEb3duKSk7XG4gICAgX2hhbmRsZXIuc3Vic2NyaWJlKF9ncmlkLm9uQ2xpY2ssXG4gICAgICAgIHdyYXBIYW5kbGVyKGhhbmRsZUNsaWNrKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIF9oYW5kbGVyLnVuc3Vic2NyaWJlQWxsKCk7XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX2luSGFuZGxlcikge1xuICAgICAgICBfaW5IYW5kbGVyID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBfaW5IYW5kbGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmdlc1RvUm93cyhyYW5nZXMpIHtcbiAgICB2YXIgcm93cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gcmFuZ2VzW2ldLmZyb21Sb3c7IGogPD0gcmFuZ2VzW2ldLnRvUm93OyBqKyspIHtcbiAgICAgICAgcm93cy5wdXNoKGopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJvd3NUb1Jhbmdlcyhyb3dzKSB7XG4gICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgIHZhciBsYXN0Q2VsbCA9IF9ncmlkLmdldENvbHVtbnMoKS5sZW5ndGggLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmFuZ2VzLnB1c2gobmV3IFNsaWNrLlJhbmdlKHJvd3NbaV0sIDAsIHJvd3NbaV0sIGxhc3RDZWxsKSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb3dzUmFuZ2UoZnJvbSwgdG8pIHtcbiAgICB2YXIgaSwgcm93cyA9IFtdO1xuICAgIGZvciAoaSA9IGZyb207IGkgPD0gdG87IGkrKykge1xuICAgICAgcm93cy5wdXNoKGkpO1xuICAgIH1cbiAgICBmb3IgKGkgPSB0bzsgaSA8IGZyb207IGkrKykge1xuICAgICAgcm93cy5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdGVkUm93cygpIHtcbiAgICByZXR1cm4gcmFuZ2VzVG9Sb3dzKF9yYW5nZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0ZWRSb3dzKHJvd3MpIHtcbiAgICBzZXRTZWxlY3RlZFJhbmdlcyhyb3dzVG9SYW5nZXMocm93cykpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0ZWRSYW5nZXMocmFuZ2VzKSB7XG4gICAgX3JhbmdlcyA9IHJhbmdlcztcbiAgICBfc2VsZi5vblNlbGVjdGVkUmFuZ2VzQ2hhbmdlZC5ub3RpZnkoX3Jhbmdlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTZWxlY3RlZFJhbmdlcygpIHtcbiAgICByZXR1cm4gX3JhbmdlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFjdGl2ZUNlbGxDaGFuZ2UoZSwgZGF0YSkge1xuICAgIGlmIChfb3B0aW9ucy5zZWxlY3RBY3RpdmVSb3cgJiYgZGF0YS5yb3cgIT0gbnVsbCkge1xuICAgICAgc2V0U2VsZWN0ZWRSYW5nZXMoW25ldyBTbGljay5SYW5nZShkYXRhLnJvdywgMCwgZGF0YS5yb3csIF9ncmlkLmdldENvbHVtbnMoKS5sZW5ndGggLSAxKV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZSkge1xuICAgIHZhciBhY3RpdmVSb3cgPSBfZ3JpZC5nZXRBY3RpdmVDZWxsKCk7XG4gICAgaWYgKGFjdGl2ZVJvdyAmJiBlLnNoaWZ0S2V5ICYmICFlLmN0cmxLZXkgJiYgIWUuYWx0S2V5ICYmICFlLm1ldGFLZXkgJiYgKGUud2hpY2ggPT0gMzggfHwgZS53aGljaCA9PSA0MCkpIHtcbiAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSBnZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgIHNlbGVjdGVkUm93cy5zb3J0KGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB4IC0geVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghc2VsZWN0ZWRSb3dzLmxlbmd0aCkge1xuICAgICAgICBzZWxlY3RlZFJvd3MgPSBbYWN0aXZlUm93LnJvd107XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3AgPSBzZWxlY3RlZFJvd3NbMF07XG4gICAgICB2YXIgYm90dG9tID0gc2VsZWN0ZWRSb3dzW3NlbGVjdGVkUm93cy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBhY3RpdmU7XG5cbiAgICAgIGlmIChlLndoaWNoID09IDQwKSB7XG4gICAgICAgIGFjdGl2ZSA9IGFjdGl2ZVJvdy5yb3cgPCBib3R0b20gfHwgdG9wID09IGJvdHRvbSA/ICsrYm90dG9tIDogKyt0b3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmUgPSBhY3RpdmVSb3cucm93IDwgYm90dG9tID8gLS1ib3R0b20gOiAtLXRvcDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZSA+PSAwICYmIGFjdGl2ZSA8IF9ncmlkLmdldERhdGFMZW5ndGgoKSkge1xuICAgICAgICBfZ3JpZC5zY3JvbGxSb3dJbnRvVmlldyhhY3RpdmUpO1xuICAgICAgICBfcmFuZ2VzID0gcm93c1RvUmFuZ2VzKGdldFJvd3NSYW5nZSh0b3AsIGJvdHRvbSkpO1xuICAgICAgICBzZXRTZWxlY3RlZFJhbmdlcyhfcmFuZ2VzKTtcbiAgICAgIH1cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG4gICAgdmFyIGNlbGwgPSBfZ3JpZC5nZXRDZWxsRnJvbUV2ZW50KGUpO1xuICAgIGlmICghY2VsbCB8fCAhX2dyaWQuY2FuQ2VsbEJlQWN0aXZlKGNlbGwucm93LCBjZWxsLmNlbGwpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFfZ3JpZC5nZXRPcHRpb25zKCkubXVsdGlTZWxlY3QgfHwgKFxuICAgICAgICAhZS5jdHJsS2V5ICYmICFlLnNoaWZ0S2V5ICYmICFlLm1ldGFLZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGlvbiA9IHJhbmdlc1RvUm93cyhfcmFuZ2VzKTtcbiAgICB2YXIgaWR4ID0gJC5pbkFycmF5KGNlbGwucm93LCBzZWxlY3Rpb24pO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICBzZWxlY3Rpb24ucHVzaChjZWxsLnJvdyk7XG4gICAgICBfZ3JpZC5zZXRBY3RpdmVDZWxsKGNlbGwucm93LCBjZWxsLmNlbGwpO1xuICAgIH0gZWxzZSBpZiAoaWR4ICE9PSAtMSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkpIHtcbiAgICAgIHNlbGVjdGlvbiA9ICQuZ3JlcChzZWxlY3Rpb24sIGZ1bmN0aW9uIChvLCBpKSB7XG4gICAgICAgIHJldHVybiAobyAhPT0gY2VsbC5yb3cpO1xuICAgICAgfSk7XG4gICAgICBfZ3JpZC5zZXRBY3RpdmVDZWxsKGNlbGwucm93LCBjZWxsLmNlbGwpO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uLmxlbmd0aCAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICB2YXIgbGFzdCA9IHNlbGVjdGlvbi5wb3AoKTtcbiAgICAgIHZhciBmcm9tID0gTWF0aC5taW4oY2VsbC5yb3csIGxhc3QpO1xuICAgICAgdmFyIHRvID0gTWF0aC5tYXgoY2VsbC5yb3csIGxhc3QpO1xuICAgICAgc2VsZWN0aW9uID0gW107XG4gICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8PSB0bzsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSBsYXN0KSB7XG4gICAgICAgICAgc2VsZWN0aW9uLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbi5wdXNoKGxhc3QpO1xuICAgICAgX2dyaWQuc2V0QWN0aXZlQ2VsbChjZWxsLnJvdywgY2VsbC5jZWxsKTtcbiAgICB9XG5cbiAgICBfcmFuZ2VzID0gcm93c1RvUmFuZ2VzKHNlbGVjdGlvbik7XG4gICAgc2V0U2VsZWN0ZWRSYW5nZXMoX3Jhbmdlcyk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgJC5leHRlbmQodGhpcywge1xuICAgIFwiZ2V0U2VsZWN0ZWRSb3dzXCI6IGdldFNlbGVjdGVkUm93cyxcbiAgICBcInNldFNlbGVjdGVkUm93c1wiOiBzZXRTZWxlY3RlZFJvd3MsXG5cbiAgICBcImdldFNlbGVjdGVkUmFuZ2VzXCI6IGdldFNlbGVjdGVkUmFuZ2VzLFxuICAgIFwic2V0U2VsZWN0ZWRSYW5nZXNcIjogc2V0U2VsZWN0ZWRSYW5nZXMsXG5cbiAgICBcImluaXRcIjogaW5pdCxcbiAgICBcImRlc3Ryb3lcIjogZGVzdHJveSxcblxuICAgIFwib25TZWxlY3RlZFJhbmdlc0NoYW5nZWRcIjogbmV3IFNsaWNrLkV2ZW50KClcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUm93U2VsZWN0aW9uTW9kZWw7XG4iLCIvKioqXG4gKiBDb250YWlucyBjb3JlIFNsaWNrR3JpZCBjbGFzc2VzLlxuICogQG1vZHVsZSBDb3JlXG4gKiBAbmFtZXNwYWNlIFNsaWNrXG4gKi9cblxudmFyICQgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xuXG4vLyByZWdpc3RlciBuYW1lc3BhY2VcbnZhciBTbGljayA9IHtcbiAgRXZlbnQ6IEV2ZW50LFxuICBFdmVudERhdGE6IEV2ZW50RGF0YSxcbiAgRXZlbnRIYW5kbGVyOiBFdmVudEhhbmRsZXIsXG4gIFJhbmdlOiBSYW5nZSxcbiAgTm9uRGF0YVJvdzogTm9uRGF0YUl0ZW0sXG4gIEdyb3VwOiBHcm91cCxcbiAgR3JvdXBUb3RhbHM6IEdyb3VwVG90YWxzLFxuICBFZGl0b3JMb2NrOiBFZGl0b3JMb2NrLFxuXG4gICAgLyoqKlxuICAgICAqIEEgZ2xvYmFsIHNpbmdsZXRvbiBlZGl0b3IgbG9jay5cbiAgICAgKiBAY2xhc3MgR2xvYmFsRWRpdG9yTG9ja1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgR2xvYmFsRWRpdG9yTG9jazogbmV3IEVkaXRvckxvY2soKVxufTtcblxuLyoqKlxuICogQW4gZXZlbnQgb2JqZWN0IGZvciBwYXNzaW5nIGRhdGEgdG8gZXZlbnQgaGFuZGxlcnMgYW5kIGxldHRpbmcgdGhlbSBjb250cm9sIHByb3BhZ2F0aW9uLlxuICogPHA+VGhpcyBpcyBwcmV0dHkgbXVjaCBpZGVudGljYWwgdG8gaG93IFczQyBhbmQgalF1ZXJ5IGltcGxlbWVudCBldmVudHMuPC9wPlxuICogQGNsYXNzIEV2ZW50RGF0YVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RGF0YSgpIHtcbiAgdmFyIGlzUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gIHZhciBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXG4gIC8qKipcbiAgICogU3RvcHMgZXZlbnQgZnJvbSBwcm9wYWdhdGluZyB1cCB0aGUgRE9NIHRyZWUuXG4gICAqIEBtZXRob2Qgc3RvcFByb3BhZ2F0aW9uXG4gICAqL1xuICB0aGlzLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH07XG5cbiAgLyoqKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgc3RvcFByb3BhZ2F0aW9uIHdhcyBjYWxsZWQgb24gdGhpcyBldmVudCBvYmplY3QuXG4gICAqIEBtZXRob2QgaXNQcm9wYWdhdGlvblN0b3BwZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzUHJvcGFnYXRpb25TdG9wcGVkO1xuICB9O1xuXG4gIC8qKipcbiAgICogUHJldmVudHMgdGhlIHJlc3Qgb2YgdGhlIGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQuXG4gICAqIEBtZXRob2Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG4gICAqL1xuICB0aGlzLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH07XG5cbiAgLyoqKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIHdhcyBjYWxsZWQgb24gdGhpcyBldmVudCBvYmplY3QuXFxcbiAgICogQG1ldGhvZCBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ7XG4gIH1cbn1cblxuLyoqKlxuICogQSBzaW1wbGUgcHVibGlzaGVyLXN1YnNjcmliZXIgaW1wbGVtZW50YXRpb24uXG4gKiBAY2xhc3MgRXZlbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBFdmVudCgpIHtcbiAgdmFyIGhhbmRsZXJzID0gW107XG5cbiAgLyoqKlxuICAgKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkLlxuICAgKiA8cD5FdmVudCBoYW5kbGVyIHdpbGwgcmVjZWl2ZSB0d28gYXJndW1lbnRzIC0gYW4gPGNvZGU+RXZlbnREYXRhPC9jb2RlPiBhbmQgdGhlIDxjb2RlPmRhdGE8L2NvZGU+XG4gICAqIG9iamVjdCB0aGUgZXZlbnQgd2FzIGZpcmVkIHdpdGguPHA+XG4gICAqIEBtZXRob2Qgc3Vic2NyaWJlXG4gICAqIEBwYXJhbSBmbiB7RnVuY3Rpb259IEV2ZW50IGhhbmRsZXIuXG4gICAqL1xuICB0aGlzLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChmbikge1xuICAgIGhhbmRsZXJzLnB1c2goZm4pO1xuICB9O1xuXG4gIC8qKipcbiAgICogUmVtb3ZlcyBhbiBldmVudCBoYW5kbGVyIGFkZGVkIHdpdGggPGNvZGU+c3Vic2NyaWJlKGZuKTwvY29kZT4uXG4gICAqIEBtZXRob2QgdW5zdWJzY3JpYmVcbiAgICogQHBhcmFtIGZuIHtGdW5jdGlvbn0gRXZlbnQgaGFuZGxlciB0byBiZSByZW1vdmVkLlxuICAgKi9cbiAgdGhpcy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChmbikge1xuICAgIGZvciAodmFyIGkgPSBoYW5kbGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGhhbmRsZXJzW2ldID09PSBmbikge1xuICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKipcbiAgICogRmlyZXMgYW4gZXZlbnQgbm90aWZ5aW5nIGFsbCBzdWJzY3JpYmVycy5cbiAgICogQG1ldGhvZCBub3RpZnlcbiAgICogQHBhcmFtIGFyZ3Mge09iamVjdH0gQWRkaXRpb25hbCBkYXRhIG9iamVjdCB0byBiZSBwYXNzZWQgdG8gYWxsIGhhbmRsZXJzLlxuICAgKiBAcGFyYW0gZSB7RXZlbnREYXRhfVxuICAgKiAgICAgIE9wdGlvbmFsLlxuICAgKiAgICAgIEFuIDxjb2RlPkV2ZW50RGF0YTwvY29kZT4gb2JqZWN0IHRvIGJlIHBhc3NlZCB0byBhbGwgaGFuZGxlcnMuXG4gICAqICAgICAgRm9yIERPTSBldmVudHMsIGFuIGV4aXN0aW5nIFczQy9qUXVlcnkgZXZlbnQgb2JqZWN0IGNhbiBiZSBwYXNzZWQgaW4uXG4gICAqIEBwYXJhbSBzY29wZSB7T2JqZWN0fVxuICAgKiAgICAgIE9wdGlvbmFsLlxuICAgKiAgICAgIFRoZSBzY29wZSAoXCJ0aGlzXCIpIHdpdGhpbiB3aGljaCB0aGUgaGFuZGxlciB3aWxsIGJlIGV4ZWN1dGVkLlxuICAgKiAgICAgIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBzY29wZSB3aWxsIGJlIHNldCB0byB0aGUgPGNvZGU+RXZlbnQ8L2NvZGU+IGluc3RhbmNlLlxuICAgKi9cbiAgdGhpcy5ub3RpZnkgPSBmdW5jdGlvbiAoYXJncywgZSwgc2NvcGUpIHtcbiAgICBlID0gZSB8fCBuZXcgRXZlbnREYXRhKCk7XG4gICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xuXG4gICAgdmFyIHJldHVyblZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoICYmICEoZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHx8IGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSk7IGkrKykge1xuICAgICAgcmV0dXJuVmFsdWUgPSBoYW5kbGVyc1tpXS5jYWxsKHNjb3BlLCBlLCBhcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIEV2ZW50SGFuZGxlcigpIHtcbiAgdmFyIGhhbmRsZXJzID0gW107XG5cbiAgdGhpcy5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBoYW5kbGVycy5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICB9KTtcbiAgICBldmVudC5zdWJzY3JpYmUoaGFuZGxlcik7XG5cbiAgICByZXR1cm4gdGhpczsgIC8vIGFsbG93IGNoYWluaW5nXG4gIH07XG5cbiAgdGhpcy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgIHZhciBpID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChoYW5kbGVyc1tpXS5ldmVudCA9PT0gZXZlbnQgJiZcbiAgICAgICAgICBoYW5kbGVyc1tpXS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXZlbnQudW5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgIC8vIGFsbG93IGNoYWluaW5nXG4gIH07XG5cbiAgdGhpcy51bnN1YnNjcmliZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBoYW5kbGVyc1tpXS5ldmVudC51bnN1YnNjcmliZShoYW5kbGVyc1tpXS5oYW5kbGVyKTtcbiAgICB9XG4gICAgaGFuZGxlcnMgPSBbXTtcblxuICAgIHJldHVybiB0aGlzOyAgLy8gYWxsb3cgY2hhaW5pbmdcbiAgfVxufVxuXG4vKioqXG4gKiBBIHN0cnVjdHVyZSBjb250YWluaW5nIGEgcmFuZ2Ugb2YgY2VsbHMuXG4gKiBAY2xhc3MgUmFuZ2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZyb21Sb3cge0ludGVnZXJ9IFN0YXJ0aW5nIHJvdy5cbiAqIEBwYXJhbSBmcm9tQ2VsbCB7SW50ZWdlcn0gU3RhcnRpbmcgY2VsbC5cbiAqIEBwYXJhbSB0b1JvdyB7SW50ZWdlcn0gT3B0aW9uYWwuIEVuZGluZyByb3cuIERlZmF1bHRzIHRvIDxjb2RlPmZyb21Sb3c8L2NvZGU+LlxuICogQHBhcmFtIHRvQ2VsbCB7SW50ZWdlcn0gT3B0aW9uYWwuIEVuZGluZyBjZWxsLiBEZWZhdWx0cyB0byA8Y29kZT5mcm9tQ2VsbDwvY29kZT4uXG4gKi9cbmZ1bmN0aW9uIFJhbmdlKGZyb21Sb3csIGZyb21DZWxsLCB0b1JvdywgdG9DZWxsKSB7XG4gIGlmICh0b1JvdyA9PT0gdW5kZWZpbmVkICYmIHRvQ2VsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG9Sb3cgPSBmcm9tUm93O1xuICAgIHRvQ2VsbCA9IGZyb21DZWxsO1xuICB9XG5cbiAgLyoqKlxuICAgKiBAcHJvcGVydHkgZnJvbVJvd1xuICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICovXG4gIHRoaXMuZnJvbVJvdyA9IE1hdGgubWluKGZyb21Sb3csIHRvUm93KTtcblxuICAvKioqXG4gICAqIEBwcm9wZXJ0eSBmcm9tQ2VsbFxuICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICovXG4gIHRoaXMuZnJvbUNlbGwgPSBNYXRoLm1pbihmcm9tQ2VsbCwgdG9DZWxsKTtcblxuICAvKioqXG4gICAqIEBwcm9wZXJ0eSB0b1Jvd1xuICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICovXG4gIHRoaXMudG9Sb3cgPSBNYXRoLm1heChmcm9tUm93LCB0b1Jvdyk7XG5cbiAgLyoqKlxuICAgKiBAcHJvcGVydHkgdG9DZWxsXG4gICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgKi9cbiAgdGhpcy50b0NlbGwgPSBNYXRoLm1heChmcm9tQ2VsbCwgdG9DZWxsKTtcblxuICAvKioqXG4gICAqIFJldHVybnMgd2hldGhlciBhIHJhbmdlIHJlcHJlc2VudHMgYSBzaW5nbGUgcm93LlxuICAgKiBAbWV0aG9kIGlzU2luZ2xlUm93XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzU2luZ2xlUm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZyb21Sb3cgPT0gdGhpcy50b1JvdztcbiAgfTtcblxuICAvKioqXG4gICAqIFJldHVybnMgd2hldGhlciBhIHJhbmdlIHJlcHJlc2VudHMgYSBzaW5nbGUgY2VsbC5cbiAgICogQG1ldGhvZCBpc1NpbmdsZUNlbGxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuaXNTaW5nbGVDZWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZyb21Sb3cgPT0gdGhpcy50b1JvdyAmJiB0aGlzLmZyb21DZWxsID09IHRoaXMudG9DZWxsO1xuICB9O1xuXG4gIC8qKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGEgcmFuZ2UgY29udGFpbnMgYSBnaXZlbiBjZWxsLlxuICAgKiBAbWV0aG9kIGNvbnRhaW5zXG4gICAqIEBwYXJhbSByb3cge0ludGVnZXJ9XG4gICAqIEBwYXJhbSBjZWxsIHtJbnRlZ2VyfVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5jb250YWlucyA9IGZ1bmN0aW9uIChyb3csIGNlbGwpIHtcbiAgICByZXR1cm4gcm93ID49IHRoaXMuZnJvbVJvdyAmJiByb3cgPD0gdGhpcy50b1JvdyAmJlxuICAgICAgICBjZWxsID49IHRoaXMuZnJvbUNlbGwgJiYgY2VsbCA8PSB0aGlzLnRvQ2VsbDtcbiAgfTtcblxuICAvKioqXG4gICAqIFJldHVybnMgYSByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIHJhbmdlLlxuICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTaW5nbGVDZWxsKCkpIHtcbiAgICAgIHJldHVybiBcIihcIiArIHRoaXMuZnJvbVJvdyArIFwiOlwiICsgdGhpcy5mcm9tQ2VsbCArIFwiKVwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBcIihcIiArIHRoaXMuZnJvbVJvdyArIFwiOlwiICsgdGhpcy5mcm9tQ2VsbCArIFwiIC0gXCIgKyB0aGlzLnRvUm93ICsgXCI6XCIgKyB0aGlzLnRvQ2VsbCArIFwiKVwiO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKipcbiAqIEEgYmFzZSBjbGFzcyB0aGF0IGFsbCBzcGVjaWFsIC8gbm9uLWRhdGEgcm93cyAobGlrZSBHcm91cCBhbmQgR3JvdXBUb3RhbHMpIGRlcml2ZSBmcm9tLlxuICogQGNsYXNzIE5vbkRhdGFJdGVtXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTm9uRGF0YUl0ZW0oKSB7XG4gIHRoaXMuX19ub25EYXRhUm93ID0gdHJ1ZTtcbn1cblxuXG4vKioqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCBhIGdyb3VwIG9mIHJvd3MuXG4gKiBAY2xhc3MgR3JvdXBcbiAqIEBleHRlbmRzIFNsaWNrLk5vbkRhdGFJdGVtXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gR3JvdXAoKSB7XG4gIHRoaXMuX19ncm91cCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEdyb3VwaW5nIGxldmVsLCBzdGFydGluZyB3aXRoIDAuXG4gICAqIEBwcm9wZXJ0eSBsZXZlbFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgdGhpcy5sZXZlbCA9IDA7XG5cbiAgLyoqKlxuICAgKiBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgZ3JvdXAuXG4gICAqIEBwcm9wZXJ0eSBjb3VudFxuICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICovXG4gIHRoaXMuY291bnQgPSAwO1xuXG4gIC8qKipcbiAgICogR3JvdXBpbmcgdmFsdWUuXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy52YWx1ZSA9IG51bGw7XG5cbiAgLyoqKlxuICAgKiBGb3JtYXR0ZWQgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ3JvdXAuXG4gICAqIEBwcm9wZXJ0eSB0aXRsZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy50aXRsZSA9IG51bGw7XG5cbiAgLyoqKlxuICAgKiBXaGV0aGVyIGEgZ3JvdXAgaXMgY29sbGFwc2VkLlxuICAgKiBAcHJvcGVydHkgY29sbGFwc2VkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5jb2xsYXBzZWQgPSBmYWxzZTtcblxuICAvKioqXG4gICAqIEdyb3VwVG90YWxzLCBpZiBhbnkuXG4gICAqIEBwcm9wZXJ0eSB0b3RhbHNcbiAgICogQHR5cGUge0dyb3VwVG90YWxzfVxuICAgKi9cbiAgdGhpcy50b3RhbHMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBSb3dzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIGdyb3VwLlxuICAgKiBAcHJvcGVydHkgcm93c1xuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB0aGlzLnJvd3MgPSBbXTtcblxuICAvKipcbiAgICogU3ViLWdyb3VwcyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBncm91cC5cbiAgICogQHByb3BlcnR5IGdyb3Vwc1xuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB0aGlzLmdyb3VwcyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoZSBncm91cC4gIFRoaXMga2V5IGNhbiBiZSB1c2VkIGluIGNhbGxzIHRvIERhdGFWaWV3XG4gICAqIGNvbGxhcHNlR3JvdXAoKSBvciBleHBhbmRHcm91cCgpLlxuICAgKiBAcHJvcGVydHkgZ3JvdXBpbmdLZXlcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuZ3JvdXBpbmdLZXkgPSBudWxsO1xufVxuXG5Hcm91cC5wcm90b3R5cGUgPSBuZXcgTm9uRGF0YUl0ZW0oKTtcblxuLyoqKlxuICogQ29tcGFyZXMgdHdvIEdyb3VwIGluc3RhbmNlcy5cbiAqIEBtZXRob2QgZXF1YWxzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHBhcmFtIGdyb3VwIHtHcm91cH0gR3JvdXAgaW5zdGFuY2UgdG8gY29tcGFyZSB0by5cbiAqL1xuR3JvdXAucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChncm91cCkge1xuICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gZ3JvdXAudmFsdWUgJiZcbiAgICAgIHRoaXMuY291bnQgPT09IGdyb3VwLmNvdW50ICYmXG4gICAgICB0aGlzLmNvbGxhcHNlZCA9PT0gZ3JvdXAuY29sbGFwc2VkICYmXG4gICAgICB0aGlzLnRpdGxlID09PSBncm91cC50aXRsZTtcbn07XG5cbi8qKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IGdyb3VwIHRvdGFscy5cbiAqIEFuIGluc3RhbmNlIG9mIEdyb3VwVG90YWxzIHdpbGwgYmUgY3JlYXRlZCBmb3IgZWFjaCB0b3RhbHMgcm93IGFuZCBwYXNzZWQgdG8gdGhlIGFnZ3JlZ2F0b3JzXG4gKiBzbyB0aGF0IHRoZXkgY2FuIHN0b3JlIGFyYml0cmFyeSBkYXRhIGluIGl0LiAgVGhhdCBkYXRhIGNhbiBsYXRlciBiZSBhY2Nlc3NlZCBieSBncm91cCB0b3RhbHNcbiAqIGZvcm1hdHRlcnMgZHVyaW5nIHRoZSBkaXNwbGF5LlxuICogQGNsYXNzIEdyb3VwVG90YWxzXG4gKiBAZXh0ZW5kcyBTbGljay5Ob25EYXRhSXRlbVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEdyb3VwVG90YWxzKCkge1xuICB0aGlzLl9fZ3JvdXBUb3RhbHMgPSB0cnVlO1xuXG4gIC8qKipcbiAgICogUGFyZW50IEdyb3VwLlxuICAgKiBAcGFyYW0gZ3JvdXBcbiAgICogQHR5cGUge0dyb3VwfVxuICAgKi9cbiAgdGhpcy5ncm91cCA9IG51bGw7XG5cbiAgLyoqKlxuICAgKiBXaGV0aGVyIHRoZSB0b3RhbHMgaGF2ZSBiZWVuIGZ1bGx5IGluaXRpYWxpemVkIC8gY2FsY3VsYXRlZC5cbiAgICogV2lsbCBiZSBzZXQgdG8gZmFsc2UgZm9yIGxhenktY2FsY3VsYXRlZCBncm91cCB0b3RhbHMuXG4gICAqIEBwYXJhbSBpbml0aWFsaXplZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cblxuR3JvdXBUb3RhbHMucHJvdG90eXBlID0gbmV3IE5vbkRhdGFJdGVtKCk7XG5cbi8qKipcbiAqIEEgbG9ja2luZyBoZWxwZXIgdG8gdHJhY2sgdGhlIGFjdGl2ZSBlZGl0IGNvbnRyb2xsZXIgYW5kIGVuc3VyZSB0aGF0IG9ubHkgYSBzaW5nbGUgY29udHJvbGxlclxuICogY2FuIGJlIGFjdGl2ZSBhdCBhIHRpbWUuICBUaGlzIHByZXZlbnRzIGEgd2hvbGUgY2xhc3Mgb2Ygc3RhdGUgYW5kIHZhbGlkYXRpb24gc3luY2hyb25pemF0aW9uXG4gKiBpc3N1ZXMuICBBbiBlZGl0IGNvbnRyb2xsZXIgKHN1Y2ggYXMgU2xpY2tHcmlkKSBjYW4gcXVlcnkgaWYgYW4gYWN0aXZlIGVkaXQgaXMgaW4gcHJvZ3Jlc3NcbiAqIGFuZCBhdHRlbXB0IGEgY29tbWl0IG9yIGNhbmNlbCBiZWZvcmUgcHJvY2VlZGluZy5cbiAqIEBjbGFzcyBFZGl0b3JMb2NrXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRWRpdG9yTG9jaygpIHtcbiAgdmFyIGFjdGl2ZUVkaXRDb250cm9sbGVyID0gbnVsbDtcblxuICAvKioqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIHNwZWNpZmllZCBlZGl0IGNvbnRyb2xsZXIgaXMgYWN0aXZlIChoYXMgdGhlIGVkaXQgbG9jaykuXG4gICAqIElmIHRoZSBwYXJhbWV0ZXIgaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyB0cnVlIGlmIGFueSBlZGl0IGNvbnRyb2xsZXIgaXMgYWN0aXZlLlxuICAgKiBAbWV0aG9kIGlzQWN0aXZlXG4gICAqIEBwYXJhbSBlZGl0Q29udHJvbGxlciB7RWRpdENvbnRyb2xsZXJ9XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzQWN0aXZlID0gZnVuY3Rpb24gKGVkaXRDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIChlZGl0Q29udHJvbGxlciA/IGFjdGl2ZUVkaXRDb250cm9sbGVyID09PSBlZGl0Q29udHJvbGxlciA6IGFjdGl2ZUVkaXRDb250cm9sbGVyICE9PSBudWxsKTtcbiAgfTtcblxuICAvKioqXG4gICAqIFNldHMgdGhlIHNwZWNpZmllZCBlZGl0IGNvbnRyb2xsZXIgYXMgdGhlIGFjdGl2ZSBlZGl0IGNvbnRyb2xsZXIgKGFjcXVpcmUgZWRpdCBsb2NrKS5cbiAgICogSWYgYW5vdGhlciBlZGl0IGNvbnRyb2xsZXIgaXMgYWxyZWFkeSBhY3RpdmUsIGFuZCBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gICAqIEBtZXRob2QgYWN0aXZhdGVcbiAgICogQHBhcmFtIGVkaXRDb250cm9sbGVyIHtFZGl0Q29udHJvbGxlcn0gZWRpdCBjb250cm9sbGVyIGFjcXVpcmluZyB0aGUgbG9ja1xuICAgKi9cbiAgdGhpcy5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChlZGl0Q29udHJvbGxlcikge1xuICAgIGlmIChlZGl0Q29udHJvbGxlciA9PT0gYWN0aXZlRWRpdENvbnRyb2xsZXIpIHsgLy8gYWxyZWFkeSBhY3RpdmF0ZWQ/XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhY3RpdmVFZGl0Q29udHJvbGxlciAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJTbGlja0dyaWQuRWRpdG9yTG9jay5hY3RpdmF0ZTogYW4gZWRpdENvbnRyb2xsZXIgaXMgc3RpbGwgYWN0aXZlLCBjYW4ndCBhY3RpdmF0ZSBhbm90aGVyIGVkaXRDb250cm9sbGVyXCI7XG4gICAgfVxuICAgIGlmICghZWRpdENvbnRyb2xsZXIuY29tbWl0Q3VycmVudEVkaXQpIHtcbiAgICAgIHRocm93IFwiU2xpY2tHcmlkLkVkaXRvckxvY2suYWN0aXZhdGU6IGVkaXRDb250cm9sbGVyIG11c3QgaW1wbGVtZW50IC5jb21taXRDdXJyZW50RWRpdCgpXCI7XG4gICAgfVxuICAgIGlmICghZWRpdENvbnRyb2xsZXIuY2FuY2VsQ3VycmVudEVkaXQpIHtcbiAgICAgIHRocm93IFwiU2xpY2tHcmlkLkVkaXRvckxvY2suYWN0aXZhdGU6IGVkaXRDb250cm9sbGVyIG11c3QgaW1wbGVtZW50IC5jYW5jZWxDdXJyZW50RWRpdCgpXCI7XG4gICAgfVxuICAgIGFjdGl2ZUVkaXRDb250cm9sbGVyID0gZWRpdENvbnRyb2xsZXI7XG4gIH07XG5cbiAgLyoqKlxuICAgKiBVbnNldHMgdGhlIHNwZWNpZmllZCBlZGl0IGNvbnRyb2xsZXIgYXMgdGhlIGFjdGl2ZSBlZGl0IGNvbnRyb2xsZXIgKHJlbGVhc2UgZWRpdCBsb2NrKS5cbiAgICogSWYgdGhlIHNwZWNpZmllZCBlZGl0IGNvbnRyb2xsZXIgaXMgbm90IHRoZSBhY3RpdmUgb25lLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gICAqIEBtZXRob2QgZGVhY3RpdmF0ZVxuICAgKiBAcGFyYW0gZWRpdENvbnRyb2xsZXIge0VkaXRDb250cm9sbGVyfSBlZGl0IGNvbnRyb2xsZXIgcmVsZWFzaW5nIHRoZSBsb2NrXG4gICAqL1xuICB0aGlzLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoZWRpdENvbnRyb2xsZXIpIHtcbiAgICBpZiAoYWN0aXZlRWRpdENvbnRyb2xsZXIgIT09IGVkaXRDb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBcIlNsaWNrR3JpZC5FZGl0b3JMb2NrLmRlYWN0aXZhdGU6IHNwZWNpZmllZCBlZGl0Q29udHJvbGxlciBpcyBub3QgdGhlIGN1cnJlbnRseSBhY3RpdmUgb25lXCI7XG4gICAgfVxuICAgIGFjdGl2ZUVkaXRDb250cm9sbGVyID0gbnVsbDtcbiAgfTtcblxuICAvKioqXG4gICAqIEF0dGVtcHRzIHRvIGNvbW1pdCB0aGUgY3VycmVudCBlZGl0IGJ5IGNhbGxpbmcgXCJjb21taXRDdXJyZW50RWRpdFwiIG1ldGhvZCBvbiB0aGUgYWN0aXZlIGVkaXRcbiAgICogY29udHJvbGxlciBhbmQgcmV0dXJucyB3aGV0aGVyIHRoZSBjb21taXQgYXR0ZW1wdCB3YXMgc3VjY2Vzc2Z1bCAoY29tbWl0IG1heSBmYWlsIGR1ZSB0byB2YWxpZGF0aW9uXG4gICAqIGVycm9ycywgZXRjLikuICBFZGl0IGNvbnRyb2xsZXIncyBcImNvbW1pdEN1cnJlbnRFZGl0XCIgbXVzdCByZXR1cm4gdHJ1ZSBpZiB0aGUgY29tbWl0IGhhcyBzdWNjZWVkZWRcbiAgICogYW5kIGZhbHNlIG90aGVyd2lzZS4gIElmIG5vIGVkaXQgY29udHJvbGxlciBpcyBhY3RpdmUsIHJldHVybnMgdHJ1ZS5cbiAgICogQG1ldGhvZCBjb21taXRDdXJyZW50RWRpdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5jb21taXRDdXJyZW50RWRpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKGFjdGl2ZUVkaXRDb250cm9sbGVyID8gYWN0aXZlRWRpdENvbnRyb2xsZXIuY29tbWl0Q3VycmVudEVkaXQoKSA6IHRydWUpO1xuICB9O1xuXG4gIC8qKipcbiAgICogQXR0ZW1wdHMgdG8gY2FuY2VsIHRoZSBjdXJyZW50IGVkaXQgYnkgY2FsbGluZyBcImNhbmNlbEN1cnJlbnRFZGl0XCIgbWV0aG9kIG9uIHRoZSBhY3RpdmUgZWRpdFxuICAgKiBjb250cm9sbGVyIGFuZCByZXR1cm5zIHdoZXRoZXIgdGhlIGVkaXQgd2FzIHN1Y2Nlc3NmdWxseSBjYW5jZWxsZWQuICBJZiBubyBlZGl0IGNvbnRyb2xsZXIgaXNcbiAgICogYWN0aXZlLCByZXR1cm5zIHRydWUuXG4gICAqIEBtZXRob2QgY2FuY2VsQ3VycmVudEVkaXRcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuY2FuY2VsQ3VycmVudEVkaXQgPSBmdW5jdGlvbiBjYW5jZWxDdXJyZW50RWRpdCgpIHtcbiAgICByZXR1cm4gKGFjdGl2ZUVkaXRDb250cm9sbGVyID8gYWN0aXZlRWRpdENvbnRyb2xsZXIuY2FuY2VsQ3VycmVudEVkaXQoKSA6IHRydWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNsaWNrO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogKGMpIDIwMDktMjAxMyBNaWNoYWVsIExlaWJtYW5cbiAqIG1pY2hhZWx7ZG90fWxlaWJtYW57YXR9Z21haWx7ZG90fWNvbVxuICogaHR0cDovL2dpdGh1Yi5jb20vbWxlaWJtYW4vc2xpY2tncmlkXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNsaWNrR3JpZCB2Mi4yXG4gKlxuICogTk9URVM6XG4gKiAgICAgQ2VsbC9yb3cgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGRvbmUgZGlyZWN0bHkgYnlwYXNzaW5nIGpRdWVyeSdzIERPTSBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAqICAgICBUaGlzIGluY3JlYXNlcyB0aGUgc3BlZWQgZHJhbWF0aWNhbGx5LCBidXQgY2FuIG9ubHkgYmUgZG9uZSBzYWZlbHkgYmVjYXVzZSB0aGVyZSBhcmUgbm8gZXZlbnQgaGFuZGxlcnNcbiAqICAgICBvciBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhbnkgY2VsbC9yb3cgRE9NIG5vZGVzLiAgQ2VsbCBlZGl0b3JzIG11c3QgbWFrZSBzdXJlIHRoZXkgaW1wbGVtZW50IC5kZXN0cm95KClcbiAqICAgICBhbmQgZG8gcHJvcGVyIGNsZWFudXAuXG4gKi9cblxudmFyICQgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xudmFyICQxID0gcmVxdWlyZShcImpxdWVyeV9ldmVudF9kcmFnXCIpO1xudmFyICQyID0gcmVxdWlyZShcImpxdWVyeV9ldmVudF9kcm9wXCIpO1xudmFyIFNsaWNrID0gcmVxdWlyZShcIi4vc2xpY2suY29yZVwiKTtcblxuXG4vLyBzaGFyZWQgYWNyb3NzIGFsbCBncmlkcyBvbiB0aGUgcGFnZVxudmFyIHNjcm9sbGJhckRpbWVuc2lvbnM7XG52YXIgbWF4U3VwcG9ydGVkQ3NzSGVpZ2h0OyAgLy8gYnJvd3NlcidzIGJyZWFraW5nIHBvaW50XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNsaWNrR3JpZCBjbGFzcyBpbXBsZW1lbnRhdGlvbiAoYXZhaWxhYmxlIGFzIFNsaWNrLkdyaWQpXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgZ3JpZC5cbiAqIEBjbGFzcyBTbGlja0dyaWRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOb2RlfSAgICAgICAgICAgICAgY29udGFpbmVyICAgQ29udGFpbmVyIG5vZGUgdG8gY3JlYXRlIHRoZSBncmlkIGluLlxuICogQHBhcmFtIHtBcnJheSxPYmplY3R9ICAgICAgZGF0YSAgICAgICAgQW4gYXJyYXkgb2Ygb2JqZWN0cyBmb3IgZGF0YWJpbmRpbmcuXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgICAgICAgICBjb2x1bW5zICAgICBBbiBhcnJheSBvZiBjb2x1bW4gZGVmaW5pdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICBvcHRpb25zICAgICBHcmlkIG9wdGlvbnMuXG4gKiovXG5mdW5jdGlvbiBTbGlja0dyaWQoY29udGFpbmVyLCBkYXRhLCBjb2x1bW5zLCBvcHRpb25zKSB7XG4gIC8vIHNldHRpbmdzXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBleHBsaWNpdEluaXRpYWxpemF0aW9uOiBmYWxzZSxcbiAgICByb3dIZWlnaHQ6IDI1LFxuICAgIGRlZmF1bHRDb2x1bW5XaWR0aDogODAsXG4gICAgZW5hYmxlQWRkUm93OiBmYWxzZSxcbiAgICBsZWF2ZVNwYWNlRm9yTmV3Um93czogZmFsc2UsXG4gICAgZWRpdGFibGU6IGZhbHNlLFxuICAgIGF1dG9FZGl0OiB0cnVlLFxuICAgIGVuYWJsZUNlbGxOYXZpZ2F0aW9uOiB0cnVlLFxuICAgIGVuYWJsZUNvbHVtblJlb3JkZXI6IHRydWUsXG4gICAgYXN5bmNFZGl0b3JMb2FkaW5nOiBmYWxzZSxcbiAgICBhc3luY0VkaXRvckxvYWREZWxheTogMTAwLFxuICAgIGZvcmNlRml0Q29sdW1uczogZmFsc2UsXG4gICAgZW5hYmxlQXN5bmNQb3N0UmVuZGVyOiBmYWxzZSxcbiAgICBhc3luY1Bvc3RSZW5kZXJEZWxheTogNTAsXG4gICAgYXV0b0hlaWdodDogZmFsc2UsXG4gICAgZWRpdG9yTG9jazogU2xpY2suR2xvYmFsRWRpdG9yTG9jayxcbiAgICBzaG93SGVhZGVyUm93OiBmYWxzZSxcbiAgICBoZWFkZXJSb3dIZWlnaHQ6IDI1LFxuICAgIHNob3dUb3BQYW5lbDogZmFsc2UsXG4gICAgdG9wUGFuZWxIZWlnaHQ6IDI1LFxuICAgIGZvcm1hdHRlckZhY3Rvcnk6IG51bGwsXG4gICAgZWRpdG9yRmFjdG9yeTogbnVsbCxcbiAgICBjZWxsRmxhc2hpbmdDc3NDbGFzczogXCJmbGFzaGluZ1wiLFxuICAgIHNlbGVjdGVkQ2VsbENzc0NsYXNzOiBcInNlbGVjdGVkXCIsXG4gICAgbXVsdGlTZWxlY3Q6IHRydWUsXG4gICAgZW5hYmxlVGV4dFNlbGVjdGlvbk9uQ2VsbHM6IGZhbHNlLFxuICAgIGRhdGFJdGVtQ29sdW1uVmFsdWVFeHRyYWN0b3I6IG51bGwsXG4gICAgZnVsbFdpZHRoUm93czogZmFsc2UsXG4gICAgbXVsdGlDb2x1bW5Tb3J0OiBmYWxzZSxcbiAgICBkZWZhdWx0Rm9ybWF0dGVyOiBkZWZhdWx0Rm9ybWF0dGVyLFxuICAgIGZvcmNlU3luY1Njcm9sbGluZzogZmFsc2UsXG4gICAgYWRkTmV3Um93Q3NzQ2xhc3M6IFwibmV3LXJvd1wiXG4gIH07XG5cbiAgdmFyIGNvbHVtbkRlZmF1bHRzID0ge1xuICAgIG5hbWU6IFwiXCIsXG4gICAgcmVzaXphYmxlOiB0cnVlLFxuICAgIHNvcnRhYmxlOiBmYWxzZSxcbiAgICBtaW5XaWR0aDogMzAsXG4gICAgcmVyZW5kZXJPblJlc2l6ZTogZmFsc2UsXG4gICAgaGVhZGVyQ3NzQ2xhc3M6IG51bGwsXG4gICAgZGVmYXVsdFNvcnRBc2M6IHRydWUsXG4gICAgZm9jdXNhYmxlOiB0cnVlLFxuICAgIHNlbGVjdGFibGU6IHRydWVcbiAgfTtcblxuICAvLyBzY3JvbGxlclxuICB2YXIgdGg7ICAgLy8gdmlydHVhbCBoZWlnaHRcbiAgdmFyIGg7ICAgIC8vIHJlYWwgc2Nyb2xsYWJsZSBoZWlnaHRcbiAgdmFyIHBoOyAgIC8vIHBhZ2UgaGVpZ2h0XG4gIHZhciBuOyAgICAvLyBudW1iZXIgb2YgcGFnZXNcbiAgdmFyIGNqOyAgIC8vIFwianVtcGluZXNzXCIgY29lZmZpY2llbnRcblxuICB2YXIgcGFnZSA9IDA7ICAgICAgIC8vIGN1cnJlbnQgcGFnZVxuICB2YXIgb2Zmc2V0ID0gMDsgICAgIC8vIGN1cnJlbnQgcGFnZSBvZmZzZXRcbiAgdmFyIHZTY3JvbGxEaXIgPSAxO1xuXG4gIC8vIHByaXZhdGVcbiAgdmFyIGluaXRpYWxpemVkID0gZmFsc2U7XG4gIHZhciAkY29udGFpbmVyO1xuICB2YXIgdWlkID0gXCJzbGlja2dyaWRfXCIgKyBNYXRoLnJvdW5kKDEwMDAwMDAgKiBNYXRoLnJhbmRvbSgpKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgJGZvY3VzU2luaywgJGZvY3VzU2luazI7XG4gIHZhciAkaGVhZGVyU2Nyb2xsZXI7XG4gIHZhciAkaGVhZGVycztcbiAgdmFyICRoZWFkZXJSb3csICRoZWFkZXJSb3dTY3JvbGxlciwgJGhlYWRlclJvd1NwYWNlcjtcbiAgdmFyICR0b3BQYW5lbFNjcm9sbGVyO1xuICB2YXIgJHRvcFBhbmVsO1xuICB2YXIgJHZpZXdwb3J0O1xuICB2YXIgJGNhbnZhcztcbiAgdmFyICRzdHlsZTtcbiAgdmFyICRib3VuZEFuY2VzdG9ycztcbiAgdmFyIHN0eWxlc2hlZXQsIGNvbHVtbkNzc1J1bGVzTCwgY29sdW1uQ3NzUnVsZXNSO1xuICB2YXIgdmlld3BvcnRILCB2aWV3cG9ydFc7XG4gIHZhciBjYW52YXNXaWR0aDtcbiAgdmFyIHZpZXdwb3J0SGFzSFNjcm9sbCwgdmlld3BvcnRIYXNWU2Nyb2xsO1xuICB2YXIgaGVhZGVyQ29sdW1uV2lkdGhEaWZmID0gMCwgaGVhZGVyQ29sdW1uSGVpZ2h0RGlmZiA9IDAsIC8vIGJvcmRlcitwYWRkaW5nXG4gICAgICBjZWxsV2lkdGhEaWZmID0gMCwgY2VsbEhlaWdodERpZmYgPSAwO1xuICB2YXIgYWJzb2x1dGVDb2x1bW5NaW5XaWR0aDtcblxuICB2YXIgdGFiYmluZ0RpcmVjdGlvbiA9IDE7XG4gIHZhciBhY3RpdmVQb3NYO1xuICB2YXIgYWN0aXZlUm93LCBhY3RpdmVDZWxsO1xuICB2YXIgYWN0aXZlQ2VsbE5vZGUgPSBudWxsO1xuICB2YXIgY3VycmVudEVkaXRvciA9IG51bGw7XG4gIHZhciBzZXJpYWxpemVkRWRpdG9yVmFsdWU7XG4gIHZhciBlZGl0Q29udHJvbGxlcjtcblxuICB2YXIgcm93c0NhY2hlID0ge307XG4gIHZhciByZW5kZXJlZFJvd3MgPSAwO1xuICB2YXIgbnVtVmlzaWJsZVJvd3M7XG4gIHZhciBwcmV2U2Nyb2xsVG9wID0gMDtcbiAgdmFyIHNjcm9sbFRvcCA9IDA7XG4gIHZhciBsYXN0UmVuZGVyZWRTY3JvbGxUb3AgPSAwO1xuICB2YXIgbGFzdFJlbmRlcmVkU2Nyb2xsTGVmdCA9IDA7XG4gIHZhciBwcmV2U2Nyb2xsTGVmdCA9IDA7XG4gIHZhciBzY3JvbGxMZWZ0ID0gMDtcblxuICB2YXIgc2VsZWN0aW9uTW9kZWw7XG4gIHZhciBzZWxlY3RlZFJvd3MgPSBbXTtcblxuICB2YXIgcGx1Z2lucyA9IFtdO1xuICB2YXIgY2VsbENzc0NsYXNzZXMgPSB7fTtcblxuICB2YXIgY29sdW1uc0J5SWQgPSB7fTtcbiAgdmFyIHNvcnRDb2x1bW5zID0gW107XG4gIHZhciBjb2x1bW5Qb3NMZWZ0ID0gW107XG4gIHZhciBjb2x1bW5Qb3NSaWdodCA9IFtdO1xuXG5cbiAgLy8gYXN5bmMgY2FsbCBoYW5kbGVzXG4gIHZhciBoX2VkaXRvckxvYWRlciA9IG51bGw7XG4gIHZhciBoX3JlbmRlciA9IG51bGw7XG4gIHZhciBoX3Bvc3RyZW5kZXIgPSBudWxsO1xuICB2YXIgcG9zdFByb2Nlc3NlZFJvd3MgPSB7fTtcbiAgdmFyIHBvc3RQcm9jZXNzVG9Sb3cgPSBudWxsO1xuICB2YXIgcG9zdFByb2Nlc3NGcm9tUm93ID0gbnVsbDtcblxuICAvLyBwZXJmIGNvdW50ZXJzXG4gIHZhciBjb3VudGVyX3Jvd3NfcmVuZGVyZWQgPSAwO1xuICB2YXIgY291bnRlcl9yb3dzX3JlbW92ZWQgPSAwO1xuXG4gIC8vIFRoZXNlIHR3byB2YXJpYWJsZXMgd29yayBhcm91bmQgYSBidWcgd2l0aCBpbmVydGlhbCBzY3JvbGxpbmcgaW4gV2Via2l0L0JsaW5rIG9uIE1hYy5cbiAgLy8gU2VlIGh0dHA6Ly9jcmJ1Zy5jb20vMzEyNDI3LlxuICB2YXIgcm93Tm9kZUZyb21MYXN0TW91c2VXaGVlbEV2ZW50OyAgLy8gdGhpcyBub2RlIG11c3Qgbm90IGJlIGRlbGV0ZWQgd2hpbGUgaW5lcnRpYWwgc2Nyb2xsaW5nXG4gIHZhciB6b21iaWVSb3dOb2RlRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQ7ICAvLyBub2RlIHRoYXQgd2FzIGhpZGRlbiBpbnN0ZWFkIG9mIGdldHRpbmcgZGVsZXRlZFxuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBJbml0aWFsaXphdGlvblxuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgJGNvbnRhaW5lciA9ICQoY29udGFpbmVyKTtcbiAgICBpZiAoJGNvbnRhaW5lci5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGlja0dyaWQgcmVxdWlyZXMgYSB2YWxpZCBjb250YWluZXIsIFwiICsgY29udGFpbmVyICsgXCIgZG9lcyBub3QgZXhpc3QgaW4gdGhlIERPTS5cIik7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZXNlIG9ubHkgb25jZSBhbmQgc2hhcmUgYmV0d2VlbiBncmlkIGluc3RhbmNlc1xuICAgIG1heFN1cHBvcnRlZENzc0hlaWdodCA9IG1heFN1cHBvcnRlZENzc0hlaWdodCB8fCBnZXRNYXhTdXBwb3J0ZWRDc3NIZWlnaHQoKTtcbiAgICBzY3JvbGxiYXJEaW1lbnNpb25zID0gc2Nyb2xsYmFyRGltZW5zaW9ucyB8fCBtZWFzdXJlU2Nyb2xsYmFyKCk7XG5cbiAgICBvcHRpb25zID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICB2YWxpZGF0ZUFuZEVuZm9yY2VPcHRpb25zKCk7XG4gICAgY29sdW1uRGVmYXVsdHMud2lkdGggPSBvcHRpb25zLmRlZmF1bHRDb2x1bW5XaWR0aDtcblxuICAgIGNvbHVtbnNCeUlkID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbSA9IGNvbHVtbnNbaV0gPSAkLmV4dGVuZCh7fSwgY29sdW1uRGVmYXVsdHMsIGNvbHVtbnNbaV0pO1xuICAgICAgY29sdW1uc0J5SWRbbS5pZF0gPSBpO1xuICAgICAgaWYgKG0ubWluV2lkdGggJiYgbS53aWR0aCA8IG0ubWluV2lkdGgpIHtcbiAgICAgICAgbS53aWR0aCA9IG0ubWluV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAobS5tYXhXaWR0aCAmJiBtLndpZHRoID4gbS5tYXhXaWR0aCkge1xuICAgICAgICBtLndpZHRoID0gbS5tYXhXaWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBsb2FkZWQgSmF2YVNjcmlwdCBtb2R1bGVzIGFnYWluc3QgcmVxdWVzdGVkIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5lbmFibGVDb2x1bW5SZW9yZGVyICYmICEkLmZuLnNvcnRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGlja0dyaWQncyAnZW5hYmxlQ29sdW1uUmVvcmRlciA9IHRydWUnIG9wdGlvbiByZXF1aXJlcyBqcXVlcnktdWkuc29ydGFibGUgbW9kdWxlIHRvIGJlIGxvYWRlZFwiKTtcbiAgICB9XG5cbiAgICBlZGl0Q29udHJvbGxlciA9IHtcbiAgICAgIFwiY29tbWl0Q3VycmVudEVkaXRcIjogY29tbWl0Q3VycmVudEVkaXQsXG4gICAgICBcImNhbmNlbEN1cnJlbnRFZGl0XCI6IGNhbmNlbEN1cnJlbnRFZGl0XG4gICAgfTtcblxuICAgICRjb250YWluZXJcbiAgICAgICAgLmVtcHR5KClcbiAgICAgICAgLmNzcyhcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpXG4gICAgICAgIC5jc3MoXCJvdXRsaW5lXCIsIDApXG4gICAgICAgIC5hZGRDbGFzcyh1aWQpXG4gICAgICAgIC5hZGRDbGFzcyhcImJrLXVpLXdpZGdldFwiKTtcblxuICAgIC8vIHNldCB1cCBhIHBvc2l0aW9uaW5nIGNvbnRhaW5lciBpZiBuZWVkZWRcbiAgICBpZiAoIS9yZWxhdGl2ZXxhYnNvbHV0ZXxmaXhlZC8udGVzdCgkY29udGFpbmVyLmNzcyhcInBvc2l0aW9uXCIpKSkge1xuICAgICAgJGNvbnRhaW5lci5jc3MoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpO1xuICAgIH1cblxuICAgICRmb2N1c1NpbmsgPSAkKFwiPGRpdiB0YWJJbmRleD0nMCcgaGlkZUZvY3VzIHN0eWxlPSdwb3NpdGlvbjpmaXhlZDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6MDtvdXRsaW5lOjA7Jz48L2Rpdj5cIikuYXBwZW5kVG8oJGNvbnRhaW5lcik7XG5cbiAgICAkaGVhZGVyU2Nyb2xsZXIgPSAkKFwiPGRpdiBjbGFzcz0nYmstc2xpY2staGVhZGVyIGJrLXVpLXN0YXRlLWRlZmF1bHQnIHN0eWxlPSdvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7JyAvPlwiKS5hcHBlbmRUbygkY29udGFpbmVyKTtcbiAgICAkaGVhZGVycyA9ICQoXCI8ZGl2IGNsYXNzPSdiay1zbGljay1oZWFkZXItY29sdW1ucycgc3R5bGU9J2xlZnQ6LTEwMDBweCcgLz5cIikuYXBwZW5kVG8oJGhlYWRlclNjcm9sbGVyKTtcbiAgICAkaGVhZGVycy53aWR0aChnZXRIZWFkZXJzV2lkdGgoKSk7XG5cbiAgICAkaGVhZGVyUm93U2Nyb2xsZXIgPSAkKFwiPGRpdiBjbGFzcz0nYmstc2xpY2staGVhZGVycm93IGJrLXVpLXN0YXRlLWRlZmF1bHQnIHN0eWxlPSdvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7JyAvPlwiKS5hcHBlbmRUbygkY29udGFpbmVyKTtcbiAgICAkaGVhZGVyUm93ID0gJChcIjxkaXYgY2xhc3M9J2JrLXNsaWNrLWhlYWRlcnJvdy1jb2x1bW5zJyAvPlwiKS5hcHBlbmRUbygkaGVhZGVyUm93U2Nyb2xsZXIpO1xuICAgICRoZWFkZXJSb3dTcGFjZXIgPSAkKFwiPGRpdiBzdHlsZT0nZGlzcGxheTpibG9jaztoZWlnaHQ6MXB4O3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDsnPjwvZGl2PlwiKVxuICAgICAgICAuY3NzKFwid2lkdGhcIiwgZ2V0Q2FudmFzV2lkdGgoKSArIHNjcm9sbGJhckRpbWVuc2lvbnMud2lkdGggKyBcInB4XCIpXG4gICAgICAgIC5hcHBlbmRUbygkaGVhZGVyUm93U2Nyb2xsZXIpO1xuXG4gICAgJHRvcFBhbmVsU2Nyb2xsZXIgPSAkKFwiPGRpdiBjbGFzcz0nYmstc2xpY2stdG9wLXBhbmVsLXNjcm9sbGVyIGJrLXVpLXN0YXRlLWRlZmF1bHQnIHN0eWxlPSdvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7JyAvPlwiKS5hcHBlbmRUbygkY29udGFpbmVyKTtcbiAgICAkdG9wUGFuZWwgPSAkKFwiPGRpdiBjbGFzcz0nYmstc2xpY2stdG9wLXBhbmVsJyBzdHlsZT0nd2lkdGg6MTAwMDBweCcgLz5cIikuYXBwZW5kVG8oJHRvcFBhbmVsU2Nyb2xsZXIpO1xuXG4gICAgaWYgKCFvcHRpb25zLnNob3dUb3BQYW5lbCkge1xuICAgICAgJHRvcFBhbmVsU2Nyb2xsZXIuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5zaG93SGVhZGVyUm93KSB7XG4gICAgICAkaGVhZGVyUm93U2Nyb2xsZXIuaGlkZSgpO1xuICAgIH1cblxuICAgICR2aWV3cG9ydCA9ICQoXCI8ZGl2IGNsYXNzPSdiay1zbGljay12aWV3cG9ydCcgc3R5bGU9J3dpZHRoOjEwMCU7b3ZlcmZsb3c6YXV0bztvdXRsaW5lOjA7cG9zaXRpb246cmVsYXRpdmU7Oyc+XCIpLmFwcGVuZFRvKCRjb250YWluZXIpO1xuICAgICR2aWV3cG9ydC5jc3MoXCJvdmVyZmxvdy15XCIsIG9wdGlvbnMuYXV0b0hlaWdodCA/IFwiaGlkZGVuXCIgOiBcImF1dG9cIik7XG5cbiAgICAkY2FudmFzID0gJChcIjxkaXYgY2xhc3M9J2dyaWQtY2FudmFzJyAvPlwiKS5hcHBlbmRUbygkdmlld3BvcnQpO1xuXG4gICAgJGZvY3VzU2luazIgPSAkZm9jdXNTaW5rLmNsb25lKCkuYXBwZW5kVG8oJGNvbnRhaW5lcik7XG5cbiAgICBpZiAoIW9wdGlvbnMuZXhwbGljaXRJbml0aWFsaXphdGlvbikge1xuICAgICAgZmluaXNoSW5pdGlhbGl6YXRpb24oKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hJbml0aWFsaXphdGlvbigpIHtcbiAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgIHZpZXdwb3J0VyA9IHBhcnNlRmxvYXQoJC5jc3MoJGNvbnRhaW5lclswXSwgXCJ3aWR0aFwiLCB0cnVlKSk7XG5cbiAgICAgIC8vIGhlYWRlciBjb2x1bW5zIGFuZCBjZWxscyBtYXkgaGF2ZSBkaWZmZXJlbnQgcGFkZGluZy9ib3JkZXIgc2tld2luZyB3aWR0aCBjYWxjdWxhdGlvbnMgKGJveC1zaXppbmcsIGhlbGxvPylcbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGlmZiBzbyB3ZSBjYW4gc2V0IGNvbnNpc3RlbnQgc2l6ZXNcbiAgICAgIG1lYXN1cmVDZWxsUGFkZGluZ0FuZEJvcmRlcigpO1xuXG4gICAgICAvLyBmb3IgdXNhYmlsaXR5IHJlYXNvbnMsIGFsbCB0ZXh0IHNlbGVjdGlvbiBpbiBTbGlja0dyaWQgaXMgZGlzYWJsZWRcbiAgICAgIC8vIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBpbnB1dCBhbmQgdGV4dGFyZWEgZWxlbWVudHMgKHNlbGVjdGlvbiBtdXN0XG4gICAgICAvLyBiZSBlbmFibGVkIHRoZXJlIHNvIHRoYXQgZWRpdG9ycyB3b3JrIGFzIGV4cGVjdGVkKTsgbm90ZSB0aGF0XG4gICAgICAvLyBzZWxlY3Rpb24gaW4gZ3JpZCBjZWxscyAoZ3JpZCBib2R5KSBpcyBhbHJlYWR5IHVuYXZhaWxhYmxlIGluXG4gICAgICAvLyBhbGwgYnJvd3NlcnMgZXhjZXB0IElFXG4gICAgICBkaXNhYmxlU2VsZWN0aW9uKCRoZWFkZXJzKTsgLy8gZGlzYWJsZSBhbGwgdGV4dCBzZWxlY3Rpb24gaW4gaGVhZGVyIChpbmNsdWRpbmcgaW5wdXQgYW5kIHRleHRhcmVhKVxuXG4gICAgICBpZiAoIW9wdGlvbnMuZW5hYmxlVGV4dFNlbGVjdGlvbk9uQ2VsbHMpIHtcbiAgICAgICAgLy8gZGlzYWJsZSB0ZXh0IHNlbGVjdGlvbiBpbiBncmlkIGNlbGxzIGV4Y2VwdCBpbiBpbnB1dCBhbmQgdGV4dGFyZWEgZWxlbWVudHNcbiAgICAgICAgLy8gKHRoaXMgaXMgSUUtc3BlY2lmaWMsIGJlY2F1c2Ugc2VsZWN0c3RhcnQgZXZlbnQgd2lsbCBvbmx5IGZpcmUgaW4gSUUpXG4gICAgICAgICR2aWV3cG9ydC5iaW5kKFwic2VsZWN0c3RhcnQudWlcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuICQoZXZlbnQudGFyZ2V0KS5pcyhcImlucHV0LHRleHRhcmVhXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlQ29sdW1uQ2FjaGVzKCk7XG4gICAgICBjcmVhdGVDb2x1bW5IZWFkZXJzKCk7XG4gICAgICBzZXR1cENvbHVtblNvcnQoKTtcbiAgICAgIGNyZWF0ZUNzc1J1bGVzKCk7XG4gICAgICByZXNpemVDYW52YXMoKTtcbiAgICAgIGJpbmRBbmNlc3RvclNjcm9sbEV2ZW50cygpO1xuXG4gICAgICAkY29udGFpbmVyXG4gICAgICAgICAgLmJpbmQoXCJyZXNpemUuYmstc2xpY2tncmlkXCIsIHJlc2l6ZUNhbnZhcyk7XG4gICAgICAkdmlld3BvcnRcbiAgICAgICAgICAvLy5iaW5kKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spXG4gICAgICAgICAgLmJpbmQoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsKTtcbiAgICAgICRoZWFkZXJTY3JvbGxlclxuICAgICAgICAgIC5iaW5kKFwiY29udGV4dG1lbnVcIiwgaGFuZGxlSGVhZGVyQ29udGV4dE1lbnUpXG4gICAgICAgICAgLmJpbmQoXCJjbGlja1wiLCBoYW5kbGVIZWFkZXJDbGljaylcbiAgICAgICAgICAuZGVsZWdhdGUoXCIuYmstc2xpY2staGVhZGVyLWNvbHVtblwiLCBcIm1vdXNlZW50ZXJcIiwgaGFuZGxlSGVhZGVyTW91c2VFbnRlcilcbiAgICAgICAgICAuZGVsZWdhdGUoXCIuYmstc2xpY2staGVhZGVyLWNvbHVtblwiLCBcIm1vdXNlbGVhdmVcIiwgaGFuZGxlSGVhZGVyTW91c2VMZWF2ZSk7XG4gICAgICAkaGVhZGVyUm93U2Nyb2xsZXJcbiAgICAgICAgICAuYmluZChcInNjcm9sbFwiLCBoYW5kbGVIZWFkZXJSb3dTY3JvbGwpO1xuICAgICAgJGZvY3VzU2luay5hZGQoJGZvY3VzU2luazIpXG4gICAgICAgICAgLmJpbmQoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xuICAgICAgJGNhbnZhc1xuICAgICAgICAgIC5iaW5kKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKVxuICAgICAgICAgIC5iaW5kKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spXG4gICAgICAgICAgLmJpbmQoXCJkYmxjbGlja1wiLCBoYW5kbGVEYmxDbGljaylcbiAgICAgICAgICAuYmluZChcImNvbnRleHRtZW51XCIsIGhhbmRsZUNvbnRleHRNZW51KVxuICAgICAgICAgIC5iaW5kKFwiZHJhZ2luaXRcIiwgaGFuZGxlRHJhZ0luaXQpXG4gICAgICAgICAgLmJpbmQoXCJkcmFnc3RhcnRcIiwge2Rpc3RhbmNlOiAzfSwgaGFuZGxlRHJhZ1N0YXJ0KVxuICAgICAgICAgIC5iaW5kKFwiZHJhZ1wiLCBoYW5kbGVEcmFnKVxuICAgICAgICAgIC5iaW5kKFwiZHJhZ2VuZFwiLCBoYW5kbGVEcmFnRW5kKVxuICAgICAgICAgIC5kZWxlZ2F0ZShcIi5iay1zbGljay1jZWxsXCIsIFwibW91c2VlbnRlclwiLCBoYW5kbGVNb3VzZUVudGVyKVxuICAgICAgICAgIC5kZWxlZ2F0ZShcIi5iay1zbGljay1jZWxsXCIsIFwibW91c2VsZWF2ZVwiLCBoYW5kbGVNb3VzZUxlYXZlKTtcblxuICAgICAgLy8gV29yayBhcm91bmQgaHR0cDovL2NyYnVnLmNvbS8zMTI0MjcuXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC93ZWJraXQvKSAmJlxuICAgICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvbWFjaW50b3NoLykpIHtcbiAgICAgICAgJGNhbnZhcy5iaW5kKFwibW91c2V3aGVlbFwiLCBoYW5kbGVNb3VzZVdoZWVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3RlclBsdWdpbihwbHVnaW4pIHtcbiAgICBwbHVnaW5zLnVuc2hpZnQocGx1Z2luKTtcbiAgICBwbHVnaW4uaW5pdChzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luKSB7XG4gICAgZm9yICh2YXIgaSA9IHBsdWdpbnMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHBsdWdpbnNbaV0gPT09IHBsdWdpbikge1xuICAgICAgICBpZiAocGx1Z2luc1tpXS5kZXN0cm95KSB7XG4gICAgICAgICAgcGx1Z2luc1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgcGx1Z2lucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvbk1vZGVsKG1vZGVsKSB7XG4gICAgaWYgKHNlbGVjdGlvbk1vZGVsKSB7XG4gICAgICBzZWxlY3Rpb25Nb2RlbC5vblNlbGVjdGVkUmFuZ2VzQ2hhbmdlZC51bnN1YnNjcmliZShoYW5kbGVTZWxlY3RlZFJhbmdlc0NoYW5nZWQpO1xuICAgICAgaWYgKHNlbGVjdGlvbk1vZGVsLmRlc3Ryb3kpIHtcbiAgICAgICAgc2VsZWN0aW9uTW9kZWwuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdGlvbk1vZGVsID0gbW9kZWw7XG4gICAgaWYgKHNlbGVjdGlvbk1vZGVsKSB7XG4gICAgICBzZWxlY3Rpb25Nb2RlbC5pbml0KHNlbGYpO1xuICAgICAgc2VsZWN0aW9uTW9kZWwub25TZWxlY3RlZFJhbmdlc0NoYW5nZWQuc3Vic2NyaWJlKGhhbmRsZVNlbGVjdGVkUmFuZ2VzQ2hhbmdlZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uTW9kZWwoKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbk1vZGVsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2FudmFzTm9kZSgpIHtcbiAgICByZXR1cm4gJGNhbnZhc1swXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lYXN1cmVTY3JvbGxiYXIoKSB7XG4gICAgdmFyICRjID0gJChcIjxkaXYgc3R5bGU9J3Bvc2l0aW9uOmFic29sdXRlOyB0b3A6LTEwMDAwcHg7IGxlZnQ6LTEwMDAwcHg7IHdpZHRoOjEwMHB4OyBoZWlnaHQ6MTAwcHg7IG92ZXJmbG93OnNjcm9sbDsnPjwvZGl2PlwiKS5hcHBlbmRUbyhcImJvZHlcIik7XG4gICAgdmFyIGRpbSA9IHtcbiAgICAgIHdpZHRoOiAkYy53aWR0aCgpIC0gJGNbMF0uY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6ICRjLmhlaWdodCgpIC0gJGNbMF0uY2xpZW50SGVpZ2h0XG4gICAgfTtcbiAgICAkYy5yZW1vdmUoKTtcbiAgICByZXR1cm4gZGltO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SGVhZGVyc1dpZHRoKCkge1xuICAgIHZhciBoZWFkZXJzV2lkdGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIHdpZHRoID0gY29sdW1uc1tpXS53aWR0aDtcbiAgICAgIGhlYWRlcnNXaWR0aCArPSB3aWR0aDtcbiAgICB9XG4gICAgaGVhZGVyc1dpZHRoICs9IHNjcm9sbGJhckRpbWVuc2lvbnMud2lkdGg7XG4gICAgcmV0dXJuIE1hdGgubWF4KGhlYWRlcnNXaWR0aCwgdmlld3BvcnRXKSArIDEwMDA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDYW52YXNXaWR0aCgpIHtcbiAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB2aWV3cG9ydEhhc1ZTY3JvbGwgPyB2aWV3cG9ydFcgLSBzY3JvbGxiYXJEaW1lbnNpb25zLndpZHRoIDogdmlld3BvcnRXO1xuICAgIHZhciByb3dXaWR0aCA9IDA7XG4gICAgdmFyIGkgPSBjb2x1bW5zLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByb3dXaWR0aCArPSBjb2x1bW5zW2ldLndpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5mdWxsV2lkdGhSb3dzID8gTWF0aC5tYXgocm93V2lkdGgsIGF2YWlsYWJsZVdpZHRoKSA6IHJvd1dpZHRoO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2FudmFzV2lkdGgoZm9yY2VDb2x1bW5XaWR0aHNVcGRhdGUpIHtcbiAgICB2YXIgb2xkQ2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICBjYW52YXNXaWR0aCA9IGdldENhbnZhc1dpZHRoKCk7XG5cbiAgICBpZiAoY2FudmFzV2lkdGggIT0gb2xkQ2FudmFzV2lkdGgpIHtcbiAgICAgICRjYW52YXMud2lkdGgoY2FudmFzV2lkdGgpO1xuICAgICAgJGhlYWRlclJvdy53aWR0aChjYW52YXNXaWR0aCk7XG4gICAgICAkaGVhZGVycy53aWR0aChnZXRIZWFkZXJzV2lkdGgoKSk7XG4gICAgICB2aWV3cG9ydEhhc0hTY3JvbGwgPSAoY2FudmFzV2lkdGggPiB2aWV3cG9ydFcgLSBzY3JvbGxiYXJEaW1lbnNpb25zLndpZHRoKTtcbiAgICB9XG5cbiAgICAkaGVhZGVyUm93U3BhY2VyLndpZHRoKGNhbnZhc1dpZHRoICsgKHZpZXdwb3J0SGFzVlNjcm9sbCA/IHNjcm9sbGJhckRpbWVuc2lvbnMud2lkdGggOiAwKSk7XG5cbiAgICBpZiAoY2FudmFzV2lkdGggIT0gb2xkQ2FudmFzV2lkdGggfHwgZm9yY2VDb2x1bW5XaWR0aHNVcGRhdGUpIHtcbiAgICAgIGFwcGx5Q29sdW1uV2lkdGhzKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzYWJsZVNlbGVjdGlvbigkdGFyZ2V0KSB7XG4gICAgaWYgKCR0YXJnZXQgJiYgJHRhcmdldC5qcXVlcnkpIHtcbiAgICAgICR0YXJnZXRcbiAgICAgICAgICAuYXR0cihcInVuc2VsZWN0YWJsZVwiLCBcIm9uXCIpXG4gICAgICAgICAgLmNzcyhcIk1velVzZXJTZWxlY3RcIiwgXCJub25lXCIpXG4gICAgICAgICAgLmJpbmQoXCJzZWxlY3RzdGFydC51aVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSk7IC8vIGZyb20ganF1ZXJ5OnVpLmNvcmUuanMgMS43LjJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNYXhTdXBwb3J0ZWRDc3NIZWlnaHQoKSB7XG4gICAgdmFyIHN1cHBvcnRlZEhlaWdodCA9IDEwMDAwMDA7XG4gICAgLy8gRkYgcmVwb3J0cyB0aGUgaGVpZ2h0IGJhY2sgYnV0IHN0aWxsIHJlbmRlcnMgYmxhbmsgYWZ0ZXIgfjZNIHB4XG4gICAgdmFyIHRlc3RVcFRvID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94LykgPyA2MDAwMDAwIDogMTAwMDAwMDAwMDtcbiAgICB2YXIgZGl2ID0gJChcIjxkaXYgc3R5bGU9J2Rpc3BsYXk6bm9uZScgLz5cIikuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHRlc3QgPSBzdXBwb3J0ZWRIZWlnaHQgKiAyO1xuICAgICAgZGl2LmNzcyhcImhlaWdodFwiLCB0ZXN0KTtcbiAgICAgIGlmICh0ZXN0ID4gdGVzdFVwVG8gfHwgZGl2LmhlaWdodCgpICE9PSB0ZXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwcG9ydGVkSGVpZ2h0ID0gdGVzdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXYucmVtb3ZlKCk7XG4gICAgcmV0dXJuIHN1cHBvcnRlZEhlaWdodDtcbiAgfVxuXG4gIC8vIFRPRE86ICB0aGlzIGlzIHN0YXRpYy4gIG5lZWQgdG8gaGFuZGxlIHBhZ2UgbXV0YXRpb24uXG4gIGZ1bmN0aW9uIGJpbmRBbmNlc3RvclNjcm9sbEV2ZW50cygpIHtcbiAgICB2YXIgZWxlbSA9ICRjYW52YXNbMF07XG4gICAgd2hpbGUgKChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAhPSBkb2N1bWVudC5ib2R5ICYmIGVsZW0gIT0gbnVsbCkge1xuICAgICAgLy8gYmluZCB0byBzY3JvbGwgY29udGFpbmVycyBvbmx5XG4gICAgICBpZiAoZWxlbSA9PSAkdmlld3BvcnRbMF0gfHwgZWxlbS5zY3JvbGxXaWR0aCAhPSBlbGVtLmNsaWVudFdpZHRoIHx8IGVsZW0uc2Nyb2xsSGVpZ2h0ICE9IGVsZW0uY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHZhciAkZWxlbSA9ICQoZWxlbSk7XG4gICAgICAgIGlmICghJGJvdW5kQW5jZXN0b3JzKSB7XG4gICAgICAgICAgJGJvdW5kQW5jZXN0b3JzID0gJGVsZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGJvdW5kQW5jZXN0b3JzID0gJGJvdW5kQW5jZXN0b3JzLmFkZCgkZWxlbSk7XG4gICAgICAgIH1cbiAgICAgICAgJGVsZW0uYmluZChcInNjcm9sbC5cIiArIHVpZCwgaGFuZGxlQWN0aXZlQ2VsbFBvc2l0aW9uQ2hhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bmJpbmRBbmNlc3RvclNjcm9sbEV2ZW50cygpIHtcbiAgICBpZiAoISRib3VuZEFuY2VzdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAkYm91bmRBbmNlc3RvcnMudW5iaW5kKFwic2Nyb2xsLlwiICsgdWlkKTtcbiAgICAkYm91bmRBbmNlc3RvcnMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29sdW1uSGVhZGVyKGNvbHVtbklkLCB0aXRsZSwgdG9vbFRpcCkge1xuICAgIGlmICghaW5pdGlhbGl6ZWQpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGlkeCA9IGdldENvbHVtbkluZGV4KGNvbHVtbklkKTtcbiAgICBpZiAoaWR4ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29sdW1uRGVmID0gY29sdW1uc1tpZHhdO1xuICAgIHZhciAkaGVhZGVyID0gJGhlYWRlcnMuY2hpbGRyZW4oKS5lcShpZHgpO1xuICAgIGlmICgkaGVhZGVyKSB7XG4gICAgICBpZiAodGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2x1bW5zW2lkeF0ubmFtZSA9IHRpdGxlO1xuICAgICAgfVxuICAgICAgaWYgKHRvb2xUaXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2x1bW5zW2lkeF0udG9vbFRpcCA9IHRvb2xUaXA7XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXIoc2VsZi5vbkJlZm9yZUhlYWRlckNlbGxEZXN0cm95LCB7XG4gICAgICAgIFwibm9kZVwiOiAkaGVhZGVyWzBdLFxuICAgICAgICBcImNvbHVtblwiOiBjb2x1bW5EZWZcbiAgICAgIH0pO1xuXG4gICAgICAkaGVhZGVyXG4gICAgICAgICAgLmF0dHIoXCJ0aXRsZVwiLCB0b29sVGlwIHx8IFwiXCIpXG4gICAgICAgICAgLmNoaWxkcmVuKCkuZXEoMCkuaHRtbCh0aXRsZSk7XG5cbiAgICAgIHRyaWdnZXIoc2VsZi5vbkhlYWRlckNlbGxSZW5kZXJlZCwge1xuICAgICAgICBcIm5vZGVcIjogJGhlYWRlclswXSxcbiAgICAgICAgXCJjb2x1bW5cIjogY29sdW1uRGVmXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIZWFkZXJSb3coKSB7XG4gICAgcmV0dXJuICRoZWFkZXJSb3dbMF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIZWFkZXJSb3dDb2x1bW4oY29sdW1uSWQpIHtcbiAgICB2YXIgaWR4ID0gZ2V0Q29sdW1uSW5kZXgoY29sdW1uSWQpO1xuICAgIHZhciAkaGVhZGVyID0gJGhlYWRlclJvdy5jaGlsZHJlbigpLmVxKGlkeCk7XG4gICAgcmV0dXJuICRoZWFkZXIgJiYgJGhlYWRlclswXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbHVtbkhlYWRlcnMoKSB7XG4gICAgZnVuY3Rpb24gb25Nb3VzZUVudGVyKCkge1xuICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcImJrLXVpLXN0YXRlLWhvdmVyXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VMZWF2ZSgpIHtcbiAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXCJiay11aS1zdGF0ZS1ob3ZlclwiKTtcbiAgICB9XG5cbiAgICAkaGVhZGVycy5maW5kKFwiLmJrLXNsaWNrLWhlYWRlci1jb2x1bW5cIilcbiAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sdW1uRGVmID0gJCh0aGlzKS5kYXRhKFwiY29sdW1uXCIpO1xuICAgICAgICBpZiAoY29sdW1uRGVmKSB7XG4gICAgICAgICAgdHJpZ2dlcihzZWxmLm9uQmVmb3JlSGVhZGVyQ2VsbERlc3Ryb3ksIHtcbiAgICAgICAgICAgIFwibm9kZVwiOiB0aGlzLFxuICAgICAgICAgICAgXCJjb2x1bW5cIjogY29sdW1uRGVmXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICRoZWFkZXJzLmVtcHR5KCk7XG4gICAgJGhlYWRlcnMud2lkdGgoZ2V0SGVhZGVyc1dpZHRoKCkpO1xuXG4gICAgJGhlYWRlclJvdy5maW5kKFwiLmJrLXNsaWNrLWhlYWRlcnJvdy1jb2x1bW5cIilcbiAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sdW1uRGVmID0gJCh0aGlzKS5kYXRhKFwiY29sdW1uXCIpO1xuICAgICAgICBpZiAoY29sdW1uRGVmKSB7XG4gICAgICAgICAgdHJpZ2dlcihzZWxmLm9uQmVmb3JlSGVhZGVyUm93Q2VsbERlc3Ryb3ksIHtcbiAgICAgICAgICAgIFwibm9kZVwiOiB0aGlzLFxuICAgICAgICAgICAgXCJjb2x1bW5cIjogY29sdW1uRGVmXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICRoZWFkZXJSb3cuZW1wdHkoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG0gPSBjb2x1bW5zW2ldO1xuXG4gICAgICB2YXIgaGVhZGVyID0gJChcIjxkaXYgY2xhc3M9J2JrLXVpLXN0YXRlLWRlZmF1bHQgYmstc2xpY2staGVhZGVyLWNvbHVtbicgLz5cIilcbiAgICAgICAgICAuaHRtbChcIjxzcGFuIGNsYXNzPSdiay1zbGljay1jb2x1bW4tbmFtZSc+XCIgKyBtLm5hbWUgKyBcIjwvc3Bhbj5cIilcbiAgICAgICAgICAud2lkdGgobS53aWR0aCAtIGhlYWRlckNvbHVtbldpZHRoRGlmZilcbiAgICAgICAgICAuYXR0cihcImlkXCIsIFwiXCIgKyB1aWQgKyBtLmlkKVxuICAgICAgICAgIC5hdHRyKFwidGl0bGVcIiwgbS50b29sVGlwIHx8IFwiXCIpXG4gICAgICAgICAgLmRhdGEoXCJjb2x1bW5cIiwgbSlcbiAgICAgICAgICAuYWRkQ2xhc3MobS5oZWFkZXJDc3NDbGFzcyB8fCBcIlwiKVxuICAgICAgICAgIC5hcHBlbmRUbygkaGVhZGVycyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZUNvbHVtblJlb3JkZXIgfHwgbS5zb3J0YWJsZSkge1xuICAgICAgICBoZWFkZXJcbiAgICAgICAgICAub24oJ21vdXNlZW50ZXInLCBvbk1vdXNlRW50ZXIpXG4gICAgICAgICAgLm9uKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG0uc29ydGFibGUpIHtcbiAgICAgICAgaGVhZGVyLmFkZENsYXNzKFwiYmstc2xpY2staGVhZGVyLXNvcnRhYmxlXCIpO1xuICAgICAgICBoZWFkZXIuYXBwZW5kKFwiPHNwYW4gY2xhc3M9J2JrLXNsaWNrLXNvcnQtaW5kaWNhdG9yJyAvPlwiKTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlcihzZWxmLm9uSGVhZGVyQ2VsbFJlbmRlcmVkLCB7XG4gICAgICAgIFwibm9kZVwiOiBoZWFkZXJbMF0sXG4gICAgICAgIFwiY29sdW1uXCI6IG1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5zaG93SGVhZGVyUm93KSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDZWxsID0gJChcIjxkaXYgY2xhc3M9J2JrLXVpLXN0YXRlLWRlZmF1bHQgYmstc2xpY2staGVhZGVycm93LWNvbHVtbiBsXCIgKyBpICsgXCIgclwiICsgaSArIFwiJz48L2Rpdj5cIilcbiAgICAgICAgICAgIC5kYXRhKFwiY29sdW1uXCIsIG0pXG4gICAgICAgICAgICAuYXBwZW5kVG8oJGhlYWRlclJvdyk7XG5cbiAgICAgICAgdHJpZ2dlcihzZWxmLm9uSGVhZGVyUm93Q2VsbFJlbmRlcmVkLCB7XG4gICAgICAgICAgXCJub2RlXCI6IGhlYWRlclJvd0NlbGxbMF0sXG4gICAgICAgICAgXCJjb2x1bW5cIjogbVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRTb3J0Q29sdW1ucyhzb3J0Q29sdW1ucyk7XG4gICAgc2V0dXBDb2x1bW5SZXNpemUoKTtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVDb2x1bW5SZW9yZGVyKSB7XG4gICAgICBzZXR1cENvbHVtblJlb3JkZXIoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cENvbHVtblNvcnQoKSB7XG4gICAgJGhlYWRlcnMuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIHRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBhIGJ1ZyBpbiBqUXVlcnkgMS43LjEgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzExMzI4KVxuICAgICAgZS5tZXRhS2V5ID0gZS5tZXRhS2V5IHx8IGUuY3RybEtleTtcblxuICAgICAgaWYgKCQoZS50YXJnZXQpLmhhc0NsYXNzKFwiYmstc2xpY2stcmVzaXphYmxlLWhhbmRsZVwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciAkY29sID0gJChlLnRhcmdldCkuY2xvc2VzdChcIi5iay1zbGljay1oZWFkZXItY29sdW1uXCIpO1xuICAgICAgaWYgKCEkY29sLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2x1bW4gPSAkY29sLmRhdGEoXCJjb2x1bW5cIik7XG4gICAgICBpZiAoY29sdW1uLnNvcnRhYmxlKSB7XG4gICAgICAgIGlmICghZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc29ydE9wdHMgPSBudWxsO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgc29ydENvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc29ydENvbHVtbnNbaV0uY29sdW1uSWQgPT0gY29sdW1uLmlkKSB7XG4gICAgICAgICAgICBzb3J0T3B0cyA9IHNvcnRDb2x1bW5zW2ldO1xuICAgICAgICAgICAgc29ydE9wdHMuc29ydEFzYyA9ICFzb3J0T3B0cy5zb3J0QXNjO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUubWV0YUtleSAmJiBvcHRpb25zLm11bHRpQ29sdW1uU29ydCkge1xuICAgICAgICAgIGlmIChzb3J0T3B0cykge1xuICAgICAgICAgICAgc29ydENvbHVtbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoKCFlLnNoaWZ0S2V5ICYmICFlLm1ldGFLZXkpIHx8ICFvcHRpb25zLm11bHRpQ29sdW1uU29ydCkge1xuICAgICAgICAgICAgc29ydENvbHVtbnMgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXNvcnRPcHRzKSB7XG4gICAgICAgICAgICBzb3J0T3B0cyA9IHsgY29sdW1uSWQ6IGNvbHVtbi5pZCwgc29ydEFzYzogY29sdW1uLmRlZmF1bHRTb3J0QXNjIH07XG4gICAgICAgICAgICBzb3J0Q29sdW1ucy5wdXNoKHNvcnRPcHRzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvcnRDb2x1bW5zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBzb3J0Q29sdW1ucy5wdXNoKHNvcnRPcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZXRTb3J0Q29sdW1ucyhzb3J0Q29sdW1ucyk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLm11bHRpQ29sdW1uU29ydCkge1xuICAgICAgICAgIHRyaWdnZXIoc2VsZi5vblNvcnQsIHtcbiAgICAgICAgICAgIG11bHRpQ29sdW1uU29ydDogZmFsc2UsXG4gICAgICAgICAgICBzb3J0Q29sOiBjb2x1bW4sXG4gICAgICAgICAgICBzb3J0QXNjOiBzb3J0T3B0cy5zb3J0QXNjfSwgZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJpZ2dlcihzZWxmLm9uU29ydCwge1xuICAgICAgICAgICAgbXVsdGlDb2x1bW5Tb3J0OiB0cnVlLFxuICAgICAgICAgICAgc29ydENvbHM6ICQubWFwKHNvcnRDb2x1bW5zLCBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtzb3J0Q29sOiBjb2x1bW5zW2dldENvbHVtbkluZGV4KGNvbC5jb2x1bW5JZCldLCBzb3J0QXNjOiBjb2wuc29ydEFzYyB9O1xuICAgICAgICAgICAgfSl9LCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXBDb2x1bW5SZW9yZGVyKCkge1xuICAgICRoZWFkZXJzLmZpbHRlcihcIjp1aS1zb3J0YWJsZVwiKS5zb3J0YWJsZShcImRlc3Ryb3lcIik7XG4gICAgJGhlYWRlcnMuc29ydGFibGUoe1xuICAgICAgY29udGFpbm1lbnQ6IFwicGFyZW50XCIsXG4gICAgICBkaXN0YW5jZTogMyxcbiAgICAgIGF4aXM6IFwieFwiLFxuICAgICAgY3Vyc29yOiBcImRlZmF1bHRcIixcbiAgICAgIHRvbGVyYW5jZTogXCJpbnRlcnNlY3Rpb25cIixcbiAgICAgIGhlbHBlcjogXCJjbG9uZVwiLFxuICAgICAgcGxhY2Vob2xkZXI6IFwiYmstc2xpY2stc29ydGFibGUtcGxhY2Vob2xkZXIgYmstdWktc3RhdGUtZGVmYXVsdCBiay1zbGljay1oZWFkZXItY29sdW1uXCIsXG4gICAgICBzdGFydDogZnVuY3Rpb24gKGUsIHVpKSB7XG4gICAgICAgIHVpLnBsYWNlaG9sZGVyLndpZHRoKHVpLmhlbHBlci5vdXRlcldpZHRoKCkgLSBoZWFkZXJDb2x1bW5XaWR0aERpZmYpO1xuICAgICAgICAkKHVpLmhlbHBlcikuYWRkQ2xhc3MoXCJiay1zbGljay1oZWFkZXItY29sdW1uLWFjdGl2ZVwiKTtcbiAgICAgIH0sXG4gICAgICBiZWZvcmVTdG9wOiBmdW5jdGlvbiAoZSwgdWkpIHtcbiAgICAgICAgJCh1aS5oZWxwZXIpLnJlbW92ZUNsYXNzKFwiYmstc2xpY2staGVhZGVyLWNvbHVtbi1hY3RpdmVcIik7XG4gICAgICB9LFxuICAgICAgc3RvcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFnZXRFZGl0b3JMb2NrKCkuY29tbWl0Q3VycmVudEVkaXQoKSkge1xuICAgICAgICAgICQodGhpcykuc29ydGFibGUoXCJjYW5jZWxcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlb3JkZXJlZElkcyA9ICRoZWFkZXJzLnNvcnRhYmxlKFwidG9BcnJheVwiKTtcbiAgICAgICAgdmFyIHJlb3JkZXJlZENvbHVtbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW9yZGVyZWRJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZW9yZGVyZWRDb2x1bW5zLnB1c2goY29sdW1uc1tnZXRDb2x1bW5JbmRleChyZW9yZGVyZWRJZHNbaV0ucmVwbGFjZSh1aWQsIFwiXCIpKV0pO1xuICAgICAgICB9XG4gICAgICAgIHNldENvbHVtbnMocmVvcmRlcmVkQ29sdW1ucyk7XG5cbiAgICAgICAgdHJpZ2dlcihzZWxmLm9uQ29sdW1uc1Jlb3JkZXJlZCwge30pO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBzZXR1cENvbHVtblJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXBDb2x1bW5SZXNpemUoKSB7XG4gICAgdmFyICRjb2wsIGosIGMsIHBhZ2VYLCBjb2x1bW5FbGVtZW50cywgbWluUGFnZVgsIG1heFBhZ2VYLCBmaXJzdFJlc2l6YWJsZSwgbGFzdFJlc2l6YWJsZTtcbiAgICBjb2x1bW5FbGVtZW50cyA9ICRoZWFkZXJzLmNoaWxkcmVuKCk7XG4gICAgY29sdW1uRWxlbWVudHMuZmluZChcIi5iay1zbGljay1yZXNpemFibGUtaGFuZGxlXCIpLnJlbW92ZSgpO1xuICAgIGNvbHVtbkVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgIGlmIChjb2x1bW5zW2ldLnJlc2l6YWJsZSkge1xuICAgICAgICBpZiAoZmlyc3RSZXNpemFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZpcnN0UmVzaXphYmxlID0gaTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UmVzaXphYmxlID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZmlyc3RSZXNpemFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb2x1bW5FbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICBpZiAoaSA8IGZpcnN0UmVzaXphYmxlIHx8IChvcHRpb25zLmZvcmNlRml0Q29sdW1ucyAmJiBpID49IGxhc3RSZXNpemFibGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgICRjb2wgPSAkKGUpO1xuICAgICAgJChcIjxkaXYgY2xhc3M9J2JrLXNsaWNrLXJlc2l6YWJsZS1oYW5kbGUnIC8+XCIpXG4gICAgICAgICAgLmFwcGVuZFRvKGUpXG4gICAgICAgICAgLmJpbmQoXCJkcmFnc3RhcnRcIiwgZnVuY3Rpb24gKGUsIGRkKSB7XG4gICAgICAgICAgICBpZiAoIWdldEVkaXRvckxvY2soKS5jb21taXRDdXJyZW50RWRpdCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhZ2VYID0gZS5wYWdlWDtcbiAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuYWRkQ2xhc3MoXCJiay1zbGljay1oZWFkZXItY29sdW1uLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIHZhciBzaHJpbmtMZWV3YXlPblJpZ2h0ID0gbnVsbCwgc3RyZXRjaExlZXdheU9uUmlnaHQgPSBudWxsO1xuICAgICAgICAgICAgLy8gbG9jayBlYWNoIGNvbHVtbidzIHdpZHRoIG9wdGlvbiB0byBjdXJyZW50IHdpZHRoXG4gICAgICAgICAgICBjb2x1bW5FbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgIGNvbHVtbnNbaV0ucHJldmlvdXNXaWR0aCA9ICQoZSkub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JjZUZpdENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgc2hyaW5rTGVld2F5T25SaWdodCA9IDA7XG4gICAgICAgICAgICAgIHN0cmV0Y2hMZWV3YXlPblJpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgLy8gY29sdW1zIG9uIHJpZ2h0IGFmZmVjdCBtYXhQYWdlWC9taW5QYWdlWFxuICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGNvbHVtbkVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYyA9IGNvbHVtbnNbal07XG4gICAgICAgICAgICAgICAgaWYgKGMucmVzaXphYmxlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RyZXRjaExlZXdheU9uUmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdHJldGNoTGVld2F5T25SaWdodCArPSBjLm1heFdpZHRoIC0gYy5wcmV2aW91c1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHN0cmV0Y2hMZWV3YXlPblJpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2hyaW5rTGVld2F5T25SaWdodCArPSBjLnByZXZpb3VzV2lkdGggLSBNYXRoLm1heChjLm1pbldpZHRoIHx8IDAsIGFic29sdXRlQ29sdW1uTWluV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNocmlua0xlZXdheU9uTGVmdCA9IDAsIHN0cmV0Y2hMZWV3YXlPbkxlZnQgPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8PSBpOyBqKyspIHtcbiAgICAgICAgICAgICAgLy8gY29sdW1ucyBvbiBsZWZ0IG9ubHkgYWZmZWN0IG1pblBhZ2VYXG4gICAgICAgICAgICAgIGMgPSBjb2x1bW5zW2pdO1xuICAgICAgICAgICAgICBpZiAoYy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZXRjaExlZXdheU9uTGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZXRjaExlZXdheU9uTGVmdCArPSBjLm1heFdpZHRoIC0gYy5wcmV2aW91c1dpZHRoO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZXRjaExlZXdheU9uTGVmdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNocmlua0xlZXdheU9uTGVmdCArPSBjLnByZXZpb3VzV2lkdGggLSBNYXRoLm1heChjLm1pbldpZHRoIHx8IDAsIGFic29sdXRlQ29sdW1uTWluV2lkdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hyaW5rTGVld2F5T25SaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBzaHJpbmtMZWV3YXlPblJpZ2h0ID0gMTAwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNocmlua0xlZXdheU9uTGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBzaHJpbmtMZWV3YXlPbkxlZnQgPSAxMDAwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZXRjaExlZXdheU9uUmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3RyZXRjaExlZXdheU9uUmlnaHQgPSAxMDAwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZXRjaExlZXdheU9uTGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdHJldGNoTGVld2F5T25MZWZ0ID0gMTAwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4UGFnZVggPSBwYWdlWCArIE1hdGgubWluKHNocmlua0xlZXdheU9uUmlnaHQsIHN0cmV0Y2hMZWV3YXlPbkxlZnQpO1xuICAgICAgICAgICAgbWluUGFnZVggPSBwYWdlWCAtIE1hdGgubWluKHNocmlua0xlZXdheU9uTGVmdCwgc3RyZXRjaExlZXdheU9uUmlnaHQpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmJpbmQoXCJkcmFnXCIsIGZ1bmN0aW9uIChlLCBkZCkge1xuICAgICAgICAgICAgdmFyIGFjdHVhbE1pbldpZHRoLCBkID0gTWF0aC5taW4obWF4UGFnZVgsIE1hdGgubWF4KG1pblBhZ2VYLCBlLnBhZ2VYKSkgLSBwYWdlWCwgeDtcbiAgICAgICAgICAgIGlmIChkIDwgMCkgeyAvLyBzaHJpbmsgY29sdW1uXG4gICAgICAgICAgICAgIHggPSBkO1xuICAgICAgICAgICAgICBmb3IgKGogPSBpOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGMgPSBjb2x1bW5zW2pdO1xuICAgICAgICAgICAgICAgIGlmIChjLnJlc2l6YWJsZSkge1xuICAgICAgICAgICAgICAgICAgYWN0dWFsTWluV2lkdGggPSBNYXRoLm1heChjLm1pbldpZHRoIHx8IDAsIGFic29sdXRlQ29sdW1uTWluV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHggJiYgYy5wcmV2aW91c1dpZHRoICsgeCA8IGFjdHVhbE1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gYy5wcmV2aW91c1dpZHRoIC0gYWN0dWFsTWluV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBhY3R1YWxNaW5XaWR0aDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBjLnByZXZpb3VzV2lkdGggKyB4O1xuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JjZUZpdENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB4ID0gLWQ7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBjb2x1bW5FbGVtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgYyA9IGNvbHVtbnNbal07XG4gICAgICAgICAgICAgICAgICBpZiAoYy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggJiYgYy5tYXhXaWR0aCAmJiAoYy5tYXhXaWR0aCAtIGMucHJldmlvdXNXaWR0aCA8IHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgeCAtPSBjLm1heFdpZHRoIC0gYy5wcmV2aW91c1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBjLm1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBjLnByZXZpb3VzV2lkdGggKyB4O1xuICAgICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBzdHJldGNoIGNvbHVtblxuICAgICAgICAgICAgICB4ID0gZDtcbiAgICAgICAgICAgICAgZm9yIChqID0gaTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjID0gY29sdW1uc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoYy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh4ICYmIGMubWF4V2lkdGggJiYgKGMubWF4V2lkdGggLSBjLnByZXZpb3VzV2lkdGggPCB4KSkge1xuICAgICAgICAgICAgICAgICAgICB4IC09IGMubWF4V2lkdGggLSBjLnByZXZpb3VzV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBjLm1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYy53aWR0aCA9IGMucHJldmlvdXNXaWR0aCArIHg7XG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmZvcmNlRml0Q29sdW1ucykge1xuICAgICAgICAgICAgICAgIHggPSAtZDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGNvbHVtbkVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBjID0gY29sdW1uc1tqXTtcbiAgICAgICAgICAgICAgICAgIGlmIChjLnJlc2l6YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxNaW5XaWR0aCA9IE1hdGgubWF4KGMubWluV2lkdGggfHwgMCwgYWJzb2x1dGVDb2x1bW5NaW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICYmIGMucHJldmlvdXNXaWR0aCArIHggPCBhY3R1YWxNaW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIHggKz0gYy5wcmV2aW91c1dpZHRoIC0gYWN0dWFsTWluV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgYy53aWR0aCA9IGFjdHVhbE1pbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBjLnByZXZpb3VzV2lkdGggKyB4O1xuICAgICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcHBseUNvbHVtbkhlYWRlcldpZHRocygpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3luY0NvbHVtbkNlbGxSZXNpemUpIHtcbiAgICAgICAgICAgICAgYXBwbHlDb2x1bW5XaWR0aHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5iaW5kKFwiZHJhZ2VuZFwiLCBmdW5jdGlvbiAoZSwgZGQpIHtcbiAgICAgICAgICAgIHZhciBuZXdXaWR0aDtcbiAgICAgICAgICAgICQodGhpcykucGFyZW50KCkucmVtb3ZlQ2xhc3MoXCJiay1zbGljay1oZWFkZXItY29sdW1uLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5FbGVtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBjID0gY29sdW1uc1tqXTtcbiAgICAgICAgICAgICAgbmV3V2lkdGggPSAkKGNvbHVtbkVsZW1lbnRzW2pdKS5vdXRlcldpZHRoKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGMucHJldmlvdXNXaWR0aCAhPT0gbmV3V2lkdGggJiYgYy5yZXJlbmRlck9uUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZUFsbFJvd3MoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlQ2FudmFzV2lkdGgodHJ1ZSk7XG4gICAgICAgICAgICByZW5kZXIoKTtcbiAgICAgICAgICAgIHRyaWdnZXIoc2VsZi5vbkNvbHVtbnNSZXNpemVkLCB7fSk7XG4gICAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWQm94RGVsdGEoJGVsKSB7XG4gICAgdmFyIHAgPSBbXCJib3JkZXJUb3BXaWR0aFwiLCBcImJvcmRlckJvdHRvbVdpZHRoXCIsIFwicGFkZGluZ1RvcFwiLCBcInBhZGRpbmdCb3R0b21cIl07XG4gICAgdmFyIGRlbHRhID0gMDtcbiAgICAkLmVhY2gocCwgZnVuY3Rpb24gKG4sIHZhbCkge1xuICAgICAgZGVsdGEgKz0gcGFyc2VGbG9hdCgkZWwuY3NzKHZhbCkpIHx8IDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlbHRhO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVhc3VyZUNlbGxQYWRkaW5nQW5kQm9yZGVyKCkge1xuICAgIHZhciBlbDtcbiAgICB2YXIgaCA9IFtcImJvcmRlckxlZnRXaWR0aFwiLCBcImJvcmRlclJpZ2h0V2lkdGhcIiwgXCJwYWRkaW5nTGVmdFwiLCBcInBhZGRpbmdSaWdodFwiXTtcbiAgICB2YXIgdiA9IFtcImJvcmRlclRvcFdpZHRoXCIsIFwiYm9yZGVyQm90dG9tV2lkdGhcIiwgXCJwYWRkaW5nVG9wXCIsIFwicGFkZGluZ0JvdHRvbVwiXTtcblxuICAgIGVsID0gJChcIjxkaXYgY2xhc3M9J2JrLXVpLXN0YXRlLWRlZmF1bHQgYmstc2xpY2staGVhZGVyLWNvbHVtbicgc3R5bGU9J3Zpc2liaWxpdHk6aGlkZGVuJz4tPC9kaXY+XCIpLmFwcGVuZFRvKCRoZWFkZXJzKTtcbiAgICBoZWFkZXJDb2x1bW5XaWR0aERpZmYgPSBoZWFkZXJDb2x1bW5IZWlnaHREaWZmID0gMDtcbiAgICBpZiAoZWwuY3NzKFwiYm94LXNpemluZ1wiKSAhPSBcImJvcmRlci1ib3hcIiAmJiBlbC5jc3MoXCItbW96LWJveC1zaXppbmdcIikgIT0gXCJib3JkZXItYm94XCIgJiYgZWwuY3NzKFwiLXdlYmtpdC1ib3gtc2l6aW5nXCIpICE9IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgICAkLmVhY2goaCwgZnVuY3Rpb24gKG4sIHZhbCkge1xuICAgICAgICBoZWFkZXJDb2x1bW5XaWR0aERpZmYgKz0gcGFyc2VGbG9hdChlbC5jc3ModmFsKSkgfHwgMDtcbiAgICAgIH0pO1xuICAgICAgJC5lYWNoKHYsIGZ1bmN0aW9uIChuLCB2YWwpIHtcbiAgICAgICAgaGVhZGVyQ29sdW1uSGVpZ2h0RGlmZiArPSBwYXJzZUZsb2F0KGVsLmNzcyh2YWwpKSB8fCAwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsLnJlbW92ZSgpO1xuXG4gICAgdmFyIHIgPSAkKFwiPGRpdiBjbGFzcz0nYmstc2xpY2stcm93JyAvPlwiKS5hcHBlbmRUbygkY2FudmFzKTtcbiAgICBlbCA9ICQoXCI8ZGl2IGNsYXNzPSdiay1zbGljay1jZWxsJyBpZD0nJyBzdHlsZT0ndmlzaWJpbGl0eTpoaWRkZW4nPi08L2Rpdj5cIikuYXBwZW5kVG8ocik7XG4gICAgY2VsbFdpZHRoRGlmZiA9IGNlbGxIZWlnaHREaWZmID0gMDtcbiAgICBpZiAoZWwuY3NzKFwiYm94LXNpemluZ1wiKSAhPSBcImJvcmRlci1ib3hcIiAmJiBlbC5jc3MoXCItbW96LWJveC1zaXppbmdcIikgIT0gXCJib3JkZXItYm94XCIgJiYgZWwuY3NzKFwiLXdlYmtpdC1ib3gtc2l6aW5nXCIpICE9IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgICAkLmVhY2goaCwgZnVuY3Rpb24gKG4sIHZhbCkge1xuICAgICAgICBjZWxsV2lkdGhEaWZmICs9IHBhcnNlRmxvYXQoZWwuY3NzKHZhbCkpIHx8IDA7XG4gICAgICB9KTtcbiAgICAgICQuZWFjaCh2LCBmdW5jdGlvbiAobiwgdmFsKSB7XG4gICAgICAgIGNlbGxIZWlnaHREaWZmICs9IHBhcnNlRmxvYXQoZWwuY3NzKHZhbCkpIHx8IDA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgci5yZW1vdmUoKTtcblxuICAgIGFic29sdXRlQ29sdW1uTWluV2lkdGggPSBNYXRoLm1heChoZWFkZXJDb2x1bW5XaWR0aERpZmYsIGNlbGxXaWR0aERpZmYpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ3NzUnVsZXMoKSB7XG4gICAgJHN0eWxlID0gJChcIjxzdHlsZSB0eXBlPSd0ZXh0L2NzcycgcmVsPSdzdHlsZXNoZWV0JyAvPlwiKS5hcHBlbmRUbygkKFwiaGVhZFwiKSk7XG4gICAgdmFyIHJvd0hlaWdodCA9IChvcHRpb25zLnJvd0hlaWdodCAtIGNlbGxIZWlnaHREaWZmKTtcbiAgICB2YXIgcnVsZXMgPSBbXG4gICAgICBcIi5cIiArIHVpZCArIFwiIC5iay1zbGljay1oZWFkZXItY29sdW1uIHsgbGVmdDogMTAwMHB4OyB9XCIsXG4gICAgICBcIi5cIiArIHVpZCArIFwiIC5iay1zbGljay10b3AtcGFuZWwgeyBoZWlnaHQ6XCIgKyBvcHRpb25zLnRvcFBhbmVsSGVpZ2h0ICsgXCJweDsgfVwiLFxuICAgICAgXCIuXCIgKyB1aWQgKyBcIiAuYmstc2xpY2staGVhZGVycm93LWNvbHVtbnMgeyBoZWlnaHQ6XCIgKyBvcHRpb25zLmhlYWRlclJvd0hlaWdodCArIFwicHg7IH1cIixcbiAgICAgIFwiLlwiICsgdWlkICsgXCIgLmJrLXNsaWNrLWNlbGwgeyBoZWlnaHQ6XCIgKyByb3dIZWlnaHQgKyBcInB4OyB9XCIsXG4gICAgICBcIi5cIiArIHVpZCArIFwiIC5iay1zbGljay1yb3cgeyBoZWlnaHQ6XCIgKyBvcHRpb25zLnJvd0hlaWdodCArIFwicHg7IH1cIlxuICAgIF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJ1bGVzLnB1c2goXCIuXCIgKyB1aWQgKyBcIiAubFwiICsgaSArIFwiIHsgfVwiKTtcbiAgICAgIHJ1bGVzLnB1c2goXCIuXCIgKyB1aWQgKyBcIiAuclwiICsgaSArIFwiIHsgfVwiKTtcbiAgICB9XG5cbiAgICBpZiAoJHN0eWxlWzBdLnN0eWxlU2hlZXQpIHsgLy8gSUVcbiAgICAgICRzdHlsZVswXS5zdHlsZVNoZWV0LmNzc1RleHQgPSBydWxlcy5qb2luKFwiIFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHN0eWxlWzBdLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJ1bGVzLmpvaW4oXCIgXCIpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29sdW1uQ3NzUnVsZXMoaWR4KSB7XG4gICAgaWYgKCFzdHlsZXNoZWV0KSB7XG4gICAgICB2YXIgc2hlZXRzID0gZG9jdW1lbnQuc3R5bGVTaGVldHM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoZWV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKHNoZWV0c1tpXS5vd25lck5vZGUgfHwgc2hlZXRzW2ldLm93bmluZ0VsZW1lbnQpID09ICRzdHlsZVswXSkge1xuICAgICAgICAgIHN0eWxlc2hlZXQgPSBzaGVldHNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFzdHlsZXNoZWV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHN0eWxlc2hlZXQuXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBmaW5kIGFuZCBjYWNoZSBjb2x1bW4gQ1NTIHJ1bGVzXG4gICAgICBjb2x1bW5Dc3NSdWxlc0wgPSBbXTtcbiAgICAgIGNvbHVtbkNzc1J1bGVzUiA9IFtdO1xuICAgICAgdmFyIGNzc1J1bGVzID0gKHN0eWxlc2hlZXQuY3NzUnVsZXMgfHwgc3R5bGVzaGVldC5ydWxlcyk7XG4gICAgICB2YXIgbWF0Y2hlcywgY29sdW1uSWR4O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjc3NSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBjc3NSdWxlc1tpXS5zZWxlY3RvclRleHQ7XG4gICAgICAgIGlmIChtYXRjaGVzID0gL1xcLmxcXGQrLy5leGVjKHNlbGVjdG9yKSkge1xuICAgICAgICAgIGNvbHVtbklkeCA9IHBhcnNlSW50KG1hdGNoZXNbMF0uc3Vic3RyKDIsIG1hdGNoZXNbMF0ubGVuZ3RoIC0gMiksIDEwKTtcbiAgICAgICAgICBjb2x1bW5Dc3NSdWxlc0xbY29sdW1uSWR4XSA9IGNzc1J1bGVzW2ldO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMgPSAvXFwuclxcZCsvLmV4ZWMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgY29sdW1uSWR4ID0gcGFyc2VJbnQobWF0Y2hlc1swXS5zdWJzdHIoMiwgbWF0Y2hlc1swXS5sZW5ndGggLSAyKSwgMTApO1xuICAgICAgICAgIGNvbHVtbkNzc1J1bGVzUltjb2x1bW5JZHhdID0gY3NzUnVsZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgXCJsZWZ0XCI6IGNvbHVtbkNzc1J1bGVzTFtpZHhdLFxuICAgICAgXCJyaWdodFwiOiBjb2x1bW5Dc3NSdWxlc1JbaWR4XVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDc3NSdWxlcygpIHtcbiAgICAkc3R5bGUucmVtb3ZlKCk7XG4gICAgc3R5bGVzaGVldCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGdldEVkaXRvckxvY2soKS5jYW5jZWxDdXJyZW50RWRpdCgpO1xuXG4gICAgdHJpZ2dlcihzZWxmLm9uQmVmb3JlRGVzdHJveSwge30pO1xuXG4gICAgdmFyIGkgPSBwbHVnaW5zLmxlbmd0aDtcbiAgICB3aGlsZShpLS0pIHtcbiAgICAgIHVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlQ29sdW1uUmVvcmRlcikge1xuICAgICAgICAkaGVhZGVycy5maWx0ZXIoXCI6dWktc29ydGFibGVcIikuc29ydGFibGUoXCJkZXN0cm95XCIpO1xuICAgIH1cblxuICAgIHVuYmluZEFuY2VzdG9yU2Nyb2xsRXZlbnRzKCk7XG4gICAgJGNvbnRhaW5lci51bmJpbmQoXCIuYmstc2xpY2tncmlkXCIpO1xuICAgIHJlbW92ZUNzc1J1bGVzKCk7XG5cbiAgICAkY2FudmFzLnVuYmluZChcImRyYWdpbml0IGRyYWdzdGFydCBkcmFnZW5kIGRyYWdcIik7XG4gICAgJGNvbnRhaW5lci5lbXB0eSgpLnJlbW92ZUNsYXNzKHVpZCk7XG4gIH1cblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gR2VuZXJhbFxuXG4gIGZ1bmN0aW9uIHRyaWdnZXIoZXZ0LCBhcmdzLCBlKSB7XG4gICAgZSA9IGUgfHwgbmV3IFNsaWNrLkV2ZW50RGF0YSgpO1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGFyZ3MuZ3JpZCA9IHNlbGY7XG4gICAgcmV0dXJuIGV2dC5ub3RpZnkoYXJncywgZSwgc2VsZik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFZGl0b3JMb2NrKCkge1xuICAgIHJldHVybiBvcHRpb25zLmVkaXRvckxvY2s7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFZGl0Q29udHJvbGxlcigpIHtcbiAgICByZXR1cm4gZWRpdENvbnRyb2xsZXI7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb2x1bW5JbmRleChpZCkge1xuICAgIHJldHVybiBjb2x1bW5zQnlJZFtpZF07XG4gIH1cblxuICBmdW5jdGlvbiBhdXRvc2l6ZUNvbHVtbnMoKSB7XG4gICAgdmFyIGksIGMsXG4gICAgICAgIHdpZHRocyA9IFtdLFxuICAgICAgICBzaHJpbmtMZWV3YXkgPSAwLFxuICAgICAgICB0b3RhbCA9IDAsXG4gICAgICAgIHByZXZUb3RhbCxcbiAgICAgICAgYXZhaWxXaWR0aCA9IHZpZXdwb3J0SGFzVlNjcm9sbCA/IHZpZXdwb3J0VyAtIHNjcm9sbGJhckRpbWVuc2lvbnMud2lkdGggOiB2aWV3cG9ydFc7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IGNvbHVtbnNbaV07XG4gICAgICB3aWR0aHMucHVzaChjLndpZHRoKTtcbiAgICAgIHRvdGFsICs9IGMud2lkdGg7XG4gICAgICBpZiAoYy5yZXNpemFibGUpIHtcbiAgICAgICAgc2hyaW5rTGVld2F5ICs9IGMud2lkdGggLSBNYXRoLm1heChjLm1pbldpZHRoLCBhYnNvbHV0ZUNvbHVtbk1pbldpZHRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzaHJpbmtcbiAgICBwcmV2VG90YWwgPSB0b3RhbDtcbiAgICB3aGlsZSAodG90YWwgPiBhdmFpbFdpZHRoICYmIHNocmlua0xlZXdheSkge1xuICAgICAgdmFyIHNocmlua1Byb3BvcnRpb24gPSAodG90YWwgLSBhdmFpbFdpZHRoKSAvIHNocmlua0xlZXdheTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aCAmJiB0b3RhbCA+IGF2YWlsV2lkdGg7IGkrKykge1xuICAgICAgICBjID0gY29sdW1uc1tpXTtcbiAgICAgICAgdmFyIHdpZHRoID0gd2lkdGhzW2ldO1xuICAgICAgICBpZiAoIWMucmVzaXphYmxlIHx8IHdpZHRoIDw9IGMubWluV2lkdGggfHwgd2lkdGggPD0gYWJzb2x1dGVDb2x1bW5NaW5XaWR0aCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhYnNNaW5XaWR0aCA9IE1hdGgubWF4KGMubWluV2lkdGgsIGFic29sdXRlQ29sdW1uTWluV2lkdGgpO1xuICAgICAgICB2YXIgc2hyaW5rU2l6ZSA9IE1hdGguZmxvb3Ioc2hyaW5rUHJvcG9ydGlvbiAqICh3aWR0aCAtIGFic01pbldpZHRoKSkgfHwgMTtcbiAgICAgICAgc2hyaW5rU2l6ZSA9IE1hdGgubWluKHNocmlua1NpemUsIHdpZHRoIC0gYWJzTWluV2lkdGgpO1xuICAgICAgICB0b3RhbCAtPSBzaHJpbmtTaXplO1xuICAgICAgICBzaHJpbmtMZWV3YXkgLT0gc2hyaW5rU2l6ZTtcbiAgICAgICAgd2lkdGhzW2ldIC09IHNocmlua1NpemU7XG4gICAgICB9XG4gICAgICBpZiAocHJldlRvdGFsIDw9IHRvdGFsKSB7ICAvLyBhdm9pZCBpbmZpbml0ZSBsb29wXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcHJldlRvdGFsID0gdG90YWw7XG4gICAgfVxuXG4gICAgLy8gZ3Jvd1xuICAgIHByZXZUb3RhbCA9IHRvdGFsO1xuICAgIHdoaWxlICh0b3RhbCA8IGF2YWlsV2lkdGgpIHtcbiAgICAgIHZhciBncm93UHJvcG9ydGlvbiA9IGF2YWlsV2lkdGggLyB0b3RhbDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aCAmJiB0b3RhbCA8IGF2YWlsV2lkdGg7IGkrKykge1xuICAgICAgICBjID0gY29sdW1uc1tpXTtcbiAgICAgICAgdmFyIGN1cnJlbnRXaWR0aCA9IHdpZHRoc1tpXTtcbiAgICAgICAgdmFyIGdyb3dTaXplO1xuXG4gICAgICAgIGlmICghYy5yZXNpemFibGUgfHwgYy5tYXhXaWR0aCA8PSBjdXJyZW50V2lkdGgpIHtcbiAgICAgICAgICBncm93U2l6ZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3Jvd1NpemUgPSBNYXRoLm1pbihNYXRoLmZsb29yKGdyb3dQcm9wb3J0aW9uICogY3VycmVudFdpZHRoKSAtIGN1cnJlbnRXaWR0aCwgKGMubWF4V2lkdGggLSBjdXJyZW50V2lkdGgpIHx8IDEwMDAwMDApIHx8IDE7XG4gICAgICAgIH1cbiAgICAgICAgdG90YWwgKz0gZ3Jvd1NpemU7XG4gICAgICAgIHdpZHRoc1tpXSArPSBncm93U2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2VG90YWwgPj0gdG90YWwpIHsgIC8vIGF2b2lkIGluZmluaXRlIGxvb3BcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwcmV2VG90YWwgPSB0b3RhbDtcbiAgICB9XG5cbiAgICB2YXIgcmVSZW5kZXIgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNvbHVtbnNbaV0ucmVyZW5kZXJPblJlc2l6ZSAmJiBjb2x1bW5zW2ldLndpZHRoICE9IHdpZHRoc1tpXSkge1xuICAgICAgICByZVJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb2x1bW5zW2ldLndpZHRoID0gd2lkdGhzW2ldO1xuICAgIH1cblxuICAgIGFwcGx5Q29sdW1uSGVhZGVyV2lkdGhzKCk7XG4gICAgdXBkYXRlQ2FudmFzV2lkdGgodHJ1ZSk7XG4gICAgaWYgKHJlUmVuZGVyKSB7XG4gICAgICBpbnZhbGlkYXRlQWxsUm93cygpO1xuICAgICAgcmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlDb2x1bW5IZWFkZXJXaWR0aHMoKSB7XG4gICAgaWYgKCFpbml0aWFsaXplZCkgeyByZXR1cm47IH1cbiAgICB2YXIgaDtcbiAgICBmb3IgKHZhciBpID0gMCwgaGVhZGVycyA9ICRoZWFkZXJzLmNoaWxkcmVuKCksIGlpID0gaGVhZGVycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBoID0gJChoZWFkZXJzW2ldKTtcbiAgICAgIGlmIChoLndpZHRoKCkgIT09IGNvbHVtbnNbaV0ud2lkdGggLSBoZWFkZXJDb2x1bW5XaWR0aERpZmYpIHtcbiAgICAgICAgaC53aWR0aChjb2x1bW5zW2ldLndpZHRoIC0gaGVhZGVyQ29sdW1uV2lkdGhEaWZmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDb2x1bW5DYWNoZXMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5Q29sdW1uV2lkdGhzKCkge1xuICAgIHZhciB4ID0gMCwgdywgcnVsZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSBjb2x1bW5zW2ldLndpZHRoO1xuXG4gICAgICBydWxlID0gZ2V0Q29sdW1uQ3NzUnVsZXMoaSk7XG4gICAgICBydWxlLmxlZnQuc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XG4gICAgICBydWxlLnJpZ2h0LnN0eWxlLnJpZ2h0ID0gKGNhbnZhc1dpZHRoIC0geCAtIHcpICsgXCJweFwiO1xuXG4gICAgICB4ICs9IGNvbHVtbnNbaV0ud2lkdGg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U29ydENvbHVtbihjb2x1bW5JZCwgYXNjZW5kaW5nKSB7XG4gICAgc2V0U29ydENvbHVtbnMoW3sgY29sdW1uSWQ6IGNvbHVtbklkLCBzb3J0QXNjOiBhc2NlbmRpbmd9XSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTb3J0Q29sdW1ucyhjb2xzKSB7XG4gICAgc29ydENvbHVtbnMgPSBjb2xzO1xuXG4gICAgdmFyIGhlYWRlckNvbHVtbkVscyA9ICRoZWFkZXJzLmNoaWxkcmVuKCk7XG4gICAgaGVhZGVyQ29sdW1uRWxzXG4gICAgICAgIC5yZW1vdmVDbGFzcyhcImJrLXNsaWNrLWhlYWRlci1jb2x1bW4tc29ydGVkXCIpXG4gICAgICAgIC5maW5kKFwiLmJrLXNsaWNrLXNvcnQtaW5kaWNhdG9yXCIpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJiay1zbGljay1zb3J0LWluZGljYXRvci1hc2MgYmstc2xpY2stc29ydC1pbmRpY2F0b3ItZGVzY1wiKTtcblxuICAgICQuZWFjaChzb3J0Q29sdW1ucywgZnVuY3Rpb24oaSwgY29sKSB7XG4gICAgICBpZiAoY29sLnNvcnRBc2MgPT0gbnVsbCkge1xuICAgICAgICBjb2wuc29ydEFzYyA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgY29sdW1uSW5kZXggPSBnZXRDb2x1bW5JbmRleChjb2wuY29sdW1uSWQpO1xuICAgICAgaWYgKGNvbHVtbkluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgaGVhZGVyQ29sdW1uRWxzLmVxKGNvbHVtbkluZGV4KVxuICAgICAgICAgICAgLmFkZENsYXNzKFwiYmstc2xpY2staGVhZGVyLWNvbHVtbi1zb3J0ZWRcIilcbiAgICAgICAgICAgIC5maW5kKFwiLmJrLXNsaWNrLXNvcnQtaW5kaWNhdG9yXCIpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKGNvbC5zb3J0QXNjID8gXCJiay1zbGljay1zb3J0LWluZGljYXRvci1hc2NcIiA6IFwiYmstc2xpY2stc29ydC1pbmRpY2F0b3ItZGVzY1wiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNvcnRDb2x1bW5zKCkge1xuICAgIHJldHVybiBzb3J0Q29sdW1ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVNlbGVjdGVkUmFuZ2VzQ2hhbmdlZChlLCByYW5nZXMpIHtcbiAgICBzZWxlY3RlZFJvd3MgPSBbXTtcbiAgICB2YXIgaGFzaCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gcmFuZ2VzW2ldLmZyb21Sb3c7IGogPD0gcmFuZ2VzW2ldLnRvUm93OyBqKyspIHtcbiAgICAgICAgaWYgKCFoYXNoW2pdKSB7ICAvLyBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgICBzZWxlY3RlZFJvd3MucHVzaChqKTtcbiAgICAgICAgICBoYXNoW2pdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgayA9IHJhbmdlc1tpXS5mcm9tQ2VsbDsgayA8PSByYW5nZXNbaV0udG9DZWxsOyBrKyspIHtcbiAgICAgICAgICBpZiAoY2FuQ2VsbEJlU2VsZWN0ZWQoaiwgaykpIHtcbiAgICAgICAgICAgIGhhc2hbal1bY29sdW1uc1trXS5pZF0gPSBvcHRpb25zLnNlbGVjdGVkQ2VsbENzc0NsYXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNldENlbGxDc3NTdHlsZXMob3B0aW9ucy5zZWxlY3RlZENlbGxDc3NDbGFzcywgaGFzaCk7XG5cbiAgICB0cmlnZ2VyKHNlbGYub25TZWxlY3RlZFJvd3NDaGFuZ2VkLCB7cm93czogZ2V0U2VsZWN0ZWRSb3dzKCl9LCBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbHVtbnMoKSB7XG4gICAgcmV0dXJuIGNvbHVtbnM7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb2x1bW5DYWNoZXMoKSB7XG4gICAgLy8gUHJlLWNhbGN1bGF0ZSBjZWxsIGJvdW5kYXJpZXMuXG4gICAgY29sdW1uUG9zTGVmdCA9IFtdO1xuICAgIGNvbHVtblBvc1JpZ2h0ID0gW107XG4gICAgdmFyIHggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29sdW1uUG9zTGVmdFtpXSA9IHg7XG4gICAgICBjb2x1bW5Qb3NSaWdodFtpXSA9IHggKyBjb2x1bW5zW2ldLndpZHRoO1xuICAgICAgeCArPSBjb2x1bW5zW2ldLndpZHRoO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbHVtbnMoY29sdW1uRGVmaW5pdGlvbnMpIHtcbiAgICBjb2x1bW5zID0gY29sdW1uRGVmaW5pdGlvbnM7XG5cbiAgICBjb2x1bW5zQnlJZCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG0gPSBjb2x1bW5zW2ldID0gJC5leHRlbmQoe30sIGNvbHVtbkRlZmF1bHRzLCBjb2x1bW5zW2ldKTtcbiAgICAgIGNvbHVtbnNCeUlkW20uaWRdID0gaTtcbiAgICAgIGlmIChtLm1pbldpZHRoICYmIG0ud2lkdGggPCBtLm1pbldpZHRoKSB7XG4gICAgICAgIG0ud2lkdGggPSBtLm1pbldpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKG0ubWF4V2lkdGggJiYgbS53aWR0aCA+IG0ubWF4V2lkdGgpIHtcbiAgICAgICAgbS53aWR0aCA9IG0ubWF4V2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlQ29sdW1uQ2FjaGVzKCk7XG5cbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGludmFsaWRhdGVBbGxSb3dzKCk7XG4gICAgICBjcmVhdGVDb2x1bW5IZWFkZXJzKCk7XG4gICAgICByZW1vdmVDc3NSdWxlcygpO1xuICAgICAgY3JlYXRlQ3NzUnVsZXMoKTtcbiAgICAgIHJlc2l6ZUNhbnZhcygpO1xuICAgICAgYXBwbHlDb2x1bW5XaWR0aHMoKTtcbiAgICAgIGhhbmRsZVNjcm9sbCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRPcHRpb25zKGFyZ3MpIHtcbiAgICBpZiAoIWdldEVkaXRvckxvY2soKS5jb21taXRDdXJyZW50RWRpdCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWFrZUFjdGl2ZUNlbGxOb3JtYWwoKTtcblxuICAgIGlmIChvcHRpb25zLmVuYWJsZUFkZFJvdyAhPT0gYXJncy5lbmFibGVBZGRSb3cpIHtcbiAgICAgIGludmFsaWRhdGVSb3coZ2V0RGF0YUxlbmd0aCgpKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gJC5leHRlbmQob3B0aW9ucywgYXJncyk7XG4gICAgdmFsaWRhdGVBbmRFbmZvcmNlT3B0aW9ucygpO1xuXG4gICAgJHZpZXdwb3J0LmNzcyhcIm92ZXJmbG93LXlcIiwgb3B0aW9ucy5hdXRvSGVpZ2h0ID8gXCJoaWRkZW5cIiA6IFwiYXV0b1wiKTtcbiAgICByZW5kZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQW5kRW5mb3JjZU9wdGlvbnMoKSB7XG4gICAgaWYgKG9wdGlvbnMuYXV0b0hlaWdodCkge1xuICAgICAgb3B0aW9ucy5sZWF2ZVNwYWNlRm9yTmV3Um93cyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERhdGEobmV3RGF0YSwgc2Nyb2xsVG9Ub3ApIHtcbiAgICBkYXRhID0gbmV3RGF0YTtcbiAgICBpbnZhbGlkYXRlQWxsUm93cygpO1xuICAgIHVwZGF0ZVJvd0NvdW50KCk7XG4gICAgaWYgKHNjcm9sbFRvVG9wKSB7XG4gICAgICBzY3JvbGxUbygwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREYXRhKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGF0YUxlbmd0aCgpIHtcbiAgICBpZiAoZGF0YS5nZXRMZW5ndGgpIHtcbiAgICAgIHJldHVybiBkYXRhLmdldExlbmd0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldygpIHtcbiAgICByZXR1cm4gZ2V0RGF0YUxlbmd0aCgpICsgKG9wdGlvbnMuZW5hYmxlQWRkUm93ID8gMSA6IDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGF0YUl0ZW0oaSkge1xuICAgIGlmIChkYXRhLmdldEl0ZW0pIHtcbiAgICAgIHJldHVybiBkYXRhLmdldEl0ZW0oaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXRhW2ldO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRvcFBhbmVsKCkge1xuICAgIHJldHVybiAkdG9wUGFuZWxbMF07XG4gIH1cblxuICBmdW5jdGlvbiBzZXRUb3BQYW5lbFZpc2liaWxpdHkodmlzaWJsZSkge1xuICAgIGlmIChvcHRpb25zLnNob3dUb3BQYW5lbCAhPSB2aXNpYmxlKSB7XG4gICAgICBvcHRpb25zLnNob3dUb3BQYW5lbCA9IHZpc2libGU7XG4gICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAkdG9wUGFuZWxTY3JvbGxlci5zbGlkZURvd24oXCJmYXN0XCIsIHJlc2l6ZUNhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkdG9wUGFuZWxTY3JvbGxlci5zbGlkZVVwKFwiZmFzdFwiLCByZXNpemVDYW52YXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEhlYWRlclJvd1Zpc2liaWxpdHkodmlzaWJsZSkge1xuICAgIGlmIChvcHRpb25zLnNob3dIZWFkZXJSb3cgIT0gdmlzaWJsZSkge1xuICAgICAgb3B0aW9ucy5zaG93SGVhZGVyUm93ID0gdmlzaWJsZTtcbiAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICRoZWFkZXJSb3dTY3JvbGxlci5zbGlkZURvd24oXCJmYXN0XCIsIHJlc2l6ZUNhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkaGVhZGVyUm93U2Nyb2xsZXIuc2xpZGVVcChcImZhc3RcIiwgcmVzaXplQ2FudmFzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb250YWluZXJOb2RlKCkge1xuICAgIHJldHVybiAkY29udGFpbmVyLmdldCgwKTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gUmVuZGVyaW5nIC8gU2Nyb2xsaW5nXG5cbiAgZnVuY3Rpb24gZ2V0Um93VG9wKHJvdykge1xuICAgIHJldHVybiBvcHRpb25zLnJvd0hlaWdodCAqIHJvdyAtIG9mZnNldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJvd0Zyb21Qb3NpdGlvbih5KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKHkgKyBvZmZzZXQpIC8gb3B0aW9ucy5yb3dIZWlnaHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsVG8oeSkge1xuICAgIHkgPSBNYXRoLm1heCh5LCAwKTtcbiAgICB5ID0gTWF0aC5taW4oeSwgdGggLSB2aWV3cG9ydEggKyAodmlld3BvcnRIYXNIU2Nyb2xsID8gc2Nyb2xsYmFyRGltZW5zaW9ucy5oZWlnaHQgOiAwKSk7XG5cbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcGFnZSA9IE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHkgLyBwaCkpO1xuICAgIG9mZnNldCA9IE1hdGgucm91bmQocGFnZSAqIGNqKTtcbiAgICB2YXIgbmV3U2Nyb2xsVG9wID0geSAtIG9mZnNldDtcblxuICAgIGlmIChvZmZzZXQgIT0gb2xkT2Zmc2V0KSB7XG4gICAgICB2YXIgcmFuZ2UgPSBnZXRWaXNpYmxlUmFuZ2UobmV3U2Nyb2xsVG9wKTtcbiAgICAgIGNsZWFudXBSb3dzKHJhbmdlKTtcbiAgICAgIHVwZGF0ZVJvd1Bvc2l0aW9ucygpO1xuICAgIH1cblxuICAgIGlmIChwcmV2U2Nyb2xsVG9wICE9IG5ld1Njcm9sbFRvcCkge1xuICAgICAgdlNjcm9sbERpciA9IChwcmV2U2Nyb2xsVG9wICsgb2xkT2Zmc2V0IDwgbmV3U2Nyb2xsVG9wICsgb2Zmc2V0KSA/IDEgOiAtMTtcbiAgICAgICR2aWV3cG9ydFswXS5zY3JvbGxUb3AgPSAobGFzdFJlbmRlcmVkU2Nyb2xsVG9wID0gc2Nyb2xsVG9wID0gcHJldlNjcm9sbFRvcCA9IG5ld1Njcm9sbFRvcCk7XG5cbiAgICAgIHRyaWdnZXIoc2VsZi5vblZpZXdwb3J0Q2hhbmdlZCwge30pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRGb3JtYXR0ZXIocm93LCBjZWxsLCB2YWx1ZSwgY29sdW1uRGVmLCBkYXRhQ29udGV4dCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICh2YWx1ZSArIFwiXCIpLnJlcGxhY2UoLyYvZyxcIiZhbXA7XCIpLnJlcGxhY2UoLzwvZyxcIiZsdDtcIikucmVwbGFjZSgvPi9nLFwiJmd0O1wiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGb3JtYXR0ZXIocm93LCBjb2x1bW4pIHtcbiAgICB2YXIgcm93TWV0YWRhdGEgPSBkYXRhLmdldEl0ZW1NZXRhZGF0YSAmJiBkYXRhLmdldEl0ZW1NZXRhZGF0YShyb3cpO1xuXG4gICAgLy8gbG9vayB1cCBieSBpZCwgdGhlbiBpbmRleFxuICAgIHZhciBjb2x1bW5PdmVycmlkZXMgPSByb3dNZXRhZGF0YSAmJlxuICAgICAgICByb3dNZXRhZGF0YS5jb2x1bW5zICYmXG4gICAgICAgIChyb3dNZXRhZGF0YS5jb2x1bW5zW2NvbHVtbi5pZF0gfHwgcm93TWV0YWRhdGEuY29sdW1uc1tnZXRDb2x1bW5JbmRleChjb2x1bW4uaWQpXSk7XG5cbiAgICB2YXIgZm9ybWF0dGVyID1cbiAgICAgICAgKGNvbHVtbk92ZXJyaWRlcyAmJiBjb2x1bW5PdmVycmlkZXMuZm9ybWF0dGVyKSB8fFxuICAgICAgICAocm93TWV0YWRhdGEgJiYgcm93TWV0YWRhdGEuZm9ybWF0dGVyKSB8fFxuICAgICAgICBjb2x1bW4uZm9ybWF0dGVyIHx8XG4gICAgICAgIChvcHRpb25zLmZvcm1hdHRlckZhY3RvcnkgJiYgb3B0aW9ucy5mb3JtYXR0ZXJGYWN0b3J5LmdldEZvcm1hdHRlcihjb2x1bW4pKSB8fFxuICAgICAgICBvcHRpb25zLmRlZmF1bHRGb3JtYXR0ZXI7XG5cbiAgICBpZiAoZm9ybWF0dGVyLmZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgbW9kZWwgPSBmb3JtYXR0ZXI7XG4gICAgICB2YXIgZm9ybWF0ID0gZnVuY3Rpb24gZm9vKHJvdywgY2VsbCwgdmFsdWUsIGNvbHVtbkRlZiwgZGF0YUNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmZvcm1hdChyb3csIGNlbGwsIHZhbHVlLCBjb2x1bW5EZWYsIGRhdGFDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdFxuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZXI7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFZGl0b3Iocm93LCBjZWxsKSB7XG4gICAgdmFyIGVkaXRvcjtcbiAgICB2YXIgY29sdW1uID0gY29sdW1uc1tjZWxsXTtcbiAgICB2YXIgcm93TWV0YWRhdGEgPSBkYXRhLmdldEl0ZW1NZXRhZGF0YSAmJiBkYXRhLmdldEl0ZW1NZXRhZGF0YShyb3cpO1xuICAgIHZhciBjb2x1bW5NZXRhZGF0YSA9IHJvd01ldGFkYXRhICYmIHJvd01ldGFkYXRhLmNvbHVtbnM7XG5cbiAgICBpZiAoY29sdW1uTWV0YWRhdGEgJiYgY29sdW1uTWV0YWRhdGFbY29sdW1uLmlkXSAmJiBjb2x1bW5NZXRhZGF0YVtjb2x1bW4uaWRdLmVkaXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlZGl0b3IgPSBjb2x1bW5NZXRhZGF0YVtjb2x1bW4uaWRdLmVkaXRvcjtcbiAgICB9IGVsc2UgaWYgKGNvbHVtbk1ldGFkYXRhICYmIGNvbHVtbk1ldGFkYXRhW2NlbGxdICYmIGNvbHVtbk1ldGFkYXRhW2NlbGxdLmVkaXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlZGl0b3IgPSBjb2x1bW5NZXRhZGF0YVtjZWxsXS5lZGl0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvciA9IGNvbHVtbi5lZGl0b3IgfHwgKG9wdGlvbnMuZWRpdG9yRmFjdG9yeSAmJiBvcHRpb25zLmVkaXRvckZhY3RvcnkuZ2V0RWRpdG9yKGNvbHVtbikpO1xuICAgIH1cblxuICAgIGlmIChlZGl0b3IuZGVmYXVsdF92aWV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVkaXRvciA9IGVkaXRvci5kZWZhdWx0X3ZpZXc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERhdGFJdGVtVmFsdWVGb3JDb2x1bW4oaXRlbSwgY29sdW1uRGVmKSB7XG4gICAgaWYgKG9wdGlvbnMuZGF0YUl0ZW1Db2x1bW5WYWx1ZUV4dHJhY3Rvcikge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZGF0YUl0ZW1Db2x1bW5WYWx1ZUV4dHJhY3RvcihpdGVtLCBjb2x1bW5EZWYpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbVtjb2x1bW5EZWYuZmllbGRdO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kUm93SHRtbChzdHJpbmdBcnJheSwgcm93LCByYW5nZSwgZGF0YUxlbmd0aCkge1xuICAgIHZhciBkID0gZ2V0RGF0YUl0ZW0ocm93KTtcbiAgICB2YXIgZGF0YUxvYWRpbmcgPSByb3cgPCBkYXRhTGVuZ3RoICYmICFkO1xuICAgIHZhciByb3dDc3MgPSBcImJrLXNsaWNrLXJvd1wiICtcbiAgICAgICAgKGRhdGFMb2FkaW5nID8gXCIgbG9hZGluZ1wiIDogXCJcIikgK1xuICAgICAgICAocm93ID09PSBhY3RpdmVSb3cgPyBcIiBhY3RpdmVcIiA6IFwiXCIpICtcbiAgICAgICAgKHJvdyAlIDIgPT0gMSA/IFwiIG9kZFwiIDogXCIgZXZlblwiKTtcblxuICAgIGlmICghZCkge1xuICAgICAgcm93Q3NzICs9IFwiIFwiICsgb3B0aW9ucy5hZGROZXdSb3dDc3NDbGFzcztcbiAgICB9XG5cbiAgICB2YXIgbWV0YWRhdGEgPSBkYXRhLmdldEl0ZW1NZXRhZGF0YSAmJiBkYXRhLmdldEl0ZW1NZXRhZGF0YShyb3cpO1xuXG4gICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmNzc0NsYXNzZXMpIHtcbiAgICAgIHJvd0NzcyArPSBcIiBcIiArIG1ldGFkYXRhLmNzc0NsYXNzZXM7XG4gICAgfVxuXG4gICAgc3RyaW5nQXJyYXkucHVzaChcIjxkaXYgY2xhc3M9J2JrLXVpLXdpZGdldC1jb250ZW50IFwiICsgcm93Q3NzICsgXCInIHN0eWxlPSd0b3A6XCIgKyBnZXRSb3dUb3Aocm93KSArIFwicHgnPlwiKTtcblxuICAgIHZhciBjb2xzcGFuLCBtO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgbSA9IGNvbHVtbnNbaV07XG4gICAgICBjb2xzcGFuID0gMTtcbiAgICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5jb2x1bW5zKSB7XG4gICAgICAgIHZhciBjb2x1bW5EYXRhID0gbWV0YWRhdGEuY29sdW1uc1ttLmlkXSB8fCBtZXRhZGF0YS5jb2x1bW5zW2ldO1xuICAgICAgICBjb2xzcGFuID0gKGNvbHVtbkRhdGEgJiYgY29sdW1uRGF0YS5jb2xzcGFuKSB8fCAxO1xuICAgICAgICBpZiAoY29sc3BhbiA9PT0gXCIqXCIpIHtcbiAgICAgICAgICBjb2xzcGFuID0gaWkgLSBpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERvIG5vdCByZW5kZXIgY2VsbHMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQuXG4gICAgICBpZiAoY29sdW1uUG9zUmlnaHRbTWF0aC5taW4oaWkgLSAxLCBpICsgY29sc3BhbiAtIDEpXSA+IHJhbmdlLmxlZnRQeCkge1xuICAgICAgICBpZiAoY29sdW1uUG9zTGVmdFtpXSA+IHJhbmdlLnJpZ2h0UHgpIHtcbiAgICAgICAgICAvLyBBbGwgY29sdW1ucyB0byB0aGUgcmlnaHQgYXJlIG91dHNpZGUgdGhlIHJhbmdlLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kQ2VsbEh0bWwoc3RyaW5nQXJyYXksIHJvdywgaSwgY29sc3BhbiwgZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2xzcGFuID4gMSkge1xuICAgICAgICBpICs9IChjb2xzcGFuIC0gMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyaW5nQXJyYXkucHVzaChcIjwvZGl2PlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZENlbGxIdG1sKHN0cmluZ0FycmF5LCByb3csIGNlbGwsIGNvbHNwYW4sIGl0ZW0pIHtcbiAgICB2YXIgbSA9IGNvbHVtbnNbY2VsbF07XG4gICAgdmFyIGNlbGxDc3MgPSBcImJrLXNsaWNrLWNlbGwgbFwiICsgY2VsbCArIFwiIHJcIiArIE1hdGgubWluKGNvbHVtbnMubGVuZ3RoIC0gMSwgY2VsbCArIGNvbHNwYW4gLSAxKSArXG4gICAgICAgIChtLmNzc0NsYXNzID8gXCIgXCIgKyBtLmNzc0NsYXNzIDogXCJcIik7XG4gICAgaWYgKHJvdyA9PT0gYWN0aXZlUm93ICYmIGNlbGwgPT09IGFjdGl2ZUNlbGwpIHtcbiAgICAgIGNlbGxDc3MgKz0gKFwiIGFjdGl2ZVwiKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiAgbWVyZ2UgdGhlbSB0b2dldGhlciBpbiB0aGUgc2V0dGVyXG4gICAgZm9yICh2YXIga2V5IGluIGNlbGxDc3NDbGFzc2VzKSB7XG4gICAgICBpZiAoY2VsbENzc0NsYXNzZXNba2V5XVtyb3ddICYmIGNlbGxDc3NDbGFzc2VzW2tleV1bcm93XVttLmlkXSkge1xuICAgICAgICBjZWxsQ3NzICs9IChcIiBcIiArIGNlbGxDc3NDbGFzc2VzW2tleV1bcm93XVttLmlkXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyaW5nQXJyYXkucHVzaChcIjxkaXYgY2xhc3M9J1wiICsgY2VsbENzcyArIFwiJz5cIik7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBhIGNvcnJlc3BvbmRpbmcgcm93IChpZiBub3QsIHRoaXMgaXMgdGhlIEFkZCBOZXcgcm93IG9yIHRoaXMgZGF0YSBoYXNuJ3QgYmVlbiBsb2FkZWQgeWV0KVxuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXREYXRhSXRlbVZhbHVlRm9yQ29sdW1uKGl0ZW0sIG0pO1xuICAgICAgc3RyaW5nQXJyYXkucHVzaChnZXRGb3JtYXR0ZXIocm93LCBtKShyb3csIGNlbGwsIHZhbHVlLCBtLCBpdGVtKSk7XG4gICAgfVxuXG4gICAgc3RyaW5nQXJyYXkucHVzaChcIjwvZGl2PlwiKTtcblxuICAgIHJvd3NDYWNoZVtyb3ddLmNlbGxSZW5kZXJRdWV1ZS5wdXNoKGNlbGwpO1xuICAgIHJvd3NDYWNoZVtyb3ddLmNlbGxDb2xTcGFuc1tjZWxsXSA9IGNvbHNwYW47XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNsZWFudXBSb3dzKHJhbmdlVG9LZWVwKSB7XG4gICAgZm9yICh2YXIgaSBpbiByb3dzQ2FjaGUpIHtcbiAgICAgIGlmICgoKGkgPSBwYXJzZUludChpLCAxMCkpICE9PSBhY3RpdmVSb3cpICYmIChpIDwgcmFuZ2VUb0tlZXAudG9wIHx8IGkgPiByYW5nZVRvS2VlcC5ib3R0b20pKSB7XG4gICAgICAgIHJlbW92ZVJvd0Zyb21DYWNoZShpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHVwZGF0ZVJvd0NvdW50KCk7XG4gICAgaW52YWxpZGF0ZUFsbFJvd3MoKTtcbiAgICByZW5kZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRhdGVBbGxSb3dzKCkge1xuICAgIGlmIChjdXJyZW50RWRpdG9yKSB7XG4gICAgICBtYWtlQWN0aXZlQ2VsbE5vcm1hbCgpO1xuICAgIH1cbiAgICBmb3IgKHZhciByb3cgaW4gcm93c0NhY2hlKSB7XG4gICAgICByZW1vdmVSb3dGcm9tQ2FjaGUocm93KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVSb3dGcm9tQ2FjaGUocm93KSB7XG4gICAgdmFyIGNhY2hlRW50cnkgPSByb3dzQ2FjaGVbcm93XTtcbiAgICBpZiAoIWNhY2hlRW50cnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocm93Tm9kZUZyb21MYXN0TW91c2VXaGVlbEV2ZW50ID09IGNhY2hlRW50cnkucm93Tm9kZSkge1xuICAgICAgY2FjaGVFbnRyeS5yb3dOb2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB6b21iaWVSb3dOb2RlRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQgPSByb3dOb2RlRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICRjYW52YXNbMF0ucmVtb3ZlQ2hpbGQoY2FjaGVFbnRyeS5yb3dOb2RlKTtcbiAgICB9XG5cbiAgICBkZWxldGUgcm93c0NhY2hlW3Jvd107XG4gICAgZGVsZXRlIHBvc3RQcm9jZXNzZWRSb3dzW3Jvd107XG4gICAgcmVuZGVyZWRSb3dzLS07XG4gICAgY291bnRlcl9yb3dzX3JlbW92ZWQrKztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRhdGVSb3dzKHJvd3MpIHtcbiAgICB2YXIgaSwgcmw7XG4gICAgaWYgKCFyb3dzIHx8ICFyb3dzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2U2Nyb2xsRGlyID0gMDtcbiAgICBmb3IgKGkgPSAwLCBybCA9IHJvd3MubGVuZ3RoOyBpIDwgcmw7IGkrKykge1xuICAgICAgaWYgKGN1cnJlbnRFZGl0b3IgJiYgYWN0aXZlUm93ID09PSByb3dzW2ldKSB7XG4gICAgICAgIG1ha2VBY3RpdmVDZWxsTm9ybWFsKCk7XG4gICAgICB9XG4gICAgICBpZiAocm93c0NhY2hlW3Jvd3NbaV1dKSB7XG4gICAgICAgIHJlbW92ZVJvd0Zyb21DYWNoZShyb3dzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkYXRlUm93KHJvdykge1xuICAgIGludmFsaWRhdGVSb3dzKFtyb3ddKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNlbGwocm93LCBjZWxsKSB7XG4gICAgdmFyIGNlbGxOb2RlID0gZ2V0Q2VsbE5vZGUocm93LCBjZWxsKTtcbiAgICBpZiAoIWNlbGxOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG0gPSBjb2x1bW5zW2NlbGxdLCBkID0gZ2V0RGF0YUl0ZW0ocm93KTtcbiAgICBpZiAoY3VycmVudEVkaXRvciAmJiBhY3RpdmVSb3cgPT09IHJvdyAmJiBhY3RpdmVDZWxsID09PSBjZWxsKSB7XG4gICAgICBjdXJyZW50RWRpdG9yLmxvYWRWYWx1ZShkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbE5vZGUuaW5uZXJIVE1MID0gZCA/IGdldEZvcm1hdHRlcihyb3csIG0pKHJvdywgY2VsbCwgZ2V0RGF0YUl0ZW1WYWx1ZUZvckNvbHVtbihkLCBtKSwgbSwgZCkgOiBcIlwiO1xuICAgICAgaW52YWxpZGF0ZVBvc3RQcm9jZXNzaW5nUmVzdWx0cyhyb3cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVJvdyhyb3cpIHtcbiAgICB2YXIgY2FjaGVFbnRyeSA9IHJvd3NDYWNoZVtyb3ddO1xuICAgIGlmICghY2FjaGVFbnRyeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVuc3VyZUNlbGxOb2Rlc0luUm93c0NhY2hlKHJvdyk7XG5cbiAgICB2YXIgZCA9IGdldERhdGFJdGVtKHJvdyk7XG5cbiAgICBmb3IgKHZhciBjb2x1bW5JZHggaW4gY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeCkge1xuICAgICAgaWYgKCFjYWNoZUVudHJ5LmNlbGxOb2Rlc0J5Q29sdW1uSWR4Lmhhc093blByb3BlcnR5KGNvbHVtbklkeCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbHVtbklkeCA9IGNvbHVtbklkeCB8IDA7XG4gICAgICB2YXIgbSA9IGNvbHVtbnNbY29sdW1uSWR4XSxcbiAgICAgICAgICBub2RlID0gY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeFtjb2x1bW5JZHhdO1xuXG4gICAgICBpZiAocm93ID09PSBhY3RpdmVSb3cgJiYgY29sdW1uSWR4ID09PSBhY3RpdmVDZWxsICYmIGN1cnJlbnRFZGl0b3IpIHtcbiAgICAgICAgY3VycmVudEVkaXRvci5sb2FkVmFsdWUoZCk7XG4gICAgICB9IGVsc2UgaWYgKGQpIHtcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBnZXRGb3JtYXR0ZXIocm93LCBtKShyb3csIGNvbHVtbklkeCwgZ2V0RGF0YUl0ZW1WYWx1ZUZvckNvbHVtbihkLCBtKSwgbSwgZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52YWxpZGF0ZVBvc3RQcm9jZXNzaW5nUmVzdWx0cyhyb3cpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Vmlld3BvcnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoJC5jc3MoJGNvbnRhaW5lclswXSwgXCJoZWlnaHRcIiwgdHJ1ZSkpIC1cbiAgICAgICAgcGFyc2VGbG9hdCgkLmNzcygkY29udGFpbmVyWzBdLCBcInBhZGRpbmdUb3BcIiwgdHJ1ZSkpIC1cbiAgICAgICAgcGFyc2VGbG9hdCgkLmNzcygkY29udGFpbmVyWzBdLCBcInBhZGRpbmdCb3R0b21cIiwgdHJ1ZSkpIC1cbiAgICAgICAgcGFyc2VGbG9hdCgkLmNzcygkaGVhZGVyU2Nyb2xsZXJbMF0sIFwiaGVpZ2h0XCIpKSAtIGdldFZCb3hEZWx0YSgkaGVhZGVyU2Nyb2xsZXIpIC1cbiAgICAgICAgKG9wdGlvbnMuc2hvd1RvcFBhbmVsID8gb3B0aW9ucy50b3BQYW5lbEhlaWdodCArIGdldFZCb3hEZWx0YSgkdG9wUGFuZWxTY3JvbGxlcikgOiAwKSAtXG4gICAgICAgIChvcHRpb25zLnNob3dIZWFkZXJSb3cgPyBvcHRpb25zLmhlYWRlclJvd0hlaWdodCArIGdldFZCb3hEZWx0YSgkaGVhZGVyUm93U2Nyb2xsZXIpIDogMCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNpemVDYW52YXMoKSB7XG4gICAgaWYgKCFpbml0aWFsaXplZCkgeyByZXR1cm47IH1cbiAgICBpZiAob3B0aW9ucy5hdXRvSGVpZ2h0KSB7XG4gICAgICB2aWV3cG9ydEggPSBvcHRpb25zLnJvd0hlaWdodCAqIGdldERhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld3BvcnRIID0gZ2V0Vmlld3BvcnRIZWlnaHQoKTtcbiAgICB9XG5cbiAgICBudW1WaXNpYmxlUm93cyA9IE1hdGguY2VpbCh2aWV3cG9ydEggLyBvcHRpb25zLnJvd0hlaWdodCk7XG4gICAgdmlld3BvcnRXID0gcGFyc2VGbG9hdCgkLmNzcygkY29udGFpbmVyWzBdLCBcIndpZHRoXCIsIHRydWUpKTtcbiAgICBpZiAoIW9wdGlvbnMuYXV0b0hlaWdodCkge1xuICAgICAgJHZpZXdwb3J0LmhlaWdodCh2aWV3cG9ydEgpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZvcmNlRml0Q29sdW1ucykge1xuICAgICAgYXV0b3NpemVDb2x1bW5zKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlUm93Q291bnQoKTtcbiAgICBoYW5kbGVTY3JvbGwoKTtcbiAgICAvLyBTaW5jZSB0aGUgd2lkdGggaGFzIGNoYW5nZWQsIGZvcmNlIHRoZSByZW5kZXIoKSB0byByZWV2YWx1YXRlIHZpcnR1YWxseSByZW5kZXJlZCBjZWxscy5cbiAgICBsYXN0UmVuZGVyZWRTY3JvbGxMZWZ0ID0gLTE7XG4gICAgcmVuZGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVSb3dDb3VudCgpIHtcbiAgICBpZiAoIWluaXRpYWxpemVkKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGRhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcgPSBnZXREYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KCk7XG4gICAgdmFyIG51bWJlck9mUm93cyA9IGRhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcgK1xuICAgICAgICAob3B0aW9ucy5sZWF2ZVNwYWNlRm9yTmV3Um93cyA/IG51bVZpc2libGVSb3dzIC0gMSA6IDApO1xuXG4gICAgdmFyIG9sZFZpZXdwb3J0SGFzVlNjcm9sbCA9IHZpZXdwb3J0SGFzVlNjcm9sbDtcbiAgICAvLyB3aXRoIGF1dG9IZWlnaHQsIHdlIGRvIG5vdCBuZWVkIHRvIGFjY29tbW9kYXRlIHRoZSB2ZXJ0aWNhbCBzY3JvbGwgYmFyXG4gICAgdmlld3BvcnRIYXNWU2Nyb2xsID0gIW9wdGlvbnMuYXV0b0hlaWdodCAmJiAobnVtYmVyT2ZSb3dzICogb3B0aW9ucy5yb3dIZWlnaHQgPiB2aWV3cG9ydEgpO1xuXG4gICAgbWFrZUFjdGl2ZUNlbGxOb3JtYWwoKTtcblxuICAgIC8vIHJlbW92ZSB0aGUgcm93cyB0aGF0IGFyZSBub3cgb3V0c2lkZSBvZiB0aGUgZGF0YSByYW5nZVxuICAgIC8vIHRoaXMgaGVscHMgYXZvaWQgcmVkdW5kYW50IGNhbGxzIHRvIC5yZW1vdmVSb3coKSB3aGVuIHRoZSBzaXplIG9mIHRoZSBkYXRhIGRlY3JlYXNlZCBieSB0aG91c2FuZHMgb2Ygcm93c1xuICAgIHZhciBsID0gZGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldyAtIDE7XG4gICAgZm9yICh2YXIgaSBpbiByb3dzQ2FjaGUpIHtcbiAgICAgIGlmIChpID49IGwpIHtcbiAgICAgICAgcmVtb3ZlUm93RnJvbUNhY2hlKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhY3RpdmVDZWxsTm9kZSAmJiBhY3RpdmVSb3cgPiBsKSB7XG4gICAgICByZXNldEFjdGl2ZUNlbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkSCA9IGg7XG4gICAgdGggPSBNYXRoLm1heChvcHRpb25zLnJvd0hlaWdodCAqIG51bWJlck9mUm93cywgdmlld3BvcnRIIC0gc2Nyb2xsYmFyRGltZW5zaW9ucy5oZWlnaHQpO1xuICAgIGlmICh0aCA8IG1heFN1cHBvcnRlZENzc0hlaWdodCkge1xuICAgICAgLy8ganVzdCBvbmUgcGFnZVxuICAgICAgaCA9IHBoID0gdGg7XG4gICAgICBuID0gMTtcbiAgICAgIGNqID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYnJlYWsgaW50byBwYWdlc1xuICAgICAgaCA9IG1heFN1cHBvcnRlZENzc0hlaWdodDtcbiAgICAgIHBoID0gaCAvIDEwMDtcbiAgICAgIG4gPSBNYXRoLmZsb29yKHRoIC8gcGgpO1xuICAgICAgY2ogPSAodGggLSBoKSAvIChuIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKGggIT09IG9sZEgpIHtcbiAgICAgICRjYW52YXMuY3NzKFwiaGVpZ2h0XCIsIGgpO1xuICAgICAgc2Nyb2xsVG9wID0gJHZpZXdwb3J0WzBdLnNjcm9sbFRvcDtcbiAgICB9XG5cbiAgICB2YXIgb2xkU2Nyb2xsVG9wSW5SYW5nZSA9IChzY3JvbGxUb3AgKyBvZmZzZXQgPD0gdGggLSB2aWV3cG9ydEgpO1xuXG4gICAgaWYgKHRoID09IDAgfHwgc2Nyb2xsVG9wID09IDApIHtcbiAgICAgIHBhZ2UgPSBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAob2xkU2Nyb2xsVG9wSW5SYW5nZSkge1xuICAgICAgLy8gbWFpbnRhaW4gdmlydHVhbCBwb3NpdGlvblxuICAgICAgc2Nyb2xsVG8oc2Nyb2xsVG9wICsgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2Nyb2xsIHRvIGJvdHRvbVxuICAgICAgc2Nyb2xsVG8odGggLSB2aWV3cG9ydEgpO1xuICAgIH1cblxuICAgIGlmIChoICE9IG9sZEggJiYgb3B0aW9ucy5hdXRvSGVpZ2h0KSB7XG4gICAgICByZXNpemVDYW52YXMoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5mb3JjZUZpdENvbHVtbnMgJiYgb2xkVmlld3BvcnRIYXNWU2Nyb2xsICE9IHZpZXdwb3J0SGFzVlNjcm9sbCkge1xuICAgICAgYXV0b3NpemVDb2x1bW5zKCk7XG4gICAgfVxuICAgIHVwZGF0ZUNhbnZhc1dpZHRoKGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZpc2libGVSYW5nZSh2aWV3cG9ydFRvcCwgdmlld3BvcnRMZWZ0KSB7XG4gICAgaWYgKHZpZXdwb3J0VG9wID09IG51bGwpIHtcbiAgICAgIHZpZXdwb3J0VG9wID0gc2Nyb2xsVG9wO1xuICAgIH1cbiAgICBpZiAodmlld3BvcnRMZWZ0ID09IG51bGwpIHtcbiAgICAgIHZpZXdwb3J0TGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogZ2V0Um93RnJvbVBvc2l0aW9uKHZpZXdwb3J0VG9wKSxcbiAgICAgIGJvdHRvbTogZ2V0Um93RnJvbVBvc2l0aW9uKHZpZXdwb3J0VG9wICsgdmlld3BvcnRIKSArIDEsXG4gICAgICBsZWZ0UHg6IHZpZXdwb3J0TGVmdCxcbiAgICAgIHJpZ2h0UHg6IHZpZXdwb3J0TGVmdCArIHZpZXdwb3J0V1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZW5kZXJlZFJhbmdlKHZpZXdwb3J0VG9wLCB2aWV3cG9ydExlZnQpIHtcbiAgICB2YXIgcmFuZ2UgPSBnZXRWaXNpYmxlUmFuZ2Uodmlld3BvcnRUb3AsIHZpZXdwb3J0TGVmdCk7XG4gICAgdmFyIGJ1ZmZlciA9IE1hdGgucm91bmQodmlld3BvcnRIIC8gb3B0aW9ucy5yb3dIZWlnaHQpO1xuICAgIHZhciBtaW5CdWZmZXIgPSAzO1xuXG4gICAgaWYgKHZTY3JvbGxEaXIgPT0gLTEpIHtcbiAgICAgIHJhbmdlLnRvcCAtPSBidWZmZXI7XG4gICAgICByYW5nZS5ib3R0b20gKz0gbWluQnVmZmVyO1xuICAgIH0gZWxzZSBpZiAodlNjcm9sbERpciA9PSAxKSB7XG4gICAgICByYW5nZS50b3AgLT0gbWluQnVmZmVyO1xuICAgICAgcmFuZ2UuYm90dG9tICs9IGJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UudG9wIC09IG1pbkJ1ZmZlcjtcbiAgICAgIHJhbmdlLmJvdHRvbSArPSBtaW5CdWZmZXI7XG4gICAgfVxuXG4gICAgcmFuZ2UudG9wID0gTWF0aC5tYXgoMCwgcmFuZ2UudG9wKTtcbiAgICByYW5nZS5ib3R0b20gPSBNYXRoLm1pbihnZXREYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KCkgLSAxLCByYW5nZS5ib3R0b20pO1xuXG4gICAgcmFuZ2UubGVmdFB4IC09IHZpZXdwb3J0VztcbiAgICByYW5nZS5yaWdodFB4ICs9IHZpZXdwb3J0VztcblxuICAgIHJhbmdlLmxlZnRQeCA9IE1hdGgubWF4KDAsIHJhbmdlLmxlZnRQeCk7XG4gICAgcmFuZ2UucmlnaHRQeCA9IE1hdGgubWluKGNhbnZhc1dpZHRoLCByYW5nZS5yaWdodFB4KTtcblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZUNlbGxOb2Rlc0luUm93c0NhY2hlKHJvdykge1xuICAgIHZhciBjYWNoZUVudHJ5ID0gcm93c0NhY2hlW3Jvd107XG4gICAgaWYgKGNhY2hlRW50cnkpIHtcbiAgICAgIGlmIChjYWNoZUVudHJ5LmNlbGxSZW5kZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGxhc3RDaGlsZCA9IGNhY2hlRW50cnkucm93Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChjYWNoZUVudHJ5LmNlbGxSZW5kZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY29sdW1uSWR4ID0gY2FjaGVFbnRyeS5jZWxsUmVuZGVyUXVldWUucG9wKCk7XG4gICAgICAgICAgY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeFtjb2x1bW5JZHhdID0gbGFzdENoaWxkO1xuICAgICAgICAgIGxhc3RDaGlsZCA9IGxhc3RDaGlsZC5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhblVwQ2VsbHMocmFuZ2UsIHJvdykge1xuICAgIHZhciB0b3RhbENlbGxzUmVtb3ZlZCA9IDA7XG4gICAgdmFyIGNhY2hlRW50cnkgPSByb3dzQ2FjaGVbcm93XTtcblxuICAgIC8vIFJlbW92ZSBjZWxscyBvdXRzaWRlIHRoZSByYW5nZS5cbiAgICB2YXIgY2VsbHNUb1JlbW92ZSA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeCkge1xuICAgICAgLy8gSSByZWFsbHkgaGF0ZSBpdCB3aGVuIHBlb3BsZSBtZXNzIHdpdGggQXJyYXkucHJvdG90eXBlLlxuICAgICAgaWYgKCFjYWNoZUVudHJ5LmNlbGxOb2Rlc0J5Q29sdW1uSWR4Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIGEgc3RyaW5nLCBzbyBpdCBuZWVkcyB0byBiZSBjYXN0IGJhY2sgdG8gYSBudW1iZXIuXG4gICAgICBpID0gaSB8IDA7XG5cbiAgICAgIHZhciBjb2xzcGFuID0gY2FjaGVFbnRyeS5jZWxsQ29sU3BhbnNbaV07XG4gICAgICBpZiAoY29sdW1uUG9zTGVmdFtpXSA+IHJhbmdlLnJpZ2h0UHggfHxcbiAgICAgICAgY29sdW1uUG9zUmlnaHRbTWF0aC5taW4oY29sdW1ucy5sZW5ndGggLSAxLCBpICsgY29sc3BhbiAtIDEpXSA8IHJhbmdlLmxlZnRQeCkge1xuICAgICAgICBpZiAoIShyb3cgPT0gYWN0aXZlUm93ICYmIGkgPT0gYWN0aXZlQ2VsbCkpIHtcbiAgICAgICAgICBjZWxsc1RvUmVtb3ZlLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2VsbFRvUmVtb3ZlO1xuICAgIHdoaWxlICgoY2VsbFRvUmVtb3ZlID0gY2VsbHNUb1JlbW92ZS5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgY2FjaGVFbnRyeS5yb3dOb2RlLnJlbW92ZUNoaWxkKGNhY2hlRW50cnkuY2VsbE5vZGVzQnlDb2x1bW5JZHhbY2VsbFRvUmVtb3ZlXSk7XG4gICAgICBkZWxldGUgY2FjaGVFbnRyeS5jZWxsQ29sU3BhbnNbY2VsbFRvUmVtb3ZlXTtcbiAgICAgIGRlbGV0ZSBjYWNoZUVudHJ5LmNlbGxOb2Rlc0J5Q29sdW1uSWR4W2NlbGxUb1JlbW92ZV07XG4gICAgICBpZiAocG9zdFByb2Nlc3NlZFJvd3Nbcm93XSkge1xuICAgICAgICBkZWxldGUgcG9zdFByb2Nlc3NlZFJvd3Nbcm93XVtjZWxsVG9SZW1vdmVdO1xuICAgICAgfVxuICAgICAgdG90YWxDZWxsc1JlbW92ZWQrKztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhblVwQW5kUmVuZGVyQ2VsbHMocmFuZ2UpIHtcbiAgICB2YXIgY2FjaGVFbnRyeTtcbiAgICB2YXIgc3RyaW5nQXJyYXkgPSBbXTtcbiAgICB2YXIgcHJvY2Vzc2VkUm93cyA9IFtdO1xuICAgIHZhciBjZWxsc0FkZGVkO1xuICAgIHZhciB0b3RhbENlbGxzQWRkZWQgPSAwO1xuICAgIHZhciBjb2xzcGFuO1xuXG4gICAgZm9yICh2YXIgcm93ID0gcmFuZ2UudG9wLCBidG0gPSByYW5nZS5ib3R0b207IHJvdyA8PSBidG07IHJvdysrKSB7XG4gICAgICBjYWNoZUVudHJ5ID0gcm93c0NhY2hlW3Jvd107XG4gICAgICBpZiAoIWNhY2hlRW50cnkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNlbGxSZW5kZXJRdWV1ZSBwb3B1bGF0ZWQgaW4gcmVuZGVyUm93cygpIG5lZWRzIHRvIGJlIGNsZWFyZWQgZmlyc3RcbiAgICAgIGVuc3VyZUNlbGxOb2Rlc0luUm93c0NhY2hlKHJvdyk7XG5cbiAgICAgIGNsZWFuVXBDZWxscyhyYW5nZSwgcm93KTtcblxuICAgICAgLy8gUmVuZGVyIG1pc3NpbmcgY2VsbHMuXG4gICAgICBjZWxsc0FkZGVkID0gMDtcblxuICAgICAgdmFyIG1ldGFkYXRhID0gZGF0YS5nZXRJdGVtTWV0YWRhdGEgJiYgZGF0YS5nZXRJdGVtTWV0YWRhdGEocm93KTtcbiAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGEgJiYgbWV0YWRhdGEuY29sdW1ucztcblxuICAgICAgdmFyIGQgPSBnZXREYXRhSXRlbShyb3cpO1xuXG4gICAgICAvLyBUT0RPOiAgc2hvcnRlbiB0aGlzIGxvb3AgKGluZGV4PyBoZXVyaXN0aWNzPyBiaW5hcnkgc2VhcmNoPylcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAvLyBDZWxscyB0byB0aGUgcmlnaHQgYXJlIG91dHNpZGUgdGhlIHJhbmdlLlxuICAgICAgICBpZiAoY29sdW1uUG9zTGVmdFtpXSA+IHJhbmdlLnJpZ2h0UHgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFscmVhZHkgcmVuZGVyZWQuXG4gICAgICAgIGlmICgoY29sc3BhbiA9IGNhY2hlRW50cnkuY2VsbENvbFNwYW5zW2ldKSAhPSBudWxsKSB7XG4gICAgICAgICAgaSArPSAoY29sc3BhbiA+IDEgPyBjb2xzcGFuIC0gMSA6IDApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sc3BhbiA9IDE7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgIHZhciBjb2x1bW5EYXRhID0gbWV0YWRhdGFbY29sdW1uc1tpXS5pZF0gfHwgbWV0YWRhdGFbaV07XG4gICAgICAgICAgY29sc3BhbiA9IChjb2x1bW5EYXRhICYmIGNvbHVtbkRhdGEuY29sc3BhbikgfHwgMTtcbiAgICAgICAgICBpZiAoY29sc3BhbiA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGNvbHNwYW4gPSBpaSAtIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbHVtblBvc1JpZ2h0W01hdGgubWluKGlpIC0gMSwgaSArIGNvbHNwYW4gLSAxKV0gPiByYW5nZS5sZWZ0UHgpIHtcbiAgICAgICAgICBhcHBlbmRDZWxsSHRtbChzdHJpbmdBcnJheSwgcm93LCBpLCBjb2xzcGFuLCBkKTtcbiAgICAgICAgICBjZWxsc0FkZGVkKys7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IChjb2xzcGFuID4gMSA/IGNvbHNwYW4gLSAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjZWxsc0FkZGVkKSB7XG4gICAgICAgIHRvdGFsQ2VsbHNBZGRlZCArPSBjZWxsc0FkZGVkO1xuICAgICAgICBwcm9jZXNzZWRSb3dzLnB1c2gocm93KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXN0cmluZ0FycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB4LmlubmVySFRNTCA9IHN0cmluZ0FycmF5LmpvaW4oXCJcIik7XG5cbiAgICB2YXIgcHJvY2Vzc2VkUm93O1xuICAgIHZhciBub2RlO1xuICAgIHdoaWxlICgocHJvY2Vzc2VkUm93ID0gcHJvY2Vzc2VkUm93cy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgY2FjaGVFbnRyeSA9IHJvd3NDYWNoZVtwcm9jZXNzZWRSb3ddO1xuICAgICAgdmFyIGNvbHVtbklkeDtcbiAgICAgIHdoaWxlICgoY29sdW1uSWR4ID0gY2FjaGVFbnRyeS5jZWxsUmVuZGVyUXVldWUucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IHgubGFzdENoaWxkO1xuICAgICAgICBjYWNoZUVudHJ5LnJvd05vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIGNhY2hlRW50cnkuY2VsbE5vZGVzQnlDb2x1bW5JZHhbY29sdW1uSWR4XSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm93cyhyYW5nZSkge1xuICAgIHZhciBwYXJlbnROb2RlID0gJGNhbnZhc1swXSxcbiAgICAgICAgc3RyaW5nQXJyYXkgPSBbXSxcbiAgICAgICAgcm93cyA9IFtdLFxuICAgICAgICBuZWVkVG9SZXNlbGVjdENlbGwgPSBmYWxzZSxcbiAgICAgICAgZGF0YUxlbmd0aCA9IGdldERhdGFMZW5ndGgoKTtcblxuICAgIGZvciAodmFyIGkgPSByYW5nZS50b3AsIGlpID0gcmFuZ2UuYm90dG9tOyBpIDw9IGlpOyBpKyspIHtcbiAgICAgIGlmIChyb3dzQ2FjaGVbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZW5kZXJlZFJvd3MrKztcbiAgICAgIHJvd3MucHVzaChpKTtcblxuICAgICAgLy8gQ3JlYXRlIGFuIGVudHJ5IHJpZ2h0IGF3YXkgc28gdGhhdCBhcHBlbmRSb3dIdG1sKCkgY2FuXG4gICAgICAvLyBzdGFydCBwb3B1bGF0YXRpbmcgaXQuXG4gICAgICByb3dzQ2FjaGVbaV0gPSB7XG4gICAgICAgIFwicm93Tm9kZVwiOiBudWxsLFxuXG4gICAgICAgIC8vIENvbFNwYW5zIG9mIHJlbmRlcmVkIGNlbGxzIChieSBjb2x1bW4gaWR4KS5cbiAgICAgICAgLy8gQ2FuIGFsc28gYmUgdXNlZCBmb3IgY2hlY2tpbmcgd2hldGhlciBhIGNlbGwgaGFzIGJlZW4gcmVuZGVyZWQuXG4gICAgICAgIFwiY2VsbENvbFNwYW5zXCI6IFtdLFxuXG4gICAgICAgIC8vIENlbGwgbm9kZXMgKGJ5IGNvbHVtbiBpZHgpLiAgTGF6eS1wb3B1bGF0ZWQgYnkgZW5zdXJlQ2VsbE5vZGVzSW5Sb3dzQ2FjaGUoKS5cbiAgICAgICAgXCJjZWxsTm9kZXNCeUNvbHVtbklkeFwiOiBbXSxcblxuICAgICAgICAvLyBDb2x1bW4gaW5kaWNlcyBvZiBjZWxsIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIHJlbmRlcmVkLCBidXQgbm90IHlldCBpbmRleGVkIGluXG4gICAgICAgIC8vIGNlbGxOb2Rlc0J5Q29sdW1uSWR4LiAgVGhlc2UgYXJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIGNlbGwgbm9kZXMgYWRkZWQgYXQgdGhlXG4gICAgICAgIC8vIGVuZCBvZiB0aGUgcm93LlxuICAgICAgICBcImNlbGxSZW5kZXJRdWV1ZVwiOiBbXVxuICAgICAgfTtcblxuICAgICAgYXBwZW5kUm93SHRtbChzdHJpbmdBcnJheSwgaSwgcmFuZ2UsIGRhdGFMZW5ndGgpO1xuICAgICAgaWYgKGFjdGl2ZUNlbGxOb2RlICYmIGFjdGl2ZVJvdyA9PT0gaSkge1xuICAgICAgICBuZWVkVG9SZXNlbGVjdENlbGwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY291bnRlcl9yb3dzX3JlbmRlcmVkKys7XG4gICAgfVxuXG4gICAgaWYgKCFyb3dzLmxlbmd0aCkgeyByZXR1cm47IH1cblxuICAgIHZhciB4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB4LmlubmVySFRNTCA9IHN0cmluZ0FycmF5LmpvaW4oXCJcIik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByb3dzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHJvd3NDYWNoZVtyb3dzW2ldXS5yb3dOb2RlID0gcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh4LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChuZWVkVG9SZXNlbGVjdENlbGwpIHtcbiAgICAgIGFjdGl2ZUNlbGxOb2RlID0gZ2V0Q2VsbE5vZGUoYWN0aXZlUm93LCBhY3RpdmVDZWxsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFBvc3RQcm9jZXNzaW5nKCkge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVBc3luY1Bvc3RSZW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGhfcG9zdHJlbmRlcik7XG4gICAgaF9wb3N0cmVuZGVyID0gc2V0VGltZW91dChhc3luY1Bvc3RQcm9jZXNzUm93cywgb3B0aW9ucy5hc3luY1Bvc3RSZW5kZXJEZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkYXRlUG9zdFByb2Nlc3NpbmdSZXN1bHRzKHJvdykge1xuICAgIGRlbGV0ZSBwb3N0UHJvY2Vzc2VkUm93c1tyb3ddO1xuICAgIHBvc3RQcm9jZXNzRnJvbVJvdyA9IE1hdGgubWluKHBvc3RQcm9jZXNzRnJvbVJvdywgcm93KTtcbiAgICBwb3N0UHJvY2Vzc1RvUm93ID0gTWF0aC5tYXgocG9zdFByb2Nlc3NUb1Jvdywgcm93KTtcbiAgICBzdGFydFBvc3RQcm9jZXNzaW5nKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVSb3dQb3NpdGlvbnMoKSB7XG4gICAgZm9yICh2YXIgcm93IGluIHJvd3NDYWNoZSkge1xuICAgICAgcm93c0NhY2hlW3Jvd10ucm93Tm9kZS5zdHlsZS50b3AgPSBnZXRSb3dUb3Aocm93KSArIFwicHhcIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgaWYgKCFpbml0aWFsaXplZCkgeyByZXR1cm47IH1cbiAgICB2YXIgdmlzaWJsZSA9IGdldFZpc2libGVSYW5nZSgpO1xuICAgIHZhciByZW5kZXJlZCA9IGdldFJlbmRlcmVkUmFuZ2UoKTtcblxuICAgIC8vIHJlbW92ZSByb3dzIG5vIGxvbmdlciBpbiB0aGUgdmlld3BvcnRcbiAgICBjbGVhbnVwUm93cyhyZW5kZXJlZCk7XG5cbiAgICAvLyBhZGQgbmV3IHJvd3MgJiBtaXNzaW5nIGNlbGxzIGluIGV4aXN0aW5nIHJvd3NcbiAgICBpZiAobGFzdFJlbmRlcmVkU2Nyb2xsTGVmdCAhPSBzY3JvbGxMZWZ0KSB7XG4gICAgICBjbGVhblVwQW5kUmVuZGVyQ2VsbHMocmVuZGVyZWQpO1xuICAgIH1cblxuICAgIC8vIHJlbmRlciBtaXNzaW5nIHJvd3NcbiAgICByZW5kZXJSb3dzKHJlbmRlcmVkKTtcblxuICAgIHBvc3RQcm9jZXNzRnJvbVJvdyA9IHZpc2libGUudG9wO1xuICAgIHBvc3RQcm9jZXNzVG9Sb3cgPSBNYXRoLm1pbihnZXREYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KCkgLSAxLCB2aXNpYmxlLmJvdHRvbSk7XG4gICAgc3RhcnRQb3N0UHJvY2Vzc2luZygpO1xuXG4gICAgbGFzdFJlbmRlcmVkU2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgIGxhc3RSZW5kZXJlZFNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgIGhfcmVuZGVyID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUhlYWRlclJvd1Njcm9sbCgpIHtcbiAgICB2YXIgc2Nyb2xsTGVmdCA9ICRoZWFkZXJSb3dTY3JvbGxlclswXS5zY3JvbGxMZWZ0O1xuICAgIGlmIChzY3JvbGxMZWZ0ICE9ICR2aWV3cG9ydFswXS5zY3JvbGxMZWZ0KSB7XG4gICAgICAkdmlld3BvcnRbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKCkge1xuICAgIHNjcm9sbFRvcCA9ICR2aWV3cG9ydFswXS5zY3JvbGxUb3A7XG4gICAgc2Nyb2xsTGVmdCA9ICR2aWV3cG9ydFswXS5zY3JvbGxMZWZ0O1xuICAgIHZhciB2U2Nyb2xsRGlzdCA9IE1hdGguYWJzKHNjcm9sbFRvcCAtIHByZXZTY3JvbGxUb3ApO1xuICAgIHZhciBoU2Nyb2xsRGlzdCA9IE1hdGguYWJzKHNjcm9sbExlZnQgLSBwcmV2U2Nyb2xsTGVmdCk7XG5cbiAgICBpZiAoaFNjcm9sbERpc3QpIHtcbiAgICAgIHByZXZTY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICRoZWFkZXJTY3JvbGxlclswXS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICR0b3BQYW5lbFNjcm9sbGVyWzBdLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgJGhlYWRlclJvd1Njcm9sbGVyWzBdLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgIH1cblxuICAgIGlmICh2U2Nyb2xsRGlzdCkge1xuICAgICAgdlNjcm9sbERpciA9IHByZXZTY3JvbGxUb3AgPCBzY3JvbGxUb3AgPyAxIDogLTE7XG4gICAgICBwcmV2U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXG4gICAgICAvLyBzd2l0Y2ggdmlydHVhbCBwYWdlcyBpZiBuZWVkZWRcbiAgICAgIGlmICh2U2Nyb2xsRGlzdCA8IHZpZXdwb3J0SCkge1xuICAgICAgICBzY3JvbGxUbyhzY3JvbGxUb3AgKyBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgaWYgKGggPT0gdmlld3BvcnRIKSB7XG4gICAgICAgICAgcGFnZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFnZSA9IE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHNjcm9sbFRvcCAqICgodGggLSB2aWV3cG9ydEgpIC8gKGggLSB2aWV3cG9ydEgpKSAqICgxIC8gcGgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5yb3VuZChwYWdlICogY2opO1xuICAgICAgICBpZiAob2xkT2Zmc2V0ICE9IG9mZnNldCkge1xuICAgICAgICAgIGludmFsaWRhdGVBbGxSb3dzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaFNjcm9sbERpc3QgfHwgdlNjcm9sbERpc3QpIHtcbiAgICAgIGlmIChoX3JlbmRlcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoaF9yZW5kZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTWF0aC5hYnMobGFzdFJlbmRlcmVkU2Nyb2xsVG9wIC0gc2Nyb2xsVG9wKSA+IDIwIHx8XG4gICAgICAgICAgTWF0aC5hYnMobGFzdFJlbmRlcmVkU2Nyb2xsTGVmdCAtIHNjcm9sbExlZnQpID4gMjApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9yY2VTeW5jU2Nyb2xsaW5nIHx8IChcbiAgICAgICAgICAgIE1hdGguYWJzKGxhc3RSZW5kZXJlZFNjcm9sbFRvcCAtIHNjcm9sbFRvcCkgPCB2aWV3cG9ydEggJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGxhc3RSZW5kZXJlZFNjcm9sbExlZnQgLSBzY3JvbGxMZWZ0KSA8IHZpZXdwb3J0VykpIHtcbiAgICAgICAgICByZW5kZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoX3JlbmRlciA9IHNldFRpbWVvdXQocmVuZGVyLCA1MCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmlnZ2VyKHNlbGYub25WaWV3cG9ydENoYW5nZWQsIHt9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmlnZ2VyKHNlbGYub25TY3JvbGwsIHtzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LCBzY3JvbGxUb3A6IHNjcm9sbFRvcH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYXN5bmNQb3N0UHJvY2Vzc1Jvd3MoKSB7XG4gICAgdmFyIGRhdGFMZW5ndGggPSBnZXREYXRhTGVuZ3RoKCk7XG4gICAgd2hpbGUgKHBvc3RQcm9jZXNzRnJvbVJvdyA8PSBwb3N0UHJvY2Vzc1RvUm93KSB7XG4gICAgICB2YXIgcm93ID0gKHZTY3JvbGxEaXIgPj0gMCkgPyBwb3N0UHJvY2Vzc0Zyb21Sb3crKyA6IHBvc3RQcm9jZXNzVG9Sb3ctLTtcbiAgICAgIHZhciBjYWNoZUVudHJ5ID0gcm93c0NhY2hlW3Jvd107XG4gICAgICBpZiAoIWNhY2hlRW50cnkgfHwgcm93ID49IGRhdGFMZW5ndGgpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghcG9zdFByb2Nlc3NlZFJvd3Nbcm93XSkge1xuICAgICAgICBwb3N0UHJvY2Vzc2VkUm93c1tyb3ddID0ge307XG4gICAgICB9XG5cbiAgICAgIGVuc3VyZUNlbGxOb2Rlc0luUm93c0NhY2hlKHJvdyk7XG4gICAgICBmb3IgKHZhciBjb2x1bW5JZHggaW4gY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeCkge1xuICAgICAgICBpZiAoIWNhY2hlRW50cnkuY2VsbE5vZGVzQnlDb2x1bW5JZHguaGFzT3duUHJvcGVydHkoY29sdW1uSWR4KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sdW1uSWR4ID0gY29sdW1uSWR4IHwgMDtcblxuICAgICAgICB2YXIgbSA9IGNvbHVtbnNbY29sdW1uSWR4XTtcbiAgICAgICAgaWYgKG0uYXN5bmNQb3N0UmVuZGVyICYmICFwb3N0UHJvY2Vzc2VkUm93c1tyb3ddW2NvbHVtbklkeF0pIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IGNhY2hlRW50cnkuY2VsbE5vZGVzQnlDb2x1bW5JZHhbY29sdW1uSWR4XTtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbS5hc3luY1Bvc3RSZW5kZXIobm9kZSwgcm93LCBnZXREYXRhSXRlbShyb3cpLCBtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zdFByb2Nlc3NlZFJvd3Nbcm93XVtjb2x1bW5JZHhdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBoX3Bvc3RyZW5kZXIgPSBzZXRUaW1lb3V0KGFzeW5jUG9zdFByb2Nlc3NSb3dzLCBvcHRpb25zLmFzeW5jUG9zdFJlbmRlckRlbGF5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDZWxsQ3NzU3R5bGVzT25SZW5kZXJlZFJvd3MoYWRkZWRIYXNoLCByZW1vdmVkSGFzaCkge1xuICAgIHZhciBub2RlLCBjb2x1bW5JZCwgYWRkZWRSb3dIYXNoLCByZW1vdmVkUm93SGFzaDtcbiAgICBmb3IgKHZhciByb3cgaW4gcm93c0NhY2hlKSB7XG4gICAgICByZW1vdmVkUm93SGFzaCA9IHJlbW92ZWRIYXNoICYmIHJlbW92ZWRIYXNoW3Jvd107XG4gICAgICBhZGRlZFJvd0hhc2ggPSBhZGRlZEhhc2ggJiYgYWRkZWRIYXNoW3Jvd107XG5cbiAgICAgIGlmIChyZW1vdmVkUm93SGFzaCkge1xuICAgICAgICBmb3IgKGNvbHVtbklkIGluIHJlbW92ZWRSb3dIYXNoKSB7XG4gICAgICAgICAgaWYgKCFhZGRlZFJvd0hhc2ggfHwgcmVtb3ZlZFJvd0hhc2hbY29sdW1uSWRdICE9IGFkZGVkUm93SGFzaFtjb2x1bW5JZF0pIHtcbiAgICAgICAgICAgIG5vZGUgPSBnZXRDZWxsTm9kZShyb3csIGdldENvbHVtbkluZGV4KGNvbHVtbklkKSk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAkKG5vZGUpLnJlbW92ZUNsYXNzKHJlbW92ZWRSb3dIYXNoW2NvbHVtbklkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRlZFJvd0hhc2gpIHtcbiAgICAgICAgZm9yIChjb2x1bW5JZCBpbiBhZGRlZFJvd0hhc2gpIHtcbiAgICAgICAgICBpZiAoIXJlbW92ZWRSb3dIYXNoIHx8IHJlbW92ZWRSb3dIYXNoW2NvbHVtbklkXSAhPSBhZGRlZFJvd0hhc2hbY29sdW1uSWRdKSB7XG4gICAgICAgICAgICBub2RlID0gZ2V0Q2VsbE5vZGUocm93LCBnZXRDb2x1bW5JbmRleChjb2x1bW5JZCkpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgJChub2RlKS5hZGRDbGFzcyhhZGRlZFJvd0hhc2hbY29sdW1uSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDZWxsQ3NzU3R5bGVzKGtleSwgaGFzaCkge1xuICAgIGlmIChjZWxsQ3NzQ2xhc3Nlc1trZXldKSB7XG4gICAgICB0aHJvdyBcImFkZENlbGxDc3NTdHlsZXM6IGNlbGwgQ1NTIGhhc2ggd2l0aCBrZXkgJ1wiICsga2V5ICsgXCInIGFscmVhZHkgZXhpc3RzLlwiO1xuICAgIH1cblxuICAgIGNlbGxDc3NDbGFzc2VzW2tleV0gPSBoYXNoO1xuICAgIHVwZGF0ZUNlbGxDc3NTdHlsZXNPblJlbmRlcmVkUm93cyhoYXNoLCBudWxsKTtcblxuICAgIHRyaWdnZXIoc2VsZi5vbkNlbGxDc3NTdHlsZXNDaGFuZ2VkLCB7IFwia2V5XCI6IGtleSwgXCJoYXNoXCI6IGhhc2ggfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDZWxsQ3NzU3R5bGVzKGtleSkge1xuICAgIGlmICghY2VsbENzc0NsYXNzZXNba2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZUNlbGxDc3NTdHlsZXNPblJlbmRlcmVkUm93cyhudWxsLCBjZWxsQ3NzQ2xhc3Nlc1trZXldKTtcbiAgICBkZWxldGUgY2VsbENzc0NsYXNzZXNba2V5XTtcblxuICAgIHRyaWdnZXIoc2VsZi5vbkNlbGxDc3NTdHlsZXNDaGFuZ2VkLCB7IFwia2V5XCI6IGtleSwgXCJoYXNoXCI6IG51bGwgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDZWxsQ3NzU3R5bGVzKGtleSwgaGFzaCkge1xuICAgIHZhciBwcmV2SGFzaCA9IGNlbGxDc3NDbGFzc2VzW2tleV07XG5cbiAgICBjZWxsQ3NzQ2xhc3Nlc1trZXldID0gaGFzaDtcbiAgICB1cGRhdGVDZWxsQ3NzU3R5bGVzT25SZW5kZXJlZFJvd3MoaGFzaCwgcHJldkhhc2gpO1xuXG4gICAgdHJpZ2dlcihzZWxmLm9uQ2VsbENzc1N0eWxlc0NoYW5nZWQsIHsgXCJrZXlcIjoga2V5LCBcImhhc2hcIjogaGFzaCB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENlbGxDc3NTdHlsZXMoa2V5KSB7XG4gICAgcmV0dXJuIGNlbGxDc3NDbGFzc2VzW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBmbGFzaENlbGwocm93LCBjZWxsLCBzcGVlZCkge1xuICAgIHNwZWVkID0gc3BlZWQgfHwgMTAwO1xuICAgIGlmIChyb3dzQ2FjaGVbcm93XSkge1xuICAgICAgdmFyICRjZWxsID0gJChnZXRDZWxsTm9kZShyb3csIGNlbGwpKTtcblxuICAgICAgdmFyIHRvZ2dsZUNlbGxDbGFzcyA9IGZ1bmN0aW9uIGZvbyh0aW1lcykge1xuICAgICAgICBpZiAoIXRpbWVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAkY2VsbC5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJGNlbGwudG9nZ2xlQ2xhc3Mob3B0aW9ucy5jZWxsRmxhc2hpbmdDc3NDbGFzcykuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZUNlbGxDbGFzcyh0aW1lcyAtIDEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzcGVlZCk7XG4gICAgICB9XG5cbiAgICAgIHRvZ2dsZUNlbGxDbGFzcyg0KTtcbiAgICB9XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIEludGVyYWN0aXZpdHlcblxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKGUpIHtcbiAgICB2YXIgcm93Tm9kZSA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoXCIuYmstc2xpY2stcm93XCIpWzBdO1xuICAgIGlmIChyb3dOb2RlICE9IHJvd05vZGVGcm9tTGFzdE1vdXNlV2hlZWxFdmVudCkge1xuICAgICAgaWYgKHpvbWJpZVJvd05vZGVGcm9tTGFzdE1vdXNlV2hlZWxFdmVudCAmJiB6b21iaWVSb3dOb2RlRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQgIT0gcm93Tm9kZSkge1xuICAgICAgICAkY2FudmFzWzBdLnJlbW92ZUNoaWxkKHpvbWJpZVJvd05vZGVGcm9tTGFzdE1vdXNlV2hlZWxFdmVudCk7XG4gICAgICAgIHpvbWJpZVJvd05vZGVGcm9tTGFzdE1vdXNlV2hlZWxFdmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICByb3dOb2RlRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQgPSByb3dOb2RlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURyYWdJbml0KGUsIGRkKSB7XG4gICAgdmFyIGNlbGwgPSBnZXRDZWxsRnJvbUV2ZW50KGUpO1xuICAgIGlmICghY2VsbCB8fCAhY2VsbEV4aXN0cyhjZWxsLnJvdywgY2VsbC5jZWxsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByZXR2YWwgPSB0cmlnZ2VyKHNlbGYub25EcmFnSW5pdCwgZGQsIGUpO1xuICAgIGlmIChlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfVxuXG4gICAgLy8gaWYgbm9ib2R5IGNsYWltcyB0byBiZSBoYW5kbGluZyBkcmFnJ24nZHJvcCBieSBzdG9wcGluZyBpbW1lZGlhdGUgcHJvcGFnYXRpb24sXG4gICAgLy8gY2FuY2VsIG91dCBvZiBpdFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURyYWdTdGFydChlLCBkZCkge1xuICAgIHZhciBjZWxsID0gZ2V0Q2VsbEZyb21FdmVudChlKTtcbiAgICBpZiAoIWNlbGwgfHwgIWNlbGxFeGlzdHMoY2VsbC5yb3csIGNlbGwuY2VsbCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcmV0dmFsID0gdHJpZ2dlcihzZWxmLm9uRHJhZ1N0YXJ0LCBkZCwgZSk7XG4gICAgaWYgKGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVEcmFnKGUsIGRkKSB7XG4gICAgcmV0dXJuIHRyaWdnZXIoc2VsZi5vbkRyYWcsIGRkLCBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURyYWdFbmQoZSwgZGQpIHtcbiAgICB0cmlnZ2VyKHNlbGYub25EcmFnRW5kLCBkZCwgZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGUpIHtcbiAgICB0cmlnZ2VyKHNlbGYub25LZXlEb3duLCB7cm93OiBhY3RpdmVSb3csIGNlbGw6IGFjdGl2ZUNlbGx9LCBlKTtcbiAgICB2YXIgaGFuZGxlZCA9IGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKTtcblxuICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgaWYgKCFlLnNoaWZ0S2V5ICYmICFlLmFsdEtleSAmJiAhZS5jdHJsS2V5KSB7XG4gICAgICAgIGlmIChlLndoaWNoID09IDI3KSB7XG4gICAgICAgICAgaWYgKCFnZXRFZGl0b3JMb2NrKCkuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBubyBlZGl0aW5nIG1vZGUgdG8gY2FuY2VsLCBhbGxvdyBidWJibGluZyBhbmQgZGVmYXVsdCBwcm9jZXNzaW5nIChleGl0IHdpdGhvdXQgY2FuY2VsbGluZyB0aGUgZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbmNlbEVkaXRBbmRTZXRGb2N1cygpO1xuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMzQpIHtcbiAgICAgICAgICBuYXZpZ2F0ZVBhZ2VEb3duKCk7XG4gICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAzMykge1xuICAgICAgICAgIG5hdmlnYXRlUGFnZVVwKCk7XG4gICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAzNykge1xuICAgICAgICAgIGhhbmRsZWQgPSBuYXZpZ2F0ZUxlZnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDM5KSB7XG4gICAgICAgICAgaGFuZGxlZCA9IG5hdmlnYXRlUmlnaHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDM4KSB7XG4gICAgICAgICAgaGFuZGxlZCA9IG5hdmlnYXRlVXAoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDQwKSB7XG4gICAgICAgICAgaGFuZGxlZCA9IG5hdmlnYXRlRG93bigpO1xuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gOSkge1xuICAgICAgICAgIGhhbmRsZWQgPSBuYXZpZ2F0ZU5leHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDEzKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RWRpdG9yKSB7XG4gICAgICAgICAgICAgIC8vIGFkZGluZyBuZXcgcm93XG4gICAgICAgICAgICAgIGlmIChhY3RpdmVSb3cgPT09IGdldERhdGFMZW5ndGgoKSkge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlRG93bigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1pdEVkaXRBbmRTZXRGb2N1cygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCkpIHtcbiAgICAgICAgICAgICAgICBtYWtlQWN0aXZlQ2VsbEVkaXRhYmxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSA5ICYmIGUuc2hpZnRLZXkgJiYgIWUuY3RybEtleSAmJiAhZS5hbHRLZXkpIHtcbiAgICAgICAgaGFuZGxlZCA9IG5hdmlnYXRlUHJldigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAvLyB0aGUgZXZlbnQgaGFzIGJlZW4gaGFuZGxlZCBzbyBkb24ndCBsZXQgcGFyZW50IGVsZW1lbnQgKGJ1YmJsaW5nL3Byb3BhZ2F0aW9uKSBvciBicm93c2VyIChkZWZhdWx0KSBoYW5kbGUgaXRcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0cnkge1xuICAgICAgICBlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9IDA7IC8vIHByZXZlbnQgZGVmYXVsdCBiZWhhdmlvdXIgZm9yIHNwZWNpYWwga2V5cyBpbiBJRSBicm93c2VycyAoRjMsIEY1LCBldGMuKVxuICAgICAgfVxuICAgICAgLy8gaWdub3JlIGV4Y2VwdGlvbnMgLSBzZXR0aW5nIHRoZSBvcmlnaW5hbCBldmVudCdzIGtleWNvZGUgdGhyb3dzIGFjY2VzcyBkZW5pZWQgZXhjZXB0aW9uIGZvciBcIkN0cmxcIlxuICAgICAgLy8gKGhpdHRpbmcgY29udHJvbCBrZXkgb25seSwgbm90aGluZyBlbHNlKSwgXCJTaGlmdFwiIChtYXliZSBvdGhlcnMpXG4gICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG4gICAgaWYgKCFjdXJyZW50RWRpdG9yKSB7XG4gICAgICAvLyBpZiB0aGlzIGNsaWNrIHJlc3VsdGVkIGluIHNvbWUgY2VsbCBjaGlsZCBub2RlIGdldHRpbmcgZm9jdXMsXG4gICAgICAvLyBkb24ndCBzdGVhbCBpdCBiYWNrIC0ga2V5Ym9hcmQgZXZlbnRzIHdpbGwgc3RpbGwgYnViYmxlIHVwXG4gICAgICAvLyBJRTkrIHNlZW1zIHRvIGRlZmF1bHQgRElWcyB0byB0YWJJbmRleD0wIGluc3RlYWQgb2YgLTEsIHNvIGNoZWNrIGZvciBjZWxsIGNsaWNrcyBkaXJlY3RseS5cbiAgICAgIGlmIChlLnRhcmdldCAhPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8ICQoZS50YXJnZXQpLmhhc0NsYXNzKFwiYmstc2xpY2stY2VsbFwiKSkge1xuICAgICAgICBzZXRGb2N1cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjZWxsID0gZ2V0Q2VsbEZyb21FdmVudChlKTtcbiAgICBpZiAoIWNlbGwgfHwgKGN1cnJlbnRFZGl0b3IgIT09IG51bGwgJiYgYWN0aXZlUm93ID09IGNlbGwucm93ICYmIGFjdGl2ZUNlbGwgPT0gY2VsbC5jZWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyaWdnZXIoc2VsZi5vbkNsaWNrLCB7cm93OiBjZWxsLnJvdywgY2VsbDogY2VsbC5jZWxsfSwgZSk7XG4gICAgaWYgKGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgoYWN0aXZlQ2VsbCAhPSBjZWxsLmNlbGwgfHwgYWN0aXZlUm93ICE9IGNlbGwucm93KSAmJiBjYW5DZWxsQmVBY3RpdmUoY2VsbC5yb3csIGNlbGwuY2VsbCkpIHtcbiAgICAgIGlmICghZ2V0RWRpdG9yTG9jaygpLmlzQWN0aXZlKCkgfHwgZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCkpIHtcbiAgICAgICAgc2Nyb2xsUm93SW50b1ZpZXcoY2VsbC5yb3csIGZhbHNlKTtcbiAgICAgICAgc2V0QWN0aXZlQ2VsbEludGVybmFsKGdldENlbGxOb2RlKGNlbGwucm93LCBjZWxsLmNlbGwpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDb250ZXh0TWVudShlKSB7XG4gICAgdmFyICRjZWxsID0gJChlLnRhcmdldCkuY2xvc2VzdChcIi5iay1zbGljay1jZWxsXCIsICRjYW52YXMpO1xuICAgIGlmICgkY2VsbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhcmUgd2UgZWRpdGluZyB0aGlzIGNlbGw/XG4gICAgaWYgKGFjdGl2ZUNlbGxOb2RlID09PSAkY2VsbFswXSAmJiBjdXJyZW50RWRpdG9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJpZ2dlcihzZWxmLm9uQ29udGV4dE1lbnUsIHt9LCBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURibENsaWNrKGUpIHtcbiAgICB2YXIgY2VsbCA9IGdldENlbGxGcm9tRXZlbnQoZSk7XG4gICAgaWYgKCFjZWxsIHx8IChjdXJyZW50RWRpdG9yICE9PSBudWxsICYmIGFjdGl2ZVJvdyA9PSBjZWxsLnJvdyAmJiBhY3RpdmVDZWxsID09IGNlbGwuY2VsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmlnZ2VyKHNlbGYub25EYmxDbGljaywge3JvdzogY2VsbC5yb3csIGNlbGw6IGNlbGwuY2VsbH0sIGUpO1xuICAgIGlmIChlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5lZGl0YWJsZSkge1xuICAgICAgZ290b0NlbGwoY2VsbC5yb3csIGNlbGwuY2VsbCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSGVhZGVyTW91c2VFbnRlcihlKSB7XG4gICAgdHJpZ2dlcihzZWxmLm9uSGVhZGVyTW91c2VFbnRlciwge1xuICAgICAgXCJjb2x1bW5cIjogJCh0aGlzKS5kYXRhKFwiY29sdW1uXCIpXG4gICAgfSwgZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVIZWFkZXJNb3VzZUxlYXZlKGUpIHtcbiAgICB0cmlnZ2VyKHNlbGYub25IZWFkZXJNb3VzZUxlYXZlLCB7XG4gICAgICBcImNvbHVtblwiOiAkKHRoaXMpLmRhdGEoXCJjb2x1bW5cIilcbiAgICB9LCBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUhlYWRlckNvbnRleHRNZW51KGUpIHtcbiAgICB2YXIgJGhlYWRlciA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoXCIuYmstc2xpY2staGVhZGVyLWNvbHVtblwiLCBcIi5iay1zbGljay1oZWFkZXItY29sdW1uc1wiKTtcbiAgICB2YXIgY29sdW1uID0gJGhlYWRlciAmJiAkaGVhZGVyLmRhdGEoXCJjb2x1bW5cIik7XG4gICAgdHJpZ2dlcihzZWxmLm9uSGVhZGVyQ29udGV4dE1lbnUsIHtjb2x1bW46IGNvbHVtbn0sIGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSGVhZGVyQ2xpY2soZSkge1xuICAgIHZhciAkaGVhZGVyID0gJChlLnRhcmdldCkuY2xvc2VzdChcIi5iay1zbGljay1oZWFkZXItY29sdW1uXCIsIFwiLmJrLXNsaWNrLWhlYWRlci1jb2x1bW5zXCIpO1xuICAgIHZhciBjb2x1bW4gPSAkaGVhZGVyICYmICRoZWFkZXIuZGF0YShcImNvbHVtblwiKTtcbiAgICBpZiAoY29sdW1uKSB7XG4gICAgICB0cmlnZ2VyKHNlbGYub25IZWFkZXJDbGljaywge2NvbHVtbjogY29sdW1ufSwgZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VFbnRlcihlKSB7XG4gICAgdHJpZ2dlcihzZWxmLm9uTW91c2VFbnRlciwge30sIGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VMZWF2ZShlKSB7XG4gICAgdHJpZ2dlcihzZWxmLm9uTW91c2VMZWF2ZSwge30sIGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VsbEV4aXN0cyhyb3csIGNlbGwpIHtcbiAgICByZXR1cm4gIShyb3cgPCAwIHx8IHJvdyA+PSBnZXREYXRhTGVuZ3RoKCkgfHwgY2VsbCA8IDAgfHwgY2VsbCA+PSBjb2x1bW5zLmxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDZWxsRnJvbVBvaW50KHgsIHkpIHtcbiAgICB2YXIgcm93ID0gZ2V0Um93RnJvbVBvc2l0aW9uKHkpO1xuICAgIHZhciBjZWxsID0gMDtcblxuICAgIHZhciB3ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoICYmIHcgPCB4OyBpKyspIHtcbiAgICAgIHcgKz0gY29sdW1uc1tpXS53aWR0aDtcbiAgICAgIGNlbGwrKztcbiAgICB9XG5cbiAgICBpZiAoY2VsbCA8IDApIHtcbiAgICAgIGNlbGwgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB7cm93OiByb3csIGNlbGw6IGNlbGwgLSAxfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENlbGxGcm9tTm9kZShjZWxsTm9kZSkge1xuICAgIC8vIHJlYWQgY29sdW1uIG51bWJlciBmcm9tIC5sPGNvbHVtbk51bWJlcj4gQ1NTIGNsYXNzXG4gICAgdmFyIGNscyA9IC9sXFxkKy8uZXhlYyhjZWxsTm9kZS5jbGFzc05hbWUpO1xuICAgIGlmICghY2xzKSB7XG4gICAgICB0aHJvdyBcImdldENlbGxGcm9tTm9kZTogY2Fubm90IGdldCBjZWxsIC0gXCIgKyBjZWxsTm9kZS5jbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludChjbHNbMF0uc3Vic3RyKDEsIGNsc1swXS5sZW5ndGggLSAxKSwgMTApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Um93RnJvbU5vZGUocm93Tm9kZSkge1xuICAgIGZvciAodmFyIHJvdyBpbiByb3dzQ2FjaGUpIHtcbiAgICAgIGlmIChyb3dzQ2FjaGVbcm93XS5yb3dOb2RlID09PSByb3dOb2RlKSB7XG4gICAgICAgIHJldHVybiByb3cgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2VsbEZyb21FdmVudChlKSB7XG4gICAgdmFyICRjZWxsID0gJChlLnRhcmdldCkuY2xvc2VzdChcIi5iay1zbGljay1jZWxsXCIsICRjYW52YXMpO1xuICAgIGlmICghJGNlbGwubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcm93ID0gZ2V0Um93RnJvbU5vZGUoJGNlbGxbMF0ucGFyZW50Tm9kZSk7XG4gICAgdmFyIGNlbGwgPSBnZXRDZWxsRnJvbU5vZGUoJGNlbGxbMF0pO1xuXG4gICAgaWYgKHJvdyA9PSBudWxsIHx8IGNlbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFwicm93XCI6IHJvdyxcbiAgICAgICAgXCJjZWxsXCI6IGNlbGxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2VsbE5vZGVCb3gocm93LCBjZWxsKSB7XG4gICAgaWYgKCFjZWxsRXhpc3RzKHJvdywgY2VsbCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB5MSA9IGdldFJvd1RvcChyb3cpO1xuICAgIHZhciB5MiA9IHkxICsgb3B0aW9ucy5yb3dIZWlnaHQgLSAxO1xuICAgIHZhciB4MSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxsOyBpKyspIHtcbiAgICAgIHgxICs9IGNvbHVtbnNbaV0ud2lkdGg7XG4gICAgfVxuICAgIHZhciB4MiA9IHgxICsgY29sdW1uc1tjZWxsXS53aWR0aDtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHkxLFxuICAgICAgbGVmdDogeDEsXG4gICAgICBib3R0b206IHkyLFxuICAgICAgcmlnaHQ6IHgyXG4gICAgfTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gQ2VsbCBzd2l0Y2hpbmdcblxuICBmdW5jdGlvbiByZXNldEFjdGl2ZUNlbGwoKSB7XG4gICAgc2V0QWN0aXZlQ2VsbEludGVybmFsKG51bGwsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEZvY3VzKCkge1xuICAgIGlmICh0YWJiaW5nRGlyZWN0aW9uID09IC0xKSB7XG4gICAgICAkZm9jdXNTaW5rWzBdLmZvY3VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRmb2N1c1NpbmsyWzBdLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsQ2VsbEludG9WaWV3KHJvdywgY2VsbCwgZG9QYWdpbmcpIHtcbiAgICBzY3JvbGxSb3dJbnRvVmlldyhyb3csIGRvUGFnaW5nKTtcblxuICAgIHZhciBjb2xzcGFuID0gZ2V0Q29sc3Bhbihyb3csIGNlbGwpO1xuICAgIHZhciBsZWZ0ID0gY29sdW1uUG9zTGVmdFtjZWxsXSxcbiAgICAgIHJpZ2h0ID0gY29sdW1uUG9zUmlnaHRbY2VsbCArIChjb2xzcGFuID4gMSA/IGNvbHNwYW4gLSAxIDogMCldLFxuICAgICAgc2Nyb2xsUmlnaHQgPSBzY3JvbGxMZWZ0ICsgdmlld3BvcnRXO1xuXG4gICAgaWYgKGxlZnQgPCBzY3JvbGxMZWZ0KSB7XG4gICAgICAkdmlld3BvcnQuc2Nyb2xsTGVmdChsZWZ0KTtcbiAgICAgIGhhbmRsZVNjcm9sbCgpO1xuICAgICAgcmVuZGVyKCk7XG4gICAgfSBlbHNlIGlmIChyaWdodCA+IHNjcm9sbFJpZ2h0KSB7XG4gICAgICAkdmlld3BvcnQuc2Nyb2xsTGVmdChNYXRoLm1pbihsZWZ0LCByaWdodCAtICR2aWV3cG9ydFswXS5jbGllbnRXaWR0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKCk7XG4gICAgICByZW5kZXIoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBY3RpdmVDZWxsSW50ZXJuYWwobmV3Q2VsbCwgb3B0X2VkaXRNb2RlKSB7XG4gICAgaWYgKGFjdGl2ZUNlbGxOb2RlICE9PSBudWxsKSB7XG4gICAgICBtYWtlQWN0aXZlQ2VsbE5vcm1hbCgpO1xuICAgICAgJChhY3RpdmVDZWxsTm9kZSkucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICBpZiAocm93c0NhY2hlW2FjdGl2ZVJvd10pIHtcbiAgICAgICAgJChyb3dzQ2FjaGVbYWN0aXZlUm93XS5yb3dOb2RlKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWN0aXZlQ2VsbENoYW5nZWQgPSAoYWN0aXZlQ2VsbE5vZGUgIT09IG5ld0NlbGwpO1xuICAgIGFjdGl2ZUNlbGxOb2RlID0gbmV3Q2VsbDtcblxuICAgIGlmIChhY3RpdmVDZWxsTm9kZSAhPSBudWxsKSB7XG4gICAgICBhY3RpdmVSb3cgPSBnZXRSb3dGcm9tTm9kZShhY3RpdmVDZWxsTm9kZS5wYXJlbnROb2RlKTtcbiAgICAgIGFjdGl2ZUNlbGwgPSBhY3RpdmVQb3NYID0gZ2V0Q2VsbEZyb21Ob2RlKGFjdGl2ZUNlbGxOb2RlKTtcblxuICAgICAgaWYgKG9wdF9lZGl0TW9kZSA9PSBudWxsKSB7XG4gICAgICAgIG9wdF9lZGl0TW9kZSA9IChhY3RpdmVSb3cgPT0gZ2V0RGF0YUxlbmd0aCgpKSB8fCBvcHRpb25zLmF1dG9FZGl0O1xuICAgICAgfVxuXG4gICAgICAkKGFjdGl2ZUNlbGxOb2RlKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcbiAgICAgICQocm93c0NhY2hlW2FjdGl2ZVJvd10ucm93Tm9kZSkuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XG5cbiAgICAgIGlmIChvcHRpb25zLmVkaXRhYmxlICYmIG9wdF9lZGl0TW9kZSAmJiBpc0NlbGxQb3RlbnRpYWxseUVkaXRhYmxlKGFjdGl2ZVJvdywgYWN0aXZlQ2VsbCkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhfZWRpdG9yTG9hZGVyKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hc3luY0VkaXRvckxvYWRpbmcpIHtcbiAgICAgICAgICBoX2VkaXRvckxvYWRlciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWFrZUFjdGl2ZUNlbGxFZGl0YWJsZSgpO1xuICAgICAgICAgIH0sIG9wdGlvbnMuYXN5bmNFZGl0b3JMb2FkRGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ha2VBY3RpdmVDZWxsRWRpdGFibGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVSb3cgPSBhY3RpdmVDZWxsID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlQ2VsbENoYW5nZWQpIHtcbiAgICAgIHRyaWdnZXIoc2VsZi5vbkFjdGl2ZUNlbGxDaGFuZ2VkLCBnZXRBY3RpdmVDZWxsKCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyVGV4dFNlbGVjdGlvbigpIHtcbiAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy9JRSBmYWlscyBoZXJlIGlmIHNlbGVjdGVkIGVsZW1lbnQgaXMgbm90IGluIGRvbVxuICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWwgJiYgc2VsLnJlbW92ZUFsbFJhbmdlcykge1xuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNDZWxsUG90ZW50aWFsbHlFZGl0YWJsZShyb3csIGNlbGwpIHtcbiAgICB2YXIgZGF0YUxlbmd0aCA9IGdldERhdGFMZW5ndGgoKTtcbiAgICAvLyBpcyB0aGUgZGF0YSBmb3IgdGhpcyByb3cgbG9hZGVkP1xuICAgIGlmIChyb3cgPCBkYXRhTGVuZ3RoICYmICFnZXREYXRhSXRlbShyb3cpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYXJlIHdlIGluIHRoZSBBZGQgTmV3IHJvdz8gIGNhbiB3ZSBjcmVhdGUgbmV3IGZyb20gdGhpcyBjZWxsP1xuICAgIGlmIChjb2x1bW5zW2NlbGxdLmNhbm5vdFRyaWdnZXJJbnNlcnQgJiYgcm93ID49IGRhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBkb2VzIHRoaXMgY2VsbCBoYXZlIGFuIGVkaXRvcj9cbiAgICBpZiAoIWdldEVkaXRvcihyb3csIGNlbGwpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQWN0aXZlQ2VsbE5vcm1hbCgpIHtcbiAgICBpZiAoIWN1cnJlbnRFZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJpZ2dlcihzZWxmLm9uQmVmb3JlQ2VsbEVkaXRvckRlc3Ryb3ksIHtlZGl0b3I6IGN1cnJlbnRFZGl0b3J9KTtcbiAgICBjdXJyZW50RWRpdG9yLmRlc3Ryb3koKTtcbiAgICBjdXJyZW50RWRpdG9yID0gbnVsbDtcblxuICAgIGlmIChhY3RpdmVDZWxsTm9kZSkge1xuICAgICAgdmFyIGQgPSBnZXREYXRhSXRlbShhY3RpdmVSb3cpO1xuICAgICAgJChhY3RpdmVDZWxsTm9kZSkucmVtb3ZlQ2xhc3MoXCJlZGl0YWJsZSBpbnZhbGlkXCIpO1xuICAgICAgaWYgKGQpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNbYWN0aXZlQ2VsbF07XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBnZXRGb3JtYXR0ZXIoYWN0aXZlUm93LCBjb2x1bW4pO1xuICAgICAgICBhY3RpdmVDZWxsTm9kZS5pbm5lckhUTUwgPSBmb3JtYXR0ZXIoYWN0aXZlUm93LCBhY3RpdmVDZWxsLCBnZXREYXRhSXRlbVZhbHVlRm9yQ29sdW1uKGQsIGNvbHVtbiksIGNvbHVtbiwgZCk7XG4gICAgICAgIGludmFsaWRhdGVQb3N0UHJvY2Vzc2luZ1Jlc3VsdHMoYWN0aXZlUm93KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBwcmV2aW91c2x5IHdhcyB0ZXh0IHNlbGVjdGVkIG9uIGEgcGFnZSAoc3VjaCBhcyBzZWxlY3RlZCB0ZXh0IGluIHRoZSBlZGl0IGNlbGwganVzdCByZW1vdmVkKSxcbiAgICAvLyBJRSBjYW4ndCBzZXQgZm9jdXMgdG8gYW55dGhpbmcgZWxzZSBjb3JyZWN0bHlcbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9tc2llLykpIHtcbiAgICAgIGNsZWFyVGV4dFNlbGVjdGlvbigpO1xuICAgIH1cblxuICAgIGdldEVkaXRvckxvY2soKS5kZWFjdGl2YXRlKGVkaXRDb250cm9sbGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VBY3RpdmVDZWxsRWRpdGFibGUoZWRpdG9yKSB7XG4gICAgaWYgKCFhY3RpdmVDZWxsTm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuZWRpdGFibGUpIHtcbiAgICAgIHRocm93IFwiR3JpZCA6IG1ha2VBY3RpdmVDZWxsRWRpdGFibGUgOiBzaG91bGQgbmV2ZXIgZ2V0IGNhbGxlZCB3aGVuIG9wdGlvbnMuZWRpdGFibGUgaXMgZmFsc2VcIjtcbiAgICB9XG5cbiAgICAvLyBjYW5jZWwgcGVuZGluZyBhc3luYyBjYWxsIGlmIHRoZXJlIGlzIG9uZVxuICAgIGNsZWFyVGltZW91dChoX2VkaXRvckxvYWRlcik7XG5cbiAgICBpZiAoIWlzQ2VsbFBvdGVudGlhbGx5RWRpdGFibGUoYWN0aXZlUm93LCBhY3RpdmVDZWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb2x1bW5EZWYgPSBjb2x1bW5zW2FjdGl2ZUNlbGxdO1xuICAgIHZhciBpdGVtID0gZ2V0RGF0YUl0ZW0oYWN0aXZlUm93KTtcblxuICAgIGlmICh0cmlnZ2VyKHNlbGYub25CZWZvcmVFZGl0Q2VsbCwge3JvdzogYWN0aXZlUm93LCBjZWxsOiBhY3RpdmVDZWxsLCBpdGVtOiBpdGVtLCBjb2x1bW46IGNvbHVtbkRlZn0pID09PSBmYWxzZSkge1xuICAgICAgc2V0Rm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZXRFZGl0b3JMb2NrKCkuYWN0aXZhdGUoZWRpdENvbnRyb2xsZXIpO1xuICAgICQoYWN0aXZlQ2VsbE5vZGUpLmFkZENsYXNzKFwiZWRpdGFibGVcIik7XG5cbiAgICAvLyBkb24ndCBjbGVhciB0aGUgY2VsbCBpZiBhIGN1c3RvbSBlZGl0b3IgaXMgcGFzc2VkIHRocm91Z2hcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgYWN0aXZlQ2VsbE5vZGUuaW5uZXJIVE1MID0gXCJcIjtcbiAgICB9XG5cbiAgICBjdXJyZW50RWRpdG9yID0gbmV3IChlZGl0b3IgfHwgZ2V0RWRpdG9yKGFjdGl2ZVJvdywgYWN0aXZlQ2VsbCkpKHtcbiAgICAgIGdyaWQ6IHNlbGYsXG4gICAgICBncmlkUG9zaXRpb246IGFic0JveCgkY29udGFpbmVyWzBdKSxcbiAgICAgIHBvc2l0aW9uOiBhYnNCb3goYWN0aXZlQ2VsbE5vZGUpLFxuICAgICAgY29udGFpbmVyOiBhY3RpdmVDZWxsTm9kZSxcbiAgICAgIGNvbHVtbjogY29sdW1uRGVmLFxuICAgICAgaXRlbTogaXRlbSB8fCB7fSxcbiAgICAgIGNvbW1pdENoYW5nZXM6IGNvbW1pdEVkaXRBbmRTZXRGb2N1cyxcbiAgICAgIGNhbmNlbENoYW5nZXM6IGNhbmNlbEVkaXRBbmRTZXRGb2N1c1xuICAgIH0pO1xuXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGN1cnJlbnRFZGl0b3IubG9hZFZhbHVlKGl0ZW0pO1xuICAgIH1cblxuICAgIHNlcmlhbGl6ZWRFZGl0b3JWYWx1ZSA9IGN1cnJlbnRFZGl0b3Iuc2VyaWFsaXplVmFsdWUoKTtcblxuICAgIGlmIChjdXJyZW50RWRpdG9yLnBvc2l0aW9uKSB7XG4gICAgICBoYW5kbGVBY3RpdmVDZWxsUG9zaXRpb25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRFZGl0QW5kU2V0Rm9jdXMoKSB7XG4gICAgLy8gaWYgdGhlIGNvbW1pdCBmYWlscywgaXQgd291bGQgZG8gc28gZHVlIHRvIGEgdmFsaWRhdGlvbiBlcnJvclxuICAgIC8vIGlmIHNvLCBkbyBub3Qgc3RlYWwgdGhlIGZvY3VzIGZyb20gdGhlIGVkaXRvclxuICAgIGlmIChnZXRFZGl0b3JMb2NrKCkuY29tbWl0Q3VycmVudEVkaXQoKSkge1xuICAgICAgc2V0Rm9jdXMoKTtcbiAgICAgIGlmIChvcHRpb25zLmF1dG9FZGl0KSB7XG4gICAgICAgIG5hdmlnYXRlRG93bigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEVkaXRBbmRTZXRGb2N1cygpIHtcbiAgICBpZiAoZ2V0RWRpdG9yTG9jaygpLmNhbmNlbEN1cnJlbnRFZGl0KCkpIHtcbiAgICAgIHNldEZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWJzQm94KGVsZW0pIHtcbiAgICB2YXIgYm94ID0ge1xuICAgICAgdG9wOiBlbGVtLm9mZnNldFRvcCxcbiAgICAgIGxlZnQ6IGVsZW0ub2Zmc2V0TGVmdCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgd2lkdGg6ICQoZWxlbSkub3V0ZXJXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiAkKGVsZW0pLm91dGVySGVpZ2h0KCksXG4gICAgICB2aXNpYmxlOiB0cnVlfTtcbiAgICBib3guYm90dG9tID0gYm94LnRvcCArIGJveC5oZWlnaHQ7XG4gICAgYm94LnJpZ2h0ID0gYm94LmxlZnQgKyBib3gud2lkdGg7XG5cbiAgICAvLyB3YWxrIHVwIHRoZSB0cmVlXG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuICAgIHdoaWxlICgoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgIT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgaWYgKGJveC52aXNpYmxlICYmIGVsZW0uc2Nyb2xsSGVpZ2h0ICE9IGVsZW0ub2Zmc2V0SGVpZ2h0ICYmICQoZWxlbSkuY3NzKFwib3ZlcmZsb3dZXCIpICE9IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIGJveC52aXNpYmxlID0gYm94LmJvdHRvbSA+IGVsZW0uc2Nyb2xsVG9wICYmIGJveC50b3AgPCBlbGVtLnNjcm9sbFRvcCArIGVsZW0uY2xpZW50SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYm94LnZpc2libGUgJiYgZWxlbS5zY3JvbGxXaWR0aCAhPSBlbGVtLm9mZnNldFdpZHRoICYmICQoZWxlbSkuY3NzKFwib3ZlcmZsb3dYXCIpICE9IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIGJveC52aXNpYmxlID0gYm94LnJpZ2h0ID4gZWxlbS5zY3JvbGxMZWZ0ICYmIGJveC5sZWZ0IDwgZWxlbS5zY3JvbGxMZWZ0ICsgZWxlbS5jbGllbnRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgYm94LmxlZnQgLT0gZWxlbS5zY3JvbGxMZWZ0O1xuICAgICAgYm94LnRvcCAtPSBlbGVtLnNjcm9sbFRvcDtcblxuICAgICAgaWYgKGVsZW0gPT09IG9mZnNldFBhcmVudCkge1xuICAgICAgICBib3gubGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG4gICAgICAgIGJveC50b3AgKz0gZWxlbS5vZmZzZXRUb3A7XG4gICAgICAgIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuICAgICAgfVxuXG4gICAgICBib3guYm90dG9tID0gYm94LnRvcCArIGJveC5oZWlnaHQ7XG4gICAgICBib3gucmlnaHQgPSBib3gubGVmdCArIGJveC53aWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm94O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWN0aXZlQ2VsbFBvc2l0aW9uKCkge1xuICAgIHJldHVybiBhYnNCb3goYWN0aXZlQ2VsbE5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0R3JpZFBvc2l0aW9uKCkge1xuICAgIHJldHVybiBhYnNCb3goJGNvbnRhaW5lclswXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFjdGl2ZUNlbGxQb3NpdGlvbkNoYW5nZSgpIHtcbiAgICBpZiAoIWFjdGl2ZUNlbGxOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJpZ2dlcihzZWxmLm9uQWN0aXZlQ2VsbFBvc2l0aW9uQ2hhbmdlZCwge30pO1xuXG4gICAgaWYgKGN1cnJlbnRFZGl0b3IpIHtcbiAgICAgIHZhciBjZWxsQm94ID0gZ2V0QWN0aXZlQ2VsbFBvc2l0aW9uKCk7XG4gICAgICBpZiAoY3VycmVudEVkaXRvci5zaG93ICYmIGN1cnJlbnRFZGl0b3IuaGlkZSkge1xuICAgICAgICBpZiAoIWNlbGxCb3gudmlzaWJsZSkge1xuICAgICAgICAgIGN1cnJlbnRFZGl0b3IuaGlkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRFZGl0b3Iuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50RWRpdG9yLnBvc2l0aW9uKSB7XG4gICAgICAgIGN1cnJlbnRFZGl0b3IucG9zaXRpb24oY2VsbEJveCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2VsbEVkaXRvcigpIHtcbiAgICByZXR1cm4gY3VycmVudEVkaXRvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFjdGl2ZUNlbGwoKSB7XG4gICAgaWYgKCFhY3RpdmVDZWxsTm9kZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7cm93OiBhY3RpdmVSb3csIGNlbGw6IGFjdGl2ZUNlbGx9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFjdGl2ZUNlbGxOb2RlKCkge1xuICAgIHJldHVybiBhY3RpdmVDZWxsTm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFJvd0ludG9WaWV3KHJvdywgZG9QYWdpbmcpIHtcbiAgICB2YXIgcm93QXRUb3AgPSByb3cgKiBvcHRpb25zLnJvd0hlaWdodDtcbiAgICB2YXIgcm93QXRCb3R0b20gPSAocm93ICsgMSkgKiBvcHRpb25zLnJvd0hlaWdodCAtIHZpZXdwb3J0SCArICh2aWV3cG9ydEhhc0hTY3JvbGwgPyBzY3JvbGxiYXJEaW1lbnNpb25zLmhlaWdodCA6IDApO1xuXG4gICAgLy8gbmVlZCB0byBwYWdlIGRvd24/XG4gICAgaWYgKChyb3cgKyAxKSAqIG9wdGlvbnMucm93SGVpZ2h0ID4gc2Nyb2xsVG9wICsgdmlld3BvcnRIICsgb2Zmc2V0KSB7XG4gICAgICBzY3JvbGxUbyhkb1BhZ2luZyA/IHJvd0F0VG9wIDogcm93QXRCb3R0b20pO1xuICAgICAgcmVuZGVyKCk7XG4gICAgfVxuICAgIC8vIG9yIHBhZ2UgdXA/XG4gICAgZWxzZSBpZiAocm93ICogb3B0aW9ucy5yb3dIZWlnaHQgPCBzY3JvbGxUb3AgKyBvZmZzZXQpIHtcbiAgICAgIHNjcm9sbFRvKGRvUGFnaW5nID8gcm93QXRCb3R0b20gOiByb3dBdFRvcCk7XG4gICAgICByZW5kZXIoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxSb3dUb1RvcChyb3cpIHtcbiAgICBzY3JvbGxUbyhyb3cgKiBvcHRpb25zLnJvd0hlaWdodCk7XG4gICAgcmVuZGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxQYWdlKGRpcikge1xuICAgIHZhciBkZWx0YVJvd3MgPSBkaXIgKiBudW1WaXNpYmxlUm93cztcbiAgICBzY3JvbGxUbygoZ2V0Um93RnJvbVBvc2l0aW9uKHNjcm9sbFRvcCkgKyBkZWx0YVJvd3MpICogb3B0aW9ucy5yb3dIZWlnaHQpO1xuICAgIHJlbmRlcigpO1xuXG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlQ2VsbE5hdmlnYXRpb24gJiYgYWN0aXZlUm93ICE9IG51bGwpIHtcbiAgICAgIHZhciByb3cgPSBhY3RpdmVSb3cgKyBkZWx0YVJvd3M7XG4gICAgICB2YXIgZGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldyA9IGdldERhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcoKTtcbiAgICAgIGlmIChyb3cgPj0gZGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldykge1xuICAgICAgICByb3cgPSBkYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3IC0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3cgPCAwKSB7XG4gICAgICAgIHJvdyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBjZWxsID0gMCwgcHJldkNlbGwgPSBudWxsO1xuICAgICAgdmFyIHByZXZBY3RpdmVQb3NYID0gYWN0aXZlUG9zWDtcbiAgICAgIHdoaWxlIChjZWxsIDw9IGFjdGl2ZVBvc1gpIHtcbiAgICAgICAgaWYgKGNhbkNlbGxCZUFjdGl2ZShyb3csIGNlbGwpKSB7XG4gICAgICAgICAgcHJldkNlbGwgPSBjZWxsO1xuICAgICAgICB9XG4gICAgICAgIGNlbGwgKz0gZ2V0Q29sc3Bhbihyb3csIGNlbGwpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldkNlbGwgIT09IG51bGwpIHtcbiAgICAgICAgc2V0QWN0aXZlQ2VsbEludGVybmFsKGdldENlbGxOb2RlKHJvdywgcHJldkNlbGwpKTtcbiAgICAgICAgYWN0aXZlUG9zWCA9IHByZXZBY3RpdmVQb3NYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRBY3RpdmVDZWxsKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmF2aWdhdGVQYWdlRG93bigpIHtcbiAgICBzY3JvbGxQYWdlKDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmF2aWdhdGVQYWdlVXAoKSB7XG4gICAgc2Nyb2xsUGFnZSgtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb2xzcGFuKHJvdywgY2VsbCkge1xuICAgIHZhciBtZXRhZGF0YSA9IGRhdGEuZ2V0SXRlbU1ldGFkYXRhICYmIGRhdGEuZ2V0SXRlbU1ldGFkYXRhKHJvdyk7XG4gICAgaWYgKCFtZXRhZGF0YSB8fCAhbWV0YWRhdGEuY29sdW1ucykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgdmFyIGNvbHVtbkRhdGEgPSBtZXRhZGF0YS5jb2x1bW5zW2NvbHVtbnNbY2VsbF0uaWRdIHx8IG1ldGFkYXRhLmNvbHVtbnNbY2VsbF07XG4gICAgdmFyIGNvbHNwYW4gPSAoY29sdW1uRGF0YSAmJiBjb2x1bW5EYXRhLmNvbHNwYW4pO1xuICAgIGlmIChjb2xzcGFuID09PSBcIipcIikge1xuICAgICAgY29sc3BhbiA9IGNvbHVtbnMubGVuZ3RoIC0gY2VsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sc3BhbiA9IGNvbHNwYW4gfHwgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sc3BhbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRGaXJzdEZvY3VzYWJsZUNlbGwocm93KSB7XG4gICAgdmFyIGNlbGwgPSAwO1xuICAgIHdoaWxlIChjZWxsIDwgY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIGlmIChjYW5DZWxsQmVBY3RpdmUocm93LCBjZWxsKSkge1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgIH1cbiAgICAgIGNlbGwgKz0gZ2V0Q29sc3Bhbihyb3csIGNlbGwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRMYXN0Rm9jdXNhYmxlQ2VsbChyb3cpIHtcbiAgICB2YXIgY2VsbCA9IDA7XG4gICAgdmFyIGxhc3RGb2N1c2FibGVDZWxsID0gbnVsbDtcbiAgICB3aGlsZSAoY2VsbCA8IGNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICBpZiAoY2FuQ2VsbEJlQWN0aXZlKHJvdywgY2VsbCkpIHtcbiAgICAgICAgbGFzdEZvY3VzYWJsZUNlbGwgPSBjZWxsO1xuICAgICAgfVxuICAgICAgY2VsbCArPSBnZXRDb2xzcGFuKHJvdywgY2VsbCk7XG4gICAgfVxuICAgIHJldHVybiBsYXN0Rm9jdXNhYmxlQ2VsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvdG9SaWdodChyb3csIGNlbGwsIHBvc1gpIHtcbiAgICBpZiAoY2VsbCA+PSBjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgY2VsbCArPSBnZXRDb2xzcGFuKHJvdywgY2VsbCk7XG4gICAgfVxuICAgIHdoaWxlIChjZWxsIDwgY29sdW1ucy5sZW5ndGggJiYgIWNhbkNlbGxCZUFjdGl2ZShyb3csIGNlbGwpKTtcblxuICAgIGlmIChjZWxsIDwgY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFwicm93XCI6IHJvdyxcbiAgICAgICAgXCJjZWxsXCI6IGNlbGwsXG4gICAgICAgIFwicG9zWFwiOiBjZWxsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvdG9MZWZ0KHJvdywgY2VsbCwgcG9zWCkge1xuICAgIGlmIChjZWxsIDw9IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmaXJzdEZvY3VzYWJsZUNlbGwgPSBmaW5kRmlyc3RGb2N1c2FibGVDZWxsKHJvdyk7XG4gICAgaWYgKGZpcnN0Rm9jdXNhYmxlQ2VsbCA9PT0gbnVsbCB8fCBmaXJzdEZvY3VzYWJsZUNlbGwgPj0gY2VsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHByZXYgPSB7XG4gICAgICBcInJvd1wiOiByb3csXG4gICAgICBcImNlbGxcIjogZmlyc3RGb2N1c2FibGVDZWxsLFxuICAgICAgXCJwb3NYXCI6IGZpcnN0Rm9jdXNhYmxlQ2VsbFxuICAgIH07XG4gICAgdmFyIHBvcztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgcG9zID0gZ290b1JpZ2h0KHByZXYucm93LCBwcmV2LmNlbGwsIHByZXYucG9zWCk7XG4gICAgICBpZiAoIXBvcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3MuY2VsbCA+PSBjZWxsKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuICAgICAgcHJldiA9IHBvcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnb3RvRG93bihyb3csIGNlbGwsIHBvc1gpIHtcbiAgICB2YXIgcHJldkNlbGw7XG4gICAgdmFyIGRhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcgPSBnZXREYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICgrK3JvdyA+PSBkYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBwcmV2Q2VsbCA9IGNlbGwgPSAwO1xuICAgICAgd2hpbGUgKGNlbGwgPD0gcG9zWCkge1xuICAgICAgICBwcmV2Q2VsbCA9IGNlbGw7XG4gICAgICAgIGNlbGwgKz0gZ2V0Q29sc3Bhbihyb3csIGNlbGwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuQ2VsbEJlQWN0aXZlKHJvdywgcHJldkNlbGwpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgXCJyb3dcIjogcm93LFxuICAgICAgICAgIFwiY2VsbFwiOiBwcmV2Q2VsbCxcbiAgICAgICAgICBcInBvc1hcIjogcG9zWFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdvdG9VcChyb3csIGNlbGwsIHBvc1gpIHtcbiAgICB2YXIgcHJldkNlbGw7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICgtLXJvdyA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHByZXZDZWxsID0gY2VsbCA9IDA7XG4gICAgICB3aGlsZSAoY2VsbCA8PSBwb3NYKSB7XG4gICAgICAgIHByZXZDZWxsID0gY2VsbDtcbiAgICAgICAgY2VsbCArPSBnZXRDb2xzcGFuKHJvdywgY2VsbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5DZWxsQmVBY3RpdmUocm93LCBwcmV2Q2VsbCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcInJvd1wiOiByb3csXG4gICAgICAgICAgXCJjZWxsXCI6IHByZXZDZWxsLFxuICAgICAgICAgIFwicG9zWFwiOiBwb3NYXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ290b05leHQocm93LCBjZWxsLCBwb3NYKSB7XG4gICAgaWYgKHJvdyA9PSBudWxsICYmIGNlbGwgPT0gbnVsbCkge1xuICAgICAgcm93ID0gY2VsbCA9IHBvc1ggPSAwO1xuICAgICAgaWYgKGNhbkNlbGxCZUFjdGl2ZShyb3csIGNlbGwpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgXCJyb3dcIjogcm93LFxuICAgICAgICAgIFwiY2VsbFwiOiBjZWxsLFxuICAgICAgICAgIFwicG9zWFwiOiBjZWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IGdvdG9SaWdodChyb3csIGNlbGwsIHBvc1gpO1xuICAgIGlmIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0Rm9jdXNhYmxlQ2VsbCA9IG51bGw7XG4gICAgdmFyIGRhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcgPSBnZXREYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KCk7XG4gICAgd2hpbGUgKCsrcm93IDwgZGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldykge1xuICAgICAgZmlyc3RGb2N1c2FibGVDZWxsID0gZmluZEZpcnN0Rm9jdXNhYmxlQ2VsbChyb3cpO1xuICAgICAgaWYgKGZpcnN0Rm9jdXNhYmxlQ2VsbCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFwicm93XCI6IHJvdyxcbiAgICAgICAgICBcImNlbGxcIjogZmlyc3RGb2N1c2FibGVDZWxsLFxuICAgICAgICAgIFwicG9zWFwiOiBmaXJzdEZvY3VzYWJsZUNlbGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnb3RvUHJldihyb3csIGNlbGwsIHBvc1gpIHtcbiAgICBpZiAocm93ID09IG51bGwgJiYgY2VsbCA9PSBudWxsKSB7XG4gICAgICByb3cgPSBnZXREYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KCkgLSAxO1xuICAgICAgY2VsbCA9IHBvc1ggPSBjb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoY2FuQ2VsbEJlQWN0aXZlKHJvdywgY2VsbCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcInJvd1wiOiByb3csXG4gICAgICAgICAgXCJjZWxsXCI6IGNlbGwsXG4gICAgICAgICAgXCJwb3NYXCI6IGNlbGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcG9zO1xuICAgIHZhciBsYXN0U2VsZWN0YWJsZUNlbGw7XG4gICAgd2hpbGUgKCFwb3MpIHtcbiAgICAgIHBvcyA9IGdvdG9MZWZ0KHJvdywgY2VsbCwgcG9zWCk7XG4gICAgICBpZiAocG9zKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKC0tcm93IDwgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY2VsbCA9IDA7XG4gICAgICBsYXN0U2VsZWN0YWJsZUNlbGwgPSBmaW5kTGFzdEZvY3VzYWJsZUNlbGwocm93KTtcbiAgICAgIGlmIChsYXN0U2VsZWN0YWJsZUNlbGwgIT09IG51bGwpIHtcbiAgICAgICAgcG9zID0ge1xuICAgICAgICAgIFwicm93XCI6IHJvdyxcbiAgICAgICAgICBcImNlbGxcIjogbGFzdFNlbGVjdGFibGVDZWxsLFxuICAgICAgICAgIFwicG9zWFwiOiBsYXN0U2VsZWN0YWJsZUNlbGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG5hdmlnYXRlUmlnaHQoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRlKFwicmlnaHRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBuYXZpZ2F0ZUxlZnQoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRlKFwibGVmdFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5hdmlnYXRlRG93bigpIHtcbiAgICByZXR1cm4gbmF2aWdhdGUoXCJkb3duXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmF2aWdhdGVVcCgpIHtcbiAgICByZXR1cm4gbmF2aWdhdGUoXCJ1cFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5hdmlnYXRlTmV4dCgpIHtcbiAgICByZXR1cm4gbmF2aWdhdGUoXCJuZXh0XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmF2aWdhdGVQcmV2KCkge1xuICAgIHJldHVybiBuYXZpZ2F0ZShcInByZXZcIik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpciBOYXZpZ2F0aW9uIGRpcmVjdGlvbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBuYXZpZ2F0aW9uIHJlc3VsdGVkIGluIGEgY2hhbmdlIG9mIGFjdGl2ZSBjZWxsLlxuICAgKi9cbiAgZnVuY3Rpb24gbmF2aWdhdGUoZGlyKSB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZUNlbGxOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmVDZWxsTm9kZSAmJiBkaXIgIT0gXCJwcmV2XCIgJiYgZGlyICE9IFwibmV4dFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFnZXRFZGl0b3JMb2NrKCkuY29tbWl0Q3VycmVudEVkaXQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNldEZvY3VzKCk7XG5cbiAgICB2YXIgdGFiYmluZ0RpcmVjdGlvbnMgPSB7XG4gICAgICBcInVwXCI6IC0xLFxuICAgICAgXCJkb3duXCI6IDEsXG4gICAgICBcImxlZnRcIjogLTEsXG4gICAgICBcInJpZ2h0XCI6IDEsXG4gICAgICBcInByZXZcIjogLTEsXG4gICAgICBcIm5leHRcIjogMVxuICAgIH07XG4gICAgdGFiYmluZ0RpcmVjdGlvbiA9IHRhYmJpbmdEaXJlY3Rpb25zW2Rpcl07XG5cbiAgICB2YXIgc3RlcEZ1bmN0aW9ucyA9IHtcbiAgICAgIFwidXBcIjogZ290b1VwLFxuICAgICAgXCJkb3duXCI6IGdvdG9Eb3duLFxuICAgICAgXCJsZWZ0XCI6IGdvdG9MZWZ0LFxuICAgICAgXCJyaWdodFwiOiBnb3RvUmlnaHQsXG4gICAgICBcInByZXZcIjogZ290b1ByZXYsXG4gICAgICBcIm5leHRcIjogZ290b05leHRcbiAgICB9O1xuICAgIHZhciBzdGVwRm4gPSBzdGVwRnVuY3Rpb25zW2Rpcl07XG4gICAgdmFyIHBvcyA9IHN0ZXBGbihhY3RpdmVSb3csIGFjdGl2ZUNlbGwsIGFjdGl2ZVBvc1gpO1xuICAgIGlmIChwb3MpIHtcbiAgICAgIHZhciBpc0FkZE5ld1JvdyA9IChwb3Mucm93ID09IGdldERhdGFMZW5ndGgoKSk7XG4gICAgICBzY3JvbGxDZWxsSW50b1ZpZXcocG9zLnJvdywgcG9zLmNlbGwsICFpc0FkZE5ld1Jvdyk7XG4gICAgICBzZXRBY3RpdmVDZWxsSW50ZXJuYWwoZ2V0Q2VsbE5vZGUocG9zLnJvdywgcG9zLmNlbGwpKTtcbiAgICAgIGFjdGl2ZVBvc1ggPSBwb3MucG9zWDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRBY3RpdmVDZWxsSW50ZXJuYWwoZ2V0Q2VsbE5vZGUoYWN0aXZlUm93LCBhY3RpdmVDZWxsKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2VsbE5vZGUocm93LCBjZWxsKSB7XG4gICAgaWYgKHJvd3NDYWNoZVtyb3ddKSB7XG4gICAgICBlbnN1cmVDZWxsTm9kZXNJblJvd3NDYWNoZShyb3cpO1xuICAgICAgcmV0dXJuIHJvd3NDYWNoZVtyb3ddLmNlbGxOb2Rlc0J5Q29sdW1uSWR4W2NlbGxdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEFjdGl2ZUNlbGwocm93LCBjZWxsKSB7XG4gICAgaWYgKCFpbml0aWFsaXplZCkgeyByZXR1cm47IH1cbiAgICBpZiAocm93ID4gZ2V0RGF0YUxlbmd0aCgpIHx8IHJvdyA8IDAgfHwgY2VsbCA+PSBjb2x1bW5zLmxlbmd0aCB8fCBjZWxsIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5lbmFibGVDZWxsTmF2aWdhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjcm9sbENlbGxJbnRvVmlldyhyb3csIGNlbGwsIGZhbHNlKTtcbiAgICBzZXRBY3RpdmVDZWxsSW50ZXJuYWwoZ2V0Q2VsbE5vZGUocm93LCBjZWxsKSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuQ2VsbEJlQWN0aXZlKHJvdywgY2VsbCkge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVDZWxsTmF2aWdhdGlvbiB8fCByb3cgPj0gZ2V0RGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldygpIHx8XG4gICAgICAgIHJvdyA8IDAgfHwgY2VsbCA+PSBjb2x1bW5zLmxlbmd0aCB8fCBjZWxsIDwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByb3dNZXRhZGF0YSA9IGRhdGEuZ2V0SXRlbU1ldGFkYXRhICYmIGRhdGEuZ2V0SXRlbU1ldGFkYXRhKHJvdyk7XG4gICAgaWYgKHJvd01ldGFkYXRhICYmIHR5cGVvZiByb3dNZXRhZGF0YS5mb2N1c2FibGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm93TWV0YWRhdGEuZm9jdXNhYmxlO1xuICAgIH1cblxuICAgIHZhciBjb2x1bW5NZXRhZGF0YSA9IHJvd01ldGFkYXRhICYmIHJvd01ldGFkYXRhLmNvbHVtbnM7XG4gICAgaWYgKGNvbHVtbk1ldGFkYXRhICYmIGNvbHVtbk1ldGFkYXRhW2NvbHVtbnNbY2VsbF0uaWRdICYmIHR5cGVvZiBjb2x1bW5NZXRhZGF0YVtjb2x1bW5zW2NlbGxdLmlkXS5mb2N1c2FibGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gY29sdW1uTWV0YWRhdGFbY29sdW1uc1tjZWxsXS5pZF0uZm9jdXNhYmxlO1xuICAgIH1cbiAgICBpZiAoY29sdW1uTWV0YWRhdGEgJiYgY29sdW1uTWV0YWRhdGFbY2VsbF0gJiYgdHlwZW9mIGNvbHVtbk1ldGFkYXRhW2NlbGxdLmZvY3VzYWJsZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBjb2x1bW5NZXRhZGF0YVtjZWxsXS5mb2N1c2FibGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbHVtbnNbY2VsbF0uZm9jdXNhYmxlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuQ2VsbEJlU2VsZWN0ZWQocm93LCBjZWxsKSB7XG4gICAgaWYgKHJvdyA+PSBnZXREYXRhTGVuZ3RoKCkgfHwgcm93IDwgMCB8fCBjZWxsID49IGNvbHVtbnMubGVuZ3RoIHx8IGNlbGwgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJvd01ldGFkYXRhID0gZGF0YS5nZXRJdGVtTWV0YWRhdGEgJiYgZGF0YS5nZXRJdGVtTWV0YWRhdGEocm93KTtcbiAgICBpZiAocm93TWV0YWRhdGEgJiYgdHlwZW9mIHJvd01ldGFkYXRhLnNlbGVjdGFibGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm93TWV0YWRhdGEuc2VsZWN0YWJsZTtcbiAgICB9XG5cbiAgICB2YXIgY29sdW1uTWV0YWRhdGEgPSByb3dNZXRhZGF0YSAmJiByb3dNZXRhZGF0YS5jb2x1bW5zICYmIChyb3dNZXRhZGF0YS5jb2x1bW5zW2NvbHVtbnNbY2VsbF0uaWRdIHx8IHJvd01ldGFkYXRhLmNvbHVtbnNbY2VsbF0pO1xuICAgIGlmIChjb2x1bW5NZXRhZGF0YSAmJiB0eXBlb2YgY29sdW1uTWV0YWRhdGEuc2VsZWN0YWJsZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBjb2x1bW5NZXRhZGF0YS5zZWxlY3RhYmxlO1xuICAgIH1cblxuICAgIHJldHVybiBjb2x1bW5zW2NlbGxdLnNlbGVjdGFibGU7XG4gIH1cblxuICBmdW5jdGlvbiBnb3RvQ2VsbChyb3csIGNlbGwsIGZvcmNlRWRpdCkge1xuICAgIGlmICghaW5pdGlhbGl6ZWQpIHsgcmV0dXJuOyB9XG4gICAgaWYgKCFjYW5DZWxsQmVBY3RpdmUocm93LCBjZWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY3JvbGxDZWxsSW50b1ZpZXcocm93LCBjZWxsLCBmYWxzZSk7XG5cbiAgICB2YXIgbmV3Q2VsbCA9IGdldENlbGxOb2RlKHJvdywgY2VsbCk7XG5cbiAgICAvLyBpZiBzZWxlY3RpbmcgdGhlICdhZGQgbmV3JyByb3csIHN0YXJ0IGVkaXRpbmcgcmlnaHQgYXdheVxuICAgIHNldEFjdGl2ZUNlbGxJbnRlcm5hbChuZXdDZWxsLCBmb3JjZUVkaXQgfHwgKHJvdyA9PT0gZ2V0RGF0YUxlbmd0aCgpKSB8fCBvcHRpb25zLmF1dG9FZGl0KTtcblxuICAgIC8vIGlmIG5vIGVkaXRvciB3YXMgY3JlYXRlZCwgc2V0IHRoZSBmb2N1cyBiYWNrIG9uIHRoZSBncmlkXG4gICAgaWYgKCFjdXJyZW50RWRpdG9yKSB7XG4gICAgICBzZXRGb2N1cygpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBJRWRpdG9yIGltcGxlbWVudGF0aW9uIGZvciB0aGUgZWRpdG9yIGxvY2tcblxuICBmdW5jdGlvbiBjb21taXRDdXJyZW50RWRpdCgpIHtcbiAgICB2YXIgaXRlbSA9IGdldERhdGFJdGVtKGFjdGl2ZVJvdyk7XG4gICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNbYWN0aXZlQ2VsbF07XG5cbiAgICBpZiAoY3VycmVudEVkaXRvcikge1xuICAgICAgaWYgKGN1cnJlbnRFZGl0b3IuaXNWYWx1ZUNoYW5nZWQoKSkge1xuICAgICAgICB2YXIgdmFsaWRhdGlvblJlc3VsdHMgPSBjdXJyZW50RWRpdG9yLnZhbGlkYXRlKCk7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHRzLnZhbGlkKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZVJvdyA8IGdldERhdGFMZW5ndGgoKSkge1xuICAgICAgICAgICAgdmFyIGVkaXRDb21tYW5kID0ge1xuICAgICAgICAgICAgICByb3c6IGFjdGl2ZVJvdyxcbiAgICAgICAgICAgICAgY2VsbDogYWN0aXZlQ2VsbCxcbiAgICAgICAgICAgICAgZWRpdG9yOiBjdXJyZW50RWRpdG9yLFxuICAgICAgICAgICAgICBzZXJpYWxpemVkVmFsdWU6IGN1cnJlbnRFZGl0b3Iuc2VyaWFsaXplVmFsdWUoKSxcbiAgICAgICAgICAgICAgcHJldlNlcmlhbGl6ZWRWYWx1ZTogc2VyaWFsaXplZEVkaXRvclZhbHVlLFxuICAgICAgICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuYXBwbHlWYWx1ZShpdGVtLCB0aGlzLnNlcmlhbGl6ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlUm93KHRoaXMucm93KTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHNlbGYub25DZWxsQ2hhbmdlLCB7XG4gICAgICAgICAgICAgICAgICByb3c6IGFjdGl2ZVJvdyxcbiAgICAgICAgICAgICAgICAgIGNlbGw6IGFjdGl2ZUNlbGwsXG4gICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHVuZG86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5hcHBseVZhbHVlKGl0ZW0sIHRoaXMucHJldlNlcmlhbGl6ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlUm93KHRoaXMucm93KTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHNlbGYub25DZWxsQ2hhbmdlLCB7XG4gICAgICAgICAgICAgICAgICByb3c6IGFjdGl2ZVJvdyxcbiAgICAgICAgICAgICAgICAgIGNlbGw6IGFjdGl2ZUNlbGwsXG4gICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVkaXRDb21tYW5kSGFuZGxlcikge1xuICAgICAgICAgICAgICBtYWtlQWN0aXZlQ2VsbE5vcm1hbCgpO1xuICAgICAgICAgICAgICBvcHRpb25zLmVkaXRDb21tYW5kSGFuZGxlcihpdGVtLCBjb2x1bW4sIGVkaXRDb21tYW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVkaXRDb21tYW5kLmV4ZWN1dGUoKTtcbiAgICAgICAgICAgICAgbWFrZUFjdGl2ZUNlbGxOb3JtYWwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3SXRlbSA9IHt9O1xuICAgICAgICAgICAgY3VycmVudEVkaXRvci5hcHBseVZhbHVlKG5ld0l0ZW0sIGN1cnJlbnRFZGl0b3Iuc2VyaWFsaXplVmFsdWUoKSk7XG4gICAgICAgICAgICBtYWtlQWN0aXZlQ2VsbE5vcm1hbCgpO1xuICAgICAgICAgICAgdHJpZ2dlcihzZWxmLm9uQWRkTmV3Um93LCB7aXRlbTogbmV3SXRlbSwgY29sdW1uOiBjb2x1bW59KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBsb2NrIGhhcyBiZWVuIHJlLWFjcXVpcmVkIGJ5IGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgcmV0dXJuICFnZXRFZGl0b3JMb2NrKCkuaXNBY3RpdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZS1hZGQgdGhlIENTUyBjbGFzcyB0byB0cmlnZ2VyIHRyYW5zaXRpb25zLCBpZiBhbnkuXG4gICAgICAgICAgJChhY3RpdmVDZWxsTm9kZSkucmVtb3ZlQ2xhc3MoXCJpbnZhbGlkXCIpO1xuICAgICAgICAgICQoYWN0aXZlQ2VsbE5vZGUpLndpZHRoKCk7ICAvLyBmb3JjZSBsYXlvdXRcbiAgICAgICAgICAkKGFjdGl2ZUNlbGxOb2RlKS5hZGRDbGFzcyhcImludmFsaWRcIik7XG5cbiAgICAgICAgICB0cmlnZ2VyKHNlbGYub25WYWxpZGF0aW9uRXJyb3IsIHtcbiAgICAgICAgICAgIGVkaXRvcjogY3VycmVudEVkaXRvcixcbiAgICAgICAgICAgIGNlbGxOb2RlOiBhY3RpdmVDZWxsTm9kZSxcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHRzOiB2YWxpZGF0aW9uUmVzdWx0cyxcbiAgICAgICAgICAgIHJvdzogYWN0aXZlUm93LFxuICAgICAgICAgICAgY2VsbDogYWN0aXZlQ2VsbCxcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjdXJyZW50RWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1ha2VBY3RpdmVDZWxsTm9ybWFsKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsQ3VycmVudEVkaXQoKSB7XG4gICAgbWFrZUFjdGl2ZUNlbGxOb3JtYWwoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJvd3NUb1Jhbmdlcyhyb3dzKSB7XG4gICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgIHZhciBsYXN0Q2VsbCA9IGNvbHVtbnMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJhbmdlcy5wdXNoKG5ldyBTbGljay5SYW5nZShyb3dzW2ldLCAwLCByb3dzW2ldLCBsYXN0Q2VsbCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VsZWN0ZWRSb3dzKCkge1xuICAgIGlmICghc2VsZWN0aW9uTW9kZWwpIHtcbiAgICAgIHRocm93IFwiU2VsZWN0aW9uIG1vZGVsIGlzIG5vdCBzZXRcIjtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkUm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGVkUm93cyhyb3dzKSB7XG4gICAgaWYgKCFzZWxlY3Rpb25Nb2RlbCkge1xuICAgICAgdGhyb3cgXCJTZWxlY3Rpb24gbW9kZWwgaXMgbm90IHNldFwiO1xuICAgIH1cbiAgICBzZWxlY3Rpb25Nb2RlbC5zZXRTZWxlY3RlZFJhbmdlcyhyb3dzVG9SYW5nZXMocm93cykpO1xuICB9XG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIERlYnVnXG5cbiAgdGhpcy5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IFwiXCI7XG5cbiAgICBzICs9IChcIlxcblwiICsgXCJjb3VudGVyX3Jvd3NfcmVuZGVyZWQ6ICBcIiArIGNvdW50ZXJfcm93c19yZW5kZXJlZCk7XG4gICAgcyArPSAoXCJcXG5cIiArIFwiY291bnRlcl9yb3dzX3JlbW92ZWQ6ICBcIiArIGNvdW50ZXJfcm93c19yZW1vdmVkKTtcbiAgICBzICs9IChcIlxcblwiICsgXCJyZW5kZXJlZFJvd3M6ICBcIiArIHJlbmRlcmVkUm93cyk7XG4gICAgcyArPSAoXCJcXG5cIiArIFwibnVtVmlzaWJsZVJvd3M6ICBcIiArIG51bVZpc2libGVSb3dzKTtcbiAgICBzICs9IChcIlxcblwiICsgXCJtYXhTdXBwb3J0ZWRDc3NIZWlnaHQ6ICBcIiArIG1heFN1cHBvcnRlZENzc0hlaWdodCk7XG4gICAgcyArPSAoXCJcXG5cIiArIFwibih1bWJlciBvZiBwYWdlcyk6ICBcIiArIG4pO1xuICAgIHMgKz0gKFwiXFxuXCIgKyBcIihjdXJyZW50KSBwYWdlOiAgXCIgKyBwYWdlKTtcbiAgICBzICs9IChcIlxcblwiICsgXCJwYWdlIGhlaWdodCAocGgpOiAgXCIgKyBwaCk7XG4gICAgcyArPSAoXCJcXG5cIiArIFwidlNjcm9sbERpcjogIFwiICsgdlNjcm9sbERpcik7XG5cbiAgICBhbGVydChzKTtcbiAgfTtcblxuICAvLyBhIGRlYnVnIGhlbHBlciB0byBiZSBhYmxlIHRvIGFjY2VzcyBwcml2YXRlIG1lbWJlcnNcbiAgdGhpcy5ldmFsID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICByZXR1cm4gZXZhbChleHByKTtcbiAgfTtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFB1YmxpYyBBUElcblxuICAkLmV4dGVuZCh0aGlzLCB7XG4gICAgXCJzbGlja0dyaWRWZXJzaW9uXCI6IFwiMi4xXCIsXG5cbiAgICAvLyBFdmVudHNcbiAgICBcIm9uU2Nyb2xsXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25Tb3J0XCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25IZWFkZXJNb3VzZUVudGVyXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25IZWFkZXJNb3VzZUxlYXZlXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25IZWFkZXJDb250ZXh0TWVudVwiOiBuZXcgU2xpY2suRXZlbnQoKSxcbiAgICBcIm9uSGVhZGVyQ2xpY2tcIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbkhlYWRlckNlbGxSZW5kZXJlZFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcbiAgICBcIm9uQmVmb3JlSGVhZGVyQ2VsbERlc3Ryb3lcIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbkhlYWRlclJvd0NlbGxSZW5kZXJlZFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcbiAgICBcIm9uQmVmb3JlSGVhZGVyUm93Q2VsbERlc3Ryb3lcIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbk1vdXNlRW50ZXJcIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbk1vdXNlTGVhdmVcIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbkNsaWNrXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25EYmxDbGlja1wiOiBuZXcgU2xpY2suRXZlbnQoKSxcbiAgICBcIm9uQ29udGV4dE1lbnVcIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbktleURvd25cIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbkFkZE5ld1Jvd1wiOiBuZXcgU2xpY2suRXZlbnQoKSxcbiAgICBcIm9uVmFsaWRhdGlvbkVycm9yXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25WaWV3cG9ydENoYW5nZWRcIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbkNvbHVtbnNSZW9yZGVyZWRcIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbkNvbHVtbnNSZXNpemVkXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25DZWxsQ2hhbmdlXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25CZWZvcmVFZGl0Q2VsbFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcbiAgICBcIm9uQmVmb3JlQ2VsbEVkaXRvckRlc3Ryb3lcIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbkJlZm9yZURlc3Ryb3lcIjogbmV3IFNsaWNrLkV2ZW50KCksXG4gICAgXCJvbkFjdGl2ZUNlbGxDaGFuZ2VkXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25BY3RpdmVDZWxsUG9zaXRpb25DaGFuZ2VkXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25EcmFnSW5pdFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcbiAgICBcIm9uRHJhZ1N0YXJ0XCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25EcmFnXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25EcmFnRW5kXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25TZWxlY3RlZFJvd3NDaGFuZ2VkXCI6IG5ldyBTbGljay5FdmVudCgpLFxuICAgIFwib25DZWxsQ3NzU3R5bGVzQ2hhbmdlZFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcblxuICAgIC8vIE1ldGhvZHNcbiAgICBcInJlZ2lzdGVyUGx1Z2luXCI6IHJlZ2lzdGVyUGx1Z2luLFxuICAgIFwidW5yZWdpc3RlclBsdWdpblwiOiB1bnJlZ2lzdGVyUGx1Z2luLFxuICAgIFwiZ2V0Q29sdW1uc1wiOiBnZXRDb2x1bW5zLFxuICAgIFwic2V0Q29sdW1uc1wiOiBzZXRDb2x1bW5zLFxuICAgIFwiZ2V0Q29sdW1uSW5kZXhcIjogZ2V0Q29sdW1uSW5kZXgsXG4gICAgXCJ1cGRhdGVDb2x1bW5IZWFkZXJcIjogdXBkYXRlQ29sdW1uSGVhZGVyLFxuICAgIFwic2V0U29ydENvbHVtblwiOiBzZXRTb3J0Q29sdW1uLFxuICAgIFwic2V0U29ydENvbHVtbnNcIjogc2V0U29ydENvbHVtbnMsXG4gICAgXCJnZXRTb3J0Q29sdW1uc1wiOiBnZXRTb3J0Q29sdW1ucyxcbiAgICBcImF1dG9zaXplQ29sdW1uc1wiOiBhdXRvc2l6ZUNvbHVtbnMsXG4gICAgXCJnZXRPcHRpb25zXCI6IGdldE9wdGlvbnMsXG4gICAgXCJzZXRPcHRpb25zXCI6IHNldE9wdGlvbnMsXG4gICAgXCJnZXREYXRhXCI6IGdldERhdGEsXG4gICAgXCJnZXREYXRhTGVuZ3RoXCI6IGdldERhdGFMZW5ndGgsXG4gICAgXCJnZXREYXRhSXRlbVwiOiBnZXREYXRhSXRlbSxcbiAgICBcInNldERhdGFcIjogc2V0RGF0YSxcbiAgICBcImdldFNlbGVjdGlvbk1vZGVsXCI6IGdldFNlbGVjdGlvbk1vZGVsLFxuICAgIFwic2V0U2VsZWN0aW9uTW9kZWxcIjogc2V0U2VsZWN0aW9uTW9kZWwsXG4gICAgXCJnZXRTZWxlY3RlZFJvd3NcIjogZ2V0U2VsZWN0ZWRSb3dzLFxuICAgIFwic2V0U2VsZWN0ZWRSb3dzXCI6IHNldFNlbGVjdGVkUm93cyxcbiAgICBcImdldENvbnRhaW5lck5vZGVcIjogZ2V0Q29udGFpbmVyTm9kZSxcblxuICAgIFwicmVuZGVyXCI6IHJlbmRlcixcbiAgICBcImludmFsaWRhdGVcIjogaW52YWxpZGF0ZSxcbiAgICBcImludmFsaWRhdGVSb3dcIjogaW52YWxpZGF0ZVJvdyxcbiAgICBcImludmFsaWRhdGVSb3dzXCI6IGludmFsaWRhdGVSb3dzLFxuICAgIFwiaW52YWxpZGF0ZUFsbFJvd3NcIjogaW52YWxpZGF0ZUFsbFJvd3MsXG4gICAgXCJ1cGRhdGVDZWxsXCI6IHVwZGF0ZUNlbGwsXG4gICAgXCJ1cGRhdGVSb3dcIjogdXBkYXRlUm93LFxuICAgIFwiZ2V0Vmlld3BvcnRcIjogZ2V0VmlzaWJsZVJhbmdlLFxuICAgIFwiZ2V0UmVuZGVyZWRSYW5nZVwiOiBnZXRSZW5kZXJlZFJhbmdlLFxuICAgIFwicmVzaXplQ2FudmFzXCI6IHJlc2l6ZUNhbnZhcyxcbiAgICBcInVwZGF0ZVJvd0NvdW50XCI6IHVwZGF0ZVJvd0NvdW50LFxuICAgIFwic2Nyb2xsUm93SW50b1ZpZXdcIjogc2Nyb2xsUm93SW50b1ZpZXcsXG4gICAgXCJzY3JvbGxSb3dUb1RvcFwiOiBzY3JvbGxSb3dUb1RvcCxcbiAgICBcInNjcm9sbENlbGxJbnRvVmlld1wiOiBzY3JvbGxDZWxsSW50b1ZpZXcsXG4gICAgXCJnZXRDYW52YXNOb2RlXCI6IGdldENhbnZhc05vZGUsXG4gICAgXCJmb2N1c1wiOiBzZXRGb2N1cyxcblxuICAgIFwiZ2V0Q2VsbEZyb21Qb2ludFwiOiBnZXRDZWxsRnJvbVBvaW50LFxuICAgIFwiZ2V0Q2VsbEZyb21FdmVudFwiOiBnZXRDZWxsRnJvbUV2ZW50LFxuICAgIFwiZ2V0QWN0aXZlQ2VsbFwiOiBnZXRBY3RpdmVDZWxsLFxuICAgIFwic2V0QWN0aXZlQ2VsbFwiOiBzZXRBY3RpdmVDZWxsLFxuICAgIFwiZ2V0QWN0aXZlQ2VsbE5vZGVcIjogZ2V0QWN0aXZlQ2VsbE5vZGUsXG4gICAgXCJnZXRBY3RpdmVDZWxsUG9zaXRpb25cIjogZ2V0QWN0aXZlQ2VsbFBvc2l0aW9uLFxuICAgIFwicmVzZXRBY3RpdmVDZWxsXCI6IHJlc2V0QWN0aXZlQ2VsbCxcbiAgICBcImVkaXRBY3RpdmVDZWxsXCI6IG1ha2VBY3RpdmVDZWxsRWRpdGFibGUsXG4gICAgXCJnZXRDZWxsRWRpdG9yXCI6IGdldENlbGxFZGl0b3IsXG4gICAgXCJnZXRDZWxsTm9kZVwiOiBnZXRDZWxsTm9kZSxcbiAgICBcImdldENlbGxOb2RlQm94XCI6IGdldENlbGxOb2RlQm94LFxuICAgIFwiY2FuQ2VsbEJlU2VsZWN0ZWRcIjogY2FuQ2VsbEJlU2VsZWN0ZWQsXG4gICAgXCJjYW5DZWxsQmVBY3RpdmVcIjogY2FuQ2VsbEJlQWN0aXZlLFxuICAgIFwibmF2aWdhdGVQcmV2XCI6IG5hdmlnYXRlUHJldixcbiAgICBcIm5hdmlnYXRlTmV4dFwiOiBuYXZpZ2F0ZU5leHQsXG4gICAgXCJuYXZpZ2F0ZVVwXCI6IG5hdmlnYXRlVXAsXG4gICAgXCJuYXZpZ2F0ZURvd25cIjogbmF2aWdhdGVEb3duLFxuICAgIFwibmF2aWdhdGVMZWZ0XCI6IG5hdmlnYXRlTGVmdCxcbiAgICBcIm5hdmlnYXRlUmlnaHRcIjogbmF2aWdhdGVSaWdodCxcbiAgICBcIm5hdmlnYXRlUGFnZVVwXCI6IG5hdmlnYXRlUGFnZVVwLFxuICAgIFwibmF2aWdhdGVQYWdlRG93blwiOiBuYXZpZ2F0ZVBhZ2VEb3duLFxuICAgIFwiZ290b0NlbGxcIjogZ290b0NlbGwsXG4gICAgXCJnZXRUb3BQYW5lbFwiOiBnZXRUb3BQYW5lbCxcbiAgICBcInNldFRvcFBhbmVsVmlzaWJpbGl0eVwiOiBzZXRUb3BQYW5lbFZpc2liaWxpdHksXG4gICAgXCJzZXRIZWFkZXJSb3dWaXNpYmlsaXR5XCI6IHNldEhlYWRlclJvd1Zpc2liaWxpdHksXG4gICAgXCJnZXRIZWFkZXJSb3dcIjogZ2V0SGVhZGVyUm93LFxuICAgIFwiZ2V0SGVhZGVyUm93Q29sdW1uXCI6IGdldEhlYWRlclJvd0NvbHVtbixcbiAgICBcImdldEdyaWRQb3NpdGlvblwiOiBnZXRHcmlkUG9zaXRpb24sXG4gICAgXCJmbGFzaENlbGxcIjogZmxhc2hDZWxsLFxuICAgIFwiYWRkQ2VsbENzc1N0eWxlc1wiOiBhZGRDZWxsQ3NzU3R5bGVzLFxuICAgIFwic2V0Q2VsbENzc1N0eWxlc1wiOiBzZXRDZWxsQ3NzU3R5bGVzLFxuICAgIFwicmVtb3ZlQ2VsbENzc1N0eWxlc1wiOiByZW1vdmVDZWxsQ3NzU3R5bGVzLFxuICAgIFwiZ2V0Q2VsbENzc1N0eWxlc1wiOiBnZXRDZWxsQ3NzU3R5bGVzLFxuXG4gICAgXCJpbml0XCI6IGZpbmlzaEluaXRpYWxpemF0aW9uLFxuICAgIFwiZGVzdHJveVwiOiBkZXN0cm95LFxuXG4gICAgLy8gSUVkaXRvciBpbXBsZW1lbnRhdGlvblxuICAgIFwiZ2V0RWRpdG9yTG9ja1wiOiBnZXRFZGl0b3JMb2NrLFxuICAgIFwiZ2V0RWRpdENvbnRyb2xsZXJcIjogZ2V0RWRpdENvbnRyb2xsZXJcbiAgfSk7XG5cbiAgaW5pdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNsaWNrR3JpZDtcbiJdfQ=="}